
TODO:
    // Checking function arguments.
    // First class functions.
    // Try to make it so only "executeable" tests are attempted. So that ALL checkDependencies calls are successful.
    // TAJS_Record: (Eksempel TestMicro#tajsRecord), skal kaldes som: TAJS_record("o.foo should be number", typeof o.foo === "number")`
    // Make sure no constructed object is tested
    // Limit the amount of tests created in underscore.
    // Explicitly try to instantiate unconstrained generic types with a primitive?
    // Måske prøve at fange og raportere nogle runtime fejl (TypeErrorException). + prøve at kalde en ikke funktion
    // Coverage can measure how well we are doing, make an automatic coverage report after each test run.


// TODO: Oprindelig blame tracker: Philip Wadler (blame)
// Thiemann, contracts for JS, "ConTest"

Notes:
    - A crucial thing about generic types, is that it works if it is instantiated with a type A or a Type B.
        Because the type GenericClass<A> is different from GenericClass<B>.
        We therefore test the two completely separately, which in some cases causes the test programs to become quite large.
        So if two methods returns two generic types, with different generic arguments, then those gets treated separately.
    - I merge tests that test the same thing (and also produce the same thing).
    - Overapproximation assumptions:
        - It is assumed that the declaration file describes all possible behaviour that an application can do.
        - instanceOf doesn't work like it should on constructed objects, they are only structurally correct.
        - No modification is made to the object structure of the library, and no modifications is done to any object returned by the library.


What we are trying to do:
    If we want to check correctness of a TypeScript declaration file with respect to an implementation, there is essentially two ways to do it, over-approximation and under-approximation.

    Turns out the two are very related, since we need an application that exercises the library in both cases.
    For it to be a valid under-approximation, the application must only exercise the library by performing valid operations.
    And for it to be a valid over-approximation, the application must potentially exercise all valid operations.

    We call this the most general application with respect to the library, and we construct this under the assumption that the TypeScript declaration file describes all possible operations, and only valid operations.

    With this assumption, we can construct an application, which non-deterministically performs every valid operation on the library

    This application exercise all possible ways for which the program can be executed,


Contributions:
    - We show that dynamic generation of complex inputs is essential in automatic JavaScript testing. (Not tested)
    - We demonstrate a method of generating a program, which potentially executes an entire library.
        - And this program is simple enough for a sound static analysis to analyze it.
    - We show how sound static analysis of a generalized test program can find errors that are not found by any automatic testing (not tested).

Related works:
    Well-typed programs can’t be blamed: (http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.645.2399&rep=rep1&type=pdf) TODO: From sec 2.2.
        Introduces blame calculus.
        We factor the well-known notion of subtyping into new notions of positive and negative subtyping
        We prove that a cast from a positive subtype cannot give rise to positive blame, and that a cast from a negative subtype cannot give rise to negative blame


    Feedback-directed random test generation (RANDOOP).
        Randomly executes statements in the tested library, records the behaviour, and creates tests that does the same thing.
        Limitations:
            - Only handles Java's type system, which is conceptually simple, since there is no union types.
            - Conceptually (section 2.3), it only constructs primitives by itself, everything else must come from previous executions (not completly true though).
            - Doesn't handle first order functions, but it would possibly not take much to make it.
            - In Java you don't have structural types. In JavaScript we have to create objects ourself.
            - RANDOOP doesn't construct much by itself, it construct things like Lists, but it doesn't construct Date, we construct everything!
            - RANDOOP gives up supprisingly quickly, example; the following input generates NO test cases:
                public class Test<T extends List<String>>  {
                    private T t;
                    public Test(T t) {
                        this.t = t;
                    }

                    public T get() {
                        return t;
                    }
                }
        Big difference: RANDOOP produces an output that does one concrete thing, while our output potentially does everything.
                        Our output is therefore well designed for static analysis, since it will provide an overapproximation of potential behaviour, which RANDOOP don't.

    Jeremy Siek and his CheckScript:
        On last check, the state of the code in the GitHub repository is not in a state where you want to refer to it.
        But if he gets something up and running, it might be interresting.

    DSD-Crasher: A Hybrid Analysis Tool for Bug Finding:
        Another way of doing static/dynamic testing.
            They first capture invariants by means of a dynamic analysis.
            Then perform a static analysis, to find possible executions that break these invariants.
            Then execute these, to see of the found bugs were real.

    Check ’n’ Crash: Combining Static Checking and Testing:
        Does something somewhat similar to DSD-Crasher. (DSD is more refined, and DSD cites this one).

    Type-Aware Concolic Testing of JavaScript Programs:
        Putting this here, just so that I won't stumble on this later.
        That article just describes symbolic execution, the only thing that is type aware, is when they generate constraints.
        They split the constraints into branch-constraints and type-constraints, and use that to minimize the number of redundant test cases.
        It is therefore not relevant to this work, other than it being symbolic execution on JavaScript.

    (Typestate: A programming language concept for enhancing software reliability)
        Typestate is a general concept, it is basically that an object has a typestate, which is mutable, and can thereby encode that a getter must be called before a setter.
        It is also called protocol analysis.


Future work:
    - Symbolic execution could be used to get the under-approximation to be less of an under-approximation (speculation: I don't think it will make a big different, we are looking for type errors).


Requirements:
    debian package timelimit
    node
    java 8