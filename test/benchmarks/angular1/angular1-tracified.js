Object.defineProperty(typeof window === 'undefined' ? global : window, '$__', { configurable: false, enumerable: false, value: {
    fs: {},
    os: {},
    functionRegExp: /^function .*\([\s\S]*\) {[\s\S]*\}$/g,
    refs: {
        pop: Array.prototype.pop,
        slice: Array.prototype.slice
    },
    uid: Symbol('bHvKvd19fGrk'),
    w: window
}});
var vvv_tmp0, vvv_tmp1, vvv_tmp2;
(((($__.fs.J$__v3645318688_2424_3 = function J$__v3645318688_2424(window) {
'use strict';
var vvv_return, vvv_switch, vvv_tmp0, minErr, REGEX_STRING_REGEXP, VALIDITY_STATE_PROPERTY, hasOwnProperty, minErrConfig, errorHandlingConfig, isValidObjectMaxDepth, lowercase, uppercase, manualLowercase, manualUppercase, msie, jqLite, jQuery, slice, splice, push, toString, getPrototypeOf, ngMinErr, angular, angularModule, uid, isArrayLike, forEach, forEachSorted, reverseParams, nextUid, setHashKey, baseExtend, extend, merge, toInt, isNumberNaN, inherit, noop, identity, valueFn, hasCustomToString, isUndefined, isDefined, isObject, isBlankObject, isString, isNumber, isDate, isArray, isFunction, isRegExp, isWindow, isScope, isFile, isFormData, isBlob, isBoolean, isPromiseLike, TYPED_ARRAY_REGEXP, isTypedArray, isArrayBuffer, trim, escapeForRegexp, isElement, makeMap, nodeName_, includes, arrayRemove, copy, equals, csp, jq, concat, sliceArgs, bind, toJsonReplacer, toJson, fromJson, ALL_COLONS, timezoneToOffset, addDateMinutes, convertTimezoneToLocal, startingTag, tryDecodeURIComponent, parseKeyValue, toKeyValue, encodeUriSegment, encodeUriQuery, ngAttrPrefixes, getNgAttribute, allowAutoBootstrap, isAutoBootstrapAllowed, angularInit, bootstrap, reloadWithDebugInfo, getTestability, SNAKE_CASE_REGEXP, snake_case, bindJQueryFired, bindJQuery, assertArg, assertArgFn, assertNotHasOwnProperty, getter, getBlockNodes, createMap, stringify, NODE_TYPE_ELEMENT, NODE_TYPE_ATTRIBUTE, NODE_TYPE_TEXT, NODE_TYPE_COMMENT, NODE_TYPE_DOCUMENT, NODE_TYPE_DOCUMENT_FRAGMENT, setupModuleLoader, shallowCopy, serializeObject, toDebugString, version, publishExternalAPI, jqCache, jqId, jqNextId, DASH_LOWERCASE_REGEXP, MS_HACK_REGEXP, MOUSE_EVENT_MAP, jqLiteMinErr, cssKebabToCamel, fnCamelCaseReplace, kebabToCamel, SINGLE_TAG_REGEXP, HTML_REGEXP, TAG_NAME_REGEXP, XHTML_TAG_REGEXP, wrapMap, jqLiteIsTextNode, jqLiteAcceptsData, jqLiteHasData, jqLiteCleanData, jqLiteBuildFragment, jqLiteParseHTML, jqLiteWrapNode, jqLiteContains, JQLite, jqLiteClone, jqLiteDealoc, jqLiteOff, jqLiteRemoveData, jqLiteExpandoStore, jqLiteData, jqLiteHasClass, jqLiteRemoveClass, jqLiteAddClass, jqLiteAddNodes, jqLiteController, jqLiteInheritedData, jqLiteEmpty, jqLiteRemove, jqLiteDocumentLoaded, jqLiteReady, JQLitePrototype, BOOLEAN_ATTR, BOOLEAN_ELEMENTS, ALIASED_ATTR, getBooleanAttrName, getAliasedAttrName, createEventHandler, defaultHandlerWrapper, specialMouseHandlerWrapper, $$jqLiteProvider, hashKey, nanKey, NgMapShim, NgMap, $$MapProvider, ARROW_ARG, FN_ARGS, FN_ARG_SPLIT, FN_ARG, STRIP_COMMENTS, $injectorMinErr, stringifyFn, extractArgs, anonFn, annotate, createInjector, $AnchorScrollProvider, $animateMinErr, ELEMENT_NODE, NG_ANIMATE_CLASSNAME, mergeClasses, extractElementNode, splitClasses, prepareAnimateOptions, $$CoreAnimateJsProvider, $$CoreAnimateQueueProvider, $AnimateProvider, $$AnimateAsyncRunFactoryProvider, $$AnimateRunnerFactoryProvider, $CoreAnimateCssProvider, Browser, $BrowserProvider, $CacheFactoryProvider, $TemplateCacheProvider, $compileMinErr, UNINITIALIZED_VALUE, _UNINITIALIZED_VALUE, $CompileProvider, SimpleChange, PREFIX_REGEXP, SPECIAL_CHARS_REGEXP, directiveNormalize, nodesetLinkingFn, directiveLinkingFn, tokenDifference, removeComments, $controllerMinErr, CNTRL_REG, identifierForController, $ControllerProvider, $DocumentProvider, $$IsDocumentHiddenProvider, $ExceptionHandlerProvider, $$ForceReflowProvider, APPLICATION_JSON, CONTENT_TYPE_APPLICATION_JSON, JSON_START, JSON_ENDS, JSON_PROTECTION_PREFIX, $httpMinErr, serializeValue, $HttpParamSerializerProvider, $HttpParamSerializerJQLikeProvider, defaultHttpResponseTransform, isJsonLike, parseHeaders, headersGetter, transformData, isSuccess, $HttpProvider, $xhrFactoryProvider, $HttpBackendProvider, createHttpBackend, $interpolateMinErr, $InterpolateProvider, $IntervalProvider, $jsonpCallbacksProvider, PATH_MATCH, DEFAULT_PORTS, $locationMinErr, encodePath, parseAbsoluteUrl, DOUBLE_SLASH_REGEX, parseAppUrl, startsWith, stripBaseUrl, stripHash, trimEmptyHash, stripFile, serverBase, LocationHtml5Url, LocationHashbangUrl, LocationHashbangInHtml5Url, locationPrototype, locationGetter, locationGetterSetter, $LocationProvider, $LogProvider, $parseMinErr, objectValueOf, getStringValue, OPERATORS, ESCAPE, Lexer, AST, ifDefined, plusFn, isStateless, findConstantAndWatchExpressions, getInputs, isAssignable, assignableAST, isLiteral, isConstant, ASTCompiler, ASTInterpreter, Parser, getValueOf, $ParseProvider, $QProvider, $$QProvider, qFactory, $$RAFProvider, $RootScopeProvider, $$SanitizeUriProvider, $sceMinErr, SCE_CONTEXTS, UNDERSCORE_LOWERCASE_REGEXP, snakeToCamel, adjustMatcher, adjustMatchers, $SceDelegateProvider, $SceProvider, $SnifferProvider, $templateRequestMinErr, $TemplateRequestProvider, $$TestabilityProvider, $TimeoutProvider, urlParsingNode, originUrl, urlResolve, urlIsSameOrigin, $WindowProvider, $$CookieReader, $$CookieReaderProvider, $FilterProvider, filterFilter, createPredicateFn, deepCompare, getTypeForFilter, MAX_DIGITS, DECIMAL_SEP, ZERO_CHAR, currencyFilter, numberFilter, parse, roundNumber, formatNumber, padNumber, dateGetter, dateStrGetter, timeZoneGetter, getFirstThursdayOfYear, getThursdayThisWeek, weekGetter, ampmGetter, eraGetter, longEraGetter, DATE_FORMATS, DATE_FORMATS_SPLIT, NUMBER_STRING, dateFilter, jsonFilter, lowercaseFilter, uppercaseFilter, limitToFilter, sliceFn, orderByFilter, ngDirective, htmlAnchorDirective, ngAttributeAliasDirectives, nullFormCtrl, PENDING_CLASS, SUBMITTED_CLASS, nullFormRenameControl, FormController, formDirectiveFactory, formDirective, ngFormDirective, setupValidity, addSetValidityMethod, isObjectEmpty, ISO_DATE_REGEXP, URL_REGEXP, EMAIL_REGEXP, NUMBER_REGEXP, DATE_REGEXP, DATETIMELOCAL_REGEXP, WEEK_REGEXP, MONTH_REGEXP, TIME_REGEXP, PARTIAL_VALIDATION_EVENTS, PARTIAL_VALIDATION_TYPES, inputType, stringBasedInputType, textInputType, baseInputType, weekParser, createDateParser, createDateInputType, badInputChecker, numberFormatterParser, parseNumberAttrVal, isNumberInteger, countDecimals, isValidForStep, numberInputType, rangeInputType, urlInputType, emailInputType, radioInputType, parseConstantExpr, checkboxInputType, inputDirective, CONSTANT_VALUE_REGEXP, ngValueDirective, ngBindDirective, ngBindTemplateDirective, ngBindHtmlDirective, ngChangeDirective, classDirective, ngClassDirective, ngClassOddDirective, ngClassEvenDirective, ngCloakDirective, ngControllerDirective, ngEventDirectives, forceAsyncEvents, ngIfDirective, ngIncludeDirective, ngIncludeFillContentDirective, ngInitDirective, ngListDirective, VALID_CLASS, INVALID_CLASS, PRISTINE_CLASS, DIRTY_CLASS, UNTOUCHED_CLASS, TOUCHED_CLASS, EMPTY_CLASS, NOT_EMPTY_CLASS, ngModelMinErr, NgModelController, setupModelWatcher, ngModelDirective, defaultModelOptions, DEFAULT_REGEXP, ModelOptions, ngModelOptionsDirective, defaults, ngNonBindableDirective, ngOptionsMinErr, NG_OPTIONS_REGEXP, ngOptionsDirective, ngPluralizeDirective, ngRepeatDirective, NG_HIDE_CLASS, NG_HIDE_IN_PROGRESS_CLASS, ngShowDirective, ngHideDirective, ngStyleDirective, ngSwitchDirective, ngSwitchWhenDirective, ngSwitchDefaultDirective, ngTranscludeMinErr, ngTranscludeDirective, scriptDirective, noopNgModelController, setOptionSelectedStatus, SelectController, selectDirective, optionDirective, requiredDirective, patternDirective, maxlengthDirective, minlengthDirective;
minErr = function minErr(module, ErrorConstructor) {
    ErrorConstructor = ErrorConstructor || Error;
    return function () {
        var code = arguments[0], template = arguments[1], message = '[' + (module ? module + ':' : '') + code + '] ', templateArgs = sliceArgs(arguments, 2).map(function (arg) {
                return toDebugString(arg, minErrConfig.objectMaxDepth);
            }), paramPrefix, i;
        message += template.replace(/\{\d+\}/g, function (match) {
            var index = +match.slice(1, -1);
            if (index < templateArgs.length) {
                return templateArgs[index];
            }
            return match;
        });
        message += '\nhttp://errors.angularjs.org/1.6.3/' + (module ? module + '/' : '') + code;
        for (i = 0, paramPrefix = '?'; i < templateArgs.length; i++, paramPrefix = '&') {
            message += paramPrefix + 'p' + i + '=' + encodeURIComponent(templateArgs[i]);
        }
        return new ErrorConstructor(message);
    };
};
errorHandlingConfig = function errorHandlingConfig(config) {
    if (isObject(config)) {
        if (isDefined(config.objectMaxDepth)) {
            minErrConfig.objectMaxDepth = isValidObjectMaxDepth(config.objectMaxDepth) ? config.objectMaxDepth : NaN;
        }
    } else {
        return minErrConfig;
    }
};
isValidObjectMaxDepth = function isValidObjectMaxDepth(maxDepth) {
    return isNumber(maxDepth) && maxDepth > 0;
};
isArrayLike = function isArrayLike(obj) {
    if (obj == null || isWindow(obj))
        return false;
    if (isArray(obj) || isString(obj) || jqLite && obj instanceof jqLite)
        return true;
    var length = 'length' in Object(obj) && obj.length;
    return isNumber(length) && (length >= 0 && (length - 1 in obj || obj instanceof Array) || typeof obj.item === 'function');
};
forEach = function forEach(obj, iterator, context) {
    var key, length;
    if (obj) {
        if (isFunction(obj)) {
            for (key in obj) {
                if (key !== 'prototype' && key !== 'length' && key !== 'name' && obj.hasOwnProperty(key)) {
                    iterator.call(context, obj[key], key, obj);
                }
            }
        } else if (isArray(obj) || isArrayLike(obj)) {
            var isPrimitive = typeof obj !== 'object';
            for (key = 0, length = obj.length; key < length; key++) {
                if (isPrimitive || key in obj) {
                    iterator.call(context, obj[key], key, obj);
                }
            }
        } else if (obj.forEach && obj.forEach !== forEach) {
            obj.forEach(iterator, context, obj);
        } else if (isBlankObject(obj)) {
            for (key in obj) {
                iterator.call(context, obj[key], key, obj);
            }
        } else if (typeof obj.hasOwnProperty === 'function') {
            for (key in obj) {
                if (obj.hasOwnProperty(key)) {
                    iterator.call(context, obj[key], key, obj);
                }
            }
        } else {
            for (key in obj) {
                if (hasOwnProperty.call(obj, key)) {
                    iterator.call(context, obj[key], key, obj);
                }
            }
        }
    }
    return obj;
};
forEachSorted = function forEachSorted(obj, iterator, context) {
    var keys = Object.keys(obj).sort();
    for (var i = 0; i < keys.length; i++) {
        iterator.call(context, obj[keys[i]], keys[i]);
    }
    return keys;
};
reverseParams = function reverseParams(iteratorFn) {
    return function (value, key) {
        iteratorFn(key, value);
    };
};
nextUid = function nextUid() {
    return ++uid;
};
setHashKey = function setHashKey(obj, h) {
    if (h) {
        obj.$$hashKey = h;
    } else {
        delete obj.$$hashKey;
    }
};
baseExtend = function baseExtend(dst, objs, deep) {
    var h = dst.$$hashKey;
    for (var i = 0, ii = objs.length; i < ii; ++i) {
        var obj = objs[i];
        if (!isObject(obj) && !isFunction(obj))
            continue;
        var keys = Object.keys(obj);
        for (var j = 0, jj = keys.length; j < jj; j++) {
            var key = keys[j];
            var src = obj[key];
            if (deep && isObject(src)) {
                if (isDate(src)) {
                    dst[key] = new Date(src.valueOf());
                } else if (isRegExp(src)) {
                    dst[key] = new RegExp(src);
                } else if (src.nodeName) {
                    dst[key] = src.cloneNode(true);
                } else if (isElement(src)) {
                    dst[key] = src.clone();
                } else {
                    if (!isObject(dst[key]))
                        dst[key] = isArray(src) ? [] : {};
                    baseExtend(dst[key], [src], true);
                }
            } else {
                dst[key] = src;
            }
        }
    }
    setHashKey(dst, h);
    return dst;
};
extend = function extend(dst) {
    return baseExtend(dst, slice.call(arguments, 1), false);
};
merge = function merge(dst) {
    return baseExtend(dst, slice.call(arguments, 1), true);
};
toInt = function toInt(str) {
    return parseInt(str, 10);
};
inherit = function inherit(parent, extra) {
    return extend(Object.create(parent), extra);
};
noop = function noop() {
};
identity = function identity($) {
    return $;
};
valueFn = function valueFn(value) {
    return function valueRef() {
        return value;
    };
};
hasCustomToString = function hasCustomToString(obj) {
    return isFunction(obj.toString) && obj.toString !== toString;
};
isUndefined = function isUndefined(value) {
    return typeof value === 'undefined';
};
isDefined = function isDefined(value) {
    return typeof value !== 'undefined';
};
isObject = function isObject(value) {
    return value !== null && typeof value === 'object';
};
isBlankObject = function isBlankObject(value) {
    return value !== null && typeof value === 'object' && !getPrototypeOf(value);
};
isString = function isString(value) {
    return typeof value === 'string';
};
isNumber = function isNumber(value) {
    return typeof value === 'number';
};
isDate = function isDate(value) {
    return toString.call(value) === '[object Date]';
};
isFunction = function isFunction(value) {
    return typeof value === 'function';
};
isRegExp = function isRegExp(value) {
    return toString.call(value) === '[object RegExp]';
};
isWindow = function isWindow(obj) {
    return obj && obj.window === obj;
};
isScope = function isScope(obj) {
    return obj && obj.$evalAsync && obj.$watch;
};
isFile = function isFile(obj) {
    return toString.call(obj) === '[object File]';
};
isFormData = function isFormData(obj) {
    return toString.call(obj) === '[object FormData]';
};
isBlob = function isBlob(obj) {
    return toString.call(obj) === '[object Blob]';
};
isBoolean = function isBoolean(value) {
    return typeof value === 'boolean';
};
isPromiseLike = function isPromiseLike(obj) {
    return obj && isFunction(obj.then);
};
isTypedArray = function isTypedArray(value) {
    return value && isNumber(value.length) && TYPED_ARRAY_REGEXP.test(toString.call(value));
};
isArrayBuffer = function isArrayBuffer(obj) {
    return toString.call(obj) === '[object ArrayBuffer]';
};
isElement = function isElement(node) {
    return !!(node && (node.nodeName || node.prop && node.attr && node.find));
};
makeMap = function makeMap(str) {
    var obj = {}, items = str.split(','), i;
    for (i = 0; i < items.length; i++) {
        obj[items[i]] = true;
    }
    return obj;
};
nodeName_ = function nodeName_(element) {
    return lowercase(element.nodeName || element[0] && element[0].nodeName);
};
includes = function includes(array, obj) {
    return Array.prototype.indexOf.call(array, obj) !== -1;
};
arrayRemove = function arrayRemove(array, value) {
    var index = array.indexOf(value);
    if (index >= 0) {
        array.splice(index, 1);
    }
    return index;
};
copy = function copy(source, destination, maxDepth) {
    var stackSource = [];
    var stackDest = [];
    maxDepth = isValidObjectMaxDepth(maxDepth) ? maxDepth : NaN;
    if (destination) {
        if (isTypedArray(destination) || isArrayBuffer(destination)) {
            throw ngMinErr('cpta', 'Can\'t copy! TypedArray destination cannot be mutated.');
        }
        if (source === destination) {
            throw ngMinErr('cpi', 'Can\'t copy! Source and destination are identical.');
        }
        if (isArray(destination)) {
            destination.length = 0;
        } else {
            forEach(destination, function (value, key) {
                if (key !== '$$hashKey') {
                    delete destination[key];
                }
            });
        }
        stackSource.push(source);
        stackDest.push(destination);
        return copyRecurse(source, destination, maxDepth);
    }
    return copyElement(source, maxDepth);
    function copyRecurse(source, destination, maxDepth) {
        maxDepth--;
        if (maxDepth < 0) {
            return '...';
        }
        var h = destination.$$hashKey;
        var key;
        if (isArray(source)) {
            for (var i = 0, ii = source.length; i < ii; i++) {
                destination.push(copyElement(source[i], maxDepth));
            }
        } else if (isBlankObject(source)) {
            for (key in source) {
                destination[key] = copyElement(source[key], maxDepth);
            }
        } else if (source && typeof source.hasOwnProperty === 'function') {
            for (key in source) {
                if (source.hasOwnProperty(key)) {
                    destination[key] = copyElement(source[key], maxDepth);
                }
            }
        } else {
            for (key in source) {
                if (hasOwnProperty.call(source, key)) {
                    destination[key] = copyElement(source[key], maxDepth);
                }
            }
        }
        setHashKey(destination, h);
        return destination;
    }
    function copyElement(source, maxDepth) {
        if (!isObject(source)) {
            return source;
        }
        var index = stackSource.indexOf(source);
        if (index !== -1) {
            return stackDest[index];
        }
        if (isWindow(source) || isScope(source)) {
            throw ngMinErr('cpws', 'Can\'t copy! Making copies of Window or Scope instances is not supported.');
        }
        var needsRecurse = false;
        var destination = copyType(source);
        if (destination === undefined) {
            destination = isArray(source) ? [] : Object.create(getPrototypeOf(source));
            needsRecurse = true;
        }
        stackSource.push(source);
        stackDest.push(destination);
        return needsRecurse ? copyRecurse(source, destination, maxDepth) : destination;
    }
    function copyType(source) {
        switch (toString.call(source)) {
        case '[object Int8Array]':
        case '[object Int16Array]':
        case '[object Int32Array]':
        case '[object Float32Array]':
        case '[object Float64Array]':
        case '[object Uint8Array]':
        case '[object Uint8ClampedArray]':
        case '[object Uint16Array]':
        case '[object Uint32Array]':
            return new source.constructor(copyElement(source.buffer), source.byteOffset, source.length);
        case '[object ArrayBuffer]':
            if (!source.slice) {
                var copied = new ArrayBuffer(source.byteLength);
                new Uint8Array(copied).set(new Uint8Array(source));
                return copied;
            }
            return source.slice(0);
        case '[object Boolean]':
        case '[object Number]':
        case '[object String]':
        case '[object Date]':
            return new source.constructor(source.valueOf());
        case '[object RegExp]':
            var re = new RegExp(source.source, source.toString().match(/[^\/]*$/)[0]);
            re.lastIndex = source.lastIndex;
            return re;
        case '[object Blob]':
            return new source.constructor([source], {
                type: source.type
            });
        }
        if (isFunction(source.cloneNode)) {
            return source.cloneNode(true);
        }
    }
};
equals = function equals(o1, o2) {
    if (o1 === o2)
        return true;
    if (o1 === null || o2 === null)
        return false;
    if (o1 !== o1 && o2 !== o2)
        return true;
    var t1 = typeof o1, t2 = typeof o2, length, key, keySet;
    if (t1 === t2 && t1 === 'object') {
        if (isArray(o1)) {
            if (!isArray(o2))
                return false;
            if ((length = o1.length) === o2.length) {
                for (key = 0; key < length; key++) {
                    if (!equals(o1[key], o2[key]))
                        return false;
                }
                return true;
            }
        } else if (isDate(o1)) {
            if (!isDate(o2))
                return false;
            return equals(o1.getTime(), o2.getTime());
        } else if (isRegExp(o1)) {
            if (!isRegExp(o2))
                return false;
            return o1.toString() === o2.toString();
        } else {
            if (isScope(o1) || isScope(o2) || isWindow(o1) || isWindow(o2) || isArray(o2) || isDate(o2) || isRegExp(o2))
                return false;
            keySet = createMap();
            for (key in o1) {
                if (key.charAt(0) === '$' || isFunction(o1[key]))
                    continue;
                if (!equals(o1[key], o2[key]))
                    return false;
                keySet[key] = true;
            }
            for (key in o2) {
                if (!(key in keySet) && key.charAt(0) !== '$' && isDefined(o2[key]) && !isFunction(o2[key]))
                    return false;
            }
            return true;
        }
    }
    return false;
};
concat = function concat(array1, array2, index) {
    return array1.concat(slice.call(array2, index));
};
sliceArgs = function sliceArgs(args, startIndex) {
    return slice.call(args, startIndex || 0);
};
bind = function bind(self, fn) {
    var curryArgs = arguments.length > 2 ? sliceArgs(arguments, 2) : [];
    if (isFunction(fn) && !(fn instanceof RegExp)) {
        return curryArgs.length ? function () {
            return arguments.length ? fn.apply(self, concat(curryArgs, arguments, 0)) : fn.apply(self, curryArgs);
        } : function () {
            return arguments.length ? fn.apply(self, arguments) : fn.call(self);
        };
    } else {
        return fn;
    }
};
toJsonReplacer = function toJsonReplacer(key, value) {
    var val = value;
    if (typeof key === 'string' && key.charAt(0) === '$' && key.charAt(1) === '$') {
        val = undefined;
    } else if (isWindow(value)) {
        val = '$WINDOW';
    } else if (value && window.document === value) {
        val = '$DOCUMENT';
    } else if (isScope(value)) {
        val = '$SCOPE';
    }
    return val;
};
toJson = function toJson(obj, pretty) {
    if (isUndefined(obj))
        return undefined;
    if (!isNumber(pretty)) {
        pretty = pretty ? 2 : null;
    }
    return JSON.stringify(obj, toJsonReplacer, pretty);
};
fromJson = function fromJson(json) {
    return isString(json) ? JSON.parse(json) : json;
};
timezoneToOffset = function timezoneToOffset(timezone, fallback) {
    timezone = timezone.replace(ALL_COLONS, '');
    var requestedTimezoneOffset = Date.parse('Jan 01, 1970 00:00:00 ' + timezone) / 60000;
    return isNumberNaN(requestedTimezoneOffset) ? fallback : requestedTimezoneOffset;
};
addDateMinutes = function addDateMinutes(date, minutes) {
    date = new Date(date.getTime());
    date.setMinutes(date.getMinutes() + minutes);
    return date;
};
convertTimezoneToLocal = function convertTimezoneToLocal(date, timezone, reverse) {
    reverse = reverse ? -1 : 1;
    var dateTimezoneOffset = date.getTimezoneOffset();
    var timezoneOffset = timezoneToOffset(timezone, dateTimezoneOffset);
    return addDateMinutes(date, reverse * (timezoneOffset - dateTimezoneOffset));
};
startingTag = function startingTag(element) {
    element = jqLite(element).clone();
    try {
        element.empty();
    } catch (e) {
    }
    var elemHtml = jqLite('<div>').append(element).html();
    try {
        return element[0].nodeType === NODE_TYPE_TEXT ? lowercase(elemHtml) : elemHtml.match(/^(<[^>]+>)/)[1].replace(/^<([\w-]+)/, function (match, nodeName) {
            return '<' + lowercase(nodeName);
        });
    } catch (e) {
        return lowercase(elemHtml);
    }
};
tryDecodeURIComponent = function tryDecodeURIComponent(value) {
    try {
        return decodeURIComponent(value);
    } catch (e) {
    }
};
parseKeyValue = function parseKeyValue(keyValue) {
    var obj = {};
    forEach((keyValue || '').split('&'), function (keyValue) {
        var splitPoint, key, val;
        if (keyValue) {
            key = keyValue = keyValue.replace(/\+/g, '%20');
            splitPoint = keyValue.indexOf('=');
            if (splitPoint !== -1) {
                key = keyValue.substring(0, splitPoint);
                val = keyValue.substring(splitPoint + 1);
            }
            key = tryDecodeURIComponent(key);
            if (isDefined(key)) {
                val = isDefined(val) ? tryDecodeURIComponent(val) : true;
                if (!hasOwnProperty.call(obj, key)) {
                    obj[key] = val;
                } else if (isArray(obj[key])) {
                    obj[key].push(val);
                } else {
                    obj[key] = [
                        obj[key],
                        val
                    ];
                }
            }
        }
    });
    return obj;
};
toKeyValue = function toKeyValue(obj) {
    var parts = [];
    forEach(obj, function (value, key) {
        if (isArray(value)) {
            forEach(value, function (arrayValue) {
                parts.push(encodeUriQuery(key, true) + (arrayValue === true ? '' : '=' + encodeUriQuery(arrayValue, true)));
            });
        } else {
            parts.push(encodeUriQuery(key, true) + (value === true ? '' : '=' + encodeUriQuery(value, true)));
        }
    });
    return parts.length ? parts.join('&') : '';
};
encodeUriSegment = function encodeUriSegment(val) {
    return encodeUriQuery(val, true).replace(/%26/gi, '&').replace(/%3D/gi, '=').replace(/%2B/gi, '+');
};
encodeUriQuery = function encodeUriQuery(val, pctEncodeSpaces) {
    return encodeURIComponent(val).replace(/%40/gi, '@').replace(/%3A/gi, ':').replace(/%24/g, '$').replace(/%2C/gi, ',').replace(/%3B/gi, ';').replace(/%20/g, pctEncodeSpaces ? '%20' : '+');
};
getNgAttribute = function getNgAttribute(element, ngAttr) {
    var attr, i, ii = ngAttrPrefixes.length;
    for (i = 0; i < ii; ++i) {
        attr = ngAttrPrefixes[i] + ngAttr;
        if (isString(attr = element.getAttribute(attr))) {
            return attr;
        }
    }
    return null;
};
allowAutoBootstrap = function allowAutoBootstrap(document) {
    var script = document.currentScript;
    if (!script) {
        return true;
    }
    if (!(script instanceof window.HTMLScriptElement || script instanceof window.SVGScriptElement)) {
        return false;
    }
    var attributes = script.attributes;
    var srcs = [
        attributes.getNamedItem('src'),
        attributes.getNamedItem('href'),
        attributes.getNamedItem('xlink:href')
    ];
    return srcs.every(function (src) {
        if (!src) {
            return true;
        }
        if (!src.value) {
            return false;
        }
        var link = document.createElement('a');
        link.href = src.value;
        if (document.location.origin === link.origin) {
            return true;
        }
        switch (link.protocol) {
        case 'http:':
        case 'https:':
        case 'ftp:':
        case 'blob:':
        case 'file:':
        case 'data:':
            return true;
        default:
            return false;
        }
    });
};
angularInit = function angularInit(element, bootstrap) {
    var appElement, module, config = {};
    forEach(ngAttrPrefixes, function (prefix) {
        var name = prefix + 'app';
        if (!appElement && element.hasAttribute && element.hasAttribute(name)) {
            appElement = element;
            module = element.getAttribute(name);
        }
    });
    forEach(ngAttrPrefixes, function (prefix) {
        var name = prefix + 'app';
        var candidate;
        if (!appElement && (candidate = element.querySelector('[' + name.replace(':', '\\:') + ']'))) {
            appElement = candidate;
            module = candidate.getAttribute(name);
        }
    });
    if (appElement) {
        if (!isAutoBootstrapAllowed) {
            window.console.error('Angular: disabling automatic bootstrap. <script> protocol indicates ' + 'an extension, document.location.href does not match.');
            return;
        }
        config.strictDi = getNgAttribute(appElement, 'strict-di') !== null;
        bootstrap(appElement, module ? [module] : [], config);
    }
};
bootstrap = function bootstrap(element, modules, config) {
    if (!isObject(config))
        config = {};
    var defaultConfig = {
        strictDi: false
    };
    config = extend(defaultConfig, config);
    var doBootstrap = function () {
        element = jqLite(element);
        if (element.injector()) {
            var tag = element[0] === window.document ? 'document' : startingTag(element);
            throw ngMinErr('btstrpd', 'App already bootstrapped with this element \'{0}\'', tag.replace(/</, '&lt;').replace(/>/, '&gt;'));
        }
        modules = modules || [];
        modules.unshift([
            '$provide',
            function ($provide) {
                $provide.value('$rootElement', element);
            }
        ]);
        if (config.debugInfoEnabled) {
            modules.push([
                '$compileProvider',
                function ($compileProvider) {
                    $compileProvider.debugInfoEnabled(true);
                }
            ]);
        }
        modules.unshift('ng');
        var injector = createInjector(modules, config.strictDi);
        injector.invoke([
            '$rootScope',
            '$rootElement',
            '$compile',
            '$injector',
            function bootstrapApply(scope, element, compile, injector) {
                scope.$apply(function () {
                    element.data('$injector', injector);
                    compile(element)(scope);
                });
            }
        ]);
        return injector;
    };
    var NG_ENABLE_DEBUG_INFO = /^NG_ENABLE_DEBUG_INFO!/;
    var NG_DEFER_BOOTSTRAP = /^NG_DEFER_BOOTSTRAP!/;
    if (window && NG_ENABLE_DEBUG_INFO.test(window.name)) {
        config.debugInfoEnabled = true;
        window.name = window.name.replace(NG_ENABLE_DEBUG_INFO, '');
    }
    if (window && !NG_DEFER_BOOTSTRAP.test(window.name)) {
        return doBootstrap();
    }
    window.name = window.name.replace(NG_DEFER_BOOTSTRAP, '');
    angular.resumeBootstrap = function (extraModules) {
        forEach(extraModules, function (module) {
            modules.push(module);
        });
        return doBootstrap();
    };
    if (isFunction(angular.resumeDeferredBootstrap)) {
        angular.resumeDeferredBootstrap();
    }
};
reloadWithDebugInfo = function reloadWithDebugInfo() {
    window.name = 'NG_ENABLE_DEBUG_INFO!' + window.name;
    window.location.reload();
};
getTestability = function getTestability(rootElement) {
    var injector = angular.element(rootElement).injector();
    if (!injector) {
        throw ngMinErr('test', 'no injector found for element argument to getTestability');
    }
    return injector.get('$$testability');
};
snake_case = function snake_case(name, separator) {
    separator = separator || '_';
    return name.replace(SNAKE_CASE_REGEXP, function (letter, pos) {
        return (pos ? separator : '') + letter.toLowerCase();
    });
};
bindJQuery = function bindJQuery() {
    var originalCleanData;
    if (bindJQueryFired) {
        return;
    }
    var jqName = jq();
    jQuery = isUndefined(jqName) ? window.jQuery : !jqName ? undefined : window[jqName];
    if (jQuery && jQuery.fn.on) {
        jqLite = jQuery;
        extend(jQuery.fn, {
            scope: JQLitePrototype.scope,
            isolateScope: JQLitePrototype.isolateScope,
            controller: JQLitePrototype.controller,
            injector: JQLitePrototype.injector,
            inheritedData: JQLitePrototype.inheritedData
        });
        originalCleanData = jQuery.cleanData;
        jQuery.cleanData = function (elems) {
            var events;
            for (var i = 0, elem; (elem = elems[i]) != null; i++) {
                events = jQuery._data(elem, 'events');
                if (events && events.$destroy) {
                    jQuery(elem).triggerHandler('$destroy');
                }
            }
            originalCleanData(elems);
        };
    } else {
        jqLite = JQLite;
    }
    angular.element = jqLite;
    bindJQueryFired = true;
};
assertArg = function assertArg(arg, name, reason) {
    if (!arg) {
        throw ngMinErr('areq', 'Argument \'{0}\' is {1}', name || '?', reason || 'required');
    }
    return arg;
};
assertArgFn = function assertArgFn(arg, name, acceptArrayAnnotation) {
    if (acceptArrayAnnotation && isArray(arg)) {
        arg = arg[arg.length - 1];
    }
    assertArg(isFunction(arg), name, 'not a function, got ' + (arg && typeof arg === 'object' ? arg.constructor.name || 'Object' : typeof arg));
    return arg;
};
assertNotHasOwnProperty = function assertNotHasOwnProperty(name, context) {
    if (name === 'hasOwnProperty') {
        throw ngMinErr('badname', 'hasOwnProperty is not a valid {0} name', context);
    }
};
getter = function getter(obj, path, bindFnToScope) {
    if (!path)
        return obj;
    var keys = path.split('.');
    var key;
    var lastInstance = obj;
    var len = keys.length;
    for (var i = 0; i < len; i++) {
        key = keys[i];
        if (obj) {
            obj = (lastInstance = obj)[key];
        }
    }
    if (!bindFnToScope && isFunction(obj)) {
        return bind(lastInstance, obj);
    }
    return obj;
};
getBlockNodes = function getBlockNodes(nodes) {
    var node = nodes[0];
    var endNode = nodes[nodes.length - 1];
    var blockNodes;
    for (var i = 1; node !== endNode && (node = node.nextSibling); i++) {
        if (blockNodes || nodes[i] !== node) {
            if (!blockNodes) {
                blockNodes = jqLite(slice.call(nodes, 0, i));
            }
            blockNodes.push(node);
        }
    }
    return blockNodes || nodes;
};
createMap = function createMap() {
    return Object.create(null);
};
stringify = function stringify(value) {
    if (value == null) {
        return '';
    }
    switch (typeof value) {
    case 'string':
        break;
    case 'number':
        value = '' + value;
        break;
    default:
        if (hasCustomToString(value) && !isArray(value) && !isDate(value)) {
            value = value.toString();
        } else {
            value = toJson(value);
        }
    }
    return value;
};
setupModuleLoader = function setupModuleLoader(window) {
    var $injectorMinErr = minErr('$injector');
    var ngMinErr = minErr('ng');
    function ensure(obj, name, factory) {
        return obj[name] || (obj[name] = factory());
    }
    var angular = ensure(window, 'angular', Object);
    angular.$$minErr = angular.$$minErr || minErr;
    return ensure(angular, 'module', function () {
        var modules = {};
        return function module(name, requires, configFn) {
            var info = {};
            var assertNotHasOwnProperty = function (name, context) {
                if (name === 'hasOwnProperty') {
                    throw ngMinErr('badname', 'hasOwnProperty is not a valid {0} name', context);
                }
            };
            assertNotHasOwnProperty(name, 'module');
            if (requires && modules.hasOwnProperty(name)) {
                modules[name] = null;
            }
            return ensure(modules, name, function () {
                if (!requires) {
                    throw $injectorMinErr('nomod', 'Module \'{0}\' is not available! You either misspelled ' + 'the module name or forgot to load it. If registering a module ensure that you ' + 'specify the dependencies as the second argument.', name);
                }
                var invokeQueue = [];
                var configBlocks = [];
                var runBlocks = [];
                var config = invokeLater('$injector', 'invoke', 'push', configBlocks);
                var moduleInstance = {
                    _invokeQueue: invokeQueue,
                    _configBlocks: configBlocks,
                    _runBlocks: runBlocks,
                    info: function (value) {
                        if (isDefined(value)) {
                            if (!isObject(value))
                                throw ngMinErr('aobj', 'Argument \'{0}\' must be an object', 'value');
                            info = value;
                            return this;
                        }
                        return info;
                    },
                    requires: requires,
                    name: name,
                    provider: invokeLaterAndSetModuleName('$provide', 'provider'),
                    factory: invokeLaterAndSetModuleName('$provide', 'factory'),
                    service: invokeLaterAndSetModuleName('$provide', 'service'),
                    value: invokeLater('$provide', 'value'),
                    constant: invokeLater('$provide', 'constant', 'unshift'),
                    decorator: invokeLaterAndSetModuleName('$provide', 'decorator', configBlocks),
                    animation: invokeLaterAndSetModuleName('$animateProvider', 'register'),
                    filter: invokeLaterAndSetModuleName('$filterProvider', 'register'),
                    controller: invokeLaterAndSetModuleName('$controllerProvider', 'register'),
                    directive: invokeLaterAndSetModuleName('$compileProvider', 'directive'),
                    component: invokeLaterAndSetModuleName('$compileProvider', 'component'),
                    config: config,
                    run: function (block) {
                        runBlocks.push(block);
                        return this;
                    }
                };
                if (configFn) {
                    config(configFn);
                }
                return moduleInstance;
                function invokeLater(provider, method, insertMethod, queue) {
                    if (!queue)
                        queue = invokeQueue;
                    return function () {
                        queue[insertMethod || 'push']([
                            provider,
                            method,
                            arguments
                        ]);
                        return moduleInstance;
                    };
                }
                function invokeLaterAndSetModuleName(provider, method, queue) {
                    if (!queue)
                        queue = invokeQueue;
                    return function (recipeName, factoryFunction) {
                        if (factoryFunction && isFunction(factoryFunction))
                            factoryFunction.$$moduleName = name;
                        queue.push([
                            provider,
                            method,
                            arguments
                        ]);
                        return moduleInstance;
                    };
                }
            });
        };
    });
};
shallowCopy = function shallowCopy(src, dst) {
    if (isArray(src)) {
        dst = dst || [];
        for (var i = 0, ii = src.length; i < ii; i++) {
            dst[i] = src[i];
        }
    } else if (isObject(src)) {
        dst = dst || {};
        for (var key in src) {
            if (!(key.charAt(0) === '$' && key.charAt(1) === '$')) {
                dst[key] = src[key];
            }
        }
    }
    return dst || src;
};
serializeObject = function serializeObject(obj, maxDepth) {
    var seen = [];
    if (isValidObjectMaxDepth(maxDepth)) {
        obj = copy(obj, null, maxDepth);
    }
    return JSON.stringify(obj, function (key, val) {
        val = toJsonReplacer(key, val);
        if (isObject(val)) {
            if (seen.indexOf(val) >= 0)
                return '...';
            seen.push(val);
        }
        return val;
    });
};
toDebugString = function toDebugString(obj, maxDepth) {
    if (typeof obj === 'function') {
        return obj.toString().replace(/ \{[\s\S]*$/, '');
    } else if (isUndefined(obj)) {
        return 'undefined';
    } else if (typeof obj !== 'string') {
        return serializeObject(obj, maxDepth);
    }
    return obj;
};
publishExternalAPI = function publishExternalAPI(angular) {
    extend(angular, {
        'errorHandlingConfig': errorHandlingConfig,
        'bootstrap': bootstrap,
        'copy': copy,
        'extend': extend,
        'merge': merge,
        'equals': equals,
        'element': jqLite,
        'forEach': forEach,
        'injector': createInjector,
        'noop': noop,
        'bind': bind,
        'toJson': toJson,
        'fromJson': fromJson,
        'identity': identity,
        'isUndefined': isUndefined,
        'isDefined': isDefined,
        'isString': isString,
        'isFunction': isFunction,
        'isObject': isObject,
        'isNumber': isNumber,
        'isElement': isElement,
        'isArray': isArray,
        'version': version,
        'isDate': isDate,
        'lowercase': lowercase,
        'uppercase': uppercase,
        'callbacks': {
            $$counter: 0
        },
        'getTestability': getTestability,
        'reloadWithDebugInfo': reloadWithDebugInfo,
        '$$minErr': minErr,
        '$$csp': csp,
        '$$encodeUriSegment': encodeUriSegment,
        '$$encodeUriQuery': encodeUriQuery,
        '$$stringify': stringify
    });
    angularModule = setupModuleLoader(window);
    angularModule('ng', ['ngLocale'], [
        '$provide',
        function ngModule($provide) {
            $provide.provider({
                $$sanitizeUri: $$SanitizeUriProvider
            });
            $provide.provider('$compile', $CompileProvider).directive({
                a: htmlAnchorDirective,
                input: inputDirective,
                textarea: inputDirective,
                form: formDirective,
                script: scriptDirective,
                select: selectDirective,
                option: optionDirective,
                ngBind: ngBindDirective,
                ngBindHtml: ngBindHtmlDirective,
                ngBindTemplate: ngBindTemplateDirective,
                ngClass: ngClassDirective,
                ngClassEven: ngClassEvenDirective,
                ngClassOdd: ngClassOddDirective,
                ngCloak: ngCloakDirective,
                ngController: ngControllerDirective,
                ngForm: ngFormDirective,
                ngHide: ngHideDirective,
                ngIf: ngIfDirective,
                ngInclude: ngIncludeDirective,
                ngInit: ngInitDirective,
                ngNonBindable: ngNonBindableDirective,
                ngPluralize: ngPluralizeDirective,
                ngRepeat: ngRepeatDirective,
                ngShow: ngShowDirective,
                ngStyle: ngStyleDirective,
                ngSwitch: ngSwitchDirective,
                ngSwitchWhen: ngSwitchWhenDirective,
                ngSwitchDefault: ngSwitchDefaultDirective,
                ngOptions: ngOptionsDirective,
                ngTransclude: ngTranscludeDirective,
                ngModel: ngModelDirective,
                ngList: ngListDirective,
                ngChange: ngChangeDirective,
                pattern: patternDirective,
                ngPattern: patternDirective,
                required: requiredDirective,
                ngRequired: requiredDirective,
                minlength: minlengthDirective,
                ngMinlength: minlengthDirective,
                maxlength: maxlengthDirective,
                ngMaxlength: maxlengthDirective,
                ngValue: ngValueDirective,
                ngModelOptions: ngModelOptionsDirective
            }).directive({
                ngInclude: ngIncludeFillContentDirective
            }).directive(ngAttributeAliasDirectives).directive(ngEventDirectives);
            $provide.provider({
                $anchorScroll: $AnchorScrollProvider,
                $animate: $AnimateProvider,
                $animateCss: $CoreAnimateCssProvider,
                $$animateJs: $$CoreAnimateJsProvider,
                $$animateQueue: $$CoreAnimateQueueProvider,
                $$AnimateRunner: $$AnimateRunnerFactoryProvider,
                $$animateAsyncRun: $$AnimateAsyncRunFactoryProvider,
                $browser: $BrowserProvider,
                $cacheFactory: $CacheFactoryProvider,
                $controller: $ControllerProvider,
                $document: $DocumentProvider,
                $$isDocumentHidden: $$IsDocumentHiddenProvider,
                $exceptionHandler: $ExceptionHandlerProvider,
                $filter: $FilterProvider,
                $$forceReflow: $$ForceReflowProvider,
                $interpolate: $InterpolateProvider,
                $interval: $IntervalProvider,
                $http: $HttpProvider,
                $httpParamSerializer: $HttpParamSerializerProvider,
                $httpParamSerializerJQLike: $HttpParamSerializerJQLikeProvider,
                $httpBackend: $HttpBackendProvider,
                $xhrFactory: $xhrFactoryProvider,
                $jsonpCallbacks: $jsonpCallbacksProvider,
                $location: $LocationProvider,
                $log: $LogProvider,
                $parse: $ParseProvider,
                $rootScope: $RootScopeProvider,
                $q: $QProvider,
                $$q: $$QProvider,
                $sce: $SceProvider,
                $sceDelegate: $SceDelegateProvider,
                $sniffer: $SnifferProvider,
                $templateCache: $TemplateCacheProvider,
                $templateRequest: $TemplateRequestProvider,
                $$testability: $$TestabilityProvider,
                $timeout: $TimeoutProvider,
                $window: $WindowProvider,
                $$rAF: $$RAFProvider,
                $$jqLite: $$jqLiteProvider,
                $$Map: $$MapProvider,
                $$cookieReader: $$CookieReaderProvider
            });
        }
    ]).info({
        angularVersion: '1.6.3'
    });
};
jqNextId = function jqNextId() {
    return ++jqId;
};
cssKebabToCamel = function cssKebabToCamel(name) {
    return kebabToCamel(name.replace(MS_HACK_REGEXP, 'ms-'));
};
fnCamelCaseReplace = function fnCamelCaseReplace(all, letter) {
    return letter.toUpperCase();
};
kebabToCamel = function kebabToCamel(name) {
    return name.replace(DASH_LOWERCASE_REGEXP, fnCamelCaseReplace);
};
jqLiteIsTextNode = function jqLiteIsTextNode(html) {
    return !HTML_REGEXP.test(html);
};
jqLiteAcceptsData = function jqLiteAcceptsData(node) {
    var nodeType = node.nodeType;
    return nodeType === NODE_TYPE_ELEMENT || !nodeType || nodeType === NODE_TYPE_DOCUMENT;
};
jqLiteHasData = function jqLiteHasData(node) {
    for (var key in jqCache[node.ng339]) {
        return true;
    }
    return false;
};
jqLiteCleanData = function jqLiteCleanData(nodes) {
    for (var i = 0, ii = nodes.length; i < ii; i++) {
        jqLiteRemoveData(nodes[i]);
    }
};
jqLiteBuildFragment = function jqLiteBuildFragment(html, context) {
    var tmp, tag, wrap, fragment = context.createDocumentFragment(), nodes = [], i;
    if (jqLiteIsTextNode(html)) {
        nodes.push(context.createTextNode(html));
    } else {
        tmp = fragment.appendChild(context.createElement('div'));
        tag = (TAG_NAME_REGEXP.exec(html) || [
            '',
            ''
        ])[1].toLowerCase();
        wrap = wrapMap[tag] || wrapMap._default;
        tmp.innerHTML = wrap[1] + html.replace(XHTML_TAG_REGEXP, '<$1></$2>') + wrap[2];
        i = wrap[0];
        while (i--) {
            tmp = tmp.lastChild;
        }
        nodes = concat(nodes, tmp.childNodes);
        tmp = fragment.firstChild;
        tmp.textContent = '';
    }
    fragment.textContent = '';
    fragment.innerHTML = '';
    forEach(nodes, function (node) {
        fragment.appendChild(node);
    });
    return fragment;
};
jqLiteParseHTML = function jqLiteParseHTML(html, context) {
    context = context || window.document;
    var parsed;
    if (parsed = SINGLE_TAG_REGEXP.exec(html)) {
        return [context.createElement(parsed[1])];
    }
    if (parsed = jqLiteBuildFragment(html, context)) {
        return parsed.childNodes;
    }
    return [];
};
jqLiteWrapNode = function jqLiteWrapNode(node, wrapper) {
    var parent = node.parentNode;
    if (parent) {
        parent.replaceChild(wrapper, node);
    }
    wrapper.appendChild(node);
};
JQLite = function JQLite(element) {
    if (element instanceof JQLite) {
        return element;
    }
    var argIsString;
    if (isString(element)) {
        element = trim(element);
        argIsString = true;
    }
    if (!(this instanceof JQLite)) {
        if (argIsString && element.charAt(0) !== '<') {
            throw jqLiteMinErr('nosel', 'Looking up elements via selectors is not supported by jqLite! See: http://docs.angularjs.org/api/angular.element');
        }
        return new JQLite(element);
    }
    if (argIsString) {
        jqLiteAddNodes(this, jqLiteParseHTML(element));
    } else if (isFunction(element)) {
        jqLiteReady(element);
    } else {
        jqLiteAddNodes(this, element);
    }
};
jqLiteClone = function jqLiteClone(element) {
    return element.cloneNode(true);
};
jqLiteDealoc = function jqLiteDealoc(element, onlyDescendants) {
    if (!onlyDescendants)
        jqLiteRemoveData(element);
    if (element.querySelectorAll) {
        var descendants = element.querySelectorAll('*');
        for (var i = 0, l = descendants.length; i < l; i++) {
            jqLiteRemoveData(descendants[i]);
        }
    }
};
jqLiteOff = function jqLiteOff(element, type, fn, unsupported) {
    if (isDefined(unsupported))
        throw jqLiteMinErr('offargs', 'jqLite#off() does not support the `selector` argument');
    var expandoStore = jqLiteExpandoStore(element);
    var events = expandoStore && expandoStore.events;
    var handle = expandoStore && expandoStore.handle;
    if (!handle)
        return;
    if (!type) {
        for (type in events) {
            if (type !== '$destroy') {
                element.removeEventListener(type, handle);
            }
            delete events[type];
        }
    } else {
        var removeHandler = function (type) {
            var listenerFns = events[type];
            if (isDefined(fn)) {
                arrayRemove(listenerFns || [], fn);
            }
            if (!(isDefined(fn) && listenerFns && listenerFns.length > 0)) {
                element.removeEventListener(type, handle);
                delete events[type];
            }
        };
        forEach(type.split(' '), function (type) {
            removeHandler(type);
            if (MOUSE_EVENT_MAP[type]) {
                removeHandler(MOUSE_EVENT_MAP[type]);
            }
        });
    }
};
jqLiteRemoveData = function jqLiteRemoveData(element, name) {
    var expandoId = element.ng339;
    var expandoStore = expandoId && jqCache[expandoId];
    if (expandoStore) {
        if (name) {
            delete expandoStore.data[name];
            return;
        }
        if (expandoStore.handle) {
            if (expandoStore.events.$destroy) {
                expandoStore.handle({}, '$destroy');
            }
            jqLiteOff(element);
        }
        delete jqCache[expandoId];
        element.ng339 = undefined;
    }
};
jqLiteExpandoStore = function jqLiteExpandoStore(element, createIfNecessary) {
    var expandoId = element.ng339, expandoStore = expandoId && jqCache[expandoId];
    if (createIfNecessary && !expandoStore) {
        element.ng339 = expandoId = jqNextId();
        expandoStore = jqCache[expandoId] = {
            events: {},
            data: {},
            handle: undefined
        };
    }
    return expandoStore;
};
jqLiteData = function jqLiteData(element, key, value) {
    if (jqLiteAcceptsData(element)) {
        var prop;
        var isSimpleSetter = isDefined(value);
        var isSimpleGetter = !isSimpleSetter && key && !isObject(key);
        var massGetter = !key;
        var expandoStore = jqLiteExpandoStore(element, !isSimpleGetter);
        var data = expandoStore && expandoStore.data;
        if (isSimpleSetter) {
            data[kebabToCamel(key)] = value;
        } else {
            if (massGetter) {
                return data;
            } else {
                if (isSimpleGetter) {
                    return data && data[kebabToCamel(key)];
                } else {
                    for (prop in key) {
                        data[kebabToCamel(prop)] = key[prop];
                    }
                }
            }
        }
    }
};
jqLiteHasClass = function jqLiteHasClass(element, selector) {
    if (!element.getAttribute)
        return false;
    return (' ' + (element.getAttribute('class') || '') + ' ').replace(/[\n\t]/g, ' ').indexOf(' ' + selector + ' ') > -1;
};
jqLiteRemoveClass = function jqLiteRemoveClass(element, cssClasses) {
    if (cssClasses && element.setAttribute) {
        forEach(cssClasses.split(' '), function (cssClass) {
            element.setAttribute('class', trim((' ' + (element.getAttribute('class') || '') + ' ').replace(/[\n\t]/g, ' ').replace(' ' + trim(cssClass) + ' ', ' ')));
        });
    }
};
jqLiteAddClass = function jqLiteAddClass(element, cssClasses) {
    if (cssClasses && element.setAttribute) {
        var existingClasses = (' ' + (element.getAttribute('class') || '') + ' ').replace(/[\n\t]/g, ' ');
        forEach(cssClasses.split(' '), function (cssClass) {
            cssClass = trim(cssClass);
            if (existingClasses.indexOf(' ' + cssClass + ' ') === -1) {
                existingClasses += cssClass + ' ';
            }
        });
        element.setAttribute('class', trim(existingClasses));
    }
};
jqLiteAddNodes = function jqLiteAddNodes(root, elements) {
    if (elements) {
        if (elements.nodeType) {
            root[root.length++] = elements;
        } else {
            var length = elements.length;
            if (typeof length === 'number' && elements.window !== elements) {
                if (length) {
                    for (var i = 0; i < length; i++) {
                        root[root.length++] = elements[i];
                    }
                }
            } else {
                root[root.length++] = elements;
            }
        }
    }
};
jqLiteController = function jqLiteController(element, name) {
    return jqLiteInheritedData(element, '$' + (name || 'ngController') + 'Controller');
};
jqLiteInheritedData = function jqLiteInheritedData(element, name, value) {
    if (element.nodeType === NODE_TYPE_DOCUMENT) {
        element = element.documentElement;
    }
    var names = isArray(name) ? name : [name];
    while (element) {
        for (var i = 0, ii = names.length; i < ii; i++) {
            if (isDefined(value = jqLite.data(element, names[i])))
                return value;
        }
        element = element.parentNode || element.nodeType === NODE_TYPE_DOCUMENT_FRAGMENT && element.host;
    }
};
jqLiteEmpty = function jqLiteEmpty(element) {
    jqLiteDealoc(element, true);
    while (element.firstChild) {
        element.removeChild(element.firstChild);
    }
};
jqLiteRemove = function jqLiteRemove(element, keepData) {
    if (!keepData)
        jqLiteDealoc(element);
    var parent = element.parentNode;
    if (parent)
        parent.removeChild(element);
};
jqLiteDocumentLoaded = function jqLiteDocumentLoaded(action, win) {
    win = win || window;
    if (win.document.readyState === 'complete') {
        win.setTimeout(action);
    } else {
        jqLite(win).on('load', action);
    }
};
jqLiteReady = function jqLiteReady(fn) {
    function trigger() {
        window.document.removeEventListener('DOMContentLoaded', trigger);
        window.removeEventListener('load', trigger);
        fn();
    }
    if (window.document.readyState === 'complete') {
        window.setTimeout(fn);
    } else {
        window.document.addEventListener('DOMContentLoaded', trigger);
        window.addEventListener('load', trigger);
    }
};
getBooleanAttrName = function getBooleanAttrName(element, name) {
    var booleanAttr = BOOLEAN_ATTR[name.toLowerCase()];
    return booleanAttr && BOOLEAN_ELEMENTS[nodeName_(element)] && booleanAttr;
};
getAliasedAttrName = function getAliasedAttrName(name) {
    return ALIASED_ATTR[name];
};
createEventHandler = function createEventHandler(element, events) {
    var eventHandler = function (event, type) {
        event.isDefaultPrevented = function () {
            return event.defaultPrevented;
        };
        var eventFns = events[type || event.type];
        var eventFnsLength = eventFns ? eventFns.length : 0;
        if (!eventFnsLength)
            return;
        if (isUndefined(event.immediatePropagationStopped)) {
            var originalStopImmediatePropagation = event.stopImmediatePropagation;
            event.stopImmediatePropagation = function () {
                event.immediatePropagationStopped = true;
                if (event.stopPropagation) {
                    event.stopPropagation();
                }
                if (originalStopImmediatePropagation) {
                    originalStopImmediatePropagation.call(event);
                }
            };
        }
        event.isImmediatePropagationStopped = function () {
            return event.immediatePropagationStopped === true;
        };
        var handlerWrapper = eventFns.specialHandlerWrapper || defaultHandlerWrapper;
        if (eventFnsLength > 1) {
            eventFns = shallowCopy(eventFns);
        }
        for (var i = 0; i < eventFnsLength; i++) {
            if (!event.isImmediatePropagationStopped()) {
                handlerWrapper(element, event, eventFns[i]);
            }
        }
    };
    eventHandler.elem = element;
    return eventHandler;
};
defaultHandlerWrapper = function defaultHandlerWrapper(element, event, handler) {
    handler.call(element, event);
};
specialMouseHandlerWrapper = function specialMouseHandlerWrapper(target, event, handler) {
    var related = event.relatedTarget;
    if (!related || related !== target && !jqLiteContains.call(target, related)) {
        handler.call(target, event);
    }
};
$$jqLiteProvider = function $$jqLiteProvider() {
    this.$get = function $$jqLite() {
        return extend(JQLite, {
            hasClass: function (node, classes) {
                if (node.attr)
                    node = node[0];
                return jqLiteHasClass(node, classes);
            },
            addClass: function (node, classes) {
                if (node.attr)
                    node = node[0];
                return jqLiteAddClass(node, classes);
            },
            removeClass: function (node, classes) {
                if (node.attr)
                    node = node[0];
                return jqLiteRemoveClass(node, classes);
            }
        });
    };
};
hashKey = function hashKey(obj, nextUidFn) {
    var key = obj && obj.$$hashKey;
    if (key) {
        if (typeof key === 'function') {
            key = obj.$$hashKey();
        }
        return key;
    }
    var objType = typeof obj;
    if (objType === 'function' || objType === 'object' && obj !== null) {
        key = obj.$$hashKey = objType + ':' + (nextUidFn || nextUid)();
    } else {
        key = objType + ':' + obj;
    }
    return key;
};
NgMapShim = function NgMapShim() {
    this._keys = [];
    this._values = [];
    this._lastKey = NaN;
    this._lastIndex = -1;
};
stringifyFn = function stringifyFn(fn) {
    return Function.prototype.toString.call(fn);
};
extractArgs = function extractArgs(fn) {
    var fnText = stringifyFn(fn).replace(STRIP_COMMENTS, ''), args = fnText.match(ARROW_ARG) || fnText.match(FN_ARGS);
    return args;
};
anonFn = function anonFn(fn) {
    var args = extractArgs(fn);
    if (args) {
        return 'function(' + (args[1] || '').replace(/[\s\r\n]+/, ' ') + ')';
    }
    return 'fn';
};
annotate = function annotate(fn, strictDi, name) {
    var $inject, argDecl, last;
    if (typeof fn === 'function') {
        if (!($inject = fn.$inject)) {
            $inject = [];
            if (fn.length) {
                if (strictDi) {
                    if (!isString(name) || !name) {
                        name = fn.name || anonFn(fn);
                    }
                    throw $injectorMinErr('strictdi', '{0} is not using explicit annotation and cannot be invoked in strict mode', name);
                }
                argDecl = extractArgs(fn);
                forEach(argDecl[1].split(FN_ARG_SPLIT), function (arg) {
                    arg.replace(FN_ARG, function (all, underscore, name) {
                        $inject.push(name);
                    });
                });
            }
            fn.$inject = $inject;
        }
    } else if (isArray(fn)) {
        last = fn.length - 1;
        assertArgFn(fn[last], 'fn');
        $inject = fn.slice(0, last);
    } else {
        assertArgFn(fn, 'fn', true);
    }
    return $inject;
};
createInjector = function createInjector(modulesToLoad, strictDi) {
    strictDi = strictDi === true;
    var INSTANTIATING = {}, providerSuffix = 'Provider', path = [], loadedModules = new NgMap(), providerCache = {
            $provide: {
                provider: supportObject(provider),
                factory: supportObject(factory),
                service: supportObject(service),
                value: supportObject(value),
                constant: supportObject(constant),
                decorator: decorator
            }
        }, providerInjector = providerCache.$injector = createInternalInjector(providerCache, function (serviceName, caller) {
            if (angular.isString(caller)) {
                path.push(caller);
            }
            throw $injectorMinErr('unpr', 'Unknown provider: {0}', path.join(' <- '));
        }), instanceCache = {}, protoInstanceInjector = createInternalInjector(instanceCache, function (serviceName, caller) {
            var provider = providerInjector.get(serviceName + providerSuffix, caller);
            return instanceInjector.invoke(provider.$get, provider, undefined, serviceName);
        }), instanceInjector = protoInstanceInjector;
    providerCache['$injector' + providerSuffix] = {
        $get: valueFn(protoInstanceInjector)
    };
    instanceInjector.modules = providerInjector.modules = createMap();
    var runBlocks = loadModules(modulesToLoad);
    instanceInjector = protoInstanceInjector.get('$injector');
    instanceInjector.strictDi = strictDi;
    forEach(runBlocks, function (fn) {
        if (fn)
            instanceInjector.invoke(fn);
    });
    return instanceInjector;
    function supportObject(delegate) {
        return function (key, value) {
            if (isObject(key)) {
                forEach(key, reverseParams(delegate));
            } else {
                return delegate(key, value);
            }
        };
    }
    function provider(name, provider_) {
        assertNotHasOwnProperty(name, 'service');
        if (isFunction(provider_) || isArray(provider_)) {
            provider_ = providerInjector.instantiate(provider_);
        }
        if (!provider_.$get) {
            throw $injectorMinErr('pget', 'Provider \'{0}\' must define $get factory method.', name);
        }
        return providerCache[name + providerSuffix] = provider_;
    }
    function enforceReturnValue(name, factory) {
        return function enforcedReturnValue() {
            var result = instanceInjector.invoke(factory, this);
            if (isUndefined(result)) {
                throw $injectorMinErr('undef', 'Provider \'{0}\' must return a value from $get factory method.', name);
            }
            return result;
        };
    }
    function factory(name, factoryFn, enforce) {
        return provider(name, {
            $get: enforce !== false ? enforceReturnValue(name, factoryFn) : factoryFn
        });
    }
    function service(name, constructor) {
        return factory(name, [
            '$injector',
            function ($injector) {
                return $injector.instantiate(constructor);
            }
        ]);
    }
    function value(name, val) {
        return factory(name, valueFn(val), false);
    }
    function constant(name, value) {
        assertNotHasOwnProperty(name, 'constant');
        providerCache[name] = value;
        instanceCache[name] = value;
    }
    function decorator(serviceName, decorFn) {
        var origProvider = providerInjector.get(serviceName + providerSuffix), orig$get = origProvider.$get;
        origProvider.$get = function () {
            var origInstance = instanceInjector.invoke(orig$get, origProvider);
            return instanceInjector.invoke(decorFn, null, {
                $delegate: origInstance
            });
        };
    }
    function loadModules(modulesToLoad) {
        assertArg(isUndefined(modulesToLoad) || isArray(modulesToLoad), 'modulesToLoad', 'not an array');
        var runBlocks = [], moduleFn;
        forEach(modulesToLoad, function (module) {
            if (loadedModules.get(module))
                return;
            loadedModules.set(module, true);
            function runInvokeQueue(queue) {
                var i, ii;
                for (i = 0, ii = queue.length; i < ii; i++) {
                    var invokeArgs = queue[i], provider = providerInjector.get(invokeArgs[0]);
                    provider[invokeArgs[1]].apply(provider, invokeArgs[2]);
                }
            }
            try {
                if (isString(module)) {
                    moduleFn = angularModule(module);
                    instanceInjector.modules[module] = moduleFn;
                    runBlocks = runBlocks.concat(loadModules(moduleFn.requires)).concat(moduleFn._runBlocks);
                    runInvokeQueue(moduleFn._invokeQueue);
                    runInvokeQueue(moduleFn._configBlocks);
                } else if (isFunction(module)) {
                    runBlocks.push(providerInjector.invoke(module));
                } else if (isArray(module)) {
                    runBlocks.push(providerInjector.invoke(module));
                } else {
                    assertArgFn(module, 'module');
                }
            } catch (e) {
                if (isArray(module)) {
                    module = module[module.length - 1];
                }
                if (e.message && e.stack && e.stack.indexOf(e.message) === -1) {
                    e = e.message + '\n' + e.stack;
                }
                throw $injectorMinErr('modulerr', 'Failed to instantiate module {0} due to:\n{1}', module, e.stack || e.message || e);
            }
        });
        return runBlocks;
    }
    function createInternalInjector(cache, factory) {
        function getService(serviceName, caller) {
            if (cache.hasOwnProperty(serviceName)) {
                if (cache[serviceName] === INSTANTIATING) {
                    throw $injectorMinErr('cdep', 'Circular dependency found: {0}', serviceName + ' <- ' + path.join(' <- '));
                }
                return cache[serviceName];
            } else {
                try {
                    path.unshift(serviceName);
                    cache[serviceName] = INSTANTIATING;
                    cache[serviceName] = factory(serviceName, caller);
                    return cache[serviceName];
                } catch (err) {
                    if (cache[serviceName] === INSTANTIATING) {
                        delete cache[serviceName];
                    }
                    throw err;
                } finally {
                    path.shift();
                }
            }
        }
        function injectionArgs(fn, locals, serviceName) {
            var args = [], $inject = createInjector.$$annotate(fn, strictDi, serviceName);
            for (var i = 0, length = $inject.length; i < length; i++) {
                var key = $inject[i];
                if (typeof key !== 'string') {
                    throw $injectorMinErr('itkn', 'Incorrect injection token! Expected service name as string, got {0}', key);
                }
                args.push(locals && locals.hasOwnProperty(key) ? locals[key] : getService(key, serviceName));
            }
            return args;
        }
        function isClass(func) {
            if (msie || typeof func !== 'function') {
                return false;
            }
            var result = func.$$ngIsClass;
            if (!isBoolean(result)) {
                result = func.$$ngIsClass = /^(?:class\b|constructor\()/.test(stringifyFn(func));
            }
            return result;
        }
        function invoke(fn, self, locals, serviceName) {
            if (typeof locals === 'string') {
                serviceName = locals;
                locals = null;
            }
            var args = injectionArgs(fn, locals, serviceName);
            if (isArray(fn)) {
                fn = fn[fn.length - 1];
            }
            if (!isClass(fn)) {
                return fn.apply(self, args);
            } else {
                args.unshift(null);
                return new (Function.prototype.bind.apply(fn, args))();
            }
        }
        function instantiate(Type, locals, serviceName) {
            var ctor = isArray(Type) ? Type[Type.length - 1] : Type;
            var args = injectionArgs(Type, locals, serviceName);
            args.unshift(null);
            return new (Function.prototype.bind.apply(ctor, args))();
        }
        return {
            invoke: invoke,
            instantiate: instantiate,
            get: getService,
            annotate: createInjector.$$annotate,
            has: function (name) {
                return providerCache.hasOwnProperty(name + providerSuffix) || cache.hasOwnProperty(name);
            }
        };
    }
};
$AnchorScrollProvider = function $AnchorScrollProvider() {
    var autoScrollingEnabled = true;
    this.disableAutoScrolling = function () {
        autoScrollingEnabled = false;
    };
    this.$get = [
        '$window',
        '$location',
        '$rootScope',
        function ($window, $location, $rootScope) {
            var document = $window.document;
            function getFirstAnchor(list) {
                var result = null;
                Array.prototype.some.call(list, function (element) {
                    if (nodeName_(element) === 'a') {
                        result = element;
                        return true;
                    }
                });
                return result;
            }
            function getYOffset() {
                var offset = scroll.yOffset;
                if (isFunction(offset)) {
                    offset = offset();
                } else if (isElement(offset)) {
                    var elem = offset[0];
                    var style = $window.getComputedStyle(elem);
                    if (style.position !== 'fixed') {
                        offset = 0;
                    } else {
                        offset = elem.getBoundingClientRect().bottom;
                    }
                } else if (!isNumber(offset)) {
                    offset = 0;
                }
                return offset;
            }
            function scrollTo(elem) {
                if (elem) {
                    elem.scrollIntoView();
                    var offset = getYOffset();
                    if (offset) {
                        var elemTop = elem.getBoundingClientRect().top;
                        $window.scrollBy(0, elemTop - offset);
                    }
                } else {
                    $window.scrollTo(0, 0);
                }
            }
            function scroll(hash) {
                hash = isString(hash) ? hash : isNumber(hash) ? hash.toString() : $location.hash();
                var elm;
                if (!hash)
                    scrollTo(null);
                else if (elm = document.getElementById(hash))
                    scrollTo(elm);
                else if (elm = getFirstAnchor(document.getElementsByName(hash)))
                    scrollTo(elm);
                else if (hash === 'top')
                    scrollTo(null);
            }
            if (autoScrollingEnabled) {
                $rootScope.$watch(function autoScrollWatch() {
                    return $location.hash();
                }, function autoScrollWatchAction(newVal, oldVal) {
                    if (newVal === oldVal && newVal === '')
                        return;
                    jqLiteDocumentLoaded(function () {
                        $rootScope.$evalAsync(scroll);
                    });
                });
            }
            return scroll;
        }
    ];
};
mergeClasses = function mergeClasses(a, b) {
    if (!a && !b)
        return '';
    if (!a)
        return b;
    if (!b)
        return a;
    if (isArray(a))
        a = a.join(' ');
    if (isArray(b))
        b = b.join(' ');
    return a + ' ' + b;
};
extractElementNode = function extractElementNode(element) {
    for (var i = 0; i < element.length; i++) {
        var elm = element[i];
        if (elm.nodeType === ELEMENT_NODE) {
            return elm;
        }
    }
};
splitClasses = function splitClasses(classes) {
    if (isString(classes)) {
        classes = classes.split(' ');
    }
    var obj = createMap();
    forEach(classes, function (klass) {
        if (klass.length) {
            obj[klass] = true;
        }
    });
    return obj;
};
prepareAnimateOptions = function prepareAnimateOptions(options) {
    return isObject(options) ? options : {};
};
Browser = function Browser(window, document, $log, $sniffer) {
    var self = this, location = window.location, history = window.history, setTimeout = window.setTimeout, clearTimeout = window.clearTimeout, pendingDeferIds = {};
    self.isMock = false;
    var outstandingRequestCount = 0;
    var outstandingRequestCallbacks = [];
    self.$$completeOutstandingRequest = completeOutstandingRequest;
    self.$$incOutstandingRequestCount = function () {
        outstandingRequestCount++;
    };
    function completeOutstandingRequest(fn) {
        try {
            fn.apply(null, sliceArgs(arguments, 1));
        } finally {
            outstandingRequestCount--;
            if (outstandingRequestCount === 0) {
                while (outstandingRequestCallbacks.length) {
                    try {
                        outstandingRequestCallbacks.pop()();
                    } catch (e) {
                        $log.error(e);
                    }
                }
            }
        }
    }
    function getHash(url) {
        var index = url.indexOf('#');
        return index === -1 ? '' : url.substr(index);
    }
    self.notifyWhenNoOutstandingRequests = function (callback) {
        if (outstandingRequestCount === 0) {
            callback();
        } else {
            outstandingRequestCallbacks.push(callback);
        }
    };
    var cachedState, lastHistoryState, lastBrowserUrl = location.href, baseElement = document.find('base'), pendingLocation = null, getCurrentState = !$sniffer.history ? noop : function getCurrentState() {
            try {
                return history.state;
            } catch (e) {
            }
        };
    cacheState();
    self.url = function (url, replace, state) {
        if (isUndefined(state)) {
            state = null;
        }
        if (location !== window.location)
            location = window.location;
        if (history !== window.history)
            history = window.history;
        if (url) {
            var sameState = lastHistoryState === state;
            if (lastBrowserUrl === url && (!$sniffer.history || sameState)) {
                return self;
            }
            var sameBase = lastBrowserUrl && stripHash(lastBrowserUrl) === stripHash(url);
            lastBrowserUrl = url;
            lastHistoryState = state;
            if ($sniffer.history && (!sameBase || !sameState)) {
                history[replace ? 'replaceState' : 'pushState'](state, '', url);
                cacheState();
            } else {
                if (!sameBase) {
                    pendingLocation = url;
                }
                if (replace) {
                    location.replace(url);
                } else if (!sameBase) {
                    location.href = url;
                } else {
                    location.hash = getHash(url);
                }
                if (location.href !== url) {
                    pendingLocation = url;
                }
            }
            if (pendingLocation) {
                pendingLocation = url;
            }
            return self;
        } else {
            return pendingLocation || location.href.replace(/%27/g, '\'');
        }
    };
    self.state = function () {
        return cachedState;
    };
    var urlChangeListeners = [], urlChangeInit = false;
    function cacheStateAndFireUrlChange() {
        pendingLocation = null;
        fireStateOrUrlChange();
    }
    var lastCachedState = null;
    function cacheState() {
        cachedState = getCurrentState();
        cachedState = isUndefined(cachedState) ? null : cachedState;
        if (equals(cachedState, lastCachedState)) {
            cachedState = lastCachedState;
        }
        lastCachedState = cachedState;
        lastHistoryState = cachedState;
    }
    function fireStateOrUrlChange() {
        var prevLastHistoryState = lastHistoryState;
        cacheState();
        if (lastBrowserUrl === self.url() && prevLastHistoryState === cachedState) {
            return;
        }
        lastBrowserUrl = self.url();
        lastHistoryState = cachedState;
        forEach(urlChangeListeners, function (listener) {
            listener(self.url(), cachedState);
        });
    }
    self.onUrlChange = function (callback) {
        if (!urlChangeInit) {
            if ($sniffer.history)
                jqLite(window).on('popstate', cacheStateAndFireUrlChange);
            jqLite(window).on('hashchange', cacheStateAndFireUrlChange);
            urlChangeInit = true;
        }
        urlChangeListeners.push(callback);
        return callback;
    };
    self.$$applicationDestroyed = function () {
        jqLite(window).off('hashchange popstate', cacheStateAndFireUrlChange);
    };
    self.$$checkUrlChange = fireStateOrUrlChange;
    self.baseHref = function () {
        var href = baseElement.attr('href');
        return href ? href.replace(/^(https?:)?\/\/[^\/]*/, '') : '';
    };
    self.defer = function (fn, delay) {
        var timeoutId;
        outstandingRequestCount++;
        timeoutId = setTimeout(function () {
            delete pendingDeferIds[timeoutId];
            completeOutstandingRequest(fn);
        }, delay || 0);
        pendingDeferIds[timeoutId] = true;
        return timeoutId;
    };
    self.defer.cancel = function (deferId) {
        if (pendingDeferIds[deferId]) {
            delete pendingDeferIds[deferId];
            clearTimeout(deferId);
            completeOutstandingRequest(noop);
            return true;
        }
        return false;
    };
};
$BrowserProvider = function $BrowserProvider() {
    this.$get = [
        '$window',
        '$log',
        '$sniffer',
        '$document',
        function ($window, $log, $sniffer, $document) {
            return new Browser($window, $document, $log, $sniffer);
        }
    ];
};
$CacheFactoryProvider = function $CacheFactoryProvider() {
    this.$get = function () {
        var caches = {};
        function cacheFactory(cacheId, options) {
            if (cacheId in caches) {
                throw minErr('$cacheFactory')('iid', 'CacheId \'{0}\' is already taken!', cacheId);
            }
            var size = 0, stats = extend({}, options, {
                    id: cacheId
                }), data = createMap(), capacity = options && options.capacity || Number.MAX_VALUE, lruHash = createMap(), freshEnd = null, staleEnd = null;
            return caches[cacheId] = {
                put: function (key, value) {
                    if (isUndefined(value))
                        return;
                    if (capacity < Number.MAX_VALUE) {
                        var lruEntry = lruHash[key] || (lruHash[key] = {
                            key: key
                        });
                        refresh(lruEntry);
                    }
                    if (!(key in data))
                        size++;
                    data[key] = value;
                    if (size > capacity) {
                        this.remove(staleEnd.key);
                    }
                    return value;
                },
                get: function (key) {
                    if (capacity < Number.MAX_VALUE) {
                        var lruEntry = lruHash[key];
                        if (!lruEntry)
                            return;
                        refresh(lruEntry);
                    }
                    return data[key];
                },
                remove: function (key) {
                    if (capacity < Number.MAX_VALUE) {
                        var lruEntry = lruHash[key];
                        if (!lruEntry)
                            return;
                        if (lruEntry === freshEnd)
                            freshEnd = lruEntry.p;
                        if (lruEntry === staleEnd)
                            staleEnd = lruEntry.n;
                        link(lruEntry.n, lruEntry.p);
                        delete lruHash[key];
                    }
                    if (!(key in data))
                        return;
                    delete data[key];
                    size--;
                },
                removeAll: function () {
                    data = createMap();
                    size = 0;
                    lruHash = createMap();
                    freshEnd = staleEnd = null;
                },
                destroy: function () {
                    data = null;
                    stats = null;
                    lruHash = null;
                    delete caches[cacheId];
                },
                info: function () {
                    return extend({}, stats, {
                        size: size
                    });
                }
            };
            function refresh(entry) {
                if (entry !== freshEnd) {
                    if (!staleEnd) {
                        staleEnd = entry;
                    } else if (staleEnd === entry) {
                        staleEnd = entry.n;
                    }
                    link(entry.n, entry.p);
                    link(entry, freshEnd);
                    freshEnd = entry;
                    freshEnd.n = null;
                }
            }
            function link(nextEntry, prevEntry) {
                if (nextEntry !== prevEntry) {
                    if (nextEntry)
                        nextEntry.p = prevEntry;
                    if (prevEntry)
                        prevEntry.n = nextEntry;
                }
            }
        }
        cacheFactory.info = function () {
            var info = {};
            forEach(caches, function (cache, cacheId) {
                info[cacheId] = cache.info();
            });
            return info;
        };
        cacheFactory.get = function (cacheId) {
            return caches[cacheId];
        };
        return cacheFactory;
    };
};
$TemplateCacheProvider = function $TemplateCacheProvider() {
    this.$get = [
        '$cacheFactory',
        function ($cacheFactory) {
            return $cacheFactory('templates');
        }
    ];
};
UNINITIALIZED_VALUE = function UNINITIALIZED_VALUE() {
};
$CompileProvider = function $CompileProvider($provide, $$sanitizeUriProvider) {
    var hasDirectives = {}, Suffix = 'Directive', COMMENT_DIRECTIVE_REGEXP = /^\s*directive:\s*([\w-]+)\s+(.*)$/, CLASS_DIRECTIVE_REGEXP = /(([\w-]+)(?::([^;]+))?;?)/, ALL_OR_NOTHING_ATTRS = makeMap('ngSrc,ngSrcset,src,srcset'), REQUIRE_PREFIX_REGEXP = /^(?:(\^\^?)?(\?)?(\^\^?)?)?/;
    var EVENT_HANDLER_ATTR_REGEXP = /^(on[a-z]+|formaction)$/;
    var bindingCache = createMap();
    function parseIsolateBindings(scope, directiveName, isController) {
        var LOCAL_REGEXP = /^\s*([@&<]|=(\*?))(\??)\s*([\w$]*)\s*$/;
        var bindings = createMap();
        forEach(scope, function (definition, scopeName) {
            if (definition in bindingCache) {
                bindings[scopeName] = bindingCache[definition];
                return;
            }
            var match = definition.match(LOCAL_REGEXP);
            if (!match) {
                throw $compileMinErr('iscp', 'Invalid {3} for directive \'{0}\'.' + ' Definition: {... {1}: \'{2}\' ...}', directiveName, scopeName, definition, isController ? 'controller bindings definition' : 'isolate scope definition');
            }
            bindings[scopeName] = {
                mode: match[1][0],
                collection: match[2] === '*',
                optional: match[3] === '?',
                attrName: match[4] || scopeName
            };
            if (match[4]) {
                bindingCache[definition] = bindings[scopeName];
            }
        });
        return bindings;
    }
    function parseDirectiveBindings(directive, directiveName) {
        var bindings = {
            isolateScope: null,
            bindToController: null
        };
        if (isObject(directive.scope)) {
            if (directive.bindToController === true) {
                bindings.bindToController = parseIsolateBindings(directive.scope, directiveName, true);
                bindings.isolateScope = {};
            } else {
                bindings.isolateScope = parseIsolateBindings(directive.scope, directiveName, false);
            }
        }
        if (isObject(directive.bindToController)) {
            bindings.bindToController = parseIsolateBindings(directive.bindToController, directiveName, true);
        }
        if (bindings.bindToController && !directive.controller) {
            throw $compileMinErr('noctrl', 'Cannot bind to controller without directive \'{0}\'s controller.', directiveName);
        }
        return bindings;
    }
    function assertValidDirectiveName(name) {
        var letter = name.charAt(0);
        if (!letter || letter !== lowercase(letter)) {
            throw $compileMinErr('baddir', 'Directive/Component name \'{0}\' is invalid. The first character must be a lowercase letter', name);
        }
        if (name !== name.trim()) {
            throw $compileMinErr('baddir', 'Directive/Component name \'{0}\' is invalid. The name should not contain leading or trailing whitespaces', name);
        }
    }
    function getDirectiveRequire(directive) {
        var require = directive.require || directive.controller && directive.name;
        if (!isArray(require) && isObject(require)) {
            forEach(require, function (value, key) {
                var match = value.match(REQUIRE_PREFIX_REGEXP);
                var name = value.substring(match[0].length);
                if (!name)
                    require[key] = match[0] + key;
            });
        }
        return require;
    }
    function getDirectiveRestrict(restrict, name) {
        if (restrict && !(isString(restrict) && /[EACM]/.test(restrict))) {
            throw $compileMinErr('badrestrict', 'Restrict property \'{0}\' of directive \'{1}\' is invalid', restrict, name);
        }
        return restrict || 'EA';
    }
    this.directive = function registerDirective(name, directiveFactory) {
        assertArg(name, 'name');
        assertNotHasOwnProperty(name, 'directive');
        if (isString(name)) {
            assertValidDirectiveName(name);
            assertArg(directiveFactory, 'directiveFactory');
            if (!hasDirectives.hasOwnProperty(name)) {
                hasDirectives[name] = [];
                $provide.factory(name + Suffix, [
                    '$injector',
                    '$exceptionHandler',
                    function ($injector, $exceptionHandler) {
                        var directives = [];
                        forEach(hasDirectives[name], function (directiveFactory, index) {
                            try {
                                var directive = $injector.invoke(directiveFactory);
                                if (isFunction(directive)) {
                                    directive = {
                                        compile: valueFn(directive)
                                    };
                                } else if (!directive.compile && directive.link) {
                                    directive.compile = valueFn(directive.link);
                                }
                                directive.priority = directive.priority || 0;
                                directive.index = index;
                                directive.name = directive.name || name;
                                directive.require = getDirectiveRequire(directive);
                                directive.restrict = getDirectiveRestrict(directive.restrict, name);
                                directive.$$moduleName = directiveFactory.$$moduleName;
                                directives.push(directive);
                            } catch (e) {
                                $exceptionHandler(e);
                            }
                        });
                        return directives;
                    }
                ]);
            }
            hasDirectives[name].push(directiveFactory);
        } else {
            forEach(name, reverseParams(registerDirective));
        }
        return this;
    };
    this.component = function registerComponent(name, options) {
        var controller = options.controller || function () {
        };
        function factory($injector) {
            function makeInjectable(fn) {
                if (isFunction(fn) || isArray(fn)) {
                    return function (tElement, tAttrs) {
                        return $injector.invoke(fn, this, {
                            $element: tElement,
                            $attrs: tAttrs
                        });
                    };
                } else {
                    return fn;
                }
            }
            var template = !options.template && !options.templateUrl ? '' : options.template;
            var ddo = {
                controller: controller,
                controllerAs: identifierForController(options.controller) || options.controllerAs || '$ctrl',
                template: makeInjectable(template),
                templateUrl: makeInjectable(options.templateUrl),
                transclude: options.transclude,
                scope: {},
                bindToController: options.bindings || {},
                restrict: 'E',
                require: options.require
            };
            forEach(options, function (val, key) {
                if (key.charAt(0) === '$')
                    ddo[key] = val;
            });
            return ddo;
        }
        forEach(options, function (val, key) {
            if (key.charAt(0) === '$') {
                factory[key] = val;
                if (isFunction(controller))
                    controller[key] = val;
            }
        });
        factory.$inject = ['$injector'];
        return this.directive(name, factory);
    };
    this.aHrefSanitizationWhitelist = function (regexp) {
        if (isDefined(regexp)) {
            $$sanitizeUriProvider.aHrefSanitizationWhitelist(regexp);
            return this;
        } else {
            return $$sanitizeUriProvider.aHrefSanitizationWhitelist();
        }
    };
    this.imgSrcSanitizationWhitelist = function (regexp) {
        if (isDefined(regexp)) {
            $$sanitizeUriProvider.imgSrcSanitizationWhitelist(regexp);
            return this;
        } else {
            return $$sanitizeUriProvider.imgSrcSanitizationWhitelist();
        }
    };
    var debugInfoEnabled = true;
    this.debugInfoEnabled = function (enabled) {
        if (isDefined(enabled)) {
            debugInfoEnabled = enabled;
            return this;
        }
        return debugInfoEnabled;
    };
    var preAssignBindingsEnabled = false;
    this.preAssignBindingsEnabled = function (enabled) {
        if (isDefined(enabled)) {
            preAssignBindingsEnabled = enabled;
            return this;
        }
        return preAssignBindingsEnabled;
    };
    var TTL = 10;
    this.onChangesTtl = function (value) {
        if (arguments.length) {
            TTL = value;
            return this;
        }
        return TTL;
    };
    var commentDirectivesEnabledConfig = true;
    this.commentDirectivesEnabled = function (value) {
        if (arguments.length) {
            commentDirectivesEnabledConfig = value;
            return this;
        }
        return commentDirectivesEnabledConfig;
    };
    var cssClassDirectivesEnabledConfig = true;
    this.cssClassDirectivesEnabled = function (value) {
        if (arguments.length) {
            cssClassDirectivesEnabledConfig = value;
            return this;
        }
        return cssClassDirectivesEnabledConfig;
    };
    this.$get = [
        '$injector',
        '$interpolate',
        '$exceptionHandler',
        '$templateRequest',
        '$parse',
        '$controller',
        '$rootScope',
        '$sce',
        '$animate',
        '$$sanitizeUri',
        function ($injector, $interpolate, $exceptionHandler, $templateRequest, $parse, $controller, $rootScope, $sce, $animate, $$sanitizeUri) {
            var SIMPLE_ATTR_NAME = /^\w/;
            var specialAttrHolder = window.document.createElement('div');
            var commentDirectivesEnabled = commentDirectivesEnabledConfig;
            var cssClassDirectivesEnabled = cssClassDirectivesEnabledConfig;
            var onChangesTtl = TTL;
            var onChangesQueue;
            function flushOnChangesQueue() {
                try {
                    if (!--onChangesTtl) {
                        onChangesQueue = undefined;
                        throw $compileMinErr('infchng', '{0} $onChanges() iterations reached. Aborting!\n', TTL);
                    }
                    $rootScope.$apply(function () {
                        var errors = [];
                        for (var i = 0, ii = onChangesQueue.length; i < ii; ++i) {
                            try {
                                onChangesQueue[i]();
                            } catch (e) {
                                errors.push(e);
                            }
                        }
                        onChangesQueue = undefined;
                        if (errors.length) {
                            throw errors;
                        }
                    });
                } finally {
                    onChangesTtl++;
                }
            }
            function Attributes(element, attributesToCopy) {
                if (attributesToCopy) {
                    var keys = Object.keys(attributesToCopy);
                    var i, l, key;
                    for (i = 0, l = keys.length; i < l; i++) {
                        key = keys[i];
                        this[key] = attributesToCopy[key];
                    }
                } else {
                    this.$attr = {};
                }
                this.$$element = element;
            }
            Attributes.prototype = {
                $normalize: directiveNormalize,
                $addClass: function (classVal) {
                    if (classVal && classVal.length > 0) {
                        $animate.addClass(this.$$element, classVal);
                    }
                },
                $removeClass: function (classVal) {
                    if (classVal && classVal.length > 0) {
                        $animate.removeClass(this.$$element, classVal);
                    }
                },
                $updateClass: function (newClasses, oldClasses) {
                    var toAdd = tokenDifference(newClasses, oldClasses);
                    if (toAdd && toAdd.length) {
                        $animate.addClass(this.$$element, toAdd);
                    }
                    var toRemove = tokenDifference(oldClasses, newClasses);
                    if (toRemove && toRemove.length) {
                        $animate.removeClass(this.$$element, toRemove);
                    }
                },
                $set: function (key, value, writeAttr, attrName) {
                    var node = this.$$element[0], booleanKey = getBooleanAttrName(node, key), aliasedKey = getAliasedAttrName(key), observer = key, nodeName;
                    if (booleanKey) {
                        this.$$element.prop(key, value);
                        attrName = booleanKey;
                    } else if (aliasedKey) {
                        this[aliasedKey] = value;
                        observer = aliasedKey;
                    }
                    this[key] = value;
                    if (attrName) {
                        this.$attr[key] = attrName;
                    } else {
                        attrName = this.$attr[key];
                        if (!attrName) {
                            this.$attr[key] = attrName = snake_case(key, '-');
                        }
                    }
                    nodeName = nodeName_(this.$$element);
                    if (nodeName === 'a' && (key === 'href' || key === 'xlinkHref') || nodeName === 'img' && key === 'src') {
                        this[key] = value = $$sanitizeUri(value, key === 'src');
                    } else if (nodeName === 'img' && key === 'srcset' && isDefined(value)) {
                        var result = '';
                        var trimmedSrcset = trim(value);
                        var srcPattern = /(\s+\d+x\s*,|\s+\d+w\s*,|\s+,|,\s+)/;
                        var pattern = /\s/.test(trimmedSrcset) ? srcPattern : /(,)/;
                        var rawUris = trimmedSrcset.split(pattern);
                        var nbrUrisWith2parts = Math.floor(rawUris.length / 2);
                        for (var i = 0; i < nbrUrisWith2parts; i++) {
                            var innerIdx = i * 2;
                            result += $$sanitizeUri(trim(rawUris[innerIdx]), true);
                            result += ' ' + trim(rawUris[innerIdx + 1]);
                        }
                        var lastTuple = trim(rawUris[i * 2]).split(/\s/);
                        result += $$sanitizeUri(trim(lastTuple[0]), true);
                        if (lastTuple.length === 2) {
                            result += ' ' + trim(lastTuple[1]);
                        }
                        this[key] = value = result;
                    }
                    if (writeAttr !== false) {
                        if (value === null || isUndefined(value)) {
                            this.$$element.removeAttr(attrName);
                        } else {
                            if (SIMPLE_ATTR_NAME.test(attrName)) {
                                this.$$element.attr(attrName, value);
                            } else {
                                setSpecialAttr(this.$$element[0], attrName, value);
                            }
                        }
                    }
                    var $$observers = this.$$observers;
                    if ($$observers) {
                        forEach($$observers[observer], function (fn) {
                            try {
                                fn(value);
                            } catch (e) {
                                $exceptionHandler(e);
                            }
                        });
                    }
                },
                $observe: function (key, fn) {
                    var attrs = this, $$observers = attrs.$$observers || (attrs.$$observers = createMap()), listeners = $$observers[key] || ($$observers[key] = []);
                    listeners.push(fn);
                    $rootScope.$evalAsync(function () {
                        if (!listeners.$$inter && attrs.hasOwnProperty(key) && !isUndefined(attrs[key])) {
                            fn(attrs[key]);
                        }
                    });
                    return function () {
                        arrayRemove(listeners, fn);
                    };
                }
            };
            function setSpecialAttr(element, attrName, value) {
                specialAttrHolder.innerHTML = '<span ' + attrName + '>';
                var attributes = specialAttrHolder.firstChild.attributes;
                var attribute = attributes[0];
                attributes.removeNamedItem(attribute.name);
                attribute.value = value;
                element.attributes.setNamedItem(attribute);
            }
            function safeAddClass($element, className) {
                try {
                    $element.addClass(className);
                } catch (e) {
                }
            }
            var startSymbol = $interpolate.startSymbol(), endSymbol = $interpolate.endSymbol(), denormalizeTemplate = startSymbol === '{{' && endSymbol === '}}' ? identity : function denormalizeTemplate(template) {
                    return template.replace(/\{\{/g, startSymbol).replace(/}}/g, endSymbol);
                }, NG_ATTR_BINDING = /^ngAttr[A-Z]/;
            var MULTI_ELEMENT_DIR_RE = /^(.+)Start$/;
            compile.$$addBindingInfo = debugInfoEnabled ? function $$addBindingInfo($element, binding) {
                var bindings = $element.data('$binding') || [];
                if (isArray(binding)) {
                    bindings = bindings.concat(binding);
                } else {
                    bindings.push(binding);
                }
                $element.data('$binding', bindings);
            } : noop;
            compile.$$addBindingClass = debugInfoEnabled ? function $$addBindingClass($element) {
                safeAddClass($element, 'ng-binding');
            } : noop;
            compile.$$addScopeInfo = debugInfoEnabled ? function $$addScopeInfo($element, scope, isolated, noTemplate) {
                var dataName = isolated ? noTemplate ? '$isolateScopeNoTemplate' : '$isolateScope' : '$scope';
                $element.data(dataName, scope);
            } : noop;
            compile.$$addScopeClass = debugInfoEnabled ? function $$addScopeClass($element, isolated) {
                safeAddClass($element, isolated ? 'ng-isolate-scope' : 'ng-scope');
            } : noop;
            compile.$$createComment = function (directiveName, comment) {
                var content = '';
                if (debugInfoEnabled) {
                    content = ' ' + (directiveName || '') + ': ';
                    if (comment)
                        content += comment + ' ';
                }
                return window.document.createComment(content);
            };
            return compile;
            function compile($compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext) {
                if (!($compileNodes instanceof jqLite)) {
                    $compileNodes = jqLite($compileNodes);
                }
                var compositeLinkFn = compileNodes($compileNodes, transcludeFn, $compileNodes, maxPriority, ignoreDirective, previousCompileContext);
                compile.$$addScopeClass($compileNodes);
                var namespace = null;
                return function publicLinkFn(scope, cloneConnectFn, options) {
                    if (!$compileNodes) {
                        throw $compileMinErr('multilink', 'This element has already been linked.');
                    }
                    assertArg(scope, 'scope');
                    if (previousCompileContext && previousCompileContext.needsNewScope) {
                        scope = scope.$parent.$new();
                    }
                    options = options || {};
                    var parentBoundTranscludeFn = options.parentBoundTranscludeFn, transcludeControllers = options.transcludeControllers, futureParentElement = options.futureParentElement;
                    if (parentBoundTranscludeFn && parentBoundTranscludeFn.$$boundTransclude) {
                        parentBoundTranscludeFn = parentBoundTranscludeFn.$$boundTransclude;
                    }
                    if (!namespace) {
                        namespace = detectNamespaceForChildElements(futureParentElement);
                    }
                    var $linkNode;
                    if (namespace !== 'html') {
                        $linkNode = jqLite(wrapTemplate(namespace, jqLite('<div>').append($compileNodes).html()));
                    } else if (cloneConnectFn) {
                        $linkNode = JQLitePrototype.clone.call($compileNodes);
                    } else {
                        $linkNode = $compileNodes;
                    }
                    if (transcludeControllers) {
                        for (var controllerName in transcludeControllers) {
                            $linkNode.data('$' + controllerName + 'Controller', transcludeControllers[controllerName].instance);
                        }
                    }
                    compile.$$addScopeInfo($linkNode, scope);
                    if (cloneConnectFn)
                        cloneConnectFn($linkNode, scope);
                    if (compositeLinkFn)
                        compositeLinkFn(scope, $linkNode, $linkNode, parentBoundTranscludeFn);
                    if (!cloneConnectFn) {
                        $compileNodes = compositeLinkFn = null;
                    }
                    return $linkNode;
                };
            }
            function detectNamespaceForChildElements(parentElement) {
                var node = parentElement && parentElement[0];
                if (!node) {
                    return 'html';
                } else {
                    return nodeName_(node) !== 'foreignobject' && toString.call(node).match(/SVG/) ? 'svg' : 'html';
                }
            }
            function compileNodes(nodeList, transcludeFn, $rootElement, maxPriority, ignoreDirective, previousCompileContext) {
                var linkFns = [], notLiveList = isArray(nodeList) || nodeList instanceof jqLite, attrs, directives, nodeLinkFn, childNodes, childLinkFn, linkFnFound, nodeLinkFnFound;
                for (var i = 0; i < nodeList.length; i++) {
                    attrs = new Attributes();
                    if (msie === 11) {
                        mergeConsecutiveTextNodes(nodeList, i, notLiveList);
                    }
                    directives = collectDirectives(nodeList[i], [], attrs, i === 0 ? maxPriority : undefined, ignoreDirective);
                    nodeLinkFn = directives.length ? applyDirectivesToNode(directives, nodeList[i], attrs, transcludeFn, $rootElement, null, [], [], previousCompileContext) : null;
                    if (nodeLinkFn && nodeLinkFn.scope) {
                        compile.$$addScopeClass(attrs.$$element);
                    }
                    childLinkFn = nodeLinkFn && nodeLinkFn.terminal || !(childNodes = nodeList[i].childNodes) || !childNodes.length ? null : compileNodes(childNodes, nodeLinkFn ? (nodeLinkFn.transcludeOnThisElement || !nodeLinkFn.templateOnThisElement) && nodeLinkFn.transclude : transcludeFn);
                    if (nodeLinkFn || childLinkFn) {
                        linkFns.push(i, nodeLinkFn, childLinkFn);
                        linkFnFound = true;
                        nodeLinkFnFound = nodeLinkFnFound || nodeLinkFn;
                    }
                    previousCompileContext = null;
                }
                return linkFnFound ? compositeLinkFn : null;
                function compositeLinkFn(scope, nodeList, $rootElement, parentBoundTranscludeFn) {
                    var nodeLinkFn, childLinkFn, node, childScope, i, ii, idx, childBoundTranscludeFn;
                    var stableNodeList;
                    if (nodeLinkFnFound) {
                        var nodeListLength = nodeList.length;
                        stableNodeList = new Array(nodeListLength);
                        for (i = 0; i < linkFns.length; i += 3) {
                            idx = linkFns[i];
                            stableNodeList[idx] = nodeList[idx];
                        }
                    } else {
                        stableNodeList = nodeList;
                    }
                    for (i = 0, ii = linkFns.length; i < ii;) {
                        node = stableNodeList[linkFns[i++]];
                        nodeLinkFn = linkFns[i++];
                        childLinkFn = linkFns[i++];
                        if (nodeLinkFn) {
                            if (nodeLinkFn.scope) {
                                childScope = scope.$new();
                                compile.$$addScopeInfo(jqLite(node), childScope);
                            } else {
                                childScope = scope;
                            }
                            if (nodeLinkFn.transcludeOnThisElement) {
                                childBoundTranscludeFn = createBoundTranscludeFn(scope, nodeLinkFn.transclude, parentBoundTranscludeFn);
                            } else if (!nodeLinkFn.templateOnThisElement && parentBoundTranscludeFn) {
                                childBoundTranscludeFn = parentBoundTranscludeFn;
                            } else if (!parentBoundTranscludeFn && transcludeFn) {
                                childBoundTranscludeFn = createBoundTranscludeFn(scope, transcludeFn);
                            } else {
                                childBoundTranscludeFn = null;
                            }
                            nodeLinkFn(childLinkFn, childScope, node, $rootElement, childBoundTranscludeFn);
                        } else if (childLinkFn) {
                            childLinkFn(scope, node.childNodes, undefined, parentBoundTranscludeFn);
                        }
                    }
                }
            }
            function mergeConsecutiveTextNodes(nodeList, idx, notLiveList) {
                var node = nodeList[idx];
                var parent = node.parentNode;
                var sibling;
                if (node.nodeType !== NODE_TYPE_TEXT) {
                    return;
                }
                while (true) {
                    sibling = parent ? node.nextSibling : nodeList[idx + 1];
                    if (!sibling || sibling.nodeType !== NODE_TYPE_TEXT) {
                        break;
                    }
                    node.nodeValue = node.nodeValue + sibling.nodeValue;
                    if (sibling.parentNode) {
                        sibling.parentNode.removeChild(sibling);
                    }
                    if (notLiveList && sibling === nodeList[idx + 1]) {
                        nodeList.splice(idx + 1, 1);
                    }
                }
            }
            function createBoundTranscludeFn(scope, transcludeFn, previousBoundTranscludeFn) {
                function boundTranscludeFn(transcludedScope, cloneFn, controllers, futureParentElement, containingScope) {
                    if (!transcludedScope) {
                        transcludedScope = scope.$new(false, containingScope);
                        transcludedScope.$$transcluded = true;
                    }
                    return transcludeFn(transcludedScope, cloneFn, {
                        parentBoundTranscludeFn: previousBoundTranscludeFn,
                        transcludeControllers: controllers,
                        futureParentElement: futureParentElement
                    });
                }
                var boundSlots = boundTranscludeFn.$$slots = createMap();
                for (var slotName in transcludeFn.$$slots) {
                    if (transcludeFn.$$slots[slotName]) {
                        boundSlots[slotName] = createBoundTranscludeFn(scope, transcludeFn.$$slots[slotName], previousBoundTranscludeFn);
                    } else {
                        boundSlots[slotName] = null;
                    }
                }
                return boundTranscludeFn;
            }
            function collectDirectives(node, directives, attrs, maxPriority, ignoreDirective) {
                var nodeType = node.nodeType, attrsMap = attrs.$attr, match, nodeName, className;
                switch (nodeType) {
                case NODE_TYPE_ELEMENT:
                    nodeName = nodeName_(node);
                    addDirective(directives, directiveNormalize(nodeName), 'E', maxPriority, ignoreDirective);
                    for (var attr, name, nName, ngAttrName, value, isNgAttr, nAttrs = node.attributes, j = 0, jj = nAttrs && nAttrs.length; j < jj; j++) {
                        var attrStartName = false;
                        var attrEndName = false;
                        attr = nAttrs[j];
                        name = attr.name;
                        value = attr.value;
                        ngAttrName = directiveNormalize(name);
                        isNgAttr = NG_ATTR_BINDING.test(ngAttrName);
                        if (isNgAttr) {
                            name = name.replace(PREFIX_REGEXP, '').substr(8).replace(/_(.)/g, function (match, letter) {
                                return letter.toUpperCase();
                            });
                        }
                        var multiElementMatch = ngAttrName.match(MULTI_ELEMENT_DIR_RE);
                        if (multiElementMatch && directiveIsMultiElement(multiElementMatch[1])) {
                            attrStartName = name;
                            attrEndName = name.substr(0, name.length - 5) + 'end';
                            name = name.substr(0, name.length - 6);
                        }
                        nName = directiveNormalize(name.toLowerCase());
                        attrsMap[nName] = name;
                        if (isNgAttr || !attrs.hasOwnProperty(nName)) {
                            attrs[nName] = value;
                            if (getBooleanAttrName(node, nName)) {
                                attrs[nName] = true;
                            }
                        }
                        addAttrInterpolateDirective(node, directives, value, nName, isNgAttr);
                        addDirective(directives, nName, 'A', maxPriority, ignoreDirective, attrStartName, attrEndName);
                    }
                    if (nodeName === 'input' && node.getAttribute('type') === 'hidden') {
                        node.setAttribute('autocomplete', 'off');
                    }
                    if (!cssClassDirectivesEnabled)
                        break;
                    className = node.className;
                    if (isObject(className)) {
                        className = className.animVal;
                    }
                    if (isString(className) && className !== '') {
                        while (match = CLASS_DIRECTIVE_REGEXP.exec(className)) {
                            nName = directiveNormalize(match[2]);
                            if (addDirective(directives, nName, 'C', maxPriority, ignoreDirective)) {
                                attrs[nName] = trim(match[3]);
                            }
                            className = className.substr(match.index + match[0].length);
                        }
                    }
                    break;
                case NODE_TYPE_TEXT:
                    addTextInterpolateDirective(directives, node.nodeValue);
                    break;
                case NODE_TYPE_COMMENT:
                    if (!commentDirectivesEnabled)
                        break;
                    collectCommentDirectives(node, directives, attrs, maxPriority, ignoreDirective);
                    break;
                }
                directives.sort(byPriority);
                return directives;
            }
            function collectCommentDirectives(node, directives, attrs, maxPriority, ignoreDirective) {
                try {
                    var match = COMMENT_DIRECTIVE_REGEXP.exec(node.nodeValue);
                    if (match) {
                        var nName = directiveNormalize(match[1]);
                        if (addDirective(directives, nName, 'M', maxPriority, ignoreDirective)) {
                            attrs[nName] = trim(match[2]);
                        }
                    }
                } catch (e) {
                }
            }
            function groupScan(node, attrStart, attrEnd) {
                var nodes = [];
                var depth = 0;
                if (attrStart && node.hasAttribute && node.hasAttribute(attrStart)) {
                    do {
                        if (!node) {
                            throw $compileMinErr('uterdir', 'Unterminated attribute, found \'{0}\' but no matching \'{1}\' found.', attrStart, attrEnd);
                        }
                        if (node.nodeType === NODE_TYPE_ELEMENT) {
                            if (node.hasAttribute(attrStart))
                                depth++;
                            if (node.hasAttribute(attrEnd))
                                depth--;
                        }
                        nodes.push(node);
                        node = node.nextSibling;
                    } while (depth > 0);
                } else {
                    nodes.push(node);
                }
                return jqLite(nodes);
            }
            function groupElementsLinkFnWrapper(linkFn, attrStart, attrEnd) {
                return function groupedElementsLink(scope, element, attrs, controllers, transcludeFn) {
                    element = groupScan(element[0], attrStart, attrEnd);
                    return linkFn(scope, element, attrs, controllers, transcludeFn);
                };
            }
            function compilationGenerator(eager, $compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext) {
                var compiled;
                if (eager) {
                    return compile($compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext);
                }
                return function lazyCompilation() {
                    if (!compiled) {
                        compiled = compile($compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext);
                        $compileNodes = transcludeFn = previousCompileContext = null;
                    }
                    return compiled.apply(this, arguments);
                };
            }
            function applyDirectivesToNode(directives, compileNode, templateAttrs, transcludeFn, jqCollection, originalReplaceDirective, preLinkFns, postLinkFns, previousCompileContext) {
                previousCompileContext = previousCompileContext || {};
                var terminalPriority = -Number.MAX_VALUE, newScopeDirective = previousCompileContext.newScopeDirective, controllerDirectives = previousCompileContext.controllerDirectives, newIsolateScopeDirective = previousCompileContext.newIsolateScopeDirective, templateDirective = previousCompileContext.templateDirective, nonTlbTranscludeDirective = previousCompileContext.nonTlbTranscludeDirective, hasTranscludeDirective = false, hasTemplate = false, hasElementTranscludeDirective = previousCompileContext.hasElementTranscludeDirective, $compileNode = templateAttrs.$$element = jqLite(compileNode), directive, directiveName, $template, replaceDirective = originalReplaceDirective, childTranscludeFn = transcludeFn, linkFn, didScanForMultipleTransclusion = false, mightHaveMultipleTransclusionError = false, directiveValue;
                for (var i = 0, ii = directives.length; i < ii; i++) {
                    directive = directives[i];
                    var attrStart = directive.$$start;
                    var attrEnd = directive.$$end;
                    if (attrStart) {
                        $compileNode = groupScan(compileNode, attrStart, attrEnd);
                    }
                    $template = undefined;
                    if (terminalPriority > directive.priority) {
                        break;
                    }
                    directiveValue = directive.scope;
                    if (directiveValue) {
                        if (!directive.templateUrl) {
                            if (isObject(directiveValue)) {
                                assertNoDuplicate('new/isolated scope', newIsolateScopeDirective || newScopeDirective, directive, $compileNode);
                                newIsolateScopeDirective = directive;
                            } else {
                                assertNoDuplicate('new/isolated scope', newIsolateScopeDirective, directive, $compileNode);
                            }
                        }
                        newScopeDirective = newScopeDirective || directive;
                    }
                    directiveName = directive.name;
                    if (!didScanForMultipleTransclusion && (directive.replace && (directive.templateUrl || directive.template) || directive.transclude && !directive.$$tlb)) {
                        var candidateDirective;
                        for (var scanningIndex = i + 1; candidateDirective = directives[scanningIndex++];) {
                            if (candidateDirective.transclude && !candidateDirective.$$tlb || candidateDirective.replace && (candidateDirective.templateUrl || candidateDirective.template)) {
                                mightHaveMultipleTransclusionError = true;
                                break;
                            }
                        }
                        didScanForMultipleTransclusion = true;
                    }
                    if (!directive.templateUrl && directive.controller) {
                        controllerDirectives = controllerDirectives || createMap();
                        assertNoDuplicate('\'' + directiveName + '\' controller', controllerDirectives[directiveName], directive, $compileNode);
                        controllerDirectives[directiveName] = directive;
                    }
                    directiveValue = directive.transclude;
                    if (directiveValue) {
                        hasTranscludeDirective = true;
                        if (!directive.$$tlb) {
                            assertNoDuplicate('transclusion', nonTlbTranscludeDirective, directive, $compileNode);
                            nonTlbTranscludeDirective = directive;
                        }
                        if (directiveValue === 'element') {
                            hasElementTranscludeDirective = true;
                            terminalPriority = directive.priority;
                            $template = $compileNode;
                            $compileNode = templateAttrs.$$element = jqLite(compile.$$createComment(directiveName, templateAttrs[directiveName]));
                            compileNode = $compileNode[0];
                            replaceWith(jqCollection, sliceArgs($template), compileNode);
                            $template[0].$$parentNode = $template[0].parentNode;
                            childTranscludeFn = compilationGenerator(mightHaveMultipleTransclusionError, $template, transcludeFn, terminalPriority, replaceDirective && replaceDirective.name, {
                                nonTlbTranscludeDirective: nonTlbTranscludeDirective
                            });
                        } else {
                            var slots = createMap();
                            if (!isObject(directiveValue)) {
                                $template = jqLite(jqLiteClone(compileNode)).contents();
                            } else {
                                $template = [];
                                var slotMap = createMap();
                                var filledSlots = createMap();
                                forEach(directiveValue, function (elementSelector, slotName) {
                                    var optional = elementSelector.charAt(0) === '?';
                                    elementSelector = optional ? elementSelector.substring(1) : elementSelector;
                                    slotMap[elementSelector] = slotName;
                                    slots[slotName] = null;
                                    filledSlots[slotName] = optional;
                                });
                                forEach($compileNode.contents(), function (node) {
                                    var slotName = slotMap[directiveNormalize(nodeName_(node))];
                                    if (slotName) {
                                        filledSlots[slotName] = true;
                                        slots[slotName] = slots[slotName] || [];
                                        slots[slotName].push(node);
                                    } else {
                                        $template.push(node);
                                    }
                                });
                                forEach(filledSlots, function (filled, slotName) {
                                    if (!filled) {
                                        throw $compileMinErr('reqslot', 'Required transclusion slot `{0}` was not filled.', slotName);
                                    }
                                });
                                for (var slotName in slots) {
                                    if (slots[slotName]) {
                                        slots[slotName] = compilationGenerator(mightHaveMultipleTransclusionError, slots[slotName], transcludeFn);
                                    }
                                }
                            }
                            $compileNode.empty();
                            childTranscludeFn = compilationGenerator(mightHaveMultipleTransclusionError, $template, transcludeFn, undefined, undefined, {
                                needsNewScope: directive.$$isolateScope || directive.$$newScope
                            });
                            childTranscludeFn.$$slots = slots;
                        }
                    }
                    if (directive.template) {
                        hasTemplate = true;
                        assertNoDuplicate('template', templateDirective, directive, $compileNode);
                        templateDirective = directive;
                        directiveValue = isFunction(directive.template) ? directive.template($compileNode, templateAttrs) : directive.template;
                        directiveValue = denormalizeTemplate(directiveValue);
                        if (directive.replace) {
                            replaceDirective = directive;
                            if (jqLiteIsTextNode(directiveValue)) {
                                $template = [];
                            } else {
                                $template = removeComments(wrapTemplate(directive.templateNamespace, trim(directiveValue)));
                            }
                            compileNode = $template[0];
                            if ($template.length !== 1 || compileNode.nodeType !== NODE_TYPE_ELEMENT) {
                                throw $compileMinErr('tplrt', 'Template for directive \'{0}\' must have exactly one root element. {1}', directiveName, '');
                            }
                            replaceWith(jqCollection, $compileNode, compileNode);
                            var newTemplateAttrs = {
                                $attr: {}
                            };
                            var templateDirectives = collectDirectives(compileNode, [], newTemplateAttrs);
                            var unprocessedDirectives = directives.splice(i + 1, directives.length - (i + 1));
                            if (newIsolateScopeDirective || newScopeDirective) {
                                markDirectiveScope(templateDirectives, newIsolateScopeDirective, newScopeDirective);
                            }
                            directives = directives.concat(templateDirectives).concat(unprocessedDirectives);
                            mergeTemplateAttributes(templateAttrs, newTemplateAttrs);
                            ii = directives.length;
                        } else {
                            $compileNode.html(directiveValue);
                        }
                    }
                    if (directive.templateUrl) {
                        hasTemplate = true;
                        assertNoDuplicate('template', templateDirective, directive, $compileNode);
                        templateDirective = directive;
                        if (directive.replace) {
                            replaceDirective = directive;
                        }
                        nodeLinkFn = compileTemplateUrl(directives.splice(i, directives.length - i), $compileNode, templateAttrs, jqCollection, hasTranscludeDirective && childTranscludeFn, preLinkFns, postLinkFns, {
                            controllerDirectives: controllerDirectives,
                            newScopeDirective: newScopeDirective !== directive && newScopeDirective,
                            newIsolateScopeDirective: newIsolateScopeDirective,
                            templateDirective: templateDirective,
                            nonTlbTranscludeDirective: nonTlbTranscludeDirective
                        });
                        ii = directives.length;
                    } else if (directive.compile) {
                        try {
                            linkFn = directive.compile($compileNode, templateAttrs, childTranscludeFn);
                            var context = directive.$$originalDirective || directive;
                            if (isFunction(linkFn)) {
                                addLinkFns(null, bind(context, linkFn), attrStart, attrEnd);
                            } else if (linkFn) {
                                addLinkFns(bind(context, linkFn.pre), bind(context, linkFn.post), attrStart, attrEnd);
                            }
                        } catch (e) {
                            $exceptionHandler(e, startingTag($compileNode));
                        }
                    }
                    if (directive.terminal) {
                        nodeLinkFn.terminal = true;
                        terminalPriority = Math.max(terminalPriority, directive.priority);
                    }
                }
                nodeLinkFn.scope = newScopeDirective && newScopeDirective.scope === true;
                nodeLinkFn.transcludeOnThisElement = hasTranscludeDirective;
                nodeLinkFn.templateOnThisElement = hasTemplate;
                nodeLinkFn.transclude = childTranscludeFn;
                previousCompileContext.hasElementTranscludeDirective = hasElementTranscludeDirective;
                return nodeLinkFn;
                function addLinkFns(pre, post, attrStart, attrEnd) {
                    if (pre) {
                        if (attrStart)
                            pre = groupElementsLinkFnWrapper(pre, attrStart, attrEnd);
                        pre.require = directive.require;
                        pre.directiveName = directiveName;
                        if (newIsolateScopeDirective === directive || directive.$$isolateScope) {
                            pre = cloneAndAnnotateFn(pre, {
                                isolateScope: true
                            });
                        }
                        preLinkFns.push(pre);
                    }
                    if (post) {
                        if (attrStart)
                            post = groupElementsLinkFnWrapper(post, attrStart, attrEnd);
                        post.require = directive.require;
                        post.directiveName = directiveName;
                        if (newIsolateScopeDirective === directive || directive.$$isolateScope) {
                            post = cloneAndAnnotateFn(post, {
                                isolateScope: true
                            });
                        }
                        postLinkFns.push(post);
                    }
                }
                function nodeLinkFn(childLinkFn, scope, linkNode, $rootElement, boundTranscludeFn) {
                    var i, ii, linkFn, isolateScope, controllerScope, elementControllers, transcludeFn, $element, attrs, scopeBindingInfo;
                    if (compileNode === linkNode) {
                        attrs = templateAttrs;
                        $element = templateAttrs.$$element;
                    } else {
                        $element = jqLite(linkNode);
                        attrs = new Attributes($element, templateAttrs);
                    }
                    controllerScope = scope;
                    if (newIsolateScopeDirective) {
                        isolateScope = scope.$new(true);
                    } else if (newScopeDirective) {
                        controllerScope = scope.$parent;
                    }
                    if (boundTranscludeFn) {
                        transcludeFn = controllersBoundTransclude;
                        transcludeFn.$$boundTransclude = boundTranscludeFn;
                        transcludeFn.isSlotFilled = function (slotName) {
                            return !!boundTranscludeFn.$$slots[slotName];
                        };
                    }
                    if (controllerDirectives) {
                        elementControllers = setupControllers($element, attrs, transcludeFn, controllerDirectives, isolateScope, scope, newIsolateScopeDirective);
                    }
                    if (newIsolateScopeDirective) {
                        compile.$$addScopeInfo($element, isolateScope, true, !(templateDirective && (templateDirective === newIsolateScopeDirective || templateDirective === newIsolateScopeDirective.$$originalDirective)));
                        compile.$$addScopeClass($element, true);
                        isolateScope.$$isolateBindings = newIsolateScopeDirective.$$isolateBindings;
                        scopeBindingInfo = initializeDirectiveBindings(scope, attrs, isolateScope, isolateScope.$$isolateBindings, newIsolateScopeDirective);
                        if (scopeBindingInfo.removeWatches) {
                            isolateScope.$on('$destroy', scopeBindingInfo.removeWatches);
                        }
                    }
                    for (var name in elementControllers) {
                        var controllerDirective = controllerDirectives[name];
                        var controller = elementControllers[name];
                        var bindings = controllerDirective.$$bindings.bindToController;
                        if (preAssignBindingsEnabled) {
                            if (bindings) {
                                controller.bindingInfo = initializeDirectiveBindings(controllerScope, attrs, controller.instance, bindings, controllerDirective);
                            } else {
                                controller.bindingInfo = {};
                            }
                            var controllerResult = controller();
                            if (controllerResult !== controller.instance) {
                                controller.instance = controllerResult;
                                $element.data('$' + controllerDirective.name + 'Controller', controllerResult);
                                if (controller.bindingInfo.removeWatches) {
                                    controller.bindingInfo.removeWatches();
                                }
                                controller.bindingInfo = initializeDirectiveBindings(controllerScope, attrs, controller.instance, bindings, controllerDirective);
                            }
                        } else {
                            controller.instance = controller();
                            $element.data('$' + controllerDirective.name + 'Controller', controller.instance);
                            controller.bindingInfo = initializeDirectiveBindings(controllerScope, attrs, controller.instance, bindings, controllerDirective);
                        }
                    }
                    forEach(controllerDirectives, function (controllerDirective, name) {
                        var require = controllerDirective.require;
                        if (controllerDirective.bindToController && !isArray(require) && isObject(require)) {
                            extend(elementControllers[name].instance, getControllers(name, require, $element, elementControllers));
                        }
                    });
                    forEach(elementControllers, function (controller) {
                        var controllerInstance = controller.instance;
                        if (isFunction(controllerInstance.$onChanges)) {
                            try {
                                controllerInstance.$onChanges(controller.bindingInfo.initialChanges);
                            } catch (e) {
                                $exceptionHandler(e);
                            }
                        }
                        if (isFunction(controllerInstance.$onInit)) {
                            try {
                                controllerInstance.$onInit();
                            } catch (e) {
                                $exceptionHandler(e);
                            }
                        }
                        if (isFunction(controllerInstance.$doCheck)) {
                            controllerScope.$watch(function () {
                                controllerInstance.$doCheck();
                            });
                            controllerInstance.$doCheck();
                        }
                        if (isFunction(controllerInstance.$onDestroy)) {
                            controllerScope.$on('$destroy', function callOnDestroyHook() {
                                controllerInstance.$onDestroy();
                            });
                        }
                    });
                    for (i = 0, ii = preLinkFns.length; i < ii; i++) {
                        linkFn = preLinkFns[i];
                        invokeLinkFn(linkFn, linkFn.isolateScope ? isolateScope : scope, $element, attrs, linkFn.require && getControllers(linkFn.directiveName, linkFn.require, $element, elementControllers), transcludeFn);
                    }
                    var scopeToChild = scope;
                    if (newIsolateScopeDirective && (newIsolateScopeDirective.template || newIsolateScopeDirective.templateUrl === null)) {
                        scopeToChild = isolateScope;
                    }
                    if (childLinkFn) {
                        childLinkFn(scopeToChild, linkNode.childNodes, undefined, boundTranscludeFn);
                    }
                    for (i = postLinkFns.length - 1; i >= 0; i--) {
                        linkFn = postLinkFns[i];
                        invokeLinkFn(linkFn, linkFn.isolateScope ? isolateScope : scope, $element, attrs, linkFn.require && getControllers(linkFn.directiveName, linkFn.require, $element, elementControllers), transcludeFn);
                    }
                    forEach(elementControllers, function (controller) {
                        var controllerInstance = controller.instance;
                        if (isFunction(controllerInstance.$postLink)) {
                            controllerInstance.$postLink();
                        }
                    });
                    function controllersBoundTransclude(scope, cloneAttachFn, futureParentElement, slotName) {
                        var transcludeControllers;
                        if (!isScope(scope)) {
                            slotName = futureParentElement;
                            futureParentElement = cloneAttachFn;
                            cloneAttachFn = scope;
                            scope = undefined;
                        }
                        if (hasElementTranscludeDirective) {
                            transcludeControllers = elementControllers;
                        }
                        if (!futureParentElement) {
                            futureParentElement = hasElementTranscludeDirective ? $element.parent() : $element;
                        }
                        if (slotName) {
                            var slotTranscludeFn = boundTranscludeFn.$$slots[slotName];
                            if (slotTranscludeFn) {
                                return slotTranscludeFn(scope, cloneAttachFn, transcludeControllers, futureParentElement, scopeToChild);
                            } else if (isUndefined(slotTranscludeFn)) {
                                throw $compileMinErr('noslot', 'No parent directive that requires a transclusion with slot name "{0}". ' + 'Element: {1}', slotName, startingTag($element));
                            }
                        } else {
                            return boundTranscludeFn(scope, cloneAttachFn, transcludeControllers, futureParentElement, scopeToChild);
                        }
                    }
                }
            }
            function getControllers(directiveName, require, $element, elementControllers) {
                var value;
                if (isString(require)) {
                    var match = require.match(REQUIRE_PREFIX_REGEXP);
                    var name = require.substring(match[0].length);
                    var inheritType = match[1] || match[3];
                    var optional = match[2] === '?';
                    if (inheritType === '^^') {
                        $element = $element.parent();
                    } else {
                        value = elementControllers && elementControllers[name];
                        value = value && value.instance;
                    }
                    if (!value) {
                        var dataName = '$' + name + 'Controller';
                        value = inheritType ? $element.inheritedData(dataName) : $element.data(dataName);
                    }
                    if (!value && !optional) {
                        throw $compileMinErr('ctreq', 'Controller \'{0}\', required by directive \'{1}\', can\'t be found!', name, directiveName);
                    }
                } else if (isArray(require)) {
                    value = [];
                    for (var i = 0, ii = require.length; i < ii; i++) {
                        value[i] = getControllers(directiveName, require[i], $element, elementControllers);
                    }
                } else if (isObject(require)) {
                    value = {};
                    forEach(require, function (controller, property) {
                        value[property] = getControllers(directiveName, controller, $element, elementControllers);
                    });
                }
                return value || null;
            }
            function setupControllers($element, attrs, transcludeFn, controllerDirectives, isolateScope, scope, newIsolateScopeDirective) {
                var elementControllers = createMap();
                for (var controllerKey in controllerDirectives) {
                    var directive = controllerDirectives[controllerKey];
                    var locals = {
                        $scope: directive === newIsolateScopeDirective || directive.$$isolateScope ? isolateScope : scope,
                        $element: $element,
                        $attrs: attrs,
                        $transclude: transcludeFn
                    };
                    var controller = directive.controller;
                    if (controller === '@') {
                        controller = attrs[directive.name];
                    }
                    var controllerInstance = $controller(controller, locals, true, directive.controllerAs);
                    elementControllers[directive.name] = controllerInstance;
                    $element.data('$' + directive.name + 'Controller', controllerInstance.instance);
                }
                return elementControllers;
            }
            function markDirectiveScope(directives, isolateScope, newScope) {
                for (var j = 0, jj = directives.length; j < jj; j++) {
                    directives[j] = inherit(directives[j], {
                        $$isolateScope: isolateScope,
                        $$newScope: newScope
                    });
                }
            }
            function addDirective(tDirectives, name, location, maxPriority, ignoreDirective, startAttrName, endAttrName) {
                if (name === ignoreDirective)
                    return null;
                var match = null;
                if (hasDirectives.hasOwnProperty(name)) {
                    for (var directive, directives = $injector.get(name + Suffix), i = 0, ii = directives.length; i < ii; i++) {
                        directive = directives[i];
                        if ((isUndefined(maxPriority) || maxPriority > directive.priority) && directive.restrict.indexOf(location) !== -1) {
                            if (startAttrName) {
                                directive = inherit(directive, {
                                    $$start: startAttrName,
                                    $$end: endAttrName
                                });
                            }
                            if (!directive.$$bindings) {
                                var bindings = directive.$$bindings = parseDirectiveBindings(directive, directive.name);
                                if (isObject(bindings.isolateScope)) {
                                    directive.$$isolateBindings = bindings.isolateScope;
                                }
                            }
                            tDirectives.push(directive);
                            match = directive;
                        }
                    }
                }
                return match;
            }
            function directiveIsMultiElement(name) {
                if (hasDirectives.hasOwnProperty(name)) {
                    for (var directive, directives = $injector.get(name + Suffix), i = 0, ii = directives.length; i < ii; i++) {
                        directive = directives[i];
                        if (directive.multiElement) {
                            return true;
                        }
                    }
                }
                return false;
            }
            function mergeTemplateAttributes(dst, src) {
                var srcAttr = src.$attr, dstAttr = dst.$attr;
                forEach(dst, function (value, key) {
                    if (key.charAt(0) !== '$') {
                        if (src[key] && src[key] !== value) {
                            if (value.length) {
                                value += (key === 'style' ? ';' : ' ') + src[key];
                            } else {
                                value = src[key];
                            }
                        }
                        dst.$set(key, value, true, srcAttr[key]);
                    }
                });
                forEach(src, function (value, key) {
                    if (!dst.hasOwnProperty(key) && key.charAt(0) !== '$') {
                        dst[key] = value;
                        if (key !== 'class' && key !== 'style') {
                            dstAttr[key] = srcAttr[key];
                        }
                    }
                });
            }
            function compileTemplateUrl(directives, $compileNode, tAttrs, $rootElement, childTranscludeFn, preLinkFns, postLinkFns, previousCompileContext) {
                var linkQueue = [], afterTemplateNodeLinkFn, afterTemplateChildLinkFn, beforeTemplateCompileNode = $compileNode[0], origAsyncDirective = directives.shift(), derivedSyncDirective = inherit(origAsyncDirective, {
                        templateUrl: null,
                        transclude: null,
                        replace: null,
                        $$originalDirective: origAsyncDirective
                    }), templateUrl = isFunction(origAsyncDirective.templateUrl) ? origAsyncDirective.templateUrl($compileNode, tAttrs) : origAsyncDirective.templateUrl, templateNamespace = origAsyncDirective.templateNamespace;
                $compileNode.empty();
                $templateRequest(templateUrl).then(function (content) {
                    var compileNode, tempTemplateAttrs, $template, childBoundTranscludeFn;
                    content = denormalizeTemplate(content);
                    if (origAsyncDirective.replace) {
                        if (jqLiteIsTextNode(content)) {
                            $template = [];
                        } else {
                            $template = removeComments(wrapTemplate(templateNamespace, trim(content)));
                        }
                        compileNode = $template[0];
                        if ($template.length !== 1 || compileNode.nodeType !== NODE_TYPE_ELEMENT) {
                            throw $compileMinErr('tplrt', 'Template for directive \'{0}\' must have exactly one root element. {1}', origAsyncDirective.name, templateUrl);
                        }
                        tempTemplateAttrs = {
                            $attr: {}
                        };
                        replaceWith($rootElement, $compileNode, compileNode);
                        var templateDirectives = collectDirectives(compileNode, [], tempTemplateAttrs);
                        if (isObject(origAsyncDirective.scope)) {
                            markDirectiveScope(templateDirectives, true);
                        }
                        directives = templateDirectives.concat(directives);
                        mergeTemplateAttributes(tAttrs, tempTemplateAttrs);
                    } else {
                        compileNode = beforeTemplateCompileNode;
                        $compileNode.html(content);
                    }
                    directives.unshift(derivedSyncDirective);
                    afterTemplateNodeLinkFn = applyDirectivesToNode(directives, compileNode, tAttrs, childTranscludeFn, $compileNode, origAsyncDirective, preLinkFns, postLinkFns, previousCompileContext);
                    forEach($rootElement, function (node, i) {
                        if (node === compileNode) {
                            $rootElement[i] = $compileNode[0];
                        }
                    });
                    afterTemplateChildLinkFn = compileNodes($compileNode[0].childNodes, childTranscludeFn);
                    while (linkQueue.length) {
                        var scope = linkQueue.shift(), beforeTemplateLinkNode = linkQueue.shift(), linkRootElement = linkQueue.shift(), boundTranscludeFn = linkQueue.shift(), linkNode = $compileNode[0];
                        if (scope.$$destroyed)
                            continue;
                        if (beforeTemplateLinkNode !== beforeTemplateCompileNode) {
                            var oldClasses = beforeTemplateLinkNode.className;
                            if (!(previousCompileContext.hasElementTranscludeDirective && origAsyncDirective.replace)) {
                                linkNode = jqLiteClone(compileNode);
                            }
                            replaceWith(linkRootElement, jqLite(beforeTemplateLinkNode), linkNode);
                            safeAddClass(jqLite(linkNode), oldClasses);
                        }
                        if (afterTemplateNodeLinkFn.transcludeOnThisElement) {
                            childBoundTranscludeFn = createBoundTranscludeFn(scope, afterTemplateNodeLinkFn.transclude, boundTranscludeFn);
                        } else {
                            childBoundTranscludeFn = boundTranscludeFn;
                        }
                        afterTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, linkNode, $rootElement, childBoundTranscludeFn);
                    }
                    linkQueue = null;
                }).catch(function (error) {
                    if (error instanceof Error) {
                        $exceptionHandler(error);
                    }
                });
                return function delayedNodeLinkFn(ignoreChildLinkFn, scope, node, rootElement, boundTranscludeFn) {
                    var childBoundTranscludeFn = boundTranscludeFn;
                    if (scope.$$destroyed)
                        return;
                    if (linkQueue) {
                        linkQueue.push(scope, node, rootElement, childBoundTranscludeFn);
                    } else {
                        if (afterTemplateNodeLinkFn.transcludeOnThisElement) {
                            childBoundTranscludeFn = createBoundTranscludeFn(scope, afterTemplateNodeLinkFn.transclude, boundTranscludeFn);
                        }
                        afterTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, node, rootElement, childBoundTranscludeFn);
                    }
                };
            }
            function byPriority(a, b) {
                var diff = b.priority - a.priority;
                if (diff !== 0)
                    return diff;
                if (a.name !== b.name)
                    return a.name < b.name ? -1 : 1;
                return a.index - b.index;
            }
            function assertNoDuplicate(what, previousDirective, directive, element) {
                function wrapModuleNameIfDefined(moduleName) {
                    return moduleName ? ' (module: ' + moduleName + ')' : '';
                }
                if (previousDirective) {
                    throw $compileMinErr('multidir', 'Multiple directives [{0}{1}, {2}{3}] asking for {4} on: {5}', previousDirective.name, wrapModuleNameIfDefined(previousDirective.$$moduleName), directive.name, wrapModuleNameIfDefined(directive.$$moduleName), what, startingTag(element));
                }
            }
            function addTextInterpolateDirective(directives, text) {
                var interpolateFn = $interpolate(text, true);
                if (interpolateFn) {
                    directives.push({
                        priority: 0,
                        compile: function textInterpolateCompileFn(templateNode) {
                            var templateNodeParent = templateNode.parent(), hasCompileParent = !!templateNodeParent.length;
                            if (hasCompileParent)
                                compile.$$addBindingClass(templateNodeParent);
                            return function textInterpolateLinkFn(scope, node) {
                                var parent = node.parent();
                                if (!hasCompileParent)
                                    compile.$$addBindingClass(parent);
                                compile.$$addBindingInfo(parent, interpolateFn.expressions);
                                scope.$watch(interpolateFn, function interpolateFnWatchAction(value) {
                                    node[0].nodeValue = value;
                                });
                            };
                        }
                    });
                }
            }
            function wrapTemplate(type, template) {
                type = lowercase(type || 'html');
                switch (type) {
                case 'svg':
                case 'math':
                    var wrapper = window.document.createElement('div');
                    wrapper.innerHTML = '<' + type + '>' + template + '</' + type + '>';
                    return wrapper.childNodes[0].childNodes;
                default:
                    return template;
                }
            }
            function getTrustedContext(node, attrNormalizedName) {
                if (attrNormalizedName === 'srcdoc') {
                    return $sce.HTML;
                }
                var tag = nodeName_(node);
                if (attrNormalizedName === 'src' || attrNormalizedName === 'ngSrc') {
                    if ([
                            'img',
                            'video',
                            'audio',
                            'source',
                            'track'
                        ].indexOf(tag) === -1) {
                        return $sce.RESOURCE_URL;
                    }
                } else if (attrNormalizedName === 'xlinkHref' || tag === 'form' && attrNormalizedName === 'action' || tag === 'link' && attrNormalizedName === 'href') {
                    return $sce.RESOURCE_URL;
                }
            }
            function addAttrInterpolateDirective(node, directives, value, name, isNgAttr) {
                var trustedContext = getTrustedContext(node, name);
                var mustHaveExpression = !isNgAttr;
                var allOrNothing = ALL_OR_NOTHING_ATTRS[name] || isNgAttr;
                var interpolateFn = $interpolate(value, mustHaveExpression, trustedContext, allOrNothing);
                if (!interpolateFn)
                    return;
                if (name === 'multiple' && nodeName_(node) === 'select') {
                    throw $compileMinErr('selmulti', 'Binding to the \'multiple\' attribute is not supported. Element: {0}', startingTag(node));
                }
                if (EVENT_HANDLER_ATTR_REGEXP.test(name)) {
                    throw $compileMinErr('nodomevents', 'Interpolations for HTML DOM event attributes are disallowed.  Please use the ' + 'ng- versions (such as ng-click instead of onclick) instead.');
                }
                directives.push({
                    priority: 100,
                    compile: function () {
                        return {
                            pre: function attrInterpolatePreLinkFn(scope, element, attr) {
                                var $$observers = attr.$$observers || (attr.$$observers = createMap());
                                var newValue = attr[name];
                                if (newValue !== value) {
                                    interpolateFn = newValue && $interpolate(newValue, true, trustedContext, allOrNothing);
                                    value = newValue;
                                }
                                if (!interpolateFn)
                                    return;
                                attr[name] = interpolateFn(scope);
                                ($$observers[name] || ($$observers[name] = [])).$$inter = true;
                                (attr.$$observers && attr.$$observers[name].$$scope || scope).$watch(interpolateFn, function interpolateFnWatchAction(newValue, oldValue) {
                                    if (name === 'class' && newValue !== oldValue) {
                                        attr.$updateClass(newValue, oldValue);
                                    } else {
                                        attr.$set(name, newValue);
                                    }
                                });
                            }
                        };
                    }
                });
            }
            function replaceWith($rootElement, elementsToRemove, newNode) {
                var firstElementToRemove = elementsToRemove[0], removeCount = elementsToRemove.length, parent = firstElementToRemove.parentNode, i, ii;
                if ($rootElement) {
                    for (i = 0, ii = $rootElement.length; i < ii; i++) {
                        if ($rootElement[i] === firstElementToRemove) {
                            $rootElement[i++] = newNode;
                            for (var j = i, j2 = j + removeCount - 1, jj = $rootElement.length; j < jj; j++, j2++) {
                                if (j2 < jj) {
                                    $rootElement[j] = $rootElement[j2];
                                } else {
                                    delete $rootElement[j];
                                }
                            }
                            $rootElement.length -= removeCount - 1;
                            if ($rootElement.context === firstElementToRemove) {
                                $rootElement.context = newNode;
                            }
                            break;
                        }
                    }
                }
                if (parent) {
                    parent.replaceChild(newNode, firstElementToRemove);
                }
                var fragment = window.document.createDocumentFragment();
                for (i = 0; i < removeCount; i++) {
                    fragment.appendChild(elementsToRemove[i]);
                }
                if (jqLite.hasData(firstElementToRemove)) {
                    jqLite.data(newNode, jqLite.data(firstElementToRemove));
                    jqLite(firstElementToRemove).off('$destroy');
                }
                jqLite.cleanData(fragment.querySelectorAll('*'));
                for (i = 1; i < removeCount; i++) {
                    delete elementsToRemove[i];
                }
                elementsToRemove[0] = newNode;
                elementsToRemove.length = 1;
            }
            function cloneAndAnnotateFn(fn, annotation) {
                return extend(function () {
                    return fn.apply(null, arguments);
                }, fn, annotation);
            }
            function invokeLinkFn(linkFn, scope, $element, attrs, controllers, transcludeFn) {
                try {
                    linkFn(scope, $element, attrs, controllers, transcludeFn);
                } catch (e) {
                    $exceptionHandler(e, startingTag($element));
                }
            }
            function initializeDirectiveBindings(scope, attrs, destination, bindings, directive) {
                var removeWatchCollection = [];
                var initialChanges = {};
                var changes;
                forEach(bindings, function initializeBinding(definition, scopeName) {
                    var attrName = definition.attrName, optional = definition.optional, mode = definition.mode, lastValue, parentGet, parentSet, compare, removeWatch;
                    switch (mode) {
                    case '@':
                        if (!optional && !hasOwnProperty.call(attrs, attrName)) {
                            destination[scopeName] = attrs[attrName] = undefined;
                        }
                        removeWatch = attrs.$observe(attrName, function (value) {
                            if (isString(value) || isBoolean(value)) {
                                var oldValue = destination[scopeName];
                                recordChanges(scopeName, value, oldValue);
                                destination[scopeName] = value;
                            }
                        });
                        attrs.$$observers[attrName].$$scope = scope;
                        lastValue = attrs[attrName];
                        if (isString(lastValue)) {
                            destination[scopeName] = $interpolate(lastValue)(scope);
                        } else if (isBoolean(lastValue)) {
                            destination[scopeName] = lastValue;
                        }
                        initialChanges[scopeName] = new SimpleChange(_UNINITIALIZED_VALUE, destination[scopeName]);
                        removeWatchCollection.push(removeWatch);
                        break;
                    case '=':
                        if (!hasOwnProperty.call(attrs, attrName)) {
                            if (optional)
                                break;
                            attrs[attrName] = undefined;
                        }
                        if (optional && !attrs[attrName])
                            break;
                        parentGet = $parse(attrs[attrName]);
                        if (parentGet.literal) {
                            compare = equals;
                        } else {
                            compare = function simpleCompare(a, b) {
                                return a === b || a !== a && b !== b;
                            };
                        }
                        parentSet = parentGet.assign || function () {
                            lastValue = destination[scopeName] = parentGet(scope);
                            throw $compileMinErr('nonassign', 'Expression \'{0}\' in attribute \'{1}\' used with directive \'{2}\' is non-assignable!', attrs[attrName], attrName, directive.name);
                        };
                        lastValue = destination[scopeName] = parentGet(scope);
                        var parentValueWatch = function parentValueWatch(parentValue) {
                            if (!compare(parentValue, destination[scopeName])) {
                                if (!compare(parentValue, lastValue)) {
                                    destination[scopeName] = parentValue;
                                } else {
                                    parentSet(scope, parentValue = destination[scopeName]);
                                }
                            }
                            lastValue = parentValue;
                            return lastValue;
                        };
                        parentValueWatch.$stateful = true;
                        if (definition.collection) {
                            removeWatch = scope.$watchCollection(attrs[attrName], parentValueWatch);
                        } else {
                            removeWatch = scope.$watch($parse(attrs[attrName], parentValueWatch), null, parentGet.literal);
                        }
                        removeWatchCollection.push(removeWatch);
                        break;
                    case '<':
                        if (!hasOwnProperty.call(attrs, attrName)) {
                            if (optional)
                                break;
                            attrs[attrName] = undefined;
                        }
                        if (optional && !attrs[attrName])
                            break;
                        parentGet = $parse(attrs[attrName]);
                        var deepWatch = parentGet.literal;
                        var initialValue = destination[scopeName] = parentGet(scope);
                        initialChanges[scopeName] = new SimpleChange(_UNINITIALIZED_VALUE, destination[scopeName]);
                        removeWatch = scope.$watch(parentGet, function parentValueWatchAction(newValue, oldValue) {
                            if (oldValue === newValue) {
                                if (oldValue === initialValue || deepWatch && equals(oldValue, initialValue)) {
                                    return;
                                }
                                oldValue = initialValue;
                            }
                            recordChanges(scopeName, newValue, oldValue);
                            destination[scopeName] = newValue;
                        }, deepWatch);
                        removeWatchCollection.push(removeWatch);
                        break;
                    case '&':
                        parentGet = attrs.hasOwnProperty(attrName) ? $parse(attrs[attrName]) : noop;
                        if (parentGet === noop && optional)
                            break;
                        destination[scopeName] = function (locals) {
                            return parentGet(scope, locals);
                        };
                        break;
                    }
                });
                function recordChanges(key, currentValue, previousValue) {
                    if (isFunction(destination.$onChanges) && currentValue !== previousValue && (currentValue === currentValue || previousValue === previousValue)) {
                        if (!onChangesQueue) {
                            scope.$$postDigest(flushOnChangesQueue);
                            onChangesQueue = [];
                        }
                        if (!changes) {
                            changes = {};
                            onChangesQueue.push(triggerOnChangesHook);
                        }
                        if (changes[key]) {
                            previousValue = changes[key].previousValue;
                        }
                        changes[key] = new SimpleChange(previousValue, currentValue);
                    }
                }
                function triggerOnChangesHook() {
                    destination.$onChanges(changes);
                    changes = undefined;
                }
                return {
                    initialChanges: initialChanges,
                    removeWatches: removeWatchCollection.length && function removeWatches() {
                        for (var i = 0, ii = removeWatchCollection.length; i < ii; ++i) {
                            removeWatchCollection[i]();
                        }
                    }
                };
            }
        }
    ];
};
SimpleChange = function SimpleChange(previous, current) {
    this.previousValue = previous;
    this.currentValue = current;
};
directiveNormalize = function directiveNormalize(name) {
    return name.replace(PREFIX_REGEXP, '').replace(SPECIAL_CHARS_REGEXP, fnCamelCaseReplace);
};
nodesetLinkingFn = function nodesetLinkingFn(scope, nodeList, rootElement, boundTranscludeFn) {
};
directiveLinkingFn = function directiveLinkingFn(nodesetLinkingFn, scope, node, rootElement, boundTranscludeFn) {
};
tokenDifference = function tokenDifference(str1, str2) {
    var values = '', tokens1 = str1.split(/\s+/), tokens2 = str2.split(/\s+/);
    outer:
        for (var i = 0; i < tokens1.length; i++) {
            var token = tokens1[i];
            for (var j = 0; j < tokens2.length; j++) {
                if (token === tokens2[j])
                    continue outer;
            }
            values += (values.length > 0 ? ' ' : '') + token;
        }
    return values;
};
removeComments = function removeComments(jqNodes) {
    jqNodes = jqLite(jqNodes);
    var i = jqNodes.length;
    if (i <= 1) {
        return jqNodes;
    }
    while (i--) {
        var node = jqNodes[i];
        if (node.nodeType === NODE_TYPE_COMMENT || node.nodeType === NODE_TYPE_TEXT && node.nodeValue.trim() === '') {
            splice.call(jqNodes, i, 1);
        }
    }
    return jqNodes;
};
identifierForController = function identifierForController(controller, ident) {
    if (ident && isString(ident))
        return ident;
    if (isString(controller)) {
        var match = CNTRL_REG.exec(controller);
        if (match)
            return match[3];
    }
};
$ControllerProvider = function $ControllerProvider() {
    var controllers = {}, globals = false;
    this.has = function (name) {
        return controllers.hasOwnProperty(name);
    };
    this.register = function (name, constructor) {
        assertNotHasOwnProperty(name, 'controller');
        if (isObject(name)) {
            extend(controllers, name);
        } else {
            controllers[name] = constructor;
        }
    };
    this.allowGlobals = function () {
        globals = true;
    };
    this.$get = [
        '$injector',
        '$window',
        function ($injector, $window) {
            return function $controller(expression, locals, later, ident) {
                var instance, match, constructor, identifier;
                later = later === true;
                if (ident && isString(ident)) {
                    identifier = ident;
                }
                if (isString(expression)) {
                    match = expression.match(CNTRL_REG);
                    if (!match) {
                        throw $controllerMinErr('ctrlfmt', 'Badly formed controller string \'{0}\'. ' + 'Must match `__name__ as __id__` or `__name__`.', expression);
                    }
                    constructor = match[1];
                    identifier = identifier || match[3];
                    expression = controllers.hasOwnProperty(constructor) ? controllers[constructor] : getter(locals.$scope, constructor, true) || (globals ? getter($window, constructor, true) : undefined);
                    if (!expression) {
                        throw $controllerMinErr('ctrlreg', 'The controller with the name \'{0}\' is not registered.', constructor);
                    }
                    assertArgFn(expression, constructor, true);
                }
                if (later) {
                    var controllerPrototype = (isArray(expression) ? expression[expression.length - 1] : expression).prototype;
                    instance = Object.create(controllerPrototype || null);
                    if (identifier) {
                        addIdentifier(locals, identifier, instance, constructor || expression.name);
                    }
                    return extend(function $controllerInit() {
                        var result = $injector.invoke(expression, instance, locals, constructor);
                        if (result !== instance && (isObject(result) || isFunction(result))) {
                            instance = result;
                            if (identifier) {
                                addIdentifier(locals, identifier, instance, constructor || expression.name);
                            }
                        }
                        return instance;
                    }, {
                        instance: instance,
                        identifier: identifier
                    });
                }
                instance = $injector.instantiate(expression, locals, constructor);
                if (identifier) {
                    addIdentifier(locals, identifier, instance, constructor || expression.name);
                }
                return instance;
            };
            function addIdentifier(locals, identifier, instance, name) {
                if (!(locals && isObject(locals.$scope))) {
                    throw minErr('$controller')('noscp', 'Cannot export controller \'{0}\' as \'{1}\'! No $scope object provided via `locals`.', name, identifier);
                }
                locals.$scope[identifier] = instance;
            }
        }
    ];
};
$DocumentProvider = function $DocumentProvider() {
    this.$get = [
        '$window',
        function (window) {
            return jqLite(window.document);
        }
    ];
};
$$IsDocumentHiddenProvider = function $$IsDocumentHiddenProvider() {
    this.$get = [
        '$document',
        '$rootScope',
        function ($document, $rootScope) {
            var doc = $document[0];
            var hidden = doc && doc.hidden;
            $document.on('visibilitychange', changeListener);
            $rootScope.$on('$destroy', function () {
                $document.off('visibilitychange', changeListener);
            });
            function changeListener() {
                hidden = doc.hidden;
            }
            return function () {
                return hidden;
            };
        }
    ];
};
$ExceptionHandlerProvider = function $ExceptionHandlerProvider() {
    this.$get = [
        '$log',
        function ($log) {
            return function (exception, cause) {
                $log.error.apply($log, arguments);
            };
        }
    ];
};
serializeValue = function serializeValue(v) {
    if (isObject(v)) {
        return isDate(v) ? v.toISOString() : toJson(v);
    }
    return v;
};
$HttpParamSerializerProvider = function $HttpParamSerializerProvider() {
    this.$get = function () {
        return function ngParamSerializer(params) {
            if (!params)
                return '';
            var parts = [];
            forEachSorted(params, function (value, key) {
                if (value === null || isUndefined(value))
                    return;
                if (isArray(value)) {
                    forEach(value, function (v) {
                        parts.push(encodeUriQuery(key) + '=' + encodeUriQuery(serializeValue(v)));
                    });
                } else {
                    parts.push(encodeUriQuery(key) + '=' + encodeUriQuery(serializeValue(value)));
                }
            });
            return parts.join('&');
        };
    };
};
$HttpParamSerializerJQLikeProvider = function $HttpParamSerializerJQLikeProvider() {
    this.$get = function () {
        return function jQueryLikeParamSerializer(params) {
            if (!params)
                return '';
            var parts = [];
            serialize(params, '', true);
            return parts.join('&');
            function serialize(toSerialize, prefix, topLevel) {
                if (toSerialize === null || isUndefined(toSerialize))
                    return;
                if (isArray(toSerialize)) {
                    forEach(toSerialize, function (value, index) {
                        serialize(value, prefix + '[' + (isObject(value) ? index : '') + ']');
                    });
                } else if (isObject(toSerialize) && !isDate(toSerialize)) {
                    forEachSorted(toSerialize, function (value, key) {
                        serialize(value, prefix + (topLevel ? '' : '[') + key + (topLevel ? '' : ']'));
                    });
                } else {
                    parts.push(encodeUriQuery(prefix) + '=' + encodeUriQuery(serializeValue(toSerialize)));
                }
            }
        };
    };
};
defaultHttpResponseTransform = function defaultHttpResponseTransform(data, headers) {
    if (isString(data)) {
        var tempData = data.replace(JSON_PROTECTION_PREFIX, '').trim();
        if (tempData) {
            var contentType = headers('Content-Type');
            if (contentType && contentType.indexOf(APPLICATION_JSON) === 0 || isJsonLike(tempData)) {
                data = fromJson(tempData);
            }
        }
    }
    return data;
};
isJsonLike = function isJsonLike(str) {
    var jsonStart = str.match(JSON_START);
    return jsonStart && JSON_ENDS[jsonStart[0]].test(str);
};
parseHeaders = function parseHeaders(headers) {
    var parsed = createMap(), i;
    function fillInParsed(key, val) {
        if (key) {
            parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
        }
    }
    if (isString(headers)) {
        forEach(headers.split('\n'), function (line) {
            i = line.indexOf(':');
            fillInParsed(lowercase(trim(line.substr(0, i))), trim(line.substr(i + 1)));
        });
    } else if (isObject(headers)) {
        forEach(headers, function (headerVal, headerKey) {
            fillInParsed(lowercase(headerKey), trim(headerVal));
        });
    }
    return parsed;
};
headersGetter = function headersGetter(headers) {
    var headersObj;
    return function (name) {
        if (!headersObj)
            headersObj = parseHeaders(headers);
        if (name) {
            var value = headersObj[lowercase(name)];
            if (value === undefined) {
                value = null;
            }
            return value;
        }
        return headersObj;
    };
};
transformData = function transformData(data, headers, status, fns) {
    if (isFunction(fns)) {
        return fns(data, headers, status);
    }
    forEach(fns, function (fn) {
        data = fn(data, headers, status);
    });
    return data;
};
isSuccess = function isSuccess(status) {
    return 200 <= status && status < 300;
};
$HttpProvider = function $HttpProvider() {
    var defaults = this.defaults = {
        transformResponse: [defaultHttpResponseTransform],
        transformRequest: [function (d) {
                return isObject(d) && !isFile(d) && !isBlob(d) && !isFormData(d) ? toJson(d) : d;
            }],
        headers: {
            common: {
                'Accept': 'application/json, text/plain, */*'
            },
            post: shallowCopy(CONTENT_TYPE_APPLICATION_JSON),
            put: shallowCopy(CONTENT_TYPE_APPLICATION_JSON),
            patch: shallowCopy(CONTENT_TYPE_APPLICATION_JSON)
        },
        xsrfCookieName: 'XSRF-TOKEN',
        xsrfHeaderName: 'X-XSRF-TOKEN',
        paramSerializer: '$httpParamSerializer',
        jsonpCallbackParam: 'callback'
    };
    var useApplyAsync = false;
    this.useApplyAsync = function (value) {
        if (isDefined(value)) {
            useApplyAsync = !!value;
            return this;
        }
        return useApplyAsync;
    };
    var interceptorFactories = this.interceptors = [];
    this.$get = [
        '$browser',
        '$httpBackend',
        '$$cookieReader',
        '$cacheFactory',
        '$rootScope',
        '$q',
        '$injector',
        '$sce',
        function ($browser, $httpBackend, $$cookieReader, $cacheFactory, $rootScope, $q, $injector, $sce) {
            var defaultCache = $cacheFactory('$http');
            defaults.paramSerializer = isString(defaults.paramSerializer) ? $injector.get(defaults.paramSerializer) : defaults.paramSerializer;
            var reversedInterceptors = [];
            forEach(interceptorFactories, function (interceptorFactory) {
                reversedInterceptors.unshift(isString(interceptorFactory) ? $injector.get(interceptorFactory) : $injector.invoke(interceptorFactory));
            });
            function $http(requestConfig) {
                if (!isObject(requestConfig)) {
                    throw minErr('$http')('badreq', 'Http request configuration must be an object.  Received: {0}', requestConfig);
                }
                if (!isString($sce.valueOf(requestConfig.url))) {
                    throw minErr('$http')('badreq', 'Http request configuration url must be a string or a $sce trusted object.  Received: {0}', requestConfig.url);
                }
                var config = extend({
                    method: 'get',
                    transformRequest: defaults.transformRequest,
                    transformResponse: defaults.transformResponse,
                    paramSerializer: defaults.paramSerializer,
                    jsonpCallbackParam: defaults.jsonpCallbackParam
                }, requestConfig);
                config.headers = mergeHeaders(requestConfig);
                config.method = uppercase(config.method);
                config.paramSerializer = isString(config.paramSerializer) ? $injector.get(config.paramSerializer) : config.paramSerializer;
                $browser.$$incOutstandingRequestCount();
                var requestInterceptors = [];
                var responseInterceptors = [];
                var promise = $q.resolve(config);
                forEach(reversedInterceptors, function (interceptor) {
                    if (interceptor.request || interceptor.requestError) {
                        requestInterceptors.unshift(interceptor.request, interceptor.requestError);
                    }
                    if (interceptor.response || interceptor.responseError) {
                        responseInterceptors.push(interceptor.response, interceptor.responseError);
                    }
                });
                promise = chainInterceptors(promise, requestInterceptors);
                promise = promise.then(serverRequest);
                promise = chainInterceptors(promise, responseInterceptors);
                promise = promise.finally(completeOutstandingRequest);
                return promise;
                function chainInterceptors(promise, interceptors) {
                    for (var i = 0, ii = interceptors.length; i < ii;) {
                        var thenFn = interceptors[i++];
                        var rejectFn = interceptors[i++];
                        promise = promise.then(thenFn, rejectFn);
                    }
                    interceptors.length = 0;
                    return promise;
                }
                function completeOutstandingRequest() {
                    $browser.$$completeOutstandingRequest(noop);
                }
                function executeHeaderFns(headers, config) {
                    var headerContent, processedHeaders = {};
                    forEach(headers, function (headerFn, header) {
                        if (isFunction(headerFn)) {
                            headerContent = headerFn(config);
                            if (headerContent != null) {
                                processedHeaders[header] = headerContent;
                            }
                        } else {
                            processedHeaders[header] = headerFn;
                        }
                    });
                    return processedHeaders;
                }
                function mergeHeaders(config) {
                    var defHeaders = defaults.headers, reqHeaders = extend({}, config.headers), defHeaderName, lowercaseDefHeaderName, reqHeaderName;
                    defHeaders = extend({}, defHeaders.common, defHeaders[lowercase(config.method)]);
                    defaultHeadersIteration:
                        for (defHeaderName in defHeaders) {
                            lowercaseDefHeaderName = lowercase(defHeaderName);
                            for (reqHeaderName in reqHeaders) {
                                if (lowercase(reqHeaderName) === lowercaseDefHeaderName) {
                                    continue defaultHeadersIteration;
                                }
                            }
                            reqHeaders[defHeaderName] = defHeaders[defHeaderName];
                        }
                    return executeHeaderFns(reqHeaders, shallowCopy(config));
                }
                function serverRequest(config) {
                    var headers = config.headers;
                    var reqData = transformData(config.data, headersGetter(headers), undefined, config.transformRequest);
                    if (isUndefined(reqData)) {
                        forEach(headers, function (value, header) {
                            if (lowercase(header) === 'content-type') {
                                delete headers[header];
                            }
                        });
                    }
                    if (isUndefined(config.withCredentials) && !isUndefined(defaults.withCredentials)) {
                        config.withCredentials = defaults.withCredentials;
                    }
                    return sendReq(config, reqData).then(transformResponse, transformResponse);
                }
                function transformResponse(response) {
                    var resp = extend({}, response);
                    resp.data = transformData(response.data, response.headers, response.status, config.transformResponse);
                    return isSuccess(response.status) ? resp : $q.reject(resp);
                }
            }
            $http.pendingRequests = [];
            createShortMethods('get', 'delete', 'head', 'jsonp');
            createShortMethodsWithData('post', 'put', 'patch');
            $http.defaults = defaults;
            return $http;
            function createShortMethods(names) {
                forEach(arguments, function (name) {
                    $http[name] = function (url, config) {
                        return $http(extend({}, config || {}, {
                            method: name,
                            url: url
                        }));
                    };
                });
            }
            function createShortMethodsWithData(name) {
                forEach(arguments, function (name) {
                    $http[name] = function (url, data, config) {
                        return $http(extend({}, config || {}, {
                            method: name,
                            url: url,
                            data: data
                        }));
                    };
                });
            }
            function sendReq(config, reqData) {
                var deferred = $q.defer(), promise = deferred.promise, cache, cachedResp, reqHeaders = config.headers, isJsonp = lowercase(config.method) === 'jsonp', url = config.url;
                if (isJsonp) {
                    url = $sce.getTrustedResourceUrl(url);
                } else if (!isString(url)) {
                    url = $sce.valueOf(url);
                }
                url = buildUrl(url, config.paramSerializer(config.params));
                if (isJsonp) {
                    url = sanitizeJsonpCallbackParam(url, config.jsonpCallbackParam);
                }
                $http.pendingRequests.push(config);
                promise.then(removePendingReq, removePendingReq);
                if ((config.cache || defaults.cache) && config.cache !== false && (config.method === 'GET' || config.method === 'JSONP')) {
                    cache = isObject(config.cache) ? config.cache : isObject(defaults.cache) ? defaults.cache : defaultCache;
                }
                if (cache) {
                    cachedResp = cache.get(url);
                    if (isDefined(cachedResp)) {
                        if (isPromiseLike(cachedResp)) {
                            cachedResp.then(resolvePromiseWithResult, resolvePromiseWithResult);
                        } else {
                            if (isArray(cachedResp)) {
                                resolvePromise(cachedResp[1], cachedResp[0], shallowCopy(cachedResp[2]), cachedResp[3]);
                            } else {
                                resolvePromise(cachedResp, 200, {}, 'OK');
                            }
                        }
                    } else {
                        cache.put(url, promise);
                    }
                }
                if (isUndefined(cachedResp)) {
                    var xsrfValue = urlIsSameOrigin(config.url) ? $$cookieReader()[config.xsrfCookieName || defaults.xsrfCookieName] : undefined;
                    if (xsrfValue) {
                        reqHeaders[config.xsrfHeaderName || defaults.xsrfHeaderName] = xsrfValue;
                    }
                    $httpBackend(config.method, url, reqData, done, reqHeaders, config.timeout, config.withCredentials, config.responseType, createApplyHandlers(config.eventHandlers), createApplyHandlers(config.uploadEventHandlers));
                }
                return promise;
                function createApplyHandlers(eventHandlers) {
                    if (eventHandlers) {
                        var applyHandlers = {};
                        forEach(eventHandlers, function (eventHandler, key) {
                            applyHandlers[key] = function (event) {
                                if (useApplyAsync) {
                                    $rootScope.$applyAsync(callEventHandler);
                                } else if ($rootScope.$$phase) {
                                    callEventHandler();
                                } else {
                                    $rootScope.$apply(callEventHandler);
                                }
                                function callEventHandler() {
                                    eventHandler(event);
                                }
                            };
                        });
                        return applyHandlers;
                    }
                }
                function done(status, response, headersString, statusText) {
                    if (cache) {
                        if (isSuccess(status)) {
                            cache.put(url, [
                                status,
                                response,
                                parseHeaders(headersString),
                                statusText
                            ]);
                        } else {
                            cache.remove(url);
                        }
                    }
                    function resolveHttpPromise() {
                        resolvePromise(response, status, headersString, statusText);
                    }
                    if (useApplyAsync) {
                        $rootScope.$applyAsync(resolveHttpPromise);
                    } else {
                        resolveHttpPromise();
                        if (!$rootScope.$$phase)
                            $rootScope.$apply();
                    }
                }
                function resolvePromise(response, status, headers, statusText) {
                    status = status >= -1 ? status : 0;
                    (isSuccess(status) ? deferred.resolve : deferred.reject)({
                        data: response,
                        status: status,
                        headers: headersGetter(headers),
                        config: config,
                        statusText: statusText
                    });
                }
                function resolvePromiseWithResult(result) {
                    resolvePromise(result.data, result.status, shallowCopy(result.headers()), result.statusText);
                }
                function removePendingReq() {
                    var idx = $http.pendingRequests.indexOf(config);
                    if (idx !== -1)
                        $http.pendingRequests.splice(idx, 1);
                }
            }
            function buildUrl(url, serializedParams) {
                if (serializedParams.length > 0) {
                    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
                }
                return url;
            }
            function sanitizeJsonpCallbackParam(url, key) {
                if (/[&?][^=]+=JSON_CALLBACK/.test(url)) {
                    throw $httpMinErr('badjsonp', 'Illegal use of JSON_CALLBACK in url, "{0}"', url);
                }
                var callbackParamRegex = new RegExp('[&?]' + key + '=');
                if (callbackParamRegex.test(url)) {
                    throw $httpMinErr('badjsonp', 'Illegal use of callback param, "{0}", in url, "{1}"', key, url);
                }
                url += (url.indexOf('?') === -1 ? '?' : '&') + key + '=JSON_CALLBACK';
                return url;
            }
        }
    ];
};
$xhrFactoryProvider = function $xhrFactoryProvider() {
    this.$get = function () {
        return function createXhr() {
            return new window.XMLHttpRequest();
        };
    };
};
$HttpBackendProvider = function $HttpBackendProvider() {
    this.$get = [
        '$browser',
        '$jsonpCallbacks',
        '$document',
        '$xhrFactory',
        function ($browser, $jsonpCallbacks, $document, $xhrFactory) {
            return createHttpBackend($browser, $xhrFactory, $browser.defer, $jsonpCallbacks, $document[0]);
        }
    ];
};
createHttpBackend = function createHttpBackend($browser, createXhr, $browserDefer, callbacks, rawDocument) {
    return function (method, url, post, callback, headers, timeout, withCredentials, responseType, eventHandlers, uploadEventHandlers) {
        url = url || $browser.url();
        if (lowercase(method) === 'jsonp') {
            var callbackPath = callbacks.createCallback(url);
            var jsonpDone = jsonpReq(url, callbackPath, function (status, text) {
                var response = status === 200 && callbacks.getResponse(callbackPath);
                completeRequest(callback, status, response, '', text);
                callbacks.removeCallback(callbackPath);
            });
        } else {
            var xhr = createXhr(method, url);
            xhr.open(method, url, true);
            forEach(headers, function (value, key) {
                if (isDefined(value)) {
                    xhr.setRequestHeader(key, value);
                }
            });
            xhr.onload = function requestLoaded() {
                var statusText = xhr.statusText || '';
                var response = 'response' in xhr ? xhr.response : xhr.responseText;
                var status = xhr.status === 1223 ? 204 : xhr.status;
                if (status === 0) {
                    status = response ? 200 : urlResolve(url).protocol === 'file' ? 404 : 0;
                }
                completeRequest(callback, status, response, xhr.getAllResponseHeaders(), statusText);
            };
            var requestError = function () {
                completeRequest(callback, -1, null, null, '');
            };
            xhr.onerror = requestError;
            xhr.onabort = requestError;
            xhr.ontimeout = requestError;
            forEach(eventHandlers, function (value, key) {
                xhr.addEventListener(key, value);
            });
            forEach(uploadEventHandlers, function (value, key) {
                xhr.upload.addEventListener(key, value);
            });
            if (withCredentials) {
                xhr.withCredentials = true;
            }
            if (responseType) {
                try {
                    xhr.responseType = responseType;
                } catch (e) {
                    if (responseType !== 'json') {
                        throw e;
                    }
                }
            }
            xhr.send(isUndefined(post) ? null : post);
        }
        if (timeout > 0) {
            var timeoutId = $browserDefer(timeoutRequest, timeout);
        } else if (isPromiseLike(timeout)) {
            timeout.then(timeoutRequest);
        }
        function timeoutRequest() {
            if (jsonpDone) {
                jsonpDone();
            }
            if (xhr) {
                xhr.abort();
            }
        }
        function completeRequest(callback, status, response, headersString, statusText) {
            if (isDefined(timeoutId)) {
                $browserDefer.cancel(timeoutId);
            }
            jsonpDone = xhr = null;
            callback(status, response, headersString, statusText);
        }
    };
    function jsonpReq(url, callbackPath, done) {
        url = url.replace('JSON_CALLBACK', callbackPath);
        var script = rawDocument.createElement('script'), callback = null;
        script.type = 'text/javascript';
        script.src = url;
        script.async = true;
        callback = function (event) {
            script.removeEventListener('load', callback);
            script.removeEventListener('error', callback);
            rawDocument.body.removeChild(script);
            script = null;
            var status = -1;
            var text = 'unknown';
            if (event) {
                if (event.type === 'load' && !callbacks.wasCalled(callbackPath)) {
                    event = {
                        type: 'error'
                    };
                }
                text = event.type;
                status = event.type === 'error' ? 404 : 200;
            }
            if (done) {
                done(status, text);
            }
        };
        script.addEventListener('load', callback);
        script.addEventListener('error', callback);
        rawDocument.body.appendChild(script);
        return callback;
    }
};
$InterpolateProvider = function $InterpolateProvider() {
    var startSymbol = '{{';
    var endSymbol = '}}';
    this.startSymbol = function (value) {
        if (value) {
            startSymbol = value;
            return this;
        } else {
            return startSymbol;
        }
    };
    this.endSymbol = function (value) {
        if (value) {
            endSymbol = value;
            return this;
        } else {
            return endSymbol;
        }
    };
    this.$get = [
        '$parse',
        '$exceptionHandler',
        '$sce',
        function ($parse, $exceptionHandler, $sce) {
            var startSymbolLength = startSymbol.length, endSymbolLength = endSymbol.length, escapedStartRegexp = new RegExp(startSymbol.replace(/./g, escape), 'g'), escapedEndRegexp = new RegExp(endSymbol.replace(/./g, escape), 'g');
            function escape(ch) {
                return '\\\\\\' + ch;
            }
            function unescapeText(text) {
                return text.replace(escapedStartRegexp, startSymbol).replace(escapedEndRegexp, endSymbol);
            }
            function constantWatchDelegate(scope, listener, objectEquality, constantInterp) {
                var unwatch = scope.$watch(function constantInterpolateWatch(scope) {
                    unwatch();
                    return constantInterp(scope);
                }, listener, objectEquality);
                return unwatch;
            }
            function $interpolate(text, mustHaveExpression, trustedContext, allOrNothing) {
                if (!text.length || text.indexOf(startSymbol) === -1) {
                    var constantInterp;
                    if (!mustHaveExpression) {
                        var unescapedText = unescapeText(text);
                        constantInterp = valueFn(unescapedText);
                        constantInterp.exp = text;
                        constantInterp.expressions = [];
                        constantInterp.$$watchDelegate = constantWatchDelegate;
                    }
                    return constantInterp;
                }
                allOrNothing = !!allOrNothing;
                var startIndex, endIndex, index = 0, expressions = [], parseFns = [], textLength = text.length, exp, concat = [], expressionPositions = [];
                while (index < textLength) {
                    if ((startIndex = text.indexOf(startSymbol, index)) !== -1 && (endIndex = text.indexOf(endSymbol, startIndex + startSymbolLength)) !== -1) {
                        if (index !== startIndex) {
                            concat.push(unescapeText(text.substring(index, startIndex)));
                        }
                        exp = text.substring(startIndex + startSymbolLength, endIndex);
                        expressions.push(exp);
                        parseFns.push($parse(exp, parseStringifyInterceptor));
                        index = endIndex + endSymbolLength;
                        expressionPositions.push(concat.length);
                        concat.push('');
                    } else {
                        if (index !== textLength) {
                            concat.push(unescapeText(text.substring(index)));
                        }
                        break;
                    }
                }
                if (trustedContext && concat.length > 1) {
                    $interpolateMinErr.throwNoconcat(text);
                }
                if (!mustHaveExpression || expressions.length) {
                    var compute = function (values) {
                        for (var i = 0, ii = expressions.length; i < ii; i++) {
                            if (allOrNothing && isUndefined(values[i]))
                                return;
                            concat[expressionPositions[i]] = values[i];
                        }
                        return concat.join('');
                    };
                    var getValue = function (value) {
                        return trustedContext ? $sce.getTrusted(trustedContext, value) : $sce.valueOf(value);
                    };
                    return extend(function interpolationFn(context) {
                        var i = 0;
                        var ii = expressions.length;
                        var values = new Array(ii);
                        try {
                            for (; i < ii; i++) {
                                values[i] = parseFns[i](context);
                            }
                            return compute(values);
                        } catch (err) {
                            $exceptionHandler($interpolateMinErr.interr(text, err));
                        }
                    }, {
                        exp: text,
                        expressions: expressions,
                        $$watchDelegate: function (scope, listener) {
                            var lastValue;
                            return scope.$watchGroup(parseFns, function interpolateFnWatcher(values, oldValues) {
                                var currValue = compute(values);
                                if (isFunction(listener)) {
                                    listener.call(this, currValue, values !== oldValues ? lastValue : currValue, scope);
                                }
                                lastValue = currValue;
                            });
                        }
                    });
                }
                function parseStringifyInterceptor(value) {
                    try {
                        value = getValue(value);
                        return allOrNothing && !isDefined(value) ? value : stringify(value);
                    } catch (err) {
                        $exceptionHandler($interpolateMinErr.interr(text, err));
                    }
                }
            }
            $interpolate.startSymbol = function () {
                return startSymbol;
            };
            $interpolate.endSymbol = function () {
                return endSymbol;
            };
            return $interpolate;
        }
    ];
};
$IntervalProvider = function $IntervalProvider() {
    this.$get = [
        '$rootScope',
        '$window',
        '$q',
        '$$q',
        '$browser',
        function ($rootScope, $window, $q, $$q, $browser) {
            var intervals = {};
            function interval(fn, delay, count, invokeApply) {
                var hasParams = arguments.length > 4, args = hasParams ? sliceArgs(arguments, 4) : [], setInterval = $window.setInterval, clearInterval = $window.clearInterval, iteration = 0, skipApply = isDefined(invokeApply) && !invokeApply, deferred = (skipApply ? $$q : $q).defer(), promise = deferred.promise;
                count = isDefined(count) ? count : 0;
                promise.$$intervalId = setInterval(function tick() {
                    if (skipApply) {
                        $browser.defer(callback);
                    } else {
                        $rootScope.$evalAsync(callback);
                    }
                    deferred.notify(iteration++);
                    if (count > 0 && iteration >= count) {
                        deferred.resolve(iteration);
                        clearInterval(promise.$$intervalId);
                        delete intervals[promise.$$intervalId];
                    }
                    if (!skipApply)
                        $rootScope.$apply();
                }, delay);
                intervals[promise.$$intervalId] = deferred;
                return promise;
                function callback() {
                    if (!hasParams) {
                        fn(iteration);
                    } else {
                        fn.apply(null, args);
                    }
                }
            }
            interval.cancel = function (promise) {
                if (promise && promise.$$intervalId in intervals) {
                    intervals[promise.$$intervalId].promise.catch(noop);
                    intervals[promise.$$intervalId].reject('canceled');
                    $window.clearInterval(promise.$$intervalId);
                    delete intervals[promise.$$intervalId];
                    return true;
                }
                return false;
            };
            return interval;
        }
    ];
};
encodePath = function encodePath(path) {
    var segments = path.split('/'), i = segments.length;
    while (i--) {
        segments[i] = encodeUriSegment(segments[i]);
    }
    return segments.join('/');
};
parseAbsoluteUrl = function parseAbsoluteUrl(absoluteUrl, locationObj) {
    var parsedUrl = urlResolve(absoluteUrl);
    locationObj.$$protocol = parsedUrl.protocol;
    locationObj.$$host = parsedUrl.hostname;
    locationObj.$$port = toInt(parsedUrl.port) || DEFAULT_PORTS[parsedUrl.protocol] || null;
};
parseAppUrl = function parseAppUrl(url, locationObj) {
    if (DOUBLE_SLASH_REGEX.test(url)) {
        throw $locationMinErr('badpath', 'Invalid url "{0}".', url);
    }
    var prefixed = url.charAt(0) !== '/';
    if (prefixed) {
        url = '/' + url;
    }
    var match = urlResolve(url);
    locationObj.$$path = decodeURIComponent(prefixed && match.pathname.charAt(0) === '/' ? match.pathname.substring(1) : match.pathname);
    locationObj.$$search = parseKeyValue(match.search);
    locationObj.$$hash = decodeURIComponent(match.hash);
    if (locationObj.$$path && locationObj.$$path.charAt(0) !== '/') {
        locationObj.$$path = '/' + locationObj.$$path;
    }
};
startsWith = function startsWith(str, search) {
    return str.slice(0, search.length) === search;
};
stripBaseUrl = function stripBaseUrl(base, url) {
    if (startsWith(url, base)) {
        return url.substr(base.length);
    }
};
stripHash = function stripHash(url) {
    var index = url.indexOf('#');
    return index === -1 ? url : url.substr(0, index);
};
trimEmptyHash = function trimEmptyHash(url) {
    return url.replace(/(#.+)|#$/, '$1');
};
stripFile = function stripFile(url) {
    return url.substr(0, stripHash(url).lastIndexOf('/') + 1);
};
serverBase = function serverBase(url) {
    return url.substring(0, url.indexOf('/', url.indexOf('//') + 2));
};
LocationHtml5Url = function LocationHtml5Url(appBase, appBaseNoFile, basePrefix) {
    this.$$html5 = true;
    basePrefix = basePrefix || '';
    parseAbsoluteUrl(appBase, this);
    this.$$parse = function (url) {
        var pathUrl = stripBaseUrl(appBaseNoFile, url);
        if (!isString(pathUrl)) {
            throw $locationMinErr('ipthprfx', 'Invalid url "{0}", missing path prefix "{1}".', url, appBaseNoFile);
        }
        parseAppUrl(pathUrl, this);
        if (!this.$$path) {
            this.$$path = '/';
        }
        this.$$compose();
    };
    this.$$compose = function () {
        var search = toKeyValue(this.$$search), hash = this.$$hash ? '#' + encodeUriSegment(this.$$hash) : '';
        this.$$url = encodePath(this.$$path) + (search ? '?' + search : '') + hash;
        this.$$absUrl = appBaseNoFile + this.$$url.substr(1);
        this.$$urlUpdatedByLocation = true;
    };
    this.$$parseLinkUrl = function (url, relHref) {
        if (relHref && relHref[0] === '#') {
            this.hash(relHref.slice(1));
            return true;
        }
        var appUrl, prevAppUrl;
        var rewrittenUrl;
        if (isDefined(appUrl = stripBaseUrl(appBase, url))) {
            prevAppUrl = appUrl;
            if (basePrefix && isDefined(appUrl = stripBaseUrl(basePrefix, appUrl))) {
                rewrittenUrl = appBaseNoFile + (stripBaseUrl('/', appUrl) || appUrl);
            } else {
                rewrittenUrl = appBase + prevAppUrl;
            }
        } else if (isDefined(appUrl = stripBaseUrl(appBaseNoFile, url))) {
            rewrittenUrl = appBaseNoFile + appUrl;
        } else if (appBaseNoFile === url + '/') {
            rewrittenUrl = appBaseNoFile;
        }
        if (rewrittenUrl) {
            this.$$parse(rewrittenUrl);
        }
        return !!rewrittenUrl;
    };
};
LocationHashbangUrl = function LocationHashbangUrl(appBase, appBaseNoFile, hashPrefix) {
    parseAbsoluteUrl(appBase, this);
    this.$$parse = function (url) {
        var withoutBaseUrl = stripBaseUrl(appBase, url) || stripBaseUrl(appBaseNoFile, url);
        var withoutHashUrl;
        if (!isUndefined(withoutBaseUrl) && withoutBaseUrl.charAt(0) === '#') {
            withoutHashUrl = stripBaseUrl(hashPrefix, withoutBaseUrl);
            if (isUndefined(withoutHashUrl)) {
                withoutHashUrl = withoutBaseUrl;
            }
        } else {
            if (this.$$html5) {
                withoutHashUrl = withoutBaseUrl;
            } else {
                withoutHashUrl = '';
                if (isUndefined(withoutBaseUrl)) {
                    appBase = url;
                    this.replace();
                }
            }
        }
        parseAppUrl(withoutHashUrl, this);
        this.$$path = removeWindowsDriveName(this.$$path, withoutHashUrl, appBase);
        this.$$compose();
        function removeWindowsDriveName(path, url, base) {
            var windowsFilePathExp = /^\/[A-Z]:(\/.*)/;
            var firstPathSegmentMatch;
            if (startsWith(url, base)) {
                url = url.replace(base, '');
            }
            if (windowsFilePathExp.exec(url)) {
                return path;
            }
            firstPathSegmentMatch = windowsFilePathExp.exec(path);
            return firstPathSegmentMatch ? firstPathSegmentMatch[1] : path;
        }
    };
    this.$$compose = function () {
        var search = toKeyValue(this.$$search), hash = this.$$hash ? '#' + encodeUriSegment(this.$$hash) : '';
        this.$$url = encodePath(this.$$path) + (search ? '?' + search : '') + hash;
        this.$$absUrl = appBase + (this.$$url ? hashPrefix + this.$$url : '');
        this.$$urlUpdatedByLocation = true;
    };
    this.$$parseLinkUrl = function (url, relHref) {
        if (stripHash(appBase) === stripHash(url)) {
            this.$$parse(url);
            return true;
        }
        return false;
    };
};
LocationHashbangInHtml5Url = function LocationHashbangInHtml5Url(appBase, appBaseNoFile, hashPrefix) {
    this.$$html5 = true;
    LocationHashbangUrl.apply(this, arguments);
    this.$$parseLinkUrl = function (url, relHref) {
        if (relHref && relHref[0] === '#') {
            this.hash(relHref.slice(1));
            return true;
        }
        var rewrittenUrl;
        var appUrl;
        if (appBase === stripHash(url)) {
            rewrittenUrl = url;
        } else if (appUrl = stripBaseUrl(appBaseNoFile, url)) {
            rewrittenUrl = appBase + hashPrefix + appUrl;
        } else if (appBaseNoFile === url + '/') {
            rewrittenUrl = appBaseNoFile;
        }
        if (rewrittenUrl) {
            this.$$parse(rewrittenUrl);
        }
        return !!rewrittenUrl;
    };
    this.$$compose = function () {
        var search = toKeyValue(this.$$search), hash = this.$$hash ? '#' + encodeUriSegment(this.$$hash) : '';
        this.$$url = encodePath(this.$$path) + (search ? '?' + search : '') + hash;
        this.$$absUrl = appBase + hashPrefix + this.$$url;
        this.$$urlUpdatedByLocation = true;
    };
};
locationGetter = function locationGetter(property) {
    return function () {
        return this[property];
    };
};
locationGetterSetter = function locationGetterSetter(property, preprocess) {
    return function (value) {
        if (isUndefined(value)) {
            return this[property];
        }
        this[property] = preprocess(value);
        this.$$compose();
        return this;
    };
};
$LocationProvider = function $LocationProvider() {
    var hashPrefix = '!', html5Mode = {
            enabled: false,
            requireBase: true,
            rewriteLinks: true
        };
    this.hashPrefix = function (prefix) {
        if (isDefined(prefix)) {
            hashPrefix = prefix;
            return this;
        } else {
            return hashPrefix;
        }
    };
    this.html5Mode = function (mode) {
        if (isBoolean(mode)) {
            html5Mode.enabled = mode;
            return this;
        } else if (isObject(mode)) {
            if (isBoolean(mode.enabled)) {
                html5Mode.enabled = mode.enabled;
            }
            if (isBoolean(mode.requireBase)) {
                html5Mode.requireBase = mode.requireBase;
            }
            if (isBoolean(mode.rewriteLinks) || isString(mode.rewriteLinks)) {
                html5Mode.rewriteLinks = mode.rewriteLinks;
            }
            return this;
        } else {
            return html5Mode;
        }
    };
    this.$get = [
        '$rootScope',
        '$browser',
        '$sniffer',
        '$rootElement',
        '$window',
        function ($rootScope, $browser, $sniffer, $rootElement, $window) {
            var $location, LocationMode, baseHref = $browser.baseHref(), initialUrl = $browser.url(), appBase;
            if (html5Mode.enabled) {
                if (!baseHref && html5Mode.requireBase) {
                    throw $locationMinErr('nobase', '$location in HTML5 mode requires a <base> tag to be present!');
                }
                appBase = serverBase(initialUrl) + (baseHref || '/');
                LocationMode = $sniffer.history ? LocationHtml5Url : LocationHashbangInHtml5Url;
            } else {
                appBase = stripHash(initialUrl);
                LocationMode = LocationHashbangUrl;
            }
            var appBaseNoFile = stripFile(appBase);
            $location = new LocationMode(appBase, appBaseNoFile, '#' + hashPrefix);
            $location.$$parseLinkUrl(initialUrl, initialUrl);
            $location.$$state = $browser.state();
            var IGNORE_URI_REGEXP = /^\s*(javascript|mailto):/i;
            function setBrowserUrlWithFallback(url, replace, state) {
                var oldUrl = $location.url();
                var oldState = $location.$$state;
                try {
                    $browser.url(url, replace, state);
                    $location.$$state = $browser.state();
                } catch (e) {
                    $location.url(oldUrl);
                    $location.$$state = oldState;
                    throw e;
                }
            }
            $rootElement.on('click', function (event) {
                var rewriteLinks = html5Mode.rewriteLinks;
                if (!rewriteLinks || event.ctrlKey || event.metaKey || event.shiftKey || event.which === 2 || event.button === 2)
                    return;
                var elm = jqLite(event.target);
                while (nodeName_(elm[0]) !== 'a') {
                    if (elm[0] === $rootElement[0] || !(elm = elm.parent())[0])
                        return;
                }
                if (isString(rewriteLinks) && isUndefined(elm.attr(rewriteLinks)))
                    return;
                var absHref = elm.prop('href');
                var relHref = elm.attr('href') || elm.attr('xlink:href');
                if (isObject(absHref) && absHref.toString() === '[object SVGAnimatedString]') {
                    absHref = urlResolve(absHref.animVal).href;
                }
                if (IGNORE_URI_REGEXP.test(absHref))
                    return;
                if (absHref && !elm.attr('target') && !event.isDefaultPrevented()) {
                    if ($location.$$parseLinkUrl(absHref, relHref)) {
                        event.preventDefault();
                        if ($location.absUrl() !== $browser.url()) {
                            $rootScope.$apply();
                            $window.angular['ff-684208-preventDefault'] = true;
                        }
                    }
                }
            });
            if (trimEmptyHash($location.absUrl()) !== trimEmptyHash(initialUrl)) {
                $browser.url($location.absUrl(), true);
            }
            var initializing = true;
            $browser.onUrlChange(function (newUrl, newState) {
                if (!startsWith(newUrl, appBaseNoFile)) {
                    $window.location.href = newUrl;
                    return;
                }
                $rootScope.$evalAsync(function () {
                    var oldUrl = $location.absUrl();
                    var oldState = $location.$$state;
                    var defaultPrevented;
                    newUrl = trimEmptyHash(newUrl);
                    $location.$$parse(newUrl);
                    $location.$$state = newState;
                    defaultPrevented = $rootScope.$broadcast('$locationChangeStart', newUrl, oldUrl, newState, oldState).defaultPrevented;
                    if ($location.absUrl() !== newUrl)
                        return;
                    if (defaultPrevented) {
                        $location.$$parse(oldUrl);
                        $location.$$state = oldState;
                        setBrowserUrlWithFallback(oldUrl, false, oldState);
                    } else {
                        initializing = false;
                        afterLocationChange(oldUrl, oldState);
                    }
                });
                if (!$rootScope.$$phase)
                    $rootScope.$digest();
            });
            $rootScope.$watch(function $locationWatch() {
                if (initializing || $location.$$urlUpdatedByLocation) {
                    $location.$$urlUpdatedByLocation = false;
                    var oldUrl = trimEmptyHash($browser.url());
                    var newUrl = trimEmptyHash($location.absUrl());
                    var oldState = $browser.state();
                    var currentReplace = $location.$$replace;
                    var urlOrStateChanged = oldUrl !== newUrl || $location.$$html5 && $sniffer.history && oldState !== $location.$$state;
                    if (initializing || urlOrStateChanged) {
                        initializing = false;
                        $rootScope.$evalAsync(function () {
                            var newUrl = $location.absUrl();
                            var defaultPrevented = $rootScope.$broadcast('$locationChangeStart', newUrl, oldUrl, $location.$$state, oldState).defaultPrevented;
                            if ($location.absUrl() !== newUrl)
                                return;
                            if (defaultPrevented) {
                                $location.$$parse(oldUrl);
                                $location.$$state = oldState;
                            } else {
                                if (urlOrStateChanged) {
                                    setBrowserUrlWithFallback(newUrl, currentReplace, oldState === $location.$$state ? null : $location.$$state);
                                }
                                afterLocationChange(oldUrl, oldState);
                            }
                        });
                    }
                }
                $location.$$replace = false;
            });
            return $location;
            function afterLocationChange(oldUrl, oldState) {
                $rootScope.$broadcast('$locationChangeSuccess', $location.absUrl(), oldUrl, $location.$$state, oldState);
            }
        }
    ];
};
$LogProvider = function $LogProvider() {
    var debug = true, self = this;
    this.debugEnabled = function (flag) {
        if (isDefined(flag)) {
            debug = flag;
            return this;
        } else {
            return debug;
        }
    };
    this.$get = [
        '$window',
        function ($window) {
            var formatStackTrace = msie || /\bEdge\//.test($window.navigator && $window.navigator.userAgent);
            return {
                log: consoleLog('log'),
                info: consoleLog('info'),
                warn: consoleLog('warn'),
                error: consoleLog('error'),
                debug: function () {
                    var fn = consoleLog('debug');
                    return function () {
                        if (debug) {
                            fn.apply(self, arguments);
                        }
                    };
                }()
            };
            function formatError(arg) {
                if (arg instanceof Error) {
                    if (arg.stack && formatStackTrace) {
                        arg = arg.message && arg.stack.indexOf(arg.message) === -1 ? 'Error: ' + arg.message + '\n' + arg.stack : arg.stack;
                    } else if (arg.sourceURL) {
                        arg = arg.message + '\n' + arg.sourceURL + ':' + arg.line;
                    }
                }
                return arg;
            }
            function consoleLog(type) {
                var console = $window.console || {}, logFn = console[type] || console.log || noop, hasApply = false;
                try {
                    hasApply = !!logFn.apply;
                } catch (e) {
                }
                if (hasApply) {
                    return function () {
                        var args = [];
                        forEach(arguments, function (arg) {
                            args.push(formatError(arg));
                        });
                        return logFn.apply(console, args);
                    };
                }
                return function (arg1, arg2) {
                    logFn(arg1, arg2 == null ? '' : arg2);
                };
            }
        }
    ];
};
getStringValue = function getStringValue(name) {
    return name + '';
};
ifDefined = function ifDefined(v, d) {
    return typeof v !== 'undefined' ? v : d;
};
plusFn = function plusFn(l, r) {
    if (typeof l === 'undefined')
        return r;
    if (typeof r === 'undefined')
        return l;
    return l + r;
};
isStateless = function isStateless($filter, filterName) {
    var fn = $filter(filterName);
    return !fn.$stateful;
};
findConstantAndWatchExpressions = function findConstantAndWatchExpressions(ast, $filter) {
    var allConstants;
    var argsToWatch;
    var isStatelessFilter;
    switch (ast.type) {
    case AST.Program:
        allConstants = true;
        forEach(ast.body, function (expr) {
            findConstantAndWatchExpressions(expr.expression, $filter);
            allConstants = allConstants && expr.expression.constant;
        });
        ast.constant = allConstants;
        break;
    case AST.Literal:
        ast.constant = true;
        ast.toWatch = [];
        break;
    case AST.UnaryExpression:
        findConstantAndWatchExpressions(ast.argument, $filter);
        ast.constant = ast.argument.constant;
        ast.toWatch = ast.argument.toWatch;
        break;
    case AST.BinaryExpression:
        findConstantAndWatchExpressions(ast.left, $filter);
        findConstantAndWatchExpressions(ast.right, $filter);
        ast.constant = ast.left.constant && ast.right.constant;
        ast.toWatch = ast.left.toWatch.concat(ast.right.toWatch);
        break;
    case AST.LogicalExpression:
        findConstantAndWatchExpressions(ast.left, $filter);
        findConstantAndWatchExpressions(ast.right, $filter);
        ast.constant = ast.left.constant && ast.right.constant;
        ast.toWatch = ast.constant ? [] : [ast];
        break;
    case AST.ConditionalExpression:
        findConstantAndWatchExpressions(ast.test, $filter);
        findConstantAndWatchExpressions(ast.alternate, $filter);
        findConstantAndWatchExpressions(ast.consequent, $filter);
        ast.constant = ast.test.constant && ast.alternate.constant && ast.consequent.constant;
        ast.toWatch = ast.constant ? [] : [ast];
        break;
    case AST.Identifier:
        ast.constant = false;
        ast.toWatch = [ast];
        break;
    case AST.MemberExpression:
        findConstantAndWatchExpressions(ast.object, $filter);
        if (ast.computed) {
            findConstantAndWatchExpressions(ast.property, $filter);
        }
        ast.constant = ast.object.constant && (!ast.computed || ast.property.constant);
        ast.toWatch = [ast];
        break;
    case AST.CallExpression:
        isStatelessFilter = ast.filter ? isStateless($filter, ast.callee.name) : false;
        allConstants = isStatelessFilter;
        argsToWatch = [];
        forEach(ast.arguments, function (expr) {
            findConstantAndWatchExpressions(expr, $filter);
            allConstants = allConstants && expr.constant;
            if (!expr.constant) {
                argsToWatch.push.apply(argsToWatch, expr.toWatch);
            }
        });
        ast.constant = allConstants;
        ast.toWatch = isStatelessFilter ? argsToWatch : [ast];
        break;
    case AST.AssignmentExpression:
        findConstantAndWatchExpressions(ast.left, $filter);
        findConstantAndWatchExpressions(ast.right, $filter);
        ast.constant = ast.left.constant && ast.right.constant;
        ast.toWatch = [ast];
        break;
    case AST.ArrayExpression:
        allConstants = true;
        argsToWatch = [];
        forEach(ast.elements, function (expr) {
            findConstantAndWatchExpressions(expr, $filter);
            allConstants = allConstants && expr.constant;
            if (!expr.constant) {
                argsToWatch.push.apply(argsToWatch, expr.toWatch);
            }
        });
        ast.constant = allConstants;
        ast.toWatch = argsToWatch;
        break;
    case AST.ObjectExpression:
        allConstants = true;
        argsToWatch = [];
        forEach(ast.properties, function (property) {
            findConstantAndWatchExpressions(property.value, $filter);
            allConstants = allConstants && property.value.constant && !property.computed;
            if (!property.value.constant) {
                argsToWatch.push.apply(argsToWatch, property.value.toWatch);
            }
            if (property.computed) {
                findConstantAndWatchExpressions(property.key, $filter);
                if (!property.key.constant) {
                    argsToWatch.push.apply(argsToWatch, property.key.toWatch);
                }
            }
        });
        ast.constant = allConstants;
        ast.toWatch = argsToWatch;
        break;
    case AST.ThisExpression:
        ast.constant = false;
        ast.toWatch = [];
        break;
    case AST.LocalsExpression:
        ast.constant = false;
        ast.toWatch = [];
        break;
    }
};
getInputs = function getInputs(body) {
    if (body.length !== 1)
        return;
    var lastExpression = body[0].expression;
    var candidate = lastExpression.toWatch;
    if (candidate.length !== 1)
        return candidate;
    return candidate[0] !== lastExpression ? candidate : undefined;
};
isAssignable = function isAssignable(ast) {
    return ast.type === AST.Identifier || ast.type === AST.MemberExpression;
};
assignableAST = function assignableAST(ast) {
    if (ast.body.length === 1 && isAssignable(ast.body[0].expression)) {
        return {
            type: AST.AssignmentExpression,
            left: ast.body[0].expression,
            right: {
                type: AST.NGValueParameter
            },
            operator: '='
        };
    }
};
isLiteral = function isLiteral(ast) {
    return ast.body.length === 0 || ast.body.length === 1 && (ast.body[0].expression.type === AST.Literal || ast.body[0].expression.type === AST.ArrayExpression || ast.body[0].expression.type === AST.ObjectExpression);
};
isConstant = function isConstant(ast) {
    return ast.constant;
};
ASTCompiler = function ASTCompiler(astBuilder, $filter) {
    this.astBuilder = astBuilder;
    this.$filter = $filter;
};
ASTInterpreter = function ASTInterpreter(astBuilder, $filter) {
    this.astBuilder = astBuilder;
    this.$filter = $filter;
};
getValueOf = function getValueOf(value) {
    return isFunction(value.valueOf) ? value.valueOf() : objectValueOf.call(value);
};
$ParseProvider = function $ParseProvider() {
    var cache = createMap();
    var literals = {
        'true': true,
        'false': false,
        'null': null,
        'undefined': undefined
    };
    var identStart, identContinue;
    this.addLiteral = function (literalName, literalValue) {
        literals[literalName] = literalValue;
    };
    this.setIdentifierFns = function (identifierStart, identifierContinue) {
        identStart = identifierStart;
        identContinue = identifierContinue;
        return this;
    };
    this.$get = [
        '$filter',
        function ($filter) {
            var noUnsafeEval = csp().noUnsafeEval;
            var $parseOptions = {
                csp: noUnsafeEval,
                literals: copy(literals),
                isIdentifierStart: isFunction(identStart) && identStart,
                isIdentifierContinue: isFunction(identContinue) && identContinue
            };
            return $parse;
            function $parse(exp, interceptorFn) {
                var parsedExpression, oneTime, cacheKey;
                switch (typeof exp) {
                case 'string':
                    exp = exp.trim();
                    cacheKey = exp;
                    parsedExpression = cache[cacheKey];
                    if (!parsedExpression) {
                        if (exp.charAt(0) === ':' && exp.charAt(1) === ':') {
                            oneTime = true;
                            exp = exp.substring(2);
                        }
                        var lexer = new Lexer($parseOptions);
                        var parser = new Parser(lexer, $filter, $parseOptions);
                        parsedExpression = parser.parse(exp);
                        if (parsedExpression.constant) {
                            parsedExpression.$$watchDelegate = constantWatchDelegate;
                        } else if (oneTime) {
                            parsedExpression.$$watchDelegate = parsedExpression.literal ? oneTimeLiteralWatchDelegate : oneTimeWatchDelegate;
                        } else if (parsedExpression.inputs) {
                            parsedExpression.$$watchDelegate = inputsWatchDelegate;
                        }
                        cache[cacheKey] = parsedExpression;
                    }
                    return addInterceptor(parsedExpression, interceptorFn);
                case 'function':
                    return addInterceptor(exp, interceptorFn);
                default:
                    return addInterceptor(noop, interceptorFn);
                }
            }
            function expressionInputDirtyCheck(newValue, oldValueOfValue, compareObjectIdentity) {
                if (newValue == null || oldValueOfValue == null) {
                    return newValue === oldValueOfValue;
                }
                if (typeof newValue === 'object' && !compareObjectIdentity) {
                    newValue = getValueOf(newValue);
                    if (typeof newValue === 'object') {
                        return false;
                    }
                }
                return newValue === oldValueOfValue || newValue !== newValue && oldValueOfValue !== oldValueOfValue;
            }
            function inputsWatchDelegate(scope, listener, objectEquality, parsedExpression, prettyPrintExpression) {
                var inputExpressions = parsedExpression.inputs;
                var lastResult;
                if (inputExpressions.length === 1) {
                    var oldInputValueOf = expressionInputDirtyCheck;
                    inputExpressions = inputExpressions[0];
                    return scope.$watch(function expressionInputWatch(scope) {
                        var newInputValue = inputExpressions(scope);
                        if (!expressionInputDirtyCheck(newInputValue, oldInputValueOf, parsedExpression.literal)) {
                            lastResult = parsedExpression(scope, undefined, undefined, [newInputValue]);
                            oldInputValueOf = newInputValue && getValueOf(newInputValue);
                        }
                        return lastResult;
                    }, listener, objectEquality, prettyPrintExpression);
                }
                var oldInputValueOfValues = [];
                var oldInputValues = [];
                for (var i = 0, ii = inputExpressions.length; i < ii; i++) {
                    oldInputValueOfValues[i] = expressionInputDirtyCheck;
                    oldInputValues[i] = null;
                }
                return scope.$watch(function expressionInputsWatch(scope) {
                    var changed = false;
                    for (var i = 0, ii = inputExpressions.length; i < ii; i++) {
                        var newInputValue = inputExpressions[i](scope);
                        if (changed || (changed = !expressionInputDirtyCheck(newInputValue, oldInputValueOfValues[i], parsedExpression.literal))) {
                            oldInputValues[i] = newInputValue;
                            oldInputValueOfValues[i] = newInputValue && getValueOf(newInputValue);
                        }
                    }
                    if (changed) {
                        lastResult = parsedExpression(scope, undefined, undefined, oldInputValues);
                    }
                    return lastResult;
                }, listener, objectEquality, prettyPrintExpression);
            }
            function oneTimeWatchDelegate(scope, listener, objectEquality, parsedExpression, prettyPrintExpression) {
                var unwatch, lastValue;
                if (parsedExpression.inputs) {
                    unwatch = inputsWatchDelegate(scope, oneTimeListener, objectEquality, parsedExpression, prettyPrintExpression);
                } else {
                    unwatch = scope.$watch(oneTimeWatch, oneTimeListener, objectEquality);
                }
                return unwatch;
                function oneTimeWatch(scope) {
                    return parsedExpression(scope);
                }
                function oneTimeListener(value, old, scope) {
                    lastValue = value;
                    if (isFunction(listener)) {
                        listener(value, old, scope);
                    }
                    if (isDefined(value)) {
                        scope.$$postDigest(function () {
                            if (isDefined(lastValue)) {
                                unwatch();
                            }
                        });
                    }
                }
            }
            function oneTimeLiteralWatchDelegate(scope, listener, objectEquality, parsedExpression) {
                var unwatch, lastValue;
                unwatch = scope.$watch(function oneTimeWatch(scope) {
                    return parsedExpression(scope);
                }, function oneTimeListener(value, old, scope) {
                    lastValue = value;
                    if (isFunction(listener)) {
                        listener(value, old, scope);
                    }
                    if (isAllDefined(value)) {
                        scope.$$postDigest(function () {
                            if (isAllDefined(lastValue))
                                unwatch();
                        });
                    }
                }, objectEquality);
                return unwatch;
                function isAllDefined(value) {
                    var allDefined = true;
                    forEach(value, function (val) {
                        if (!isDefined(val))
                            allDefined = false;
                    });
                    return allDefined;
                }
            }
            function constantWatchDelegate(scope, listener, objectEquality, parsedExpression) {
                var unwatch = scope.$watch(function constantWatch(scope) {
                    unwatch();
                    return parsedExpression(scope);
                }, listener, objectEquality);
                return unwatch;
            }
            function addInterceptor(parsedExpression, interceptorFn) {
                if (!interceptorFn)
                    return parsedExpression;
                var watchDelegate = parsedExpression.$$watchDelegate;
                var useInputs = false;
                var regularWatch = watchDelegate !== oneTimeLiteralWatchDelegate && watchDelegate !== oneTimeWatchDelegate;
                var fn = regularWatch ? function regularInterceptedExpression(scope, locals, assign, inputs) {
                    var value = useInputs && inputs ? inputs[0] : parsedExpression(scope, locals, assign, inputs);
                    return interceptorFn(value, scope, locals);
                } : function oneTimeInterceptedExpression(scope, locals, assign, inputs) {
                    var value = parsedExpression(scope, locals, assign, inputs);
                    var result = interceptorFn(value, scope, locals);
                    return isDefined(value) ? result : value;
                };
                useInputs = !parsedExpression.inputs;
                if (parsedExpression.$$watchDelegate && parsedExpression.$$watchDelegate !== inputsWatchDelegate) {
                    fn.$$watchDelegate = parsedExpression.$$watchDelegate;
                    fn.inputs = parsedExpression.inputs;
                } else if (!interceptorFn.$stateful) {
                    fn.$$watchDelegate = inputsWatchDelegate;
                    fn.inputs = parsedExpression.inputs ? parsedExpression.inputs : [parsedExpression];
                }
                return fn;
            }
        }
    ];
};
$QProvider = function $QProvider() {
    var errorOnUnhandledRejections = true;
    this.$get = [
        '$rootScope',
        '$exceptionHandler',
        function ($rootScope, $exceptionHandler) {
            return qFactory(function (callback) {
                $rootScope.$evalAsync(callback);
            }, $exceptionHandler, errorOnUnhandledRejections);
        }
    ];
    this.errorOnUnhandledRejections = function (value) {
        if (isDefined(value)) {
            errorOnUnhandledRejections = value;
            return this;
        } else {
            return errorOnUnhandledRejections;
        }
    };
};
$$QProvider = function $$QProvider() {
    var errorOnUnhandledRejections = true;
    this.$get = [
        '$browser',
        '$exceptionHandler',
        function ($browser, $exceptionHandler) {
            return qFactory(function (callback) {
                $browser.defer(callback);
            }, $exceptionHandler, errorOnUnhandledRejections);
        }
    ];
    this.errorOnUnhandledRejections = function (value) {
        if (isDefined(value)) {
            errorOnUnhandledRejections = value;
            return this;
        } else {
            return errorOnUnhandledRejections;
        }
    };
};
qFactory = function qFactory(nextTick, exceptionHandler, errorOnUnhandledRejections) {
    var $qMinErr = minErr('$q', TypeError);
    var queueSize = 0;
    var checkQueue = [];
    function defer() {
        return new Deferred();
    }
    function Deferred() {
        var promise = this.promise = new Promise();
        this.resolve = function (val) {
            resolvePromise(promise, val);
        };
        this.reject = function (reason) {
            rejectPromise(promise, reason);
        };
        this.notify = function (progress) {
            notifyPromise(promise, progress);
        };
    }
    function Promise() {
        this.$$state = {
            status: 0
        };
    }
    extend(Promise.prototype, {
        then: function (onFulfilled, onRejected, progressBack) {
            if (isUndefined(onFulfilled) && isUndefined(onRejected) && isUndefined(progressBack)) {
                return this;
            }
            var result = new Promise();
            this.$$state.pending = this.$$state.pending || [];
            this.$$state.pending.push([
                result,
                onFulfilled,
                onRejected,
                progressBack
            ]);
            if (this.$$state.status > 0)
                scheduleProcessQueue(this.$$state);
            return result;
        },
        'catch': function (callback) {
            return this.then(null, callback);
        },
        'finally': function (callback, progressBack) {
            return this.then(function (value) {
                return handleCallback(value, resolve, callback);
            }, function (error) {
                return handleCallback(error, reject, callback);
            }, progressBack);
        }
    });
    function processQueue(state) {
        var fn, promise, pending;
        pending = state.pending;
        state.processScheduled = false;
        state.pending = undefined;
        try {
            for (var i = 0, ii = pending.length; i < ii; ++i) {
                state.pur = true;
                promise = pending[i][0];
                fn = pending[i][state.status];
                try {
                    if (isFunction(fn)) {
                        resolvePromise(promise, fn(state.value));
                    } else if (state.status === 1) {
                        resolvePromise(promise, state.value);
                    } else {
                        rejectPromise(promise, state.value);
                    }
                } catch (e) {
                    rejectPromise(promise, e);
                }
            }
        } finally {
            --queueSize;
            if (errorOnUnhandledRejections && queueSize === 0) {
                nextTick(processChecks);
            }
        }
    }
    function processChecks() {
        while (!queueSize && checkQueue.length) {
            var toCheck = checkQueue.shift();
            if (!toCheck.pur) {
                toCheck.pur = true;
                var errorMessage = 'Possibly unhandled rejection: ' + toDebugString(toCheck.value);
                if (toCheck.value instanceof Error) {
                    exceptionHandler(toCheck.value, errorMessage);
                } else {
                    exceptionHandler(errorMessage);
                }
            }
        }
    }
    function scheduleProcessQueue(state) {
        if (errorOnUnhandledRejections && !state.pending && state.status === 2 && !state.pur) {
            if (queueSize === 0 && checkQueue.length === 0) {
                nextTick(processChecks);
            }
            checkQueue.push(state);
        }
        if (state.processScheduled || !state.pending)
            return;
        state.processScheduled = true;
        ++queueSize;
        nextTick(function () {
            processQueue(state);
        });
    }
    function resolvePromise(promise, val) {
        if (promise.$$state.status)
            return;
        if (val === promise) {
            $$reject(promise, $qMinErr('qcycle', 'Expected promise to be resolved with value other than itself \'{0}\'', val));
        } else {
            $$resolve(promise, val);
        }
    }
    function $$resolve(promise, val) {
        var then;
        var done = false;
        try {
            if (isObject(val) || isFunction(val))
                then = val.then;
            if (isFunction(then)) {
                promise.$$state.status = -1;
                then.call(val, doResolve, doReject, doNotify);
            } else {
                promise.$$state.value = val;
                promise.$$state.status = 1;
                scheduleProcessQueue(promise.$$state);
            }
        } catch (e) {
            doReject(e);
        }
        function doResolve(val) {
            if (done)
                return;
            done = true;
            $$resolve(promise, val);
        }
        function doReject(val) {
            if (done)
                return;
            done = true;
            $$reject(promise, val);
        }
        function doNotify(progress) {
            notifyPromise(promise, progress);
        }
    }
    function rejectPromise(promise, reason) {
        if (promise.$$state.status)
            return;
        $$reject(promise, reason);
    }
    function $$reject(promise, reason) {
        promise.$$state.value = reason;
        promise.$$state.status = 2;
        scheduleProcessQueue(promise.$$state);
    }
    function notifyPromise(promise, progress) {
        var callbacks = promise.$$state.pending;
        if (promise.$$state.status <= 0 && callbacks && callbacks.length) {
            nextTick(function () {
                var callback, result;
                for (var i = 0, ii = callbacks.length; i < ii; i++) {
                    result = callbacks[i][0];
                    callback = callbacks[i][3];
                    try {
                        notifyPromise(result, isFunction(callback) ? callback(progress) : progress);
                    } catch (e) {
                        exceptionHandler(e);
                    }
                }
            });
        }
    }
    function reject(reason) {
        var result = new Promise();
        rejectPromise(result, reason);
        return result;
    }
    function handleCallback(value, resolver, callback) {
        var callbackOutput = null;
        try {
            if (isFunction(callback))
                callbackOutput = callback();
        } catch (e) {
            return reject(e);
        }
        if (isPromiseLike(callbackOutput)) {
            return callbackOutput.then(function () {
                return resolver(value);
            }, reject);
        } else {
            return resolver(value);
        }
    }
    function when(value, callback, errback, progressBack) {
        var result = new Promise();
        resolvePromise(result, value);
        return result.then(callback, errback, progressBack);
    }
    var resolve = when;
    function all(promises) {
        var result = new Promise(), counter = 0, results = isArray(promises) ? [] : {};
        forEach(promises, function (promise, key) {
            counter++;
            when(promise).then(function (value) {
                results[key] = value;
                if (!--counter)
                    resolvePromise(result, results);
            }, function (reason) {
                rejectPromise(result, reason);
            });
        });
        if (counter === 0) {
            resolvePromise(result, results);
        }
        return result;
    }
    function race(promises) {
        var deferred = defer();
        forEach(promises, function (promise) {
            when(promise).then(deferred.resolve, deferred.reject);
        });
        return deferred.promise;
    }
    function $Q(resolver) {
        if (!isFunction(resolver)) {
            throw $qMinErr('norslvr', 'Expected resolverFn, got \'{0}\'', resolver);
        }
        var promise = new Promise();
        function resolveFn(value) {
            resolvePromise(promise, value);
        }
        function rejectFn(reason) {
            rejectPromise(promise, reason);
        }
        resolver(resolveFn, rejectFn);
        return promise;
    }
    $Q.prototype = Promise.prototype;
    $Q.defer = defer;
    $Q.reject = reject;
    $Q.when = when;
    $Q.resolve = resolve;
    $Q.all = all;
    $Q.race = race;
    return $Q;
};
$$RAFProvider = function $$RAFProvider() {
    this.$get = [
        '$window',
        '$timeout',
        function ($window, $timeout) {
            var requestAnimationFrame = $window.requestAnimationFrame || $window.webkitRequestAnimationFrame;
            var cancelAnimationFrame = $window.cancelAnimationFrame || $window.webkitCancelAnimationFrame || $window.webkitCancelRequestAnimationFrame;
            var rafSupported = !!requestAnimationFrame;
            var raf = rafSupported ? function (fn) {
                var id = requestAnimationFrame(fn);
                return function () {
                    cancelAnimationFrame(id);
                };
            } : function (fn) {
                var timer = $timeout(fn, 16.66, false);
                return function () {
                    $timeout.cancel(timer);
                };
            };
            raf.supported = rafSupported;
            return raf;
        }
    ];
};
$RootScopeProvider = function $RootScopeProvider() {
    var TTL = 10;
    var $rootScopeMinErr = minErr('$rootScope');
    var lastDirtyWatch = null;
    var applyAsyncId = null;
    this.digestTtl = function (value) {
        if (arguments.length) {
            TTL = value;
        }
        return TTL;
    };
    function createChildScopeClass(parent) {
        function ChildScope() {
            this.$$watchers = this.$$nextSibling = this.$$childHead = this.$$childTail = null;
            this.$$listeners = {};
            this.$$listenerCount = {};
            this.$$watchersCount = 0;
            this.$id = nextUid();
            this.$$ChildScope = null;
        }
        ChildScope.prototype = parent;
        return ChildScope;
    }
    this.$get = [
        '$exceptionHandler',
        '$parse',
        '$browser',
        function ($exceptionHandler, $parse, $browser) {
            function destroyChildScope($event) {
                $event.currentScope.$$destroyed = true;
            }
            function cleanUpScope($scope) {
                if (msie === 9) {
                    if ($scope.$$childHead) {
                        cleanUpScope($scope.$$childHead);
                    }
                    if ($scope.$$nextSibling) {
                        cleanUpScope($scope.$$nextSibling);
                    }
                }
                $scope.$parent = $scope.$$nextSibling = $scope.$$prevSibling = $scope.$$childHead = $scope.$$childTail = $scope.$root = $scope.$$watchers = null;
            }
            function Scope() {
                this.$id = nextUid();
                this.$$phase = this.$parent = this.$$watchers = this.$$nextSibling = this.$$prevSibling = this.$$childHead = this.$$childTail = null;
                this.$root = this;
                this.$$destroyed = false;
                this.$$listeners = {};
                this.$$listenerCount = {};
                this.$$watchersCount = 0;
                this.$$isolateBindings = null;
            }
            Scope.prototype = {
                constructor: Scope,
                $new: function (isolate, parent) {
                    var child;
                    parent = parent || this;
                    if (isolate) {
                        child = new Scope();
                        child.$root = this.$root;
                    } else {
                        if (!this.$$ChildScope) {
                            this.$$ChildScope = createChildScopeClass(this);
                        }
                        child = new this.$$ChildScope();
                    }
                    child.$parent = parent;
                    child.$$prevSibling = parent.$$childTail;
                    if (parent.$$childHead) {
                        parent.$$childTail.$$nextSibling = child;
                        parent.$$childTail = child;
                    } else {
                        parent.$$childHead = parent.$$childTail = child;
                    }
                    if (isolate || parent !== this)
                        child.$on('$destroy', destroyChildScope);
                    return child;
                },
                $watch: function (watchExp, listener, objectEquality, prettyPrintExpression) {
                    var get = $parse(watchExp);
                    if (get.$$watchDelegate) {
                        return get.$$watchDelegate(this, listener, objectEquality, get, watchExp);
                    }
                    var scope = this, array = scope.$$watchers, watcher = {
                            fn: listener,
                            last: initWatchVal,
                            get: get,
                            exp: prettyPrintExpression || watchExp,
                            eq: !!objectEquality
                        };
                    lastDirtyWatch = null;
                    if (!isFunction(listener)) {
                        watcher.fn = noop;
                    }
                    if (!array) {
                        array = scope.$$watchers = [];
                        array.$$digestWatchIndex = -1;
                    }
                    array.unshift(watcher);
                    array.$$digestWatchIndex++;
                    incrementWatchersCount(this, 1);
                    return function deregisterWatch() {
                        var index = arrayRemove(array, watcher);
                        if (index >= 0) {
                            incrementWatchersCount(scope, -1);
                            if (index < array.$$digestWatchIndex) {
                                array.$$digestWatchIndex--;
                            }
                        }
                        lastDirtyWatch = null;
                    };
                },
                $watchGroup: function (watchExpressions, listener) {
                    var oldValues = new Array(watchExpressions.length);
                    var newValues = new Array(watchExpressions.length);
                    var deregisterFns = [];
                    var self = this;
                    var changeReactionScheduled = false;
                    var firstRun = true;
                    if (!watchExpressions.length) {
                        var shouldCall = true;
                        self.$evalAsync(function () {
                            if (shouldCall)
                                listener(newValues, newValues, self);
                        });
                        return function deregisterWatchGroup() {
                            shouldCall = false;
                        };
                    }
                    if (watchExpressions.length === 1) {
                        return this.$watch(watchExpressions[0], function watchGroupAction(value, oldValue, scope) {
                            newValues[0] = value;
                            oldValues[0] = oldValue;
                            listener(newValues, value === oldValue ? newValues : oldValues, scope);
                        });
                    }
                    forEach(watchExpressions, function (expr, i) {
                        var unwatchFn = self.$watch(expr, function watchGroupSubAction(value, oldValue) {
                            newValues[i] = value;
                            oldValues[i] = oldValue;
                            if (!changeReactionScheduled) {
                                changeReactionScheduled = true;
                                self.$evalAsync(watchGroupAction);
                            }
                        });
                        deregisterFns.push(unwatchFn);
                    });
                    function watchGroupAction() {
                        changeReactionScheduled = false;
                        if (firstRun) {
                            firstRun = false;
                            listener(newValues, newValues, self);
                        } else {
                            listener(newValues, oldValues, self);
                        }
                    }
                    return function deregisterWatchGroup() {
                        while (deregisterFns.length) {
                            deregisterFns.shift()();
                        }
                    };
                },
                $watchCollection: function (obj, listener) {
                    $watchCollectionInterceptor.$stateful = true;
                    var self = this;
                    var newValue;
                    var oldValue;
                    var veryOldValue;
                    var trackVeryOldValue = listener.length > 1;
                    var changeDetected = 0;
                    var changeDetector = $parse(obj, $watchCollectionInterceptor);
                    var internalArray = [];
                    var internalObject = {};
                    var initRun = true;
                    var oldLength = 0;
                    function $watchCollectionInterceptor(_value) {
                        newValue = _value;
                        var newLength, key, bothNaN, newItem, oldItem;
                        if (isUndefined(newValue))
                            return;
                        if (!isObject(newValue)) {
                            if (oldValue !== newValue) {
                                oldValue = newValue;
                                changeDetected++;
                            }
                        } else if (isArrayLike(newValue)) {
                            if (oldValue !== internalArray) {
                                oldValue = internalArray;
                                oldLength = oldValue.length = 0;
                                changeDetected++;
                            }
                            newLength = newValue.length;
                            if (oldLength !== newLength) {
                                changeDetected++;
                                oldValue.length = oldLength = newLength;
                            }
                            for (var i = 0; i < newLength; i++) {
                                oldItem = oldValue[i];
                                newItem = newValue[i];
                                bothNaN = oldItem !== oldItem && newItem !== newItem;
                                if (!bothNaN && oldItem !== newItem) {
                                    changeDetected++;
                                    oldValue[i] = newItem;
                                }
                            }
                        } else {
                            if (oldValue !== internalObject) {
                                oldValue = internalObject = {};
                                oldLength = 0;
                                changeDetected++;
                            }
                            newLength = 0;
                            for (key in newValue) {
                                if (hasOwnProperty.call(newValue, key)) {
                                    newLength++;
                                    newItem = newValue[key];
                                    oldItem = oldValue[key];
                                    if (key in oldValue) {
                                        bothNaN = oldItem !== oldItem && newItem !== newItem;
                                        if (!bothNaN && oldItem !== newItem) {
                                            changeDetected++;
                                            oldValue[key] = newItem;
                                        }
                                    } else {
                                        oldLength++;
                                        oldValue[key] = newItem;
                                        changeDetected++;
                                    }
                                }
                            }
                            if (oldLength > newLength) {
                                changeDetected++;
                                for (key in oldValue) {
                                    if (!hasOwnProperty.call(newValue, key)) {
                                        oldLength--;
                                        delete oldValue[key];
                                    }
                                }
                            }
                        }
                        return changeDetected;
                    }
                    function $watchCollectionAction() {
                        if (initRun) {
                            initRun = false;
                            listener(newValue, newValue, self);
                        } else {
                            listener(newValue, veryOldValue, self);
                        }
                        if (trackVeryOldValue) {
                            if (!isObject(newValue)) {
                                veryOldValue = newValue;
                            } else if (isArrayLike(newValue)) {
                                veryOldValue = new Array(newValue.length);
                                for (var i = 0; i < newValue.length; i++) {
                                    veryOldValue[i] = newValue[i];
                                }
                            } else {
                                veryOldValue = {};
                                for (var key in newValue) {
                                    if (hasOwnProperty.call(newValue, key)) {
                                        veryOldValue[key] = newValue[key];
                                    }
                                }
                            }
                        }
                    }
                    return this.$watch(changeDetector, $watchCollectionAction);
                },
                $digest: function () {
                    var watch, value, last, fn, get, watchers, dirty, ttl = TTL, next, current, target = this, watchLog = [], logIdx, asyncTask;
                    beginPhase('$digest');
                    $browser.$$checkUrlChange();
                    if (this === $rootScope && applyAsyncId !== null) {
                        $browser.defer.cancel(applyAsyncId);
                        flushApplyAsync();
                    }
                    lastDirtyWatch = null;
                    do {
                        dirty = false;
                        current = target;
                        for (var asyncQueuePosition = 0; asyncQueuePosition < asyncQueue.length; asyncQueuePosition++) {
                            try {
                                asyncTask = asyncQueue[asyncQueuePosition];
                                fn = asyncTask.fn;
                                fn(asyncTask.scope, asyncTask.locals);
                            } catch (e) {
                                $exceptionHandler(e);
                            }
                            lastDirtyWatch = null;
                        }
                        asyncQueue.length = 0;
                        traverseScopesLoop:
                            do {
                                if (watchers = current.$$watchers) {
                                    watchers.$$digestWatchIndex = watchers.length;
                                    while (watchers.$$digestWatchIndex--) {
                                        try {
                                            watch = watchers[watchers.$$digestWatchIndex];
                                            if (watch) {
                                                get = watch.get;
                                                if ((value = get(current)) !== (last = watch.last) && !(watch.eq ? equals(value, last) : isNumberNaN(value) && isNumberNaN(last))) {
                                                    dirty = true;
                                                    lastDirtyWatch = watch;
                                                    watch.last = watch.eq ? copy(value, null) : value;
                                                    fn = watch.fn;
                                                    fn(value, last === initWatchVal ? value : last, current);
                                                    if (ttl < 5) {
                                                        logIdx = 4 - ttl;
                                                        if (!watchLog[logIdx])
                                                            watchLog[logIdx] = [];
                                                        watchLog[logIdx].push({
                                                            msg: isFunction(watch.exp) ? 'fn: ' + (watch.exp.name || watch.exp.toString()) : watch.exp,
                                                            newVal: value,
                                                            oldVal: last
                                                        });
                                                    }
                                                } else if (watch === lastDirtyWatch) {
                                                    dirty = false;
                                                    break traverseScopesLoop;
                                                }
                                            }
                                        } catch (e) {
                                            $exceptionHandler(e);
                                        }
                                    }
                                }
                                if (!(next = current.$$watchersCount && current.$$childHead || current !== target && current.$$nextSibling)) {
                                    while (current !== target && !(next = current.$$nextSibling)) {
                                        current = current.$parent;
                                    }
                                }
                            } while (current = next);
                        if ((dirty || asyncQueue.length) && !ttl--) {
                            clearPhase();
                            throw $rootScopeMinErr('infdig', '{0} $digest() iterations reached. Aborting!\n' + 'Watchers fired in the last 5 iterations: {1}', TTL, watchLog);
                        }
                    } while (dirty || asyncQueue.length);
                    clearPhase();
                    while (postDigestQueuePosition < postDigestQueue.length) {
                        try {
                            postDigestQueue[postDigestQueuePosition++]();
                        } catch (e) {
                            $exceptionHandler(e);
                        }
                    }
                    postDigestQueue.length = postDigestQueuePosition = 0;
                    $browser.$$checkUrlChange();
                },
                $destroy: function () {
                    if (this.$$destroyed)
                        return;
                    var parent = this.$parent;
                    this.$broadcast('$destroy');
                    this.$$destroyed = true;
                    if (this === $rootScope) {
                        $browser.$$applicationDestroyed();
                    }
                    incrementWatchersCount(this, -this.$$watchersCount);
                    for (var eventName in this.$$listenerCount) {
                        decrementListenerCount(this, this.$$listenerCount[eventName], eventName);
                    }
                    if (parent && parent.$$childHead === this)
                        parent.$$childHead = this.$$nextSibling;
                    if (parent && parent.$$childTail === this)
                        parent.$$childTail = this.$$prevSibling;
                    if (this.$$prevSibling)
                        this.$$prevSibling.$$nextSibling = this.$$nextSibling;
                    if (this.$$nextSibling)
                        this.$$nextSibling.$$prevSibling = this.$$prevSibling;
                    this.$destroy = this.$digest = this.$apply = this.$evalAsync = this.$applyAsync = noop;
                    this.$on = this.$watch = this.$watchGroup = function () {
                        return noop;
                    };
                    this.$$listeners = {};
                    this.$$nextSibling = null;
                    cleanUpScope(this);
                },
                $eval: function (expr, locals) {
                    return $parse(expr)(this, locals);
                },
                $evalAsync: function (expr, locals) {
                    if (!$rootScope.$$phase && !asyncQueue.length) {
                        $browser.defer(function () {
                            if (asyncQueue.length) {
                                $rootScope.$digest();
                            }
                        });
                    }
                    asyncQueue.push({
                        scope: this,
                        fn: $parse(expr),
                        locals: locals
                    });
                },
                $$postDigest: function (fn) {
                    postDigestQueue.push(fn);
                },
                $apply: function (expr) {
                    try {
                        beginPhase('$apply');
                        try {
                            return this.$eval(expr);
                        } finally {
                            clearPhase();
                        }
                    } catch (e) {
                        $exceptionHandler(e);
                    } finally {
                        try {
                            $rootScope.$digest();
                        } catch (e) {
                            $exceptionHandler(e);
                            throw e;
                        }
                    }
                },
                $applyAsync: function (expr) {
                    var scope = this;
                    if (expr) {
                        applyAsyncQueue.push($applyAsyncExpression);
                    }
                    expr = $parse(expr);
                    scheduleApplyAsync();
                    function $applyAsyncExpression() {
                        scope.$eval(expr);
                    }
                },
                $on: function (name, listener) {
                    var namedListeners = this.$$listeners[name];
                    if (!namedListeners) {
                        this.$$listeners[name] = namedListeners = [];
                    }
                    namedListeners.push(listener);
                    var current = this;
                    do {
                        if (!current.$$listenerCount[name]) {
                            current.$$listenerCount[name] = 0;
                        }
                        current.$$listenerCount[name]++;
                    } while (current = current.$parent);
                    var self = this;
                    return function () {
                        var indexOfListener = namedListeners.indexOf(listener);
                        if (indexOfListener !== -1) {
                            namedListeners[indexOfListener] = null;
                            decrementListenerCount(self, 1, name);
                        }
                    };
                },
                $emit: function (name, args) {
                    var empty = [], namedListeners, scope = this, stopPropagation = false, event = {
                            name: name,
                            targetScope: scope,
                            stopPropagation: function () {
                                stopPropagation = true;
                            },
                            preventDefault: function () {
                                event.defaultPrevented = true;
                            },
                            defaultPrevented: false
                        }, listenerArgs = concat([event], arguments, 1), i, length;
                    do {
                        namedListeners = scope.$$listeners[name] || empty;
                        event.currentScope = scope;
                        for (i = 0, length = namedListeners.length; i < length; i++) {
                            if (!namedListeners[i]) {
                                namedListeners.splice(i, 1);
                                i--;
                                length--;
                                continue;
                            }
                            try {
                                namedListeners[i].apply(null, listenerArgs);
                            } catch (e) {
                                $exceptionHandler(e);
                            }
                        }
                        if (stopPropagation) {
                            event.currentScope = null;
                            return event;
                        }
                        scope = scope.$parent;
                    } while (scope);
                    event.currentScope = null;
                    return event;
                },
                $broadcast: function (name, args) {
                    var target = this, current = target, next = target, event = {
                            name: name,
                            targetScope: target,
                            preventDefault: function () {
                                event.defaultPrevented = true;
                            },
                            defaultPrevented: false
                        };
                    if (!target.$$listenerCount[name])
                        return event;
                    var listenerArgs = concat([event], arguments, 1), listeners, i, length;
                    while (current = next) {
                        event.currentScope = current;
                        listeners = current.$$listeners[name] || [];
                        for (i = 0, length = listeners.length; i < length; i++) {
                            if (!listeners[i]) {
                                listeners.splice(i, 1);
                                i--;
                                length--;
                                continue;
                            }
                            try {
                                listeners[i].apply(null, listenerArgs);
                            } catch (e) {
                                $exceptionHandler(e);
                            }
                        }
                        if (!(next = current.$$listenerCount[name] && current.$$childHead || current !== target && current.$$nextSibling)) {
                            while (current !== target && !(next = current.$$nextSibling)) {
                                current = current.$parent;
                            }
                        }
                    }
                    event.currentScope = null;
                    return event;
                }
            };
            var $rootScope = new Scope();
            var asyncQueue = $rootScope.$$asyncQueue = [];
            var postDigestQueue = $rootScope.$$postDigestQueue = [];
            var applyAsyncQueue = $rootScope.$$applyAsyncQueue = [];
            var postDigestQueuePosition = 0;
            return $rootScope;
            function beginPhase(phase) {
                if ($rootScope.$$phase) {
                    throw $rootScopeMinErr('inprog', '{0} already in progress', $rootScope.$$phase);
                }
                $rootScope.$$phase = phase;
            }
            function clearPhase() {
                $rootScope.$$phase = null;
            }
            function incrementWatchersCount(current, count) {
                do {
                    current.$$watchersCount += count;
                } while (current = current.$parent);
            }
            function decrementListenerCount(current, count, name) {
                do {
                    current.$$listenerCount[name] -= count;
                    if (current.$$listenerCount[name] === 0) {
                        delete current.$$listenerCount[name];
                    }
                } while (current = current.$parent);
            }
            function initWatchVal() {
            }
            function flushApplyAsync() {
                while (applyAsyncQueue.length) {
                    try {
                        applyAsyncQueue.shift()();
                    } catch (e) {
                        $exceptionHandler(e);
                    }
                }
                applyAsyncId = null;
            }
            function scheduleApplyAsync() {
                if (applyAsyncId === null) {
                    applyAsyncId = $browser.defer(function () {
                        $rootScope.$apply(flushApplyAsync);
                    });
                }
            }
        }
    ];
};
$$SanitizeUriProvider = function $$SanitizeUriProvider() {
    var aHrefSanitizationWhitelist = /^\s*(https?|ftp|mailto|tel|file):/, imgSrcSanitizationWhitelist = /^\s*((https?|ftp|file|blob):|data:image\/)/;
    this.aHrefSanitizationWhitelist = function (regexp) {
        if (isDefined(regexp)) {
            aHrefSanitizationWhitelist = regexp;
            return this;
        }
        return aHrefSanitizationWhitelist;
    };
    this.imgSrcSanitizationWhitelist = function (regexp) {
        if (isDefined(regexp)) {
            imgSrcSanitizationWhitelist = regexp;
            return this;
        }
        return imgSrcSanitizationWhitelist;
    };
    this.$get = function () {
        return function sanitizeUri(uri, isImage) {
            var regex = isImage ? imgSrcSanitizationWhitelist : aHrefSanitizationWhitelist;
            var normalizedVal;
            normalizedVal = urlResolve(uri).href;
            if (normalizedVal !== '' && !normalizedVal.match(regex)) {
                return 'unsafe:' + normalizedVal;
            }
            return uri;
        };
    };
};
snakeToCamel = function snakeToCamel(name) {
    return name.replace(UNDERSCORE_LOWERCASE_REGEXP, fnCamelCaseReplace);
};
adjustMatcher = function adjustMatcher(matcher) {
    if (matcher === 'self') {
        return matcher;
    } else if (isString(matcher)) {
        if (matcher.indexOf('***') > -1) {
            throw $sceMinErr('iwcard', 'Illegal sequence *** in string matcher.  String: {0}', matcher);
        }
        matcher = escapeForRegexp(matcher).replace(/\\\*\\\*/g, '.*').replace(/\\\*/g, '[^:/.?&;]*');
        return new RegExp('^' + matcher + '$');
    } else if (isRegExp(matcher)) {
        return new RegExp('^' + matcher.source + '$');
    } else {
        throw $sceMinErr('imatcher', 'Matchers may only be "self", string patterns or RegExp objects');
    }
};
adjustMatchers = function adjustMatchers(matchers) {
    var adjustedMatchers = [];
    if (isDefined(matchers)) {
        forEach(matchers, function (matcher) {
            adjustedMatchers.push(adjustMatcher(matcher));
        });
    }
    return adjustedMatchers;
};
$SceDelegateProvider = function $SceDelegateProvider() {
    this.SCE_CONTEXTS = SCE_CONTEXTS;
    var resourceUrlWhitelist = ['self'], resourceUrlBlacklist = [];
    this.resourceUrlWhitelist = function (value) {
        if (arguments.length) {
            resourceUrlWhitelist = adjustMatchers(value);
        }
        return resourceUrlWhitelist;
    };
    this.resourceUrlBlacklist = function (value) {
        if (arguments.length) {
            resourceUrlBlacklist = adjustMatchers(value);
        }
        return resourceUrlBlacklist;
    };
    this.$get = [
        '$injector',
        function ($injector) {
            var htmlSanitizer = function htmlSanitizer(html) {
                throw $sceMinErr('unsafe', 'Attempting to use an unsafe value in a safe context.');
            };
            if ($injector.has('$sanitize')) {
                htmlSanitizer = $injector.get('$sanitize');
            }
            function matchUrl(matcher, parsedUrl) {
                if (matcher === 'self') {
                    return urlIsSameOrigin(parsedUrl);
                } else {
                    return !!matcher.exec(parsedUrl.href);
                }
            }
            function isResourceUrlAllowedByPolicy(url) {
                var parsedUrl = urlResolve(url.toString());
                var i, n, allowed = false;
                for (i = 0, n = resourceUrlWhitelist.length; i < n; i++) {
                    if (matchUrl(resourceUrlWhitelist[i], parsedUrl)) {
                        allowed = true;
                        break;
                    }
                }
                if (allowed) {
                    for (i = 0, n = resourceUrlBlacklist.length; i < n; i++) {
                        if (matchUrl(resourceUrlBlacklist[i], parsedUrl)) {
                            allowed = false;
                            break;
                        }
                    }
                }
                return allowed;
            }
            function generateHolderType(Base) {
                var holderType = function TrustedValueHolderType(trustedValue) {
                    this.$$unwrapTrustedValue = function () {
                        return trustedValue;
                    };
                };
                if (Base) {
                    holderType.prototype = new Base();
                }
                holderType.prototype.valueOf = function sceValueOf() {
                    return this.$$unwrapTrustedValue();
                };
                holderType.prototype.toString = function sceToString() {
                    return this.$$unwrapTrustedValue().toString();
                };
                return holderType;
            }
            var trustedValueHolderBase = generateHolderType(), byType = {};
            byType[SCE_CONTEXTS.HTML] = generateHolderType(trustedValueHolderBase);
            byType[SCE_CONTEXTS.CSS] = generateHolderType(trustedValueHolderBase);
            byType[SCE_CONTEXTS.URL] = generateHolderType(trustedValueHolderBase);
            byType[SCE_CONTEXTS.JS] = generateHolderType(trustedValueHolderBase);
            byType[SCE_CONTEXTS.RESOURCE_URL] = generateHolderType(byType[SCE_CONTEXTS.URL]);
            function trustAs(type, trustedValue) {
                var Constructor = byType.hasOwnProperty(type) ? byType[type] : null;
                if (!Constructor) {
                    throw $sceMinErr('icontext', 'Attempted to trust a value in invalid context. Context: {0}; Value: {1}', type, trustedValue);
                }
                if (trustedValue === null || isUndefined(trustedValue) || trustedValue === '') {
                    return trustedValue;
                }
                if (typeof trustedValue !== 'string') {
                    throw $sceMinErr('itype', 'Attempted to trust a non-string value in a content requiring a string: Context: {0}', type);
                }
                return new Constructor(trustedValue);
            }
            function valueOf(maybeTrusted) {
                if (maybeTrusted instanceof trustedValueHolderBase) {
                    return maybeTrusted.$$unwrapTrustedValue();
                } else {
                    return maybeTrusted;
                }
            }
            function getTrusted(type, maybeTrusted) {
                if (maybeTrusted === null || isUndefined(maybeTrusted) || maybeTrusted === '') {
                    return maybeTrusted;
                }
                var constructor = byType.hasOwnProperty(type) ? byType[type] : null;
                if (constructor && maybeTrusted instanceof constructor) {
                    return maybeTrusted.$$unwrapTrustedValue();
                }
                if (type === SCE_CONTEXTS.RESOURCE_URL) {
                    if (isResourceUrlAllowedByPolicy(maybeTrusted)) {
                        return maybeTrusted;
                    } else {
                        throw $sceMinErr('insecurl', 'Blocked loading resource from url not allowed by $sceDelegate policy.  URL: {0}', maybeTrusted.toString());
                    }
                } else if (type === SCE_CONTEXTS.HTML) {
                    return htmlSanitizer(maybeTrusted);
                }
                throw $sceMinErr('unsafe', 'Attempting to use an unsafe value in a safe context.');
            }
            return {
                trustAs: trustAs,
                getTrusted: getTrusted,
                valueOf: valueOf
            };
        }
    ];
};
$SceProvider = function $SceProvider() {
    var enabled = true;
    this.enabled = function (value) {
        if (arguments.length) {
            enabled = !!value;
        }
        return enabled;
    };
    this.$get = [
        '$parse',
        '$sceDelegate',
        function ($parse, $sceDelegate) {
            if (enabled && msie < 8) {
                throw $sceMinErr('iequirks', 'Strict Contextual Escaping does not support Internet Explorer version < 11 in quirks ' + 'mode.  You can fix this by adding the text <!doctype html> to the top of your HTML ' + 'document.  See http://docs.angularjs.org/api/ng.$sce for more information.');
            }
            var sce = shallowCopy(SCE_CONTEXTS);
            sce.isEnabled = function () {
                return enabled;
            };
            sce.trustAs = $sceDelegate.trustAs;
            sce.getTrusted = $sceDelegate.getTrusted;
            sce.valueOf = $sceDelegate.valueOf;
            if (!enabled) {
                sce.trustAs = sce.getTrusted = function (type, value) {
                    return value;
                };
                sce.valueOf = identity;
            }
            sce.parseAs = function sceParseAs(type, expr) {
                var parsed = $parse(expr);
                if (parsed.literal && parsed.constant) {
                    return parsed;
                } else {
                    return $parse(expr, function (value) {
                        return sce.getTrusted(type, value);
                    });
                }
            };
            var parse = sce.parseAs, getTrusted = sce.getTrusted, trustAs = sce.trustAs;
            forEach(SCE_CONTEXTS, function (enumValue, name) {
                var lName = lowercase(name);
                sce[snakeToCamel('parse_as_' + lName)] = function (expr) {
                    return parse(enumValue, expr);
                };
                sce[snakeToCamel('get_trusted_' + lName)] = function (value) {
                    return getTrusted(enumValue, value);
                };
                sce[snakeToCamel('trust_as_' + lName)] = function (value) {
                    return trustAs(enumValue, value);
                };
            });
            return sce;
        }
    ];
};
$SnifferProvider = function $SnifferProvider() {
    this.$get = [
        '$window',
        '$document',
        function ($window, $document) {
            var eventSupport = {}, isNw = $window.nw && $window.nw.process, isChromePackagedApp = !isNw && $window.chrome && ($window.chrome.app && $window.chrome.app.runtime || !$window.chrome.app && $window.chrome.runtime && $window.chrome.runtime.id), hasHistoryPushState = !isChromePackagedApp && $window.history && $window.history.pushState, android = toInt((/android (\d+)/.exec(lowercase(($window.navigator || {}).userAgent)) || [])[1]), boxee = /Boxee/i.test(($window.navigator || {}).userAgent), document = $document[0] || {}, bodyStyle = document.body && document.body.style, transitions = false, animations = false;
            if (bodyStyle) {
                transitions = !!('transition' in bodyStyle || 'webkitTransition' in bodyStyle);
                animations = !!('animation' in bodyStyle || 'webkitAnimation' in bodyStyle);
            }
            return {
                history: !!(hasHistoryPushState && !(android < 4) && !boxee),
                hasEvent: function (event) {
                    if (event === 'input' && msie)
                        return false;
                    if (isUndefined(eventSupport[event])) {
                        var divElm = document.createElement('div');
                        eventSupport[event] = 'on' + event in divElm;
                    }
                    return eventSupport[event];
                },
                csp: csp(),
                transitions: transitions,
                animations: animations,
                android: android
            };
        }
    ];
};
$TemplateRequestProvider = function $TemplateRequestProvider() {
    var httpOptions;
    this.httpOptions = function (val) {
        if (val) {
            httpOptions = val;
            return this;
        }
        return httpOptions;
    };
    this.$get = [
        '$exceptionHandler',
        '$templateCache',
        '$http',
        '$q',
        '$sce',
        function ($exceptionHandler, $templateCache, $http, $q, $sce) {
            function handleRequestFn(tpl, ignoreRequestError) {
                handleRequestFn.totalPendingRequests++;
                if (!isString(tpl) || isUndefined($templateCache.get(tpl))) {
                    tpl = $sce.getTrustedResourceUrl(tpl);
                }
                var transformResponse = $http.defaults && $http.defaults.transformResponse;
                if (isArray(transformResponse)) {
                    transformResponse = transformResponse.filter(function (transformer) {
                        return transformer !== defaultHttpResponseTransform;
                    });
                } else if (transformResponse === defaultHttpResponseTransform) {
                    transformResponse = null;
                }
                return $http.get(tpl, extend({
                    cache: $templateCache,
                    transformResponse: transformResponse
                }, httpOptions)).finally(function () {
                    handleRequestFn.totalPendingRequests--;
                }).then(function (response) {
                    $templateCache.put(tpl, response.data);
                    return response.data;
                }, handleError);
                function handleError(resp) {
                    if (!ignoreRequestError) {
                        resp = $templateRequestMinErr('tpload', 'Failed to load template: {0} (HTTP status: {1} {2})', tpl, resp.status, resp.statusText);
                        $exceptionHandler(resp);
                    }
                    return $q.reject(resp);
                }
            }
            handleRequestFn.totalPendingRequests = 0;
            return handleRequestFn;
        }
    ];
};
$$TestabilityProvider = function $$TestabilityProvider() {
    this.$get = [
        '$rootScope',
        '$browser',
        '$location',
        function ($rootScope, $browser, $location) {
            var testability = {};
            testability.findBindings = function (element, expression, opt_exactMatch) {
                var bindings = element.getElementsByClassName('ng-binding');
                var matches = [];
                forEach(bindings, function (binding) {
                    var dataBinding = angular.element(binding).data('$binding');
                    if (dataBinding) {
                        forEach(dataBinding, function (bindingName) {
                            if (opt_exactMatch) {
                                var matcher = new RegExp('(^|\\s)' + escapeForRegexp(expression) + '(\\s|\\||$)');
                                if (matcher.test(bindingName)) {
                                    matches.push(binding);
                                }
                            } else {
                                if (bindingName.indexOf(expression) !== -1) {
                                    matches.push(binding);
                                }
                            }
                        });
                    }
                });
                return matches;
            };
            testability.findModels = function (element, expression, opt_exactMatch) {
                var prefixes = [
                    'ng-',
                    'data-ng-',
                    'ng\\:'
                ];
                for (var p = 0; p < prefixes.length; ++p) {
                    var attributeEquals = opt_exactMatch ? '=' : '*=';
                    var selector = '[' + prefixes[p] + 'model' + attributeEquals + '"' + expression + '"]';
                    var elements = element.querySelectorAll(selector);
                    if (elements.length) {
                        return elements;
                    }
                }
            };
            testability.getLocation = function () {
                return $location.url();
            };
            testability.setLocation = function (url) {
                if (url !== $location.url()) {
                    $location.url(url);
                    $rootScope.$digest();
                }
            };
            testability.whenStable = function (callback) {
                $browser.notifyWhenNoOutstandingRequests(callback);
            };
            return testability;
        }
    ];
};
$TimeoutProvider = function $TimeoutProvider() {
    this.$get = [
        '$rootScope',
        '$browser',
        '$q',
        '$$q',
        '$exceptionHandler',
        function ($rootScope, $browser, $q, $$q, $exceptionHandler) {
            var deferreds = {};
            function timeout(fn, delay, invokeApply) {
                if (!isFunction(fn)) {
                    invokeApply = delay;
                    delay = fn;
                    fn = noop;
                }
                var args = sliceArgs(arguments, 3), skipApply = isDefined(invokeApply) && !invokeApply, deferred = (skipApply ? $$q : $q).defer(), promise = deferred.promise, timeoutId;
                timeoutId = $browser.defer(function () {
                    try {
                        deferred.resolve(fn.apply(null, args));
                    } catch (e) {
                        deferred.reject(e);
                        $exceptionHandler(e);
                    } finally {
                        delete deferreds[promise.$$timeoutId];
                    }
                    if (!skipApply)
                        $rootScope.$apply();
                }, delay);
                promise.$$timeoutId = timeoutId;
                deferreds[timeoutId] = deferred;
                return promise;
            }
            timeout.cancel = function (promise) {
                if (promise && promise.$$timeoutId in deferreds) {
                    deferreds[promise.$$timeoutId].promise.catch(noop);
                    deferreds[promise.$$timeoutId].reject('canceled');
                    delete deferreds[promise.$$timeoutId];
                    return $browser.defer.cancel(promise.$$timeoutId);
                }
                return false;
            };
            return timeout;
        }
    ];
};
urlResolve = function urlResolve(url) {
    var href = url;
    if (msie) {
        urlParsingNode.setAttribute('href', href);
        href = urlParsingNode.href;
    }
    urlParsingNode.setAttribute('href', href);
    return {
        href: urlParsingNode.href,
        protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
        host: urlParsingNode.host,
        search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
        hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
        hostname: urlParsingNode.hostname,
        port: urlParsingNode.port,
        pathname: urlParsingNode.pathname.charAt(0) === '/' ? urlParsingNode.pathname : '/' + urlParsingNode.pathname
    };
};
urlIsSameOrigin = function urlIsSameOrigin(requestUrl) {
    var parsed = isString(requestUrl) ? urlResolve(requestUrl) : requestUrl;
    return parsed.protocol === originUrl.protocol && parsed.host === originUrl.host;
};
$WindowProvider = function $WindowProvider() {
    this.$get = valueFn(window);
};
$$CookieReader = function $$CookieReader($document) {
    var rawDocument = $document[0] || {};
    var lastCookies = {};
    var lastCookieString = '';
    function safeGetCookie(rawDocument) {
        try {
            return rawDocument.cookie || '';
        } catch (e) {
            return '';
        }
    }
    function safeDecodeURIComponent(str) {
        try {
            return decodeURIComponent(str);
        } catch (e) {
            return str;
        }
    }
    return function () {
        var cookieArray, cookie, i, index, name;
        var currentCookieString = safeGetCookie(rawDocument);
        if (currentCookieString !== lastCookieString) {
            lastCookieString = currentCookieString;
            cookieArray = lastCookieString.split('; ');
            lastCookies = {};
            for (i = 0; i < cookieArray.length; i++) {
                cookie = cookieArray[i];
                index = cookie.indexOf('=');
                if (index > 0) {
                    name = safeDecodeURIComponent(cookie.substring(0, index));
                    if (isUndefined(lastCookies[name])) {
                        lastCookies[name] = safeDecodeURIComponent(cookie.substring(index + 1));
                    }
                }
            }
        }
        return lastCookies;
    };
};
$$CookieReaderProvider = function $$CookieReaderProvider() {
    this.$get = $$CookieReader;
};
$FilterProvider = function $FilterProvider($provide) {
    var suffix = 'Filter';
    function register(name, factory) {
        if (isObject(name)) {
            var filters = {};
            forEach(name, function (filter, key) {
                filters[key] = register(key, filter);
            });
            return filters;
        } else {
            return $provide.factory(name + suffix, factory);
        }
    }
    this.register = register;
    this.$get = [
        '$injector',
        function ($injector) {
            return function (name) {
                return $injector.get(name + suffix);
            };
        }
    ];
    register('currency', currencyFilter);
    register('date', dateFilter);
    register('filter', filterFilter);
    register('json', jsonFilter);
    register('limitTo', limitToFilter);
    register('lowercase', lowercaseFilter);
    register('number', numberFilter);
    register('orderBy', orderByFilter);
    register('uppercase', uppercaseFilter);
};
filterFilter = function filterFilter() {
    return function (array, expression, comparator, anyPropertyKey) {
        if (!isArrayLike(array)) {
            if (array == null) {
                return array;
            } else {
                throw minErr('filter')('notarray', 'Expected array but received: {0}', array);
            }
        }
        anyPropertyKey = anyPropertyKey || '$';
        var expressionType = getTypeForFilter(expression);
        var predicateFn;
        var matchAgainstAnyProp;
        switch (expressionType) {
        case 'function':
            predicateFn = expression;
            break;
        case 'boolean':
        case 'null':
        case 'number':
        case 'string':
            matchAgainstAnyProp = true;
        case 'object':
            predicateFn = createPredicateFn(expression, comparator, anyPropertyKey, matchAgainstAnyProp);
            break;
        default:
            return array;
        }
        return Array.prototype.filter.call(array, predicateFn);
    };
};
createPredicateFn = function createPredicateFn(expression, comparator, anyPropertyKey, matchAgainstAnyProp) {
    var shouldMatchPrimitives = isObject(expression) && anyPropertyKey in expression;
    var predicateFn;
    if (comparator === true) {
        comparator = equals;
    } else if (!isFunction(comparator)) {
        comparator = function (actual, expected) {
            if (isUndefined(actual)) {
                return false;
            }
            if (actual === null || expected === null) {
                return actual === expected;
            }
            if (isObject(expected) || isObject(actual) && !hasCustomToString(actual)) {
                return false;
            }
            actual = lowercase('' + actual);
            expected = lowercase('' + expected);
            return actual.indexOf(expected) !== -1;
        };
    }
    predicateFn = function (item) {
        if (shouldMatchPrimitives && !isObject(item)) {
            return deepCompare(item, expression[anyPropertyKey], comparator, anyPropertyKey, false);
        }
        return deepCompare(item, expression, comparator, anyPropertyKey, matchAgainstAnyProp);
    };
    return predicateFn;
};
deepCompare = function deepCompare(actual, expected, comparator, anyPropertyKey, matchAgainstAnyProp, dontMatchWholeObject) {
    var actualType = getTypeForFilter(actual);
    var expectedType = getTypeForFilter(expected);
    if (expectedType === 'string' && expected.charAt(0) === '!') {
        return !deepCompare(actual, expected.substring(1), comparator, anyPropertyKey, matchAgainstAnyProp);
    } else if (isArray(actual)) {
        return actual.some(function (item) {
            return deepCompare(item, expected, comparator, anyPropertyKey, matchAgainstAnyProp);
        });
    }
    switch (actualType) {
    case 'object':
        var key;
        if (matchAgainstAnyProp) {
            for (key in actual) {
                if (key.charAt && key.charAt(0) !== '$' && deepCompare(actual[key], expected, comparator, anyPropertyKey, true)) {
                    return true;
                }
            }
            return dontMatchWholeObject ? false : deepCompare(actual, expected, comparator, anyPropertyKey, false);
        } else if (expectedType === 'object') {
            for (key in expected) {
                var expectedVal = expected[key];
                if (isFunction(expectedVal) || isUndefined(expectedVal)) {
                    continue;
                }
                var matchAnyProperty = key === anyPropertyKey;
                var actualVal = matchAnyProperty ? actual : actual[key];
                if (!deepCompare(actualVal, expectedVal, comparator, anyPropertyKey, matchAnyProperty, matchAnyProperty)) {
                    return false;
                }
            }
            return true;
        } else {
            return comparator(actual, expected);
        }
    case 'function':
        return false;
    default:
        return comparator(actual, expected);
    }
};
getTypeForFilter = function getTypeForFilter(val) {
    return val === null ? 'null' : typeof val;
};
currencyFilter = function currencyFilter($locale) {
    var formats = $locale.NUMBER_FORMATS;
    return function (amount, currencySymbol, fractionSize) {
        if (isUndefined(currencySymbol)) {
            currencySymbol = formats.CURRENCY_SYM;
        }
        if (isUndefined(fractionSize)) {
            fractionSize = formats.PATTERNS[1].maxFrac;
        }
        return amount == null ? amount : formatNumber(amount, formats.PATTERNS[1], formats.GROUP_SEP, formats.DECIMAL_SEP, fractionSize).replace(/\u00A4/g, currencySymbol);
    };
};
numberFilter = function numberFilter($locale) {
    var formats = $locale.NUMBER_FORMATS;
    return function (number, fractionSize) {
        return number == null ? number : formatNumber(number, formats.PATTERNS[0], formats.GROUP_SEP, formats.DECIMAL_SEP, fractionSize);
    };
};
parse = function parse(numStr) {
    var exponent = 0, digits, numberOfIntegerDigits;
    var i, j, zeros;
    if ((numberOfIntegerDigits = numStr.indexOf(DECIMAL_SEP)) > -1) {
        numStr = numStr.replace(DECIMAL_SEP, '');
    }
    if ((i = numStr.search(/e/i)) > 0) {
        if (numberOfIntegerDigits < 0)
            numberOfIntegerDigits = i;
        numberOfIntegerDigits += +numStr.slice(i + 1);
        numStr = numStr.substring(0, i);
    } else if (numberOfIntegerDigits < 0) {
        numberOfIntegerDigits = numStr.length;
    }
    for (i = 0; numStr.charAt(i) === ZERO_CHAR; i++) {
    }
    if (i === (zeros = numStr.length)) {
        digits = [0];
        numberOfIntegerDigits = 1;
    } else {
        zeros--;
        while (numStr.charAt(zeros) === ZERO_CHAR)
            zeros--;
        numberOfIntegerDigits -= i;
        digits = [];
        for (j = 0; i <= zeros; i++, j++) {
            digits[j] = +numStr.charAt(i);
        }
    }
    if (numberOfIntegerDigits > MAX_DIGITS) {
        digits = digits.splice(0, MAX_DIGITS - 1);
        exponent = numberOfIntegerDigits - 1;
        numberOfIntegerDigits = 1;
    }
    return {
        d: digits,
        e: exponent,
        i: numberOfIntegerDigits
    };
};
roundNumber = function roundNumber(parsedNumber, fractionSize, minFrac, maxFrac) {
    var digits = parsedNumber.d;
    var fractionLen = digits.length - parsedNumber.i;
    fractionSize = isUndefined(fractionSize) ? Math.min(Math.max(minFrac, fractionLen), maxFrac) : +fractionSize;
    var roundAt = fractionSize + parsedNumber.i;
    var digit = digits[roundAt];
    if (roundAt > 0) {
        digits.splice(Math.max(parsedNumber.i, roundAt));
        for (var j = roundAt; j < digits.length; j++) {
            digits[j] = 0;
        }
    } else {
        fractionLen = Math.max(0, fractionLen);
        parsedNumber.i = 1;
        digits.length = Math.max(1, roundAt = fractionSize + 1);
        digits[0] = 0;
        for (var i = 1; i < roundAt; i++)
            digits[i] = 0;
    }
    if (digit >= 5) {
        if (roundAt - 1 < 0) {
            for (var k = 0; k > roundAt; k--) {
                digits.unshift(0);
                parsedNumber.i++;
            }
            digits.unshift(1);
            parsedNumber.i++;
        } else {
            digits[roundAt - 1]++;
        }
    }
    for (; fractionLen < Math.max(0, fractionSize); fractionLen++)
        digits.push(0);
    var carry = digits.reduceRight(function (carry, d, i, digits) {
        d = d + carry;
        digits[i] = d % 10;
        return Math.floor(d / 10);
    }, 0);
    if (carry) {
        digits.unshift(carry);
        parsedNumber.i++;
    }
};
formatNumber = function formatNumber(number, pattern, groupSep, decimalSep, fractionSize) {
    if (!(isString(number) || isNumber(number)) || isNaN(number))
        return '';
    var isInfinity = !isFinite(number);
    var isZero = false;
    var numStr = Math.abs(number) + '', formattedText = '', parsedNumber;
    if (isInfinity) {
        formattedText = '\u221E';
    } else {
        parsedNumber = parse(numStr);
        roundNumber(parsedNumber, fractionSize, pattern.minFrac, pattern.maxFrac);
        var digits = parsedNumber.d;
        var integerLen = parsedNumber.i;
        var exponent = parsedNumber.e;
        var decimals = [];
        isZero = digits.reduce(function (isZero, d) {
            return isZero && !d;
        }, true);
        while (integerLen < 0) {
            digits.unshift(0);
            integerLen++;
        }
        if (integerLen > 0) {
            decimals = digits.splice(integerLen, digits.length);
        } else {
            decimals = digits;
            digits = [0];
        }
        var groups = [];
        if (digits.length >= pattern.lgSize) {
            groups.unshift(digits.splice(-pattern.lgSize, digits.length).join(''));
        }
        while (digits.length > pattern.gSize) {
            groups.unshift(digits.splice(-pattern.gSize, digits.length).join(''));
        }
        if (digits.length) {
            groups.unshift(digits.join(''));
        }
        formattedText = groups.join(groupSep);
        if (decimals.length) {
            formattedText += decimalSep + decimals.join('');
        }
        if (exponent) {
            formattedText += 'e+' + exponent;
        }
    }
    if (number < 0 && !isZero) {
        return pattern.negPre + formattedText + pattern.negSuf;
    } else {
        return pattern.posPre + formattedText + pattern.posSuf;
    }
};
padNumber = function padNumber(num, digits, trim, negWrap) {
    var neg = '';
    if (num < 0 || negWrap && num <= 0) {
        if (negWrap) {
            num = -num + 1;
        } else {
            num = -num;
            neg = '-';
        }
    }
    num = '' + num;
    while (num.length < digits)
        num = ZERO_CHAR + num;
    if (trim) {
        num = num.substr(num.length - digits);
    }
    return neg + num;
};
dateGetter = function dateGetter(name, size, offset, trim, negWrap) {
    offset = offset || 0;
    return function (date) {
        var value = date['get' + name]();
        if (offset > 0 || value > -offset) {
            value += offset;
        }
        if (value === 0 && offset === -12)
            value = 12;
        return padNumber(value, size, trim, negWrap);
    };
};
dateStrGetter = function dateStrGetter(name, shortForm, standAlone) {
    return function (date, formats) {
        var value = date['get' + name]();
        var propPrefix = (standAlone ? 'STANDALONE' : '') + (shortForm ? 'SHORT' : '');
        var get = uppercase(propPrefix + name);
        return formats[get][value];
    };
};
timeZoneGetter = function timeZoneGetter(date, formats, offset) {
    var zone = -1 * offset;
    var paddedZone = zone >= 0 ? '+' : '';
    paddedZone += padNumber(Math[zone > 0 ? 'floor' : 'ceil'](zone / 60), 2) + padNumber(Math.abs(zone % 60), 2);
    return paddedZone;
};
getFirstThursdayOfYear = function getFirstThursdayOfYear(year) {
    var dayOfWeekOnFirst = new Date(year, 0, 1).getDay();
    return new Date(year, 0, (dayOfWeekOnFirst <= 4 ? 5 : 12) - dayOfWeekOnFirst);
};
getThursdayThisWeek = function getThursdayThisWeek(datetime) {
    return new Date(datetime.getFullYear(), datetime.getMonth(), datetime.getDate() + (4 - datetime.getDay()));
};
weekGetter = function weekGetter(size) {
    return function (date) {
        var firstThurs = getFirstThursdayOfYear(date.getFullYear()), thisThurs = getThursdayThisWeek(date);
        var diff = +thisThurs - +firstThurs, result = 1 + Math.round(diff / 604800000);
        return padNumber(result, size);
    };
};
ampmGetter = function ampmGetter(date, formats) {
    return date.getHours() < 12 ? formats.AMPMS[0] : formats.AMPMS[1];
};
eraGetter = function eraGetter(date, formats) {
    return date.getFullYear() <= 0 ? formats.ERAS[0] : formats.ERAS[1];
};
longEraGetter = function longEraGetter(date, formats) {
    return date.getFullYear() <= 0 ? formats.ERANAMES[0] : formats.ERANAMES[1];
};
dateFilter = function dateFilter($locale) {
    var R_ISO8601_STR = /^(\d{4})-?(\d\d)-?(\d\d)(?:T(\d\d)(?::?(\d\d)(?::?(\d\d)(?:\.(\d+))?)?)?(Z|([+-])(\d\d):?(\d\d))?)?$/;
    function jsonStringToDate(string) {
        var match;
        if (match = string.match(R_ISO8601_STR)) {
            var date = new Date(0), tzHour = 0, tzMin = 0, dateSetter = match[8] ? date.setUTCFullYear : date.setFullYear, timeSetter = match[8] ? date.setUTCHours : date.setHours;
            if (match[9]) {
                tzHour = toInt(match[9] + match[10]);
                tzMin = toInt(match[9] + match[11]);
            }
            dateSetter.call(date, toInt(match[1]), toInt(match[2]) - 1, toInt(match[3]));
            var h = toInt(match[4] || 0) - tzHour;
            var m = toInt(match[5] || 0) - tzMin;
            var s = toInt(match[6] || 0);
            var ms = Math.round(parseFloat('0.' + (match[7] || 0)) * 1000);
            timeSetter.call(date, h, m, s, ms);
            return date;
        }
        return string;
    }
    return function (date, format, timezone) {
        var text = '', parts = [], fn, match;
        format = format || 'mediumDate';
        format = $locale.DATETIME_FORMATS[format] || format;
        if (isString(date)) {
            date = NUMBER_STRING.test(date) ? toInt(date) : jsonStringToDate(date);
        }
        if (isNumber(date)) {
            date = new Date(date);
        }
        if (!isDate(date) || !isFinite(date.getTime())) {
            return date;
        }
        while (format) {
            match = DATE_FORMATS_SPLIT.exec(format);
            if (match) {
                parts = concat(parts, match, 1);
                format = parts.pop();
            } else {
                parts.push(format);
                format = null;
            }
        }
        var dateTimezoneOffset = date.getTimezoneOffset();
        if (timezone) {
            dateTimezoneOffset = timezoneToOffset(timezone, dateTimezoneOffset);
            date = convertTimezoneToLocal(date, timezone, true);
        }
        forEach(parts, function (value) {
            fn = DATE_FORMATS[value];
            text += fn ? fn(date, $locale.DATETIME_FORMATS, dateTimezoneOffset) : value === '\'\'' ? '\'' : value.replace(/(^'|'$)/g, '').replace(/''/g, '\'');
        });
        return text;
    };
};
jsonFilter = function jsonFilter() {
    return function (object, spacing) {
        if (isUndefined(spacing)) {
            spacing = 2;
        }
        return toJson(object, spacing);
    };
};
limitToFilter = function limitToFilter() {
    return function (input, limit, begin) {
        if (Math.abs(Number(limit)) === Infinity) {
            limit = Number(limit);
        } else {
            limit = toInt(limit);
        }
        if (isNumberNaN(limit))
            return input;
        if (isNumber(input))
            input = input.toString();
        if (!isArrayLike(input))
            return input;
        begin = !begin || isNaN(begin) ? 0 : toInt(begin);
        begin = begin < 0 ? Math.max(0, input.length + begin) : begin;
        if (limit >= 0) {
            return sliceFn(input, begin, begin + limit);
        } else {
            if (begin === 0) {
                return sliceFn(input, limit, input.length);
            } else {
                return sliceFn(input, Math.max(0, begin + limit), begin);
            }
        }
    };
};
sliceFn = function sliceFn(input, begin, end) {
    if (isString(input))
        return input.slice(begin, end);
    return slice.call(input, begin, end);
};
orderByFilter = function orderByFilter($parse) {
    return function (array, sortPredicate, reverseOrder, compareFn) {
        if (array == null)
            return array;
        if (!isArrayLike(array)) {
            throw minErr('orderBy')('notarray', 'Expected array but received: {0}', array);
        }
        if (!isArray(sortPredicate)) {
            sortPredicate = [sortPredicate];
        }
        if (sortPredicate.length === 0) {
            sortPredicate = ['+'];
        }
        var predicates = processPredicates(sortPredicate);
        var descending = reverseOrder ? -1 : 1;
        var compare = isFunction(compareFn) ? compareFn : defaultCompare;
        var compareValues = Array.prototype.map.call(array, getComparisonObject);
        compareValues.sort(doComparison);
        array = compareValues.map(function (item) {
            return item.value;
        });
        return array;
        function getComparisonObject(value, index) {
            return {
                value: value,
                tieBreaker: {
                    value: index,
                    type: 'number',
                    index: index
                },
                predicateValues: predicates.map(function (predicate) {
                    return getPredicateValue(predicate.get(value), index);
                })
            };
        }
        function doComparison(v1, v2) {
            for (var i = 0, ii = predicates.length; i < ii; i++) {
                var result = compare(v1.predicateValues[i], v2.predicateValues[i]);
                if (result) {
                    return result * predicates[i].descending * descending;
                }
            }
            return compare(v1.tieBreaker, v2.tieBreaker) * descending;
        }
    };
    function processPredicates(sortPredicates) {
        return sortPredicates.map(function (predicate) {
            var descending = 1, get = identity;
            if (isFunction(predicate)) {
                get = predicate;
            } else if (isString(predicate)) {
                if (predicate.charAt(0) === '+' || predicate.charAt(0) === '-') {
                    descending = predicate.charAt(0) === '-' ? -1 : 1;
                    predicate = predicate.substring(1);
                }
                if (predicate !== '') {
                    get = $parse(predicate);
                    if (get.constant) {
                        var key = get();
                        get = function (value) {
                            return value[key];
                        };
                    }
                }
            }
            return {
                get: get,
                descending: descending
            };
        });
    }
    function isPrimitive(value) {
        switch (typeof value) {
        case 'number':
        case 'boolean':
        case 'string':
            return true;
        default:
            return false;
        }
    }
    function objectValue(value) {
        if (isFunction(value.valueOf)) {
            value = value.valueOf();
            if (isPrimitive(value))
                return value;
        }
        if (hasCustomToString(value)) {
            value = value.toString();
            if (isPrimitive(value))
                return value;
        }
        return value;
    }
    function getPredicateValue(value, index) {
        var type = typeof value;
        if (value === null) {
            type = 'string';
            value = 'null';
        } else if (type === 'object') {
            value = objectValue(value);
        }
        return {
            value: value,
            type: type,
            index: index
        };
    }
    function defaultCompare(v1, v2) {
        var result = 0;
        var type1 = v1.type;
        var type2 = v2.type;
        if (type1 === type2) {
            var value1 = v1.value;
            var value2 = v2.value;
            if (type1 === 'string') {
                value1 = value1.toLowerCase();
                value2 = value2.toLowerCase();
            } else if (type1 === 'object') {
                if (isObject(value1))
                    value1 = v1.index;
                if (isObject(value2))
                    value2 = v2.index;
            }
            if (value1 !== value2) {
                result = value1 < value2 ? -1 : 1;
            }
        } else {
            result = type1 < type2 ? -1 : 1;
        }
        return result;
    }
};
ngDirective = function ngDirective(directive) {
    if (isFunction(directive)) {
        directive = {
            link: directive
        };
    }
    directive.restrict = directive.restrict || 'AC';
    return valueFn(directive);
};
nullFormRenameControl = function nullFormRenameControl(control, name) {
    control.$name = name;
};
FormController = function FormController($element, $attrs, $scope, $animate, $interpolate) {
    this.$$controls = [];
    this.$error = {};
    this.$$success = {};
    this.$pending = undefined;
    this.$name = $interpolate($attrs.name || $attrs.ngForm || '')($scope);
    this.$dirty = false;
    this.$pristine = true;
    this.$valid = true;
    this.$invalid = false;
    this.$submitted = false;
    this.$$parentForm = nullFormCtrl;
    this.$$element = $element;
    this.$$animate = $animate;
    setupValidity(this);
};
setupValidity = function setupValidity(instance) {
    instance.$$classCache = {};
    instance.$$classCache[INVALID_CLASS] = !(instance.$$classCache[VALID_CLASS] = instance.$$element.hasClass(VALID_CLASS));
};
addSetValidityMethod = function addSetValidityMethod(context) {
    var clazz = context.clazz, set = context.set, unset = context.unset;
    clazz.prototype.$setValidity = function (validationErrorKey, state, controller) {
        if (isUndefined(state)) {
            createAndSet(this, '$pending', validationErrorKey, controller);
        } else {
            unsetAndCleanup(this, '$pending', validationErrorKey, controller);
        }
        if (!isBoolean(state)) {
            unset(this.$error, validationErrorKey, controller);
            unset(this.$$success, validationErrorKey, controller);
        } else {
            if (state) {
                unset(this.$error, validationErrorKey, controller);
                set(this.$$success, validationErrorKey, controller);
            } else {
                set(this.$error, validationErrorKey, controller);
                unset(this.$$success, validationErrorKey, controller);
            }
        }
        if (this.$pending) {
            cachedToggleClass(this, PENDING_CLASS, true);
            this.$valid = this.$invalid = undefined;
            toggleValidationCss(this, '', null);
        } else {
            cachedToggleClass(this, PENDING_CLASS, false);
            this.$valid = isObjectEmpty(this.$error);
            this.$invalid = !this.$valid;
            toggleValidationCss(this, '', this.$valid);
        }
        var combinedState;
        if (this.$pending && this.$pending[validationErrorKey]) {
            combinedState = undefined;
        } else if (this.$error[validationErrorKey]) {
            combinedState = false;
        } else if (this.$$success[validationErrorKey]) {
            combinedState = true;
        } else {
            combinedState = null;
        }
        toggleValidationCss(this, validationErrorKey, combinedState);
        this.$$parentForm.$setValidity(validationErrorKey, combinedState, this);
    };
    function createAndSet(ctrl, name, value, controller) {
        if (!ctrl[name]) {
            ctrl[name] = {};
        }
        set(ctrl[name], value, controller);
    }
    function unsetAndCleanup(ctrl, name, value, controller) {
        if (ctrl[name]) {
            unset(ctrl[name], value, controller);
        }
        if (isObjectEmpty(ctrl[name])) {
            ctrl[name] = undefined;
        }
    }
    function cachedToggleClass(ctrl, className, switchValue) {
        if (switchValue && !ctrl.$$classCache[className]) {
            ctrl.$$animate.addClass(ctrl.$$element, className);
            ctrl.$$classCache[className] = true;
        } else if (!switchValue && ctrl.$$classCache[className]) {
            ctrl.$$animate.removeClass(ctrl.$$element, className);
            ctrl.$$classCache[className] = false;
        }
    }
    function toggleValidationCss(ctrl, validationErrorKey, isValid) {
        validationErrorKey = validationErrorKey ? '-' + snake_case(validationErrorKey, '-') : '';
        cachedToggleClass(ctrl, VALID_CLASS + validationErrorKey, isValid === true);
        cachedToggleClass(ctrl, INVALID_CLASS + validationErrorKey, isValid === false);
    }
};
isObjectEmpty = function isObjectEmpty(obj) {
    if (obj) {
        for (var prop in obj) {
            if (obj.hasOwnProperty(prop)) {
                return false;
            }
        }
    }
    return true;
};
stringBasedInputType = function stringBasedInputType(ctrl) {
    ctrl.$formatters.push(function (value) {
        return ctrl.$isEmpty(value) ? value : value.toString();
    });
};
textInputType = function textInputType(scope, element, attr, ctrl, $sniffer, $browser) {
    baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
    stringBasedInputType(ctrl);
};
baseInputType = function baseInputType(scope, element, attr, ctrl, $sniffer, $browser) {
    var type = lowercase(element[0].type);
    if (!$sniffer.android) {
        var composing = false;
        element.on('compositionstart', function () {
            composing = true;
        });
        element.on('compositionend', function () {
            composing = false;
            listener();
        });
    }
    var timeout;
    var listener = function (ev) {
        if (timeout) {
            $browser.defer.cancel(timeout);
            timeout = null;
        }
        if (composing)
            return;
        var value = element.val(), event = ev && ev.type;
        if (type !== 'password' && (!attr.ngTrim || attr.ngTrim !== 'false')) {
            value = trim(value);
        }
        if (ctrl.$viewValue !== value || value === '' && ctrl.$$hasNativeValidators) {
            ctrl.$setViewValue(value, event);
        }
    };
    if ($sniffer.hasEvent('input')) {
        element.on('input', listener);
    } else {
        var deferListener = function (ev, input, origValue) {
            if (!timeout) {
                timeout = $browser.defer(function () {
                    timeout = null;
                    if (!input || input.value !== origValue) {
                        listener(ev);
                    }
                });
            }
        };
        element.on('keydown', function (event) {
            var key = event.keyCode;
            if (key === 91 || 15 < key && key < 19 || 37 <= key && key <= 40)
                return;
            deferListener(event, this, this.value);
        });
        if ($sniffer.hasEvent('paste')) {
            element.on('paste cut', deferListener);
        }
    }
    element.on('change', listener);
    if (PARTIAL_VALIDATION_TYPES[type] && ctrl.$$hasNativeValidators && type === attr.type) {
        element.on(PARTIAL_VALIDATION_EVENTS, function (ev) {
            if (!timeout) {
                var validity = this[VALIDITY_STATE_PROPERTY];
                var origBadInput = validity.badInput;
                var origTypeMismatch = validity.typeMismatch;
                timeout = $browser.defer(function () {
                    timeout = null;
                    if (validity.badInput !== origBadInput || validity.typeMismatch !== origTypeMismatch) {
                        listener(ev);
                    }
                });
            }
        });
    }
    ctrl.$render = function () {
        var value = ctrl.$isEmpty(ctrl.$viewValue) ? '' : ctrl.$viewValue;
        if (element.val() !== value) {
            element.val(value);
        }
    };
};
weekParser = function weekParser(isoWeek, existingDate) {
    if (isDate(isoWeek)) {
        return isoWeek;
    }
    if (isString(isoWeek)) {
        WEEK_REGEXP.lastIndex = 0;
        var parts = WEEK_REGEXP.exec(isoWeek);
        if (parts) {
            var year = +parts[1], week = +parts[2], hours = 0, minutes = 0, seconds = 0, milliseconds = 0, firstThurs = getFirstThursdayOfYear(year), addDays = (week - 1) * 7;
            if (existingDate) {
                hours = existingDate.getHours();
                minutes = existingDate.getMinutes();
                seconds = existingDate.getSeconds();
                milliseconds = existingDate.getMilliseconds();
            }
            return new Date(year, 0, firstThurs.getDate() + addDays, hours, minutes, seconds, milliseconds);
        }
    }
    return NaN;
};
createDateParser = function createDateParser(regexp, mapping) {
    return function (iso, date) {
        var parts, map;
        if (isDate(iso)) {
            return iso;
        }
        if (isString(iso)) {
            if (iso.charAt(0) === '"' && iso.charAt(iso.length - 1) === '"') {
                iso = iso.substring(1, iso.length - 1);
            }
            if (ISO_DATE_REGEXP.test(iso)) {
                return new Date(iso);
            }
            regexp.lastIndex = 0;
            parts = regexp.exec(iso);
            if (parts) {
                parts.shift();
                if (date) {
                    map = {
                        yyyy: date.getFullYear(),
                        MM: date.getMonth() + 1,
                        dd: date.getDate(),
                        HH: date.getHours(),
                        mm: date.getMinutes(),
                        ss: date.getSeconds(),
                        sss: date.getMilliseconds() / 1000
                    };
                } else {
                    map = {
                        yyyy: 1970,
                        MM: 1,
                        dd: 1,
                        HH: 0,
                        mm: 0,
                        ss: 0,
                        sss: 0
                    };
                }
                forEach(parts, function (part, index) {
                    if (index < mapping.length) {
                        map[mapping[index]] = +part;
                    }
                });
                return new Date(map.yyyy, map.MM - 1, map.dd, map.HH, map.mm, map.ss || 0, map.sss * 1000 || 0);
            }
        }
        return NaN;
    };
};
createDateInputType = function createDateInputType(type, regexp, parseDate, format) {
    return function dynamicDateInputType(scope, element, attr, ctrl, $sniffer, $browser, $filter) {
        badInputChecker(scope, element, attr, ctrl);
        baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
        var timezone = ctrl && ctrl.$options.getOption('timezone');
        var previousDate;
        ctrl.$$parserName = type;
        ctrl.$parsers.push(function (value) {
            if (ctrl.$isEmpty(value))
                return null;
            if (regexp.test(value)) {
                var parsedDate = parseDate(value, previousDate);
                if (timezone) {
                    parsedDate = convertTimezoneToLocal(parsedDate, timezone);
                }
                return parsedDate;
            }
            return undefined;
        });
        ctrl.$formatters.push(function (value) {
            if (value && !isDate(value)) {
                throw ngModelMinErr('datefmt', 'Expected `{0}` to be a date', value);
            }
            if (isValidDate(value)) {
                previousDate = value;
                if (previousDate && timezone) {
                    previousDate = convertTimezoneToLocal(previousDate, timezone, true);
                }
                return $filter('date')(value, format, timezone);
            } else {
                previousDate = null;
                return '';
            }
        });
        if (isDefined(attr.min) || attr.ngMin) {
            var minVal;
            ctrl.$validators.min = function (value) {
                return !isValidDate(value) || isUndefined(minVal) || parseDate(value) >= minVal;
            };
            attr.$observe('min', function (val) {
                minVal = parseObservedDateValue(val);
                ctrl.$validate();
            });
        }
        if (isDefined(attr.max) || attr.ngMax) {
            var maxVal;
            ctrl.$validators.max = function (value) {
                return !isValidDate(value) || isUndefined(maxVal) || parseDate(value) <= maxVal;
            };
            attr.$observe('max', function (val) {
                maxVal = parseObservedDateValue(val);
                ctrl.$validate();
            });
        }
        function isValidDate(value) {
            return value && !(value.getTime && value.getTime() !== value.getTime());
        }
        function parseObservedDateValue(val) {
            return isDefined(val) && !isDate(val) ? parseDate(val) || undefined : val;
        }
    };
};
badInputChecker = function badInputChecker(scope, element, attr, ctrl) {
    var node = element[0];
    var nativeValidation = ctrl.$$hasNativeValidators = isObject(node.validity);
    if (nativeValidation) {
        ctrl.$parsers.push(function (value) {
            var validity = element.prop(VALIDITY_STATE_PROPERTY) || {};
            return validity.badInput || validity.typeMismatch ? undefined : value;
        });
    }
};
numberFormatterParser = function numberFormatterParser(ctrl) {
    ctrl.$$parserName = 'number';
    ctrl.$parsers.push(function (value) {
        if (ctrl.$isEmpty(value))
            return null;
        if (NUMBER_REGEXP.test(value))
            return parseFloat(value);
        return undefined;
    });
    ctrl.$formatters.push(function (value) {
        if (!ctrl.$isEmpty(value)) {
            if (!isNumber(value)) {
                throw ngModelMinErr('numfmt', 'Expected `{0}` to be a number', value);
            }
            value = value.toString();
        }
        return value;
    });
};
parseNumberAttrVal = function parseNumberAttrVal(val) {
    if (isDefined(val) && !isNumber(val)) {
        val = parseFloat(val);
    }
    return !isNumberNaN(val) ? val : undefined;
};
isNumberInteger = function isNumberInteger(num) {
    return (num | 0) === num;
};
countDecimals = function countDecimals(num) {
    var numString = num.toString();
    var decimalSymbolIndex = numString.indexOf('.');
    if (decimalSymbolIndex === -1) {
        if (-1 < num && num < 1) {
            var match = /e-(\d+)$/.exec(numString);
            if (match) {
                return Number(match[1]);
            }
        }
        return 0;
    }
    return numString.length - decimalSymbolIndex - 1;
};
isValidForStep = function isValidForStep(viewValue, stepBase, step) {
    var value = Number(viewValue);
    var isNonIntegerValue = !isNumberInteger(value);
    var isNonIntegerStepBase = !isNumberInteger(stepBase);
    var isNonIntegerStep = !isNumberInteger(step);
    if (isNonIntegerValue || isNonIntegerStepBase || isNonIntegerStep) {
        var valueDecimals = isNonIntegerValue ? countDecimals(value) : 0;
        var stepBaseDecimals = isNonIntegerStepBase ? countDecimals(stepBase) : 0;
        var stepDecimals = isNonIntegerStep ? countDecimals(step) : 0;
        var decimalCount = Math.max(valueDecimals, stepBaseDecimals, stepDecimals);
        var multiplier = Math.pow(10, decimalCount);
        value = value * multiplier;
        stepBase = stepBase * multiplier;
        step = step * multiplier;
        if (isNonIntegerValue)
            value = Math.round(value);
        if (isNonIntegerStepBase)
            stepBase = Math.round(stepBase);
        if (isNonIntegerStep)
            step = Math.round(step);
    }
    return (value - stepBase) % step === 0;
};
numberInputType = function numberInputType(scope, element, attr, ctrl, $sniffer, $browser) {
    badInputChecker(scope, element, attr, ctrl);
    numberFormatterParser(ctrl);
    baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
    var minVal;
    var maxVal;
    if (isDefined(attr.min) || attr.ngMin) {
        ctrl.$validators.min = function (value) {
            return ctrl.$isEmpty(value) || isUndefined(minVal) || value >= minVal;
        };
        attr.$observe('min', function (val) {
            minVal = parseNumberAttrVal(val);
            ctrl.$validate();
        });
    }
    if (isDefined(attr.max) || attr.ngMax) {
        ctrl.$validators.max = function (value) {
            return ctrl.$isEmpty(value) || isUndefined(maxVal) || value <= maxVal;
        };
        attr.$observe('max', function (val) {
            maxVal = parseNumberAttrVal(val);
            ctrl.$validate();
        });
    }
    if (isDefined(attr.step) || attr.ngStep) {
        var stepVal;
        ctrl.$validators.step = function (modelValue, viewValue) {
            return ctrl.$isEmpty(viewValue) || isUndefined(stepVal) || isValidForStep(viewValue, minVal || 0, stepVal);
        };
        attr.$observe('step', function (val) {
            stepVal = parseNumberAttrVal(val);
            ctrl.$validate();
        });
    }
};
rangeInputType = function rangeInputType(scope, element, attr, ctrl, $sniffer, $browser) {
    badInputChecker(scope, element, attr, ctrl);
    numberFormatterParser(ctrl);
    baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
    var supportsRange = ctrl.$$hasNativeValidators && element[0].type === 'range', minVal = supportsRange ? 0 : undefined, maxVal = supportsRange ? 100 : undefined, stepVal = supportsRange ? 1 : undefined, validity = element[0].validity, hasMinAttr = isDefined(attr.min), hasMaxAttr = isDefined(attr.max), hasStepAttr = isDefined(attr.step);
    var originalRender = ctrl.$render;
    ctrl.$render = supportsRange && isDefined(validity.rangeUnderflow) && isDefined(validity.rangeOverflow) ? function rangeRender() {
        originalRender();
        ctrl.$setViewValue(element.val());
    } : originalRender;
    if (hasMinAttr) {
        ctrl.$validators.min = supportsRange ? function noopMinValidator() {
            return true;
        } : function minValidator(modelValue, viewValue) {
            return ctrl.$isEmpty(viewValue) || isUndefined(minVal) || viewValue >= minVal;
        };
        setInitialValueAndObserver('min', minChange);
    }
    if (hasMaxAttr) {
        ctrl.$validators.max = supportsRange ? function noopMaxValidator() {
            return true;
        } : function maxValidator(modelValue, viewValue) {
            return ctrl.$isEmpty(viewValue) || isUndefined(maxVal) || viewValue <= maxVal;
        };
        setInitialValueAndObserver('max', maxChange);
    }
    if (hasStepAttr) {
        ctrl.$validators.step = supportsRange ? function nativeStepValidator() {
            return !validity.stepMismatch;
        } : function stepValidator(modelValue, viewValue) {
            return ctrl.$isEmpty(viewValue) || isUndefined(stepVal) || isValidForStep(viewValue, minVal || 0, stepVal);
        };
        setInitialValueAndObserver('step', stepChange);
    }
    function setInitialValueAndObserver(htmlAttrName, changeFn) {
        element.attr(htmlAttrName, attr[htmlAttrName]);
        attr.$observe(htmlAttrName, changeFn);
    }
    function minChange(val) {
        minVal = parseNumberAttrVal(val);
        if (isNumberNaN(ctrl.$modelValue)) {
            return;
        }
        if (supportsRange) {
            var elVal = element.val();
            if (minVal > elVal) {
                elVal = minVal;
                element.val(elVal);
            }
            ctrl.$setViewValue(elVal);
        } else {
            ctrl.$validate();
        }
    }
    function maxChange(val) {
        maxVal = parseNumberAttrVal(val);
        if (isNumberNaN(ctrl.$modelValue)) {
            return;
        }
        if (supportsRange) {
            var elVal = element.val();
            if (maxVal < elVal) {
                element.val(maxVal);
                elVal = maxVal < minVal ? minVal : maxVal;
            }
            ctrl.$setViewValue(elVal);
        } else {
            ctrl.$validate();
        }
    }
    function stepChange(val) {
        stepVal = parseNumberAttrVal(val);
        if (isNumberNaN(ctrl.$modelValue)) {
            return;
        }
        if (supportsRange && ctrl.$viewValue !== element.val()) {
            ctrl.$setViewValue(element.val());
        } else {
            ctrl.$validate();
        }
    }
};
urlInputType = function urlInputType(scope, element, attr, ctrl, $sniffer, $browser) {
    baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
    stringBasedInputType(ctrl);
    ctrl.$$parserName = 'url';
    ctrl.$validators.url = function (modelValue, viewValue) {
        var value = modelValue || viewValue;
        return ctrl.$isEmpty(value) || URL_REGEXP.test(value);
    };
};
emailInputType = function emailInputType(scope, element, attr, ctrl, $sniffer, $browser) {
    baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
    stringBasedInputType(ctrl);
    ctrl.$$parserName = 'email';
    ctrl.$validators.email = function (modelValue, viewValue) {
        var value = modelValue || viewValue;
        return ctrl.$isEmpty(value) || EMAIL_REGEXP.test(value);
    };
};
radioInputType = function radioInputType(scope, element, attr, ctrl) {
    var doTrim = !attr.ngTrim || trim(attr.ngTrim) !== 'false';
    if (isUndefined(attr.name)) {
        element.attr('name', nextUid());
    }
    var listener = function (ev) {
        var value;
        if (element[0].checked) {
            value = attr.value;
            if (doTrim) {
                value = trim(value);
            }
            ctrl.$setViewValue(value, ev && ev.type);
        }
    };
    element.on('click', listener);
    ctrl.$render = function () {
        var value = attr.value;
        if (doTrim) {
            value = trim(value);
        }
        element[0].checked = value === ctrl.$viewValue;
    };
    attr.$observe('value', ctrl.$render);
};
parseConstantExpr = function parseConstantExpr($parse, context, name, expression, fallback) {
    var parseFn;
    if (isDefined(expression)) {
        parseFn = $parse(expression);
        if (!parseFn.constant) {
            throw ngModelMinErr('constexpr', 'Expected constant expression for `{0}`, but saw ' + '`{1}`.', name, expression);
        }
        return parseFn(context);
    }
    return fallback;
};
checkboxInputType = function checkboxInputType(scope, element, attr, ctrl, $sniffer, $browser, $filter, $parse) {
    var trueValue = parseConstantExpr($parse, scope, 'ngTrueValue', attr.ngTrueValue, true);
    var falseValue = parseConstantExpr($parse, scope, 'ngFalseValue', attr.ngFalseValue, false);
    var listener = function (ev) {
        ctrl.$setViewValue(element[0].checked, ev && ev.type);
    };
    element.on('click', listener);
    ctrl.$render = function () {
        element[0].checked = ctrl.$viewValue;
    };
    ctrl.$isEmpty = function (value) {
        return value === false;
    };
    ctrl.$formatters.push(function (value) {
        return equals(value, trueValue);
    });
    ctrl.$parsers.push(function (value) {
        return value ? trueValue : falseValue;
    });
};
classDirective = function classDirective(name, selector) {
    name = 'ngClass' + name;
    var indexWatchExpression;
    return [
        '$parse',
        function ($parse) {
            return {
                restrict: 'AC',
                link: function (scope, element, attr) {
                    var expression = attr[name].trim();
                    var isOneTime = expression.charAt(0) === ':' && expression.charAt(1) === ':';
                    var watchInterceptor = isOneTime ? toFlatValue : toClassString;
                    var watchExpression = $parse(expression, watchInterceptor);
                    var watchAction = isOneTime ? ngClassOneTimeWatchAction : ngClassWatchAction;
                    var classCounts = element.data('$classCounts');
                    var oldModulo = true;
                    var oldClassString;
                    if (!classCounts) {
                        classCounts = createMap();
                        element.data('$classCounts', classCounts);
                    }
                    if (name !== 'ngClass') {
                        if (!indexWatchExpression) {
                            indexWatchExpression = $parse('$index', function moduloTwo($index) {
                                return $index & 1;
                            });
                        }
                        scope.$watch(indexWatchExpression, ngClassIndexWatchAction);
                    }
                    scope.$watch(watchExpression, watchAction, isOneTime);
                    function addClasses(classString) {
                        classString = digestClassCounts(split(classString), 1);
                        attr.$addClass(classString);
                    }
                    function removeClasses(classString) {
                        classString = digestClassCounts(split(classString), -1);
                        attr.$removeClass(classString);
                    }
                    function updateClasses(oldClassString, newClassString) {
                        var oldClassArray = split(oldClassString);
                        var newClassArray = split(newClassString);
                        var toRemoveArray = arrayDifference(oldClassArray, newClassArray);
                        var toAddArray = arrayDifference(newClassArray, oldClassArray);
                        var toRemoveString = digestClassCounts(toRemoveArray, -1);
                        var toAddString = digestClassCounts(toAddArray, 1);
                        attr.$addClass(toAddString);
                        attr.$removeClass(toRemoveString);
                    }
                    function digestClassCounts(classArray, count) {
                        var classesToUpdate = [];
                        forEach(classArray, function (className) {
                            if (count > 0 || classCounts[className]) {
                                classCounts[className] = (classCounts[className] || 0) + count;
                                if (classCounts[className] === +(count > 0)) {
                                    classesToUpdate.push(className);
                                }
                            }
                        });
                        return classesToUpdate.join(' ');
                    }
                    function ngClassIndexWatchAction(newModulo) {
                        if (newModulo === selector) {
                            addClasses(oldClassString);
                        } else {
                            removeClasses(oldClassString);
                        }
                        oldModulo = newModulo;
                    }
                    function ngClassOneTimeWatchAction(newClassValue) {
                        var newClassString = toClassString(newClassValue);
                        if (newClassString !== oldClassString) {
                            ngClassWatchAction(newClassString);
                        }
                    }
                    function ngClassWatchAction(newClassString) {
                        if (oldModulo === selector) {
                            updateClasses(oldClassString, newClassString);
                        }
                        oldClassString = newClassString;
                    }
                }
            };
        }
    ];
    function arrayDifference(tokens1, tokens2) {
        if (!tokens1 || !tokens1.length)
            return [];
        if (!tokens2 || !tokens2.length)
            return tokens1;
        var values = [];
        outer:
            for (var i = 0; i < tokens1.length; i++) {
                var token = tokens1[i];
                for (var j = 0; j < tokens2.length; j++) {
                    if (token === tokens2[j])
                        continue outer;
                }
                values.push(token);
            }
        return values;
    }
    function split(classString) {
        return classString && classString.split(' ');
    }
    function toClassString(classValue) {
        var classString = classValue;
        if (isArray(classValue)) {
            classString = classValue.map(toClassString).join(' ');
        } else if (isObject(classValue)) {
            classString = Object.keys(classValue).filter(function (key) {
                return classValue[key];
            }).join(' ');
        }
        return classString;
    }
    function toFlatValue(classValue) {
        var flatValue = classValue;
        if (isArray(classValue)) {
            flatValue = classValue.map(toFlatValue);
        } else if (isObject(classValue)) {
            var hasUndefined = false;
            flatValue = Object.keys(classValue).filter(function (key) {
                var value = classValue[key];
                if (!hasUndefined && isUndefined(value)) {
                    hasUndefined = true;
                }
                return value;
            });
            if (hasUndefined) {
                flatValue.push(undefined);
            }
        }
        return flatValue;
    }
};
NgModelController = function NgModelController($scope, $exceptionHandler, $attr, $element, $parse, $animate, $timeout, $q, $interpolate) {
    this.$viewValue = Number.NaN;
    this.$modelValue = Number.NaN;
    this.$$rawModelValue = undefined;
    this.$validators = {};
    this.$asyncValidators = {};
    this.$parsers = [];
    this.$formatters = [];
    this.$viewChangeListeners = [];
    this.$untouched = true;
    this.$touched = false;
    this.$pristine = true;
    this.$dirty = false;
    this.$valid = true;
    this.$invalid = false;
    this.$error = {};
    this.$$success = {};
    this.$pending = undefined;
    this.$name = $interpolate($attr.name || '', false)($scope);
    this.$$parentForm = nullFormCtrl;
    this.$options = defaultModelOptions;
    this.$$parsedNgModel = $parse($attr.ngModel);
    this.$$parsedNgModelAssign = this.$$parsedNgModel.assign;
    this.$$ngModelGet = this.$$parsedNgModel;
    this.$$ngModelSet = this.$$parsedNgModelAssign;
    this.$$pendingDebounce = null;
    this.$$parserValid = undefined;
    this.$$currentValidationRunId = 0;
    this.$$scope = $scope;
    this.$$attr = $attr;
    this.$$element = $element;
    this.$$animate = $animate;
    this.$$timeout = $timeout;
    this.$$parse = $parse;
    this.$$q = $q;
    this.$$exceptionHandler = $exceptionHandler;
    setupValidity(this);
    setupModelWatcher(this);
};
setupModelWatcher = function setupModelWatcher(ctrl) {
    ctrl.$$scope.$watch(function ngModelWatch() {
        var modelValue = ctrl.$$ngModelGet(ctrl.$$scope);
        if (modelValue !== ctrl.$modelValue && (ctrl.$modelValue === ctrl.$modelValue || modelValue === modelValue)) {
            ctrl.$modelValue = ctrl.$$rawModelValue = modelValue;
            ctrl.$$parserValid = undefined;
            var formatters = ctrl.$formatters, idx = formatters.length;
            var viewValue = modelValue;
            while (idx--) {
                viewValue = formatters[idx](viewValue);
            }
            if (ctrl.$viewValue !== viewValue) {
                ctrl.$$updateEmptyClasses(viewValue);
                ctrl.$viewValue = ctrl.$$lastCommittedViewValue = viewValue;
                ctrl.$render();
                ctrl.$$runValidators(ctrl.$modelValue, ctrl.$viewValue, noop);
            }
        }
        return modelValue;
    });
};
ModelOptions = function ModelOptions(options) {
    this.$$options = options;
};
defaults = function defaults(dst, src) {
    forEach(src, function (value, key) {
        if (!isDefined(dst[key])) {
            dst[key] = value;
        }
    });
};
setOptionSelectedStatus = function setOptionSelectedStatus(optionEl, value) {
    optionEl.prop('selected', value);
    optionEl.attr('selected', value);
};
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
window = arguments[0];
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    minErr = ($__.fs.minErr_4 = function minErr(module, ErrorConstructor) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
module = arguments[0], ErrorConstructor = arguments[1];
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    ErrorConstructor = (ErrorConstructor, Error);
    return ($__.fs.J$__v3645318688_5_270 = function J$__v3645318688_5() {
var vvv_return, vvv_switch, code, template, message, templateArgs, paramPrefix, i;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
code = arguments[0];
template = arguments[1];
message = '[' + (module ? module + ':' : '') + code + '] ';
templateArgs = sliceArgs(arguments, 2).map(function (arg) {
    return toDebugString(arg, minErrConfig.objectMaxDepth);
});
message += template.replace(/\{\d+\}/g, function (match) {
    var index = +match.slice(1, -1);
    if (index < templateArgs.length) {
        return templateArgs[index];
    }
    return match;
});
message += '\nhttp://errors.angularjs.org/1.6.3/' + (module ? module + '/' : '') + code;
for (i = 0, paramPrefix = '?'; i < templateArgs.length; i++, paramPrefix = '&') {
    message += paramPrefix + 'p' + i + '=' + encodeURIComponent(templateArgs[i]);
}
return new ErrorConstructor(message);});
case 1:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 1);
    ErrorConstructor = (ErrorConstructor, Error);
    return ($__.fs.J$__v3645318688_5_277 = function J$__v3645318688_5() {
var vvv_return, vvv_switch, code, template, message, templateArgs, paramPrefix, i;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
code = arguments[0];
template = arguments[1];
message = '[' + (module ? module + ':' : '') + code + '] ';
templateArgs = sliceArgs(arguments, 2).map(function (arg) {
    return toDebugString(arg, minErrConfig.objectMaxDepth);
});
message += template.replace(/\{\d+\}/g, function (match) {
    var index = +match.slice(1, -1);
    if (index < templateArgs.length) {
        return templateArgs[index];
    }
    return match;
});
message += '\nhttp://errors.angularjs.org/1.6.3/' + (module ? module + '/' : '') + code;
for (i = 0, paramPrefix = '?'; i < templateArgs.length; i++, paramPrefix = '&') {
    message += paramPrefix + 'p' + i + '=' + encodeURIComponent(templateArgs[i]);
}
return new ErrorConstructor(message);});
case 2:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 2);
    ErrorConstructor = (ErrorConstructor, Error);
    return ($__.fs.J$__v3645318688_5_353 = function J$__v3645318688_5() {
var vvv_return, vvv_switch, code, template, message, templateArgs, paramPrefix, i;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
code = arguments[0];
template = arguments[1];
message = '[' + (module ? module + ':' : '') + code + '] ';
templateArgs = sliceArgs(arguments, 2).map(function (arg) {
    return toDebugString(arg, minErrConfig.objectMaxDepth);
});
message += template.replace(/\{\d+\}/g, function (match) {
    var index = +match.slice(1, -1);
    if (index < templateArgs.length) {
        return templateArgs[index];
    }
    return match;
});
message += '\nhttp://errors.angularjs.org/1.6.3/' + (module ? module + '/' : '') + code;
for (i = 0, paramPrefix = '?'; i < templateArgs.length; i++, paramPrefix = '&') {
    message += paramPrefix + 'p' + i + '=' + encodeURIComponent(templateArgs[i]);
}
return new ErrorConstructor(message);});
case 3:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 3);
    ErrorConstructor = (ErrorConstructor, Error);
    return ($__.fs.J$__v3645318688_5_354 = function J$__v3645318688_5() {
var vvv_return, vvv_switch, code, template, message, templateArgs, paramPrefix, i;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
code = arguments[0];
template = arguments[1];
message = '[' + (module ? module + ':' : '') + code + '] ';
templateArgs = sliceArgs(arguments, 2).map(function (arg) {
    return toDebugString(arg, minErrConfig.objectMaxDepth);
});
message += template.replace(/\{\d+\}/g, function (match) {
    var index = +match.slice(1, -1);
    if (index < templateArgs.length) {
        return templateArgs[index];
    }
    return match;
});
message += '\nhttp://errors.angularjs.org/1.6.3/' + (module ? module + '/' : '') + code;
for (i = 0, paramPrefix = '?'; i < templateArgs.length; i++, paramPrefix = '&') {
    message += paramPrefix + 'p' + i + '=' + encodeURIComponent(templateArgs[i]);
}
return new ErrorConstructor(message);});
case 4:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 4);
    ErrorConstructor = (ErrorConstructor, Error);
    return ($__.fs.J$__v3645318688_5_361 = function J$__v3645318688_5() {
var vvv_return, vvv_switch, code, template, message, templateArgs, paramPrefix, i;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
code = arguments[0];
template = arguments[1];
message = '[' + (module ? module + ':' : '') + code + '] ';
templateArgs = sliceArgs(arguments, 2).map(function (arg) {
    return toDebugString(arg, minErrConfig.objectMaxDepth);
});
message += template.replace(/\{\d+\}/g, function (match) {
    var index = +match.slice(1, -1);
    if (index < templateArgs.length) {
        return templateArgs[index];
    }
    return match;
});
message += '\nhttp://errors.angularjs.org/1.6.3/' + (module ? module + '/' : '') + code;
for (i = 0, paramPrefix = '?'; i < templateArgs.length; i++, paramPrefix = '&') {
    message += paramPrefix + 'p' + i + '=' + encodeURIComponent(templateArgs[i]);
}
return new ErrorConstructor(message);});
case 5:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 5);
    ErrorConstructor = (ErrorConstructor, Error);
    return ($__.fs.J$__v3645318688_5_363 = function J$__v3645318688_5() {
var vvv_return, vvv_switch, code, template, message, templateArgs, paramPrefix, i;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
code = arguments[0];
template = arguments[1];
message = '[' + (module ? module + ':' : '') + code + '] ';
templateArgs = sliceArgs(arguments, 2).map(function (arg) {
    return toDebugString(arg, minErrConfig.objectMaxDepth);
});
message += template.replace(/\{\d+\}/g, function (match) {
    var index = +match.slice(1, -1);
    if (index < templateArgs.length) {
        return templateArgs[index];
    }
    return match;
});
message += '\nhttp://errors.angularjs.org/1.6.3/' + (module ? module + '/' : '') + code;
for (i = 0, paramPrefix = '?'; i < templateArgs.length; i++, paramPrefix = '&') {
    message += paramPrefix + 'p' + i + '=' + encodeURIComponent(templateArgs[i]);
}
return new ErrorConstructor(message);});
case 6:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 6);
    ErrorConstructor = (ErrorConstructor, Error);
    return ($__.fs.J$__v3645318688_5_365 = function J$__v3645318688_5() {
var vvv_return, vvv_switch, code, template, message, templateArgs, paramPrefix, i;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
code = arguments[0];
template = arguments[1];
message = '[' + (module ? module + ':' : '') + code + '] ';
templateArgs = sliceArgs(arguments, 2).map(function (arg) {
    return toDebugString(arg, minErrConfig.objectMaxDepth);
});
message += template.replace(/\{\d+\}/g, function (match) {
    var index = +match.slice(1, -1);
    if (index < templateArgs.length) {
        return templateArgs[index];
    }
    return match;
});
message += '\nhttp://errors.angularjs.org/1.6.3/' + (module ? module + '/' : '') + code;
for (i = 0, paramPrefix = '?'; i < templateArgs.length; i++, paramPrefix = '&') {
    message += paramPrefix + 'p' + i + '=' + encodeURIComponent(templateArgs[i]);
}
return new ErrorConstructor(message);});
case 7:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 7);
    ErrorConstructor = (ErrorConstructor, Error);
    return ($__.fs.J$__v3645318688_5_366 = function J$__v3645318688_5() {
var vvv_return, vvv_switch, code, template, message, templateArgs, paramPrefix, i;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
code = arguments[0];
template = arguments[1];
message = '[' + (module ? module + ':' : '') + code + '] ';
templateArgs = sliceArgs(arguments, 2).map(function (arg) {
    return toDebugString(arg, minErrConfig.objectMaxDepth);
});
message += template.replace(/\{\d+\}/g, function (match) {
    var index = +match.slice(1, -1);
    if (index < templateArgs.length) {
        return templateArgs[index];
    }
    return match;
});
message += '\nhttp://errors.angularjs.org/1.6.3/' + (module ? module + '/' : '') + code;
for (i = 0, paramPrefix = '?'; i < templateArgs.length; i++, paramPrefix = '&') {
    message += paramPrefix + 'p' + i + '=' + encodeURIComponent(templateArgs[i]);
}
return new ErrorConstructor(message);});
case 8:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 8);
    ErrorConstructor = (ErrorConstructor, Error);
    return ($__.fs.J$__v3645318688_5_370 = function J$__v3645318688_5() {
var vvv_return, vvv_switch, code, template, message, templateArgs, paramPrefix, i;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
code = arguments[0];
template = arguments[1];
message = '[' + (module ? module + ':' : '') + code + '] ';
templateArgs = sliceArgs(arguments, 2).map(function (arg) {
    return toDebugString(arg, minErrConfig.objectMaxDepth);
});
message += template.replace(/\{\d+\}/g, function (match) {
    var index = +match.slice(1, -1);
    if (index < templateArgs.length) {
        return templateArgs[index];
    }
    return match;
});
message += '\nhttp://errors.angularjs.org/1.6.3/' + (module ? module + '/' : '') + code;
for (i = 0, paramPrefix = '?'; i < templateArgs.length; i++, paramPrefix = '&') {
    message += paramPrefix + 'p' + i + '=' + encodeURIComponent(templateArgs[i]);
}
return new ErrorConstructor(message);});
case 9:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 9);
    ErrorConstructor = (ErrorConstructor, Error);
    return ($__.fs.J$__v3645318688_5_386 = function J$__v3645318688_5() {
var vvv_return, vvv_switch, code, template, message, templateArgs, paramPrefix, i;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
code = arguments[0];
template = arguments[1];
message = '[' + (module ? module + ':' : '') + code + '] ';
templateArgs = sliceArgs(arguments, 2).map(function (arg) {
    return toDebugString(arg, minErrConfig.objectMaxDepth);
});
message += template.replace(/\{\d+\}/g, function (match) {
    var index = +match.slice(1, -1);
    if (index < templateArgs.length) {
        return templateArgs[index];
    }
    return match;
});
message += '\nhttp://errors.angularjs.org/1.6.3/' + (module ? module + '/' : '') + code;
for (i = 0, paramPrefix = '?'; i < templateArgs.length; i++, paramPrefix = '&') {
    message += paramPrefix + 'p' + i + '=' + encodeURIComponent(templateArgs[i]);
}
return new ErrorConstructor(message);});
case 10:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 10);
    ErrorConstructor = (ErrorConstructor, Error);
    return ($__.fs.J$__v3645318688_5_488 = function J$__v3645318688_5() {
var vvv_return, vvv_switch, code, template, message, templateArgs, paramPrefix, i;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
code = arguments[0];
template = arguments[1];
message = '[' + (module ? module + ':' : '') + code + '] ';
templateArgs = sliceArgs(arguments, 2).map(function (arg) {
    return toDebugString(arg, minErrConfig.objectMaxDepth);
});
message += template.replace(/\{\d+\}/g, function (match) {
    var index = +match.slice(1, -1);
    if (index < templateArgs.length) {
        return templateArgs[index];
    }
    return match;
});
message += '\nhttp://errors.angularjs.org/1.6.3/' + (module ? module + '/' : '') + code;
for (i = 0, paramPrefix = '?'; i < templateArgs.length; i++, paramPrefix = '&') {
    message += paramPrefix + 'p' + i + '=' + encodeURIComponent(templateArgs[i]);
}
return new ErrorConstructor(message);});
case 11:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 11);
    ErrorConstructor = (ErrorConstructor, Error);
    return ($__.fs.J$__v3645318688_5_489 = function J$__v3645318688_5() {
var vvv_return, vvv_switch, code, template, message, templateArgs, paramPrefix, i;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
code = arguments[0];
template = arguments[1];
message = '[' + (module ? module + ':' : '') + code + '] ';
templateArgs = sliceArgs(arguments, 2).map(function (arg) {
    return toDebugString(arg, minErrConfig.objectMaxDepth);
});
message += template.replace(/\{\d+\}/g, function (match) {
    var index = +match.slice(1, -1);
    if (index < templateArgs.length) {
        return templateArgs[index];
    }
    return match;
});
message += '\nhttp://errors.angularjs.org/1.6.3/' + (module ? module + '/' : '') + code;
for (i = 0, paramPrefix = '?'; i < templateArgs.length; i++, paramPrefix = '&') {
    message += paramPrefix + 'p' + i + '=' + encodeURIComponent(templateArgs[i]);
}
return new ErrorConstructor(message);});
case 12:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 12);
    ErrorConstructor = (ErrorConstructor, Error);
    return ($__.fs.J$__v3645318688_5_622 = function J$__v3645318688_5() {
var vvv_return, vvv_switch, code, template, message, templateArgs, paramPrefix, i;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
code = arguments[0];
template = arguments[1];
message = '[' + (module ? module + ':' : '') + code + '] ';
templateArgs = sliceArgs(arguments, 2).map(function (arg) {
    return toDebugString(arg, minErrConfig.objectMaxDepth);
});
message += template.replace(/\{\d+\}/g, function (match) {
    var index = +match.slice(1, -1);
    if (index < templateArgs.length) {
        return templateArgs[index];
    }
    return match;
});
message += '\nhttp://errors.angularjs.org/1.6.3/' + (module ? module + '/' : '') + code;
for (i = 0, paramPrefix = '?'; i < templateArgs.length; i++, paramPrefix = '&') {
    message += paramPrefix + 'p' + i + '=' + encodeURIComponent(templateArgs[i]);
}
return new ErrorConstructor(message);});
case 13:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 13);
    ErrorConstructor = (ErrorConstructor, Error);
    return ($__.fs.J$__v3645318688_5_651 = function J$__v3645318688_5() {
var vvv_return, vvv_switch, code, template, message, templateArgs, paramPrefix, i;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
code = arguments[0];
template = arguments[1];
message = '[' + (module ? module + ':' : '') + code + '] ';
templateArgs = sliceArgs(arguments, 2).map(function (arg) {
    return toDebugString(arg, minErrConfig.objectMaxDepth);
});
message += template.replace(/\{\d+\}/g, function (match) {
    var index = +match.slice(1, -1);
    if (index < templateArgs.length) {
        return templateArgs[index];
    }
    return match;
});
message += '\nhttp://errors.angularjs.org/1.6.3/' + (module ? module + '/' : '') + code;
for (i = 0, paramPrefix = '?'; i < templateArgs.length; i++, paramPrefix = '&') {
    message += paramPrefix + 'p' + i + '=' + encodeURIComponent(templateArgs[i]);
}
return new ErrorConstructor(message);});
case 14:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 14);
    ErrorConstructor = (ErrorConstructor, Error);
    return ($__.fs.J$__v3645318688_5_664 = function J$__v3645318688_5() {
var vvv_return, vvv_switch, code, template, message, templateArgs, paramPrefix, i;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
code = arguments[0];
template = arguments[1];
message = '[' + (module ? module + ':' : '') + code + '] ';
templateArgs = sliceArgs(arguments, 2).map(function (arg) {
    return toDebugString(arg, minErrConfig.objectMaxDepth);
});
message += template.replace(/\{\d+\}/g, function (match) {
    var index = +match.slice(1, -1);
    if (index < templateArgs.length) {
        return templateArgs[index];
    }
    return match;
});
message += '\nhttp://errors.angularjs.org/1.6.3/' + (module ? module + '/' : '') + code;
for (i = 0, paramPrefix = '?'; i < templateArgs.length; i++, paramPrefix = '&') {
    message += paramPrefix + 'p' + i + '=' + encodeURIComponent(templateArgs[i]);
}
return new ErrorConstructor(message);});
case 15:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 15);
    ErrorConstructor = (ErrorConstructor, Error);
    return ($__.fs.J$__v3645318688_5_675 = function J$__v3645318688_5() {
var vvv_return, vvv_switch, code, template, message, templateArgs, paramPrefix, i;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
code = arguments[0];
template = arguments[1];
message = '[' + (module ? module + ':' : '') + code + '] ';
templateArgs = sliceArgs(arguments, 2).map(function (arg) {
    return toDebugString(arg, minErrConfig.objectMaxDepth);
});
message += template.replace(/\{\d+\}/g, function (match) {
    var index = +match.slice(1, -1);
    if (index < templateArgs.length) {
        return templateArgs[index];
    }
    return match;
});
message += '\nhttp://errors.angularjs.org/1.6.3/' + (module ? module + '/' : '') + code;
for (i = 0, paramPrefix = '?'; i < templateArgs.length; i++, paramPrefix = '&') {
    message += paramPrefix + 'p' + i + '=' + encodeURIComponent(templateArgs[i]);
}
return new ErrorConstructor(message);});
case 16:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 16);
    ErrorConstructor = (ErrorConstructor, Error);
    return ($__.fs.J$__v3645318688_5_676 = function J$__v3645318688_5() {
var vvv_return, vvv_switch, code, template, message, templateArgs, paramPrefix, i;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
code = arguments[0];
template = arguments[1];
message = '[' + (module ? module + ':' : '') + code + '] ';
templateArgs = sliceArgs(arguments, 2).map(function (arg) {
    return toDebugString(arg, minErrConfig.objectMaxDepth);
});
message += template.replace(/\{\d+\}/g, function (match) {
    var index = +match.slice(1, -1);
    if (index < templateArgs.length) {
        return templateArgs[index];
    }
    return match;
});
message += '\nhttp://errors.angularjs.org/1.6.3/' + (module ? module + '/' : '') + code;
for (i = 0, paramPrefix = '?'; i < templateArgs.length; i++, paramPrefix = '&') {
    message += paramPrefix + 'p' + i + '=' + encodeURIComponent(templateArgs[i]);
}
return new ErrorConstructor(message);});
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
ErrorConstructor = ErrorConstructor || Error;
return function () {
    var code = arguments[0], template = arguments[1], message = '[' + (module ? module + ':' : '') + code + '] ', templateArgs = sliceArgs(arguments, 2).map(function (arg) {
            return toDebugString(arg, minErrConfig.objectMaxDepth);
        }), paramPrefix, i;
    message += template.replace(/\{\d+\}/g, function (match) {
        var index = +match.slice(1, -1);
        if (index < templateArgs.length) {
            return templateArgs[index];
        }
        return match;
    });
    message += '\nhttp://errors.angularjs.org/1.6.3/' + (module ? module + '/' : '') + code;
    for (i = 0, paramPrefix = '?'; i < templateArgs.length; i++, paramPrefix = '&') {
        message += paramPrefix + 'p' + i + '=' + encodeURIComponent(templateArgs[i]);
    }
    return new ErrorConstructor(message);
};});
    errorHandlingConfig = ($__.fs.errorHandlingConfig_5 = function errorHandlingConfig(config) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
config = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (isObject(config)) {
    if (isDefined(config.objectMaxDepth)) {
        minErrConfig.objectMaxDepth = isValidObjectMaxDepth(config.objectMaxDepth) ? config.objectMaxDepth : NaN;
    }
} else {
    return minErrConfig;
}});
    isValidObjectMaxDepth = ($__.fs.isValidObjectMaxDepth_6 = function isValidObjectMaxDepth(maxDepth) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
maxDepth = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return isNumber(maxDepth) && maxDepth > 0;});
    isArrayLike = ($__.fs.isArrayLike_7 = function isArrayLike(obj) {
var vvv_return, vvv_switch, length;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
obj = arguments[0];
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    obj == null, (isWindow, $__.fs.isWindow_31)(obj, 0, true, $__.uid);
    (isArray(obj), (isString, $__.fs.isString_26)(obj, 7, true, $__.uid)), jqLite;
    length = 'length' in Object(obj);
    return (isNumber, $__.fs.isNumber_27)(length, 0, true, $__.uid);
case 1:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 1);
    obj == null, (isWindow, $__.fs.isWindow_31)(obj, 1, true, $__.uid);
    (isArray(obj), (isString, $__.fs.isString_26)(obj, 8, true, $__.uid)), jqLite;
    length = 'length' in Object(obj);
    return (isNumber, $__.fs.isNumber_27)(length, 1, true, $__.uid);
case 2:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 2);
    obj == null, (isWindow, $__.fs.isWindow_31)(obj, 2, true, $__.uid);
    (isArray(obj), (isString, $__.fs.isString_26)(obj, 9, true, $__.uid)), jqLite;
    length = 'length' in Object(obj);
    return (isNumber, $__.fs.isNumber_27)(length, 2, true, $__.uid);
case 3:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 3);
    obj == null, (isWindow, $__.fs.isWindow_31)(obj, 3, true, $__.uid);
    (isArray(obj), (isString, $__.fs.isString_26)(obj, 10, true, $__.uid)), jqLite;
    length = 'length' in Object(obj);
    return (isNumber, $__.fs.isNumber_27)(length, 3, true, $__.uid);
case 4:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 4);
    obj == null, (isWindow, $__.fs.isWindow_31)(obj, 4, true, $__.uid);
    (isArray(obj), (isString, $__.fs.isString_26)(obj, 11, true, $__.uid)), jqLite;
    length = 'length' in Object(obj);
    return (isNumber, $__.fs.isNumber_27)(length, 4, true, $__.uid);
case 5:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 5);
    obj == null, (isWindow, $__.fs.isWindow_31)(obj, 5, true, $__.uid);
    (isArray(obj), (isString, $__.fs.isString_26)(obj, 18, true, $__.uid)), (jqLite, obj instanceof jqLite);
    return true;
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (obj == null || isWindow(obj))
    return false;
if (isArray(obj) || isString(obj) || jqLite && obj instanceof jqLite)
    return true;
length = 'length' in Object(obj) && obj.length;
return isNumber(length) && (length >= 0 && (length - 1 in obj || obj instanceof Array) || typeof obj.item === 'function');});
    forEach = ($__.fs.forEach_8 = function forEach(obj, iterator, context) {
var vvv_return, vvv_switch, vvv_tmp0, vvv_tmp1, vvv_tmp2, vvv_tmp3, vvv_tmp4, vvv_tmp5, vvv_tmp6, key, length, isPrimitive, vvv_tmp7, vvv_tmp8, vvv_tmp9, vvv_tmp10, vvv_tmp11, vvv_tmp12, vvv_tmp13, vvv_tmp14, vvv_tmp15, vvv_tmp16, vvv_tmp17, vvv_tmp18, vvv_tmp19, vvv_tmp20, vvv_tmp21;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
obj = arguments[0], iterator = arguments[1], context = arguments[2];
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    obj;
    (isFunction, $__.fs.isFunction_29)(obj, 0, true, $__.uid);
    isArray(obj);
    isPrimitive = typeof obj !== 'object';
    key = 0, length = (obj.length, 7);
    key < length;
    isPrimitive, key in obj;
    vvv_tmp0 = context, (iterator, $__.fs.J$__v3645318688_220_280).call(vvv_tmp0, TAJS_restrictToType(obj[key, 0], 'string'), key, obj, 0, true, $__.uid);
    (key = +key + 1) - 1;
    key < length;
    isPrimitive, key in obj;
    vvv_tmp1 = context, (iterator, $__.fs.J$__v3645318688_220_280).call(vvv_tmp1, TAJS_restrictToType(obj[key, 1], 'string'), key, obj, 1, true, $__.uid);
    (key = +key + 1) - 1;
    key < length;
    isPrimitive, key in obj;
    vvv_tmp2 = context, (iterator, $__.fs.J$__v3645318688_220_280).call(vvv_tmp2, TAJS_restrictToType(obj[key, 2], 'string'), key, obj, 2, true, $__.uid);
    (key = +key + 1) - 1;
    key < length;
    isPrimitive, key in obj;
    vvv_tmp3 = context, (iterator, $__.fs.J$__v3645318688_220_280).call(vvv_tmp3, TAJS_restrictToType(obj[key, 3], 'string'), key, obj, 3, true, $__.uid);
    (key = +key + 1) - 1;
    key < length;
    isPrimitive, key in obj;
    vvv_tmp4 = context, (iterator, $__.fs.J$__v3645318688_220_280).call(vvv_tmp4, TAJS_restrictToType(obj[key, 4], 'string'), key, obj, 4, true, $__.uid);
    (key = +key + 1) - 1;
    key < length;
    isPrimitive, key in obj;
    vvv_tmp5 = context, (iterator, $__.fs.J$__v3645318688_220_280).call(vvv_tmp5, TAJS_restrictToType(obj[key, 5], 'string'), key, obj, 5, true, $__.uid);
    (key = +key + 1) - 1;
    key < length;
    isPrimitive, key in obj;
    vvv_tmp6 = context, (iterator, $__.fs.J$__v3645318688_220_280).call(vvv_tmp6, TAJS_restrictToType(obj[key, 6], 'string'), key, obj, 6, true, $__.uid);
    (key = +key + 1) - 1;
    key < length;
    return obj;
case 1:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 1);
    obj;
    (isFunction, $__.fs.isFunction_29)(obj, 1, true, $__.uid);
    isArray(obj);
    isPrimitive = typeof obj !== 'object';
    key = 0, length = (obj.length, 7);
    key < length;
    isPrimitive, key in obj;
    vvv_tmp0 = context, (iterator, $__.fs.J$__v3645318688_222_281).call(vvv_tmp0, TAJS_restrictToType(obj[key, 0], 'string'), key, obj, 0, true, $__.uid);
    (key = +key + 1) - 1;
    key < length;
    isPrimitive, key in obj;
    vvv_tmp1 = context, (iterator, $__.fs.J$__v3645318688_222_281).call(vvv_tmp1, TAJS_restrictToType(obj[key, 1], 'string'), key, obj, 1, true, $__.uid);
    (key = +key + 1) - 1;
    key < length;
    isPrimitive, key in obj;
    vvv_tmp2 = context, (iterator, $__.fs.J$__v3645318688_222_281).call(vvv_tmp2, TAJS_restrictToType(obj[key, 2], 'string'), key, obj, 2, true, $__.uid);
    (key = +key + 1) - 1;
    key < length;
    isPrimitive, key in obj;
    vvv_tmp3 = context, (iterator, $__.fs.J$__v3645318688_222_281).call(vvv_tmp3, TAJS_restrictToType(obj[key, 3], 'string'), key, obj, 3, true, $__.uid);
    (key = +key + 1) - 1;
    key < length;
    isPrimitive, key in obj;
    vvv_tmp4 = context, (iterator, $__.fs.J$__v3645318688_222_281).call(vvv_tmp4, TAJS_restrictToType(obj[key, 4], 'string'), key, obj, 4, true, $__.uid);
    (key = +key + 1) - 1;
    key < length;
    isPrimitive, key in obj;
    vvv_tmp5 = context, (iterator, $__.fs.J$__v3645318688_222_281).call(vvv_tmp5, TAJS_restrictToType(obj[key, 5], 'string'), key, obj, 5, true, $__.uid);
    (key = +key + 1) - 1;
    key < length;
    isPrimitive, key in obj;
    vvv_tmp6 = context, (iterator, $__.fs.J$__v3645318688_222_281).call(vvv_tmp6, TAJS_restrictToType(obj[key, 6], 'string'), key, obj, 6, true, $__.uid);
    (key = +key + 1) - 1;
    key < length;
    return obj;
case 2:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 2);
    obj;
    (isFunction, $__.fs.isFunction_29)(obj, 2, true, $__.uid);
    isArray(obj), (isArrayLike, $__.fs.isArrayLike_7)(obj, 0, true, $__.uid);
    TAJS_restrictToType((obj, $__.os.oid10).forEach, 'undefined');
    (isBlankObject, $__.fs.isBlankObject_25)(obj, 0, true, $__.uid);
    typeof TAJS_restrictToType((obj, $__.os.oid10).hasOwnProperty, 'function') === 'function';
    vvv_tmp0 = obj;
    'data' in vvv_tmp0;
    key = 'data';
    obj['hasOwnProperty'](key);
    vvv_tmp1 = context, (iterator, $__.fs.J$__v3645318688_226_282).call(vvv_tmp1, (TAJS_restrictToType((obj, $__.os.oid10)[key, 'data'], 'function'), $__.fs.jqLiteData_99), key, obj, 0, true, $__.uid);
    'removeData' in vvv_tmp0;
    key = 'removeData';
    obj['hasOwnProperty'](key);
    vvv_tmp2 = context, (iterator, $__.fs.J$__v3645318688_226_282).call(vvv_tmp2, (TAJS_restrictToType((obj, $__.os.oid10)[key, 'removeData'], 'function'), $__.fs.jqLiteRemoveData_97), key, obj, 1, true, $__.uid);
    'hasData' in vvv_tmp0;
    key = 'hasData';
    obj['hasOwnProperty'](key);
    vvv_tmp3 = context, (iterator, $__.fs.J$__v3645318688_226_282).call(vvv_tmp3, (TAJS_restrictToType((obj, $__.os.oid10)[key, 'hasData'], 'function'), $__.fs.jqLiteHasData_88), key, obj, 2, true, $__.uid);
    'cleanData' in vvv_tmp0;
    key = 'cleanData';
    obj['hasOwnProperty'](key);
    vvv_tmp4 = context, (iterator, $__.fs.J$__v3645318688_226_282).call(vvv_tmp4, (TAJS_restrictToType((obj, $__.os.oid10)[key, 'cleanData'], 'function'), $__.fs.jqLiteCleanData_89), key, obj, 3, true, $__.uid);
    return obj;
case 3:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 3);
    obj;
    (isFunction, $__.fs.isFunction_29)(obj, 3, true, $__.uid);
    isArray(obj), (isArrayLike, $__.fs.isArrayLike_7)(obj, 1, true, $__.uid);
    TAJS_restrictToType((obj, $__.os.oid11).forEach, 'undefined');
    (isBlankObject, $__.fs.isBlankObject_25)(obj, 1, true, $__.uid);
    typeof TAJS_restrictToType((obj, $__.os.oid11).hasOwnProperty, 'function') === 'function';
    vvv_tmp0 = obj;
    'data' in vvv_tmp0;
    key = 'data';
    obj['hasOwnProperty'](key);
    vvv_tmp1 = context, (iterator, $__.fs.J$__v3645318688_253_294).call(vvv_tmp1, (TAJS_restrictToType((obj, $__.os.oid11)[key, 'data'], 'function'), $__.fs.jqLiteData_99), key, obj, 0, true, $__.uid);
    'inheritedData' in vvv_tmp0;
    key = 'inheritedData';
    obj['hasOwnProperty'](key);
    vvv_tmp2 = context, (iterator, $__.fs.J$__v3645318688_253_294).call(vvv_tmp2, (TAJS_restrictToType((obj, $__.os.oid11)[key, 'inheritedData'], 'function'), $__.fs.jqLiteInheritedData_105), key, obj, 1, true, $__.uid);
    'scope' in vvv_tmp0;
    key = 'scope';
    obj['hasOwnProperty'](key);
    vvv_tmp3 = context, (iterator, $__.fs.J$__v3645318688_253_294).call(vvv_tmp3, (TAJS_restrictToType((obj, $__.os.oid11)[key, 'scope'], 'function'), $__.fs.J$__v3645318688_228_283), key, obj, 2, true, $__.uid);
    'isolateScope' in vvv_tmp0;
    key = 'isolateScope';
    obj['hasOwnProperty'](key);
    vvv_tmp4 = context, (iterator, $__.fs.J$__v3645318688_253_294).call(vvv_tmp4, (TAJS_restrictToType((obj, $__.os.oid11)[key, 'isolateScope'], 'function'), $__.fs.J$__v3645318688_230_284), key, obj, 3, true, $__.uid);
    'controller' in vvv_tmp0;
    key = 'controller';
    obj['hasOwnProperty'](key);
    vvv_tmp5 = context, (iterator, $__.fs.J$__v3645318688_253_294).call(vvv_tmp5, (TAJS_restrictToType((obj, $__.os.oid11)[key, 'controller'], 'function'), $__.fs.jqLiteController_104), key, obj, 4, true, $__.uid);
    'injector' in vvv_tmp0;
    key = 'injector';
    obj['hasOwnProperty'](key);
    vvv_tmp6 = context, (iterator, $__.fs.J$__v3645318688_253_294).call(vvv_tmp6, (TAJS_restrictToType((obj, $__.os.oid11)[key, 'injector'], 'function'), $__.fs.J$__v3645318688_232_285), key, obj, 5, true, $__.uid);
    'removeAttr' in vvv_tmp0;
    key = 'removeAttr';
    obj['hasOwnProperty'](key);
    vvv_tmp7 = context, (iterator, $__.fs.J$__v3645318688_253_294).call(vvv_tmp7, (TAJS_restrictToType((obj, $__.os.oid11)[key, 'removeAttr'], 'function'), $__.fs.J$__v3645318688_234_286), key, obj, 6, true, $__.uid);
    'hasClass' in vvv_tmp0;
    key = 'hasClass';
    obj['hasOwnProperty'](key);
    vvv_tmp8 = context, (iterator, $__.fs.J$__v3645318688_253_294).call(vvv_tmp8, (TAJS_restrictToType((obj, $__.os.oid11)[key, 'hasClass'], 'function'), $__.fs.jqLiteHasClass_100), key, obj, 7, true, $__.uid);
    'css' in vvv_tmp0;
    key = 'css';
    obj['hasOwnProperty'](key);
    vvv_tmp9 = context, (iterator, $__.fs.J$__v3645318688_253_294).call(vvv_tmp9, (TAJS_restrictToType((obj, $__.os.oid11)[key, 'css'], 'function'), $__.fs.J$__v3645318688_236_287), key, obj, 8, true, $__.uid);
    'attr' in vvv_tmp0;
    key = 'attr';
    obj['hasOwnProperty'](key);
    vvv_tmp10 = context, (iterator, $__.fs.J$__v3645318688_253_294).call(vvv_tmp10, (TAJS_restrictToType((obj, $__.os.oid11)[key, 'attr'], 'function'), $__.fs.J$__v3645318688_238_288), key, obj, 9, true, $__.uid);
    'prop' in vvv_tmp0;
    key = 'prop';
    obj['hasOwnProperty'](key);
    vvv_tmp11 = context, (iterator, $__.fs.J$__v3645318688_253_294).call(vvv_tmp11, (TAJS_restrictToType((obj, $__.os.oid11)[key, 'prop'], 'function'), $__.fs.J$__v3645318688_240_289), key, obj, 10, true, $__.uid);
    'text' in vvv_tmp0;
    key = 'text';
    obj['hasOwnProperty'](key);
    vvv_tmp12 = context, (iterator, $__.fs.J$__v3645318688_253_294).call(vvv_tmp12, (TAJS_restrictToType((obj, $__.os.oid11)[key, 'text'], 'function'), $__.fs.getText_291), key, obj, 11, true, $__.uid);
    'val' in vvv_tmp0;
    key = 'val';
    obj['hasOwnProperty'](key);
    vvv_tmp13 = context, (iterator, $__.fs.J$__v3645318688_253_294).call(vvv_tmp13, (TAJS_restrictToType((obj, $__.os.oid11)[key, 'val'], 'function'), $__.fs.J$__v3645318688_247_292), key, obj, 12, true, $__.uid);
    'html' in vvv_tmp0;
    key = 'html';
    obj['hasOwnProperty'](key);
    vvv_tmp14 = context, (iterator, $__.fs.J$__v3645318688_253_294).call(vvv_tmp14, (TAJS_restrictToType((obj, $__.os.oid11)[key, 'html'], 'function'), $__.fs.J$__v3645318688_249_293), key, obj, 13, true, $__.uid);
    'empty' in vvv_tmp0;
    key = 'empty';
    obj['hasOwnProperty'](key);
    vvv_tmp15 = context, (iterator, $__.fs.J$__v3645318688_253_294).call(vvv_tmp15, (TAJS_restrictToType((obj, $__.os.oid11)[key, 'empty'], 'function'), $__.fs.jqLiteEmpty_106), key, obj, 14, true, $__.uid);
    return obj;
case 4:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 4);
    obj;
    (isFunction, $__.fs.isFunction_29)(obj, 4, true, $__.uid);
    isArray(obj), (isArrayLike, $__.fs.isArrayLike_7)(obj, 2, true, $__.uid);
    TAJS_restrictToType((obj, $__.os.oid12).forEach, 'undefined');
    (isBlankObject, $__.fs.isBlankObject_25)(obj, 2, true, $__.uid);
    typeof TAJS_restrictToType((obj, $__.os.oid12).hasOwnProperty, 'function') === 'function';
    vvv_tmp0 = obj;
    'removeData' in vvv_tmp0;
    key = 'removeData';
    obj['hasOwnProperty'](key);
    vvv_tmp1 = context, (iterator, $__.fs.J$__v3645318688_318_325).call(vvv_tmp1, (TAJS_restrictToType((obj, $__.os.oid12)[key, 'removeData'], 'function'), $__.fs.jqLiteRemoveData_97), key, obj, 0, true, $__.uid);
    'on' in vvv_tmp0;
    key = 'on';
    obj['hasOwnProperty'](key);
    vvv_tmp2 = context, (iterator, $__.fs.J$__v3645318688_318_325).call(vvv_tmp2, (TAJS_restrictToType((obj, $__.os.oid12)[key, 'on'], 'function'), $__.fs.jqLiteOn_310), key, obj, 1, true, $__.uid);
    'off' in vvv_tmp0;
    key = 'off';
    obj['hasOwnProperty'](key);
    vvv_tmp3 = context, (iterator, $__.fs.J$__v3645318688_318_325).call(vvv_tmp3, (TAJS_restrictToType((obj, $__.os.oid12)[key, 'off'], 'function'), $__.fs.jqLiteOff_96), key, obj, 2, true, $__.uid);
    'one' in vvv_tmp0;
    key = 'one';
    obj['hasOwnProperty'](key);
    vvv_tmp4 = context, (iterator, $__.fs.J$__v3645318688_318_325).call(vvv_tmp4, (TAJS_restrictToType((obj, $__.os.oid12)[key, 'one'], 'function'), $__.fs.J$__v3645318688_270_311), key, obj, 3, true, $__.uid);
    'replaceWith' in vvv_tmp0;
    key = 'replaceWith';
    obj['hasOwnProperty'](key);
    vvv_tmp5 = context, (iterator, $__.fs.J$__v3645318688_318_325).call(vvv_tmp5, (TAJS_restrictToType((obj, $__.os.oid12)[key, 'replaceWith'], 'function'), $__.fs.J$__v3645318688_274_312), key, obj, 4, true, $__.uid);
    'children' in vvv_tmp0;
    key = 'children';
    obj['hasOwnProperty'](key);
    vvv_tmp6 = context, (iterator, $__.fs.J$__v3645318688_318_325).call(vvv_tmp6, (TAJS_restrictToType((obj, $__.os.oid12)[key, 'children'], 'function'), $__.fs.J$__v3645318688_278_313), key, obj, 5, true, $__.uid);
    'contents' in vvv_tmp0;
    key = 'contents';
    obj['hasOwnProperty'](key);
    vvv_tmp7 = context, (iterator, $__.fs.J$__v3645318688_318_325).call(vvv_tmp7, (TAJS_restrictToType((obj, $__.os.oid12)[key, 'contents'], 'function'), $__.fs.J$__v3645318688_280_314), key, obj, 6, true, $__.uid);
    'append' in vvv_tmp0;
    key = 'append';
    obj['hasOwnProperty'](key);
    vvv_tmp8 = context, (iterator, $__.fs.J$__v3645318688_318_325).call(vvv_tmp8, (TAJS_restrictToType((obj, $__.os.oid12)[key, 'append'], 'function'), $__.fs.J$__v3645318688_282_315), key, obj, 7, true, $__.uid);
    'prepend' in vvv_tmp0;
    key = 'prepend';
    obj['hasOwnProperty'](key);
    vvv_tmp9 = context, (iterator, $__.fs.J$__v3645318688_318_325).call(vvv_tmp9, (TAJS_restrictToType((obj, $__.os.oid12)[key, 'prepend'], 'function'), $__.fs.J$__v3645318688_286_316), key, obj, 8, true, $__.uid);
    'wrap' in vvv_tmp0;
    key = 'wrap';
    obj['hasOwnProperty'](key);
    vvv_tmp10 = context, (iterator, $__.fs.J$__v3645318688_318_325).call(vvv_tmp10, (TAJS_restrictToType((obj, $__.os.oid12)[key, 'wrap'], 'function'), $__.fs.J$__v3645318688_288_317), key, obj, 9, true, $__.uid);
    'remove' in vvv_tmp0;
    key = 'remove';
    obj['hasOwnProperty'](key);
    vvv_tmp11 = context, (iterator, $__.fs.J$__v3645318688_318_325).call(vvv_tmp11, (TAJS_restrictToType((obj, $__.os.oid12)[key, 'remove'], 'function'), $__.fs.jqLiteRemove_107), key, obj, 10, true, $__.uid);
    'detach' in vvv_tmp0;
    key = 'detach';
    obj['hasOwnProperty'](key);
    vvv_tmp12 = context, (iterator, $__.fs.J$__v3645318688_318_325).call(vvv_tmp12, (TAJS_restrictToType((obj, $__.os.oid12)[key, 'detach'], 'function'), $__.fs.J$__v3645318688_290_318), key, obj, 11, true, $__.uid);
    'after' in vvv_tmp0;
    key = 'after';
    obj['hasOwnProperty'](key);
    vvv_tmp13 = context, (iterator, $__.fs.J$__v3645318688_318_325).call(vvv_tmp13, (TAJS_restrictToType((obj, $__.os.oid12)[key, 'after'], 'function'), $__.fs.J$__v3645318688_292_319), key, obj, 12, true, $__.uid);
    'addClass' in vvv_tmp0;
    key = 'addClass';
    obj['hasOwnProperty'](key);
    vvv_tmp14 = context, (iterator, $__.fs.J$__v3645318688_318_325).call(vvv_tmp14, (TAJS_restrictToType((obj, $__.os.oid12)[key, 'addClass'], 'function'), $__.fs.jqLiteAddClass_102), key, obj, 13, true, $__.uid);
    'removeClass' in vvv_tmp0;
    key = 'removeClass';
    obj['hasOwnProperty'](key);
    vvv_tmp15 = context, (iterator, $__.fs.J$__v3645318688_318_325).call(vvv_tmp15, (TAJS_restrictToType((obj, $__.os.oid12)[key, 'removeClass'], 'function'), $__.fs.jqLiteRemoveClass_101), key, obj, 14, true, $__.uid);
    'toggleClass' in vvv_tmp0;
    key = 'toggleClass';
    obj['hasOwnProperty'](key);
    vvv_tmp16 = context, (iterator, $__.fs.J$__v3645318688_318_325).call(vvv_tmp16, (TAJS_restrictToType((obj, $__.os.oid12)[key, 'toggleClass'], 'function'), $__.fs.J$__v3645318688_296_320), key, obj, 15, true, $__.uid);
    'parent' in vvv_tmp0;
    key = 'parent';
    obj['hasOwnProperty'](key);
    vvv_tmp17 = context, (iterator, $__.fs.J$__v3645318688_318_325).call(vvv_tmp17, (TAJS_restrictToType((obj, $__.os.oid12)[key, 'parent'], 'function'), $__.fs.J$__v3645318688_298_321), key, obj, 16, true, $__.uid);
    'next' in vvv_tmp0;
    key = 'next';
    obj['hasOwnProperty'](key);
    vvv_tmp18 = context, (iterator, $__.fs.J$__v3645318688_318_325).call(vvv_tmp18, (TAJS_restrictToType((obj, $__.os.oid12)[key, 'next'], 'function'), $__.fs.J$__v3645318688_300_322), key, obj, 17, true, $__.uid);
    'find' in vvv_tmp0;
    key = 'find';
    obj['hasOwnProperty'](key);
    vvv_tmp19 = context, (iterator, $__.fs.J$__v3645318688_318_325).call(vvv_tmp19, (TAJS_restrictToType((obj, $__.os.oid12)[key, 'find'], 'function'), $__.fs.J$__v3645318688_302_323), key, obj, 18, true, $__.uid);
    'clone' in vvv_tmp0;
    key = 'clone';
    obj['hasOwnProperty'](key);
    vvv_tmp20 = context, (iterator, $__.fs.J$__v3645318688_318_325).call(vvv_tmp20, (TAJS_restrictToType((obj, $__.os.oid12)[key, 'clone'], 'function'), $__.fs.jqLiteClone_94), key, obj, 19, true, $__.uid);
    'triggerHandler' in vvv_tmp0;
    key = 'triggerHandler';
    obj['hasOwnProperty'](key);
    vvv_tmp21 = context, (iterator, $__.fs.J$__v3645318688_318_325).call(vvv_tmp21, (TAJS_restrictToType((obj, $__.os.oid12)[key, 'triggerHandler'], 'function'), $__.fs.J$__v3645318688_314_324), key, obj, 20, true, $__.uid);
    return obj;
case 5:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 5);
    obj;
    (isFunction, $__.fs.isFunction_29)(obj, 5, true, $__.uid);
    isArray(obj);
    isPrimitive = typeof obj !== 'object';
    key = 0, length = (obj.length, 3);
    key < length;
    isPrimitive, key in obj;
    vvv_tmp0 = context, (iterator, $__.fs.J$__v3645318688_992_382).call(vvv_tmp0, (TAJS_restrictToType(obj[key, 0], 'function'), $__.fs.LocationHashbangInHtml5Url_171), key, obj, 0, true, $__.uid);
    (key = +key + 1) - 1;
    key < length;
    isPrimitive, key in obj;
    vvv_tmp1 = context, (iterator, $__.fs.J$__v3645318688_992_382).call(vvv_tmp1, (TAJS_restrictToType(obj[key, 1], 'function'), $__.fs.LocationHashbangUrl_170), key, obj, 1, true, $__.uid);
    (key = +key + 1) - 1;
    key < length;
    isPrimitive, key in obj;
    vvv_tmp2 = context, (iterator, $__.fs.J$__v3645318688_992_382).call(vvv_tmp2, (TAJS_restrictToType(obj[key, 2], 'function'), $__.fs.LocationHtml5Url_169), key, obj, 2, true, $__.uid);
    (key = +key + 1) - 1;
    key < length;
    return obj;
case 6:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 6);
    obj;
    (isFunction, $__.fs.isFunction_29)(obj, 6, true, $__.uid);
    isArray(obj);
    isPrimitive = typeof obj !== 'object';
    key = 0, length = (obj.length, 18);
    key < length;
    isPrimitive, key in obj;
    vvv_tmp0 = context, (iterator, $__.fs.J$__v3645318688_1036_387).call(vvv_tmp0, TAJS_restrictToType(obj[key, 0], 'string'), key, obj, 0, true, $__.uid);
    (key = +key + 1) - 1;
    key < length;
    isPrimitive, key in obj;
    vvv_tmp1 = context, (iterator, $__.fs.J$__v3645318688_1036_387).call(vvv_tmp1, TAJS_restrictToType(obj[key, 1], 'string'), key, obj, 1, true, $__.uid);
    (key = +key + 1) - 1;
    key < length;
    isPrimitive, key in obj;
    vvv_tmp2 = context, (iterator, $__.fs.J$__v3645318688_1036_387).call(vvv_tmp2, TAJS_restrictToType(obj[key, 2], 'string'), key, obj, 2, true, $__.uid);
    (key = +key + 1) - 1;
    key < length;
    isPrimitive, key in obj;
    vvv_tmp3 = context, (iterator, $__.fs.J$__v3645318688_1036_387).call(vvv_tmp3, TAJS_restrictToType(obj[key, 3], 'string'), key, obj, 3, true, $__.uid);
    (key = +key + 1) - 1;
    key < length;
    isPrimitive, key in obj;
    vvv_tmp4 = context, (iterator, $__.fs.J$__v3645318688_1036_387).call(vvv_tmp4, TAJS_restrictToType(obj[key, 4], 'string'), key, obj, 4, true, $__.uid);
    (key = +key + 1) - 1;
    key < length;
    isPrimitive, key in obj;
    vvv_tmp5 = context, (iterator, $__.fs.J$__v3645318688_1036_387).call(vvv_tmp5, TAJS_restrictToType(obj[key, 5], 'string'), key, obj, 5, true, $__.uid);
    (key = +key + 1) - 1;
    key < length;
    isPrimitive, key in obj;
    vvv_tmp6 = context, (iterator, $__.fs.J$__v3645318688_1036_387).call(vvv_tmp6, TAJS_restrictToType(obj[key, 6], 'string'), key, obj, 6, true, $__.uid);
    (key = +key + 1) - 1;
    key < length;
    isPrimitive, key in obj;
    vvv_tmp7 = context, (iterator, $__.fs.J$__v3645318688_1036_387).call(vvv_tmp7, TAJS_restrictToType(obj[key, 7], 'string'), key, obj, 7, true, $__.uid);
    (key = +key + 1) - 1;
    key < length;
    isPrimitive, key in obj;
    vvv_tmp8 = context, (iterator, $__.fs.J$__v3645318688_1036_387).call(vvv_tmp8, TAJS_restrictToType(obj[key, 8], 'string'), key, obj, 8, true, $__.uid);
    (key = +key + 1) - 1;
    key < length;
    isPrimitive, key in obj;
    vvv_tmp9 = context, (iterator, $__.fs.J$__v3645318688_1036_387).call(vvv_tmp9, TAJS_restrictToType(obj[key, 9], 'string'), key, obj, 9, true, $__.uid);
    (key = +key + 1) - 1;
    key < length;
    isPrimitive, key in obj;
    vvv_tmp10 = context, (iterator, $__.fs.J$__v3645318688_1036_387).call(vvv_tmp10, TAJS_restrictToType(obj[key, 10], 'string'), key, obj, 10, true, $__.uid);
    (key = +key + 1) - 1;
    key < length;
    isPrimitive, key in obj;
    vvv_tmp11 = context, (iterator, $__.fs.J$__v3645318688_1036_387).call(vvv_tmp11, TAJS_restrictToType(obj[key, 11], 'string'), key, obj, 11, true, $__.uid);
    (key = +key + 1) - 1;
    key < length;
    isPrimitive, key in obj;
    vvv_tmp12 = context, (iterator, $__.fs.J$__v3645318688_1036_387).call(vvv_tmp12, TAJS_restrictToType(obj[key, 12], 'string'), key, obj, 12, true, $__.uid);
    (key = +key + 1) - 1;
    key < length;
    isPrimitive, key in obj;
    vvv_tmp13 = context, (iterator, $__.fs.J$__v3645318688_1036_387).call(vvv_tmp13, TAJS_restrictToType(obj[key, 13], 'string'), key, obj, 13, true, $__.uid);
    (key = +key + 1) - 1;
    key < length;
    isPrimitive, key in obj;
    vvv_tmp14 = context, (iterator, $__.fs.J$__v3645318688_1036_387).call(vvv_tmp14, TAJS_restrictToType(obj[key, 14], 'string'), key, obj, 14, true, $__.uid);
    (key = +key + 1) - 1;
    key < length;
    isPrimitive, key in obj;
    vvv_tmp15 = context, (iterator, $__.fs.J$__v3645318688_1036_387).call(vvv_tmp15, TAJS_restrictToType(obj[key, 15], 'string'), key, obj, 15, true, $__.uid);
    (key = +key + 1) - 1;
    key < length;
    isPrimitive, key in obj;
    vvv_tmp16 = context, (iterator, $__.fs.J$__v3645318688_1036_387).call(vvv_tmp16, TAJS_restrictToType(obj[key, 16], 'string'), key, obj, 16, true, $__.uid);
    (key = +key + 1) - 1;
    key < length;
    isPrimitive, key in obj;
    vvv_tmp17 = context, (iterator, $__.fs.J$__v3645318688_1036_387).call(vvv_tmp17, TAJS_restrictToType(obj[key, 17], 'string'), key, obj, 17, true, $__.uid);
    (key = +key + 1) - 1;
    key < length;
    return obj;
case 7:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 7);
    obj;
    (isFunction, $__.fs.isFunction_29)(obj, 7, true, $__.uid);
    isArray(obj), (isArrayLike, $__.fs.isArrayLike_7)(obj, 3, true, $__.uid);
    TAJS_restrictToType((obj, $__.os.oid7).forEach, 'undefined');
    (isBlankObject, $__.fs.isBlankObject_25)(obj, 3, true, $__.uid);
    typeof TAJS_restrictToType((obj, $__.os.oid7).hasOwnProperty, 'function') === 'function';
    vvv_tmp0 = obj;
    'multiple' in vvv_tmp0;
    key = 'multiple';
    obj['hasOwnProperty'](key);
    vvv_tmp1 = context, (iterator, $__.fs.J$__v3645318688_1770_517).call(vvv_tmp1, TAJS_restrictToType((obj, $__.os.oid7)[key, 'multiple'], 'string'), key, obj, 0, true, $__.uid);
    'selected' in vvv_tmp0;
    key = 'selected';
    obj['hasOwnProperty'](key);
    vvv_tmp2 = context, (iterator, $__.fs.J$__v3645318688_1770_517).call(vvv_tmp2, TAJS_restrictToType((obj, $__.os.oid7)[key, 'selected'], 'string'), key, obj, 1, true, $__.uid);
    'checked' in vvv_tmp0;
    key = 'checked';
    obj['hasOwnProperty'](key);
    vvv_tmp3 = context, (iterator, $__.fs.J$__v3645318688_1770_517).call(vvv_tmp3, TAJS_restrictToType((obj, $__.os.oid7)[key, 'checked'], 'string'), key, obj, 2, true, $__.uid);
    'disabled' in vvv_tmp0;
    key = 'disabled';
    obj['hasOwnProperty'](key);
    vvv_tmp4 = context, (iterator, $__.fs.J$__v3645318688_1770_517).call(vvv_tmp4, TAJS_restrictToType((obj, $__.os.oid7)[key, 'disabled'], 'string'), key, obj, 3, true, $__.uid);
    'readonly' in vvv_tmp0;
    key = 'readonly';
    obj['hasOwnProperty'](key);
    vvv_tmp5 = context, (iterator, $__.fs.J$__v3645318688_1770_517).call(vvv_tmp5, TAJS_restrictToType((obj, $__.os.oid7)[key, 'readonly'], 'string'), key, obj, 4, true, $__.uid);
    'required' in vvv_tmp0;
    key = 'required';
    obj['hasOwnProperty'](key);
    vvv_tmp6 = context, (iterator, $__.fs.J$__v3645318688_1770_517).call(vvv_tmp6, TAJS_restrictToType((obj, $__.os.oid7)[key, 'required'], 'string'), key, obj, 5, true, $__.uid);
    'open' in vvv_tmp0;
    key = 'open';
    obj['hasOwnProperty'](key);
    vvv_tmp7 = context, (iterator, $__.fs.J$__v3645318688_1770_517).call(vvv_tmp7, TAJS_restrictToType((obj, $__.os.oid7)[key, 'open'], 'string'), key, obj, 6, true, $__.uid);
    return obj;
case 8:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 8);
    obj;
    (isFunction, $__.fs.isFunction_29)(obj, 8, true, $__.uid);
    isArray(obj), (isArrayLike, $__.fs.isArrayLike_7)(obj, 4, true, $__.uid);
    TAJS_restrictToType((obj, $__.os.oid9).forEach, 'undefined');
    (isBlankObject, $__.fs.isBlankObject_25)(obj, 4, true, $__.uid);
    typeof TAJS_restrictToType((obj, $__.os.oid9).hasOwnProperty, 'function') === 'function';
    vvv_tmp0 = obj;
    'ngMinlength' in vvv_tmp0;
    key = 'ngMinlength';
    obj['hasOwnProperty'](key);
    vvv_tmp1 = context, (iterator, $__.fs.J$__v3645318688_1777_532).call(vvv_tmp1, TAJS_restrictToType((obj, $__.os.oid9)[key, 'ngMinlength'], 'string'), key, obj, 0, true, $__.uid);
    'ngMaxlength' in vvv_tmp0;
    key = 'ngMaxlength';
    obj['hasOwnProperty'](key);
    vvv_tmp2 = context, (iterator, $__.fs.J$__v3645318688_1777_532).call(vvv_tmp2, TAJS_restrictToType((obj, $__.os.oid9)[key, 'ngMaxlength'], 'string'), key, obj, 1, true, $__.uid);
    'ngMin' in vvv_tmp0;
    key = 'ngMin';
    obj['hasOwnProperty'](key);
    vvv_tmp3 = context, (iterator, $__.fs.J$__v3645318688_1777_532).call(vvv_tmp3, TAJS_restrictToType((obj, $__.os.oid9)[key, 'ngMin'], 'string'), key, obj, 2, true, $__.uid);
    'ngMax' in vvv_tmp0;
    key = 'ngMax';
    obj['hasOwnProperty'](key);
    vvv_tmp4 = context, (iterator, $__.fs.J$__v3645318688_1777_532).call(vvv_tmp4, TAJS_restrictToType((obj, $__.os.oid9)[key, 'ngMax'], 'string'), key, obj, 3, true, $__.uid);
    'ngPattern' in vvv_tmp0;
    key = 'ngPattern';
    obj['hasOwnProperty'](key);
    vvv_tmp5 = context, (iterator, $__.fs.J$__v3645318688_1777_532).call(vvv_tmp5, TAJS_restrictToType((obj, $__.os.oid9)[key, 'ngPattern'], 'string'), key, obj, 4, true, $__.uid);
    'ngStep' in vvv_tmp0;
    key = 'ngStep';
    obj['hasOwnProperty'](key);
    vvv_tmp6 = context, (iterator, $__.fs.J$__v3645318688_1777_532).call(vvv_tmp6, TAJS_restrictToType((obj, $__.os.oid9)[key, 'ngStep'], 'string'), key, obj, 5, true, $__.uid);
    return obj;
case 9:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 9);
    obj;
    (isFunction, $__.fs.isFunction_29)(obj, 9, true, $__.uid);
    isArray(obj);
    isPrimitive = typeof obj !== 'object';
    key = 0, length = (obj.length, 3);
    key < length;
    isPrimitive, key in obj;
    vvv_tmp0 = context, (iterator, $__.fs.J$__v3645318688_1785_539).call(vvv_tmp0, TAJS_restrictToType(obj[key, 0], 'string'), key, obj, 0, true, $__.uid);
    (key = +key + 1) - 1;
    key < length;
    isPrimitive, key in obj;
    vvv_tmp1 = context, (iterator, $__.fs.J$__v3645318688_1785_539).call(vvv_tmp1, TAJS_restrictToType(obj[key, 1], 'string'), key, obj, 1, true, $__.uid);
    (key = +key + 1) - 1;
    key < length;
    isPrimitive, key in obj;
    vvv_tmp2 = context, (iterator, $__.fs.J$__v3645318688_1785_539).call(vvv_tmp2, TAJS_restrictToType(obj[key, 2], 'string'), key, obj, 2, true, $__.uid);
    (key = +key + 1) - 1;
    key < length;
    return obj;
case 10:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 10);
    obj;
    (isFunction, $__.fs.isFunction_29)(obj, 10, true, $__.uid);
    isArray(obj);
    isPrimitive = typeof obj !== 'object';
    key = 0, length = (obj.length, 5);
    key < length;
    isPrimitive, key in obj;
    vvv_tmp0 = context, (iterator, $__.fs.J$__v3645318688_1853_562).call(vvv_tmp0, TAJS_restrictToType(obj[key, 0], 'string'), key, obj, 0, true, $__.uid);
    (key = +key + 1) - 1;
    key < length;
    isPrimitive, key in obj;
    vvv_tmp1 = context, (iterator, $__.fs.J$__v3645318688_1853_562).call(vvv_tmp1, TAJS_restrictToType(obj[key, 1], 'string'), key, obj, 1, true, $__.uid);
    (key = +key + 1) - 1;
    key < length;
    isPrimitive, key in obj;
    vvv_tmp2 = context, (iterator, $__.fs.J$__v3645318688_1853_562).call(vvv_tmp2, TAJS_restrictToType(obj[key, 2], 'string'), key, obj, 2, true, $__.uid);
    (key = +key + 1) - 1;
    key < length;
    isPrimitive, key in obj;
    vvv_tmp3 = context, (iterator, $__.fs.J$__v3645318688_1853_562).call(vvv_tmp3, TAJS_restrictToType(obj[key, 3], 'string'), key, obj, 3, true, $__.uid);
    (key = +key + 1) - 1;
    key < length;
    isPrimitive, key in obj;
    vvv_tmp4 = context, (iterator, $__.fs.J$__v3645318688_1853_562).call(vvv_tmp4, TAJS_restrictToType(obj[key, 4], 'string'), key, obj, 4, true, $__.uid);
    (key = +key + 1) - 1;
    key < length;
    return obj;
case 11:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 11);
    obj;
    (isFunction, $__.fs.isFunction_29)(obj, 12, true, $__.uid);
    isArray(obj);
    isPrimitive = typeof obj !== 'object';
    key = 0, length = (obj.length, 18);
    key < length;
    isPrimitive, key in obj;
    vvv_tmp0 = context, (iterator, $__.fs.J$__v3645318688_2029_597).call(vvv_tmp0, TAJS_restrictToType(obj[key, 0], 'string'), key, obj, 0, true, $__.uid);
    (key = +key + 1) - 1;
    key < length;
    isPrimitive, key in obj;
    vvv_tmp1 = context, (iterator, $__.fs.J$__v3645318688_2029_597).call(vvv_tmp1, TAJS_restrictToType(obj[key, 1], 'string'), key, obj, 1, true, $__.uid);
    (key = +key + 1) - 1;
    key < length;
    isPrimitive, key in obj;
    vvv_tmp2 = context, (iterator, $__.fs.J$__v3645318688_2029_597).call(vvv_tmp2, TAJS_restrictToType(obj[key, 2], 'string'), key, obj, 2, true, $__.uid);
    (key = +key + 1) - 1;
    key < length;
    isPrimitive, key in obj;
    vvv_tmp3 = context, (iterator, $__.fs.J$__v3645318688_2029_597).call(vvv_tmp3, TAJS_restrictToType(obj[key, 3], 'string'), key, obj, 3, true, $__.uid);
    (key = +key + 1) - 1;
    key < length;
    isPrimitive, key in obj;
    vvv_tmp4 = context, (iterator, $__.fs.J$__v3645318688_2029_597).call(vvv_tmp4, TAJS_restrictToType(obj[key, 4], 'string'), key, obj, 4, true, $__.uid);
    (key = +key + 1) - 1;
    key < length;
    isPrimitive, key in obj;
    vvv_tmp5 = context, (iterator, $__.fs.J$__v3645318688_2029_597).call(vvv_tmp5, TAJS_restrictToType(obj[key, 5], 'string'), key, obj, 5, true, $__.uid);
    (key = +key + 1) - 1;
    key < length;
    isPrimitive, key in obj;
    vvv_tmp6 = context, (iterator, $__.fs.J$__v3645318688_2029_597).call(vvv_tmp6, TAJS_restrictToType(obj[key, 6], 'string'), key, obj, 6, true, $__.uid);
    (key = +key + 1) - 1;
    key < length;
    isPrimitive, key in obj;
    vvv_tmp7 = context, (iterator, $__.fs.J$__v3645318688_2029_597).call(vvv_tmp7, TAJS_restrictToType(obj[key, 7], 'string'), key, obj, 7, true, $__.uid);
    (key = +key + 1) - 1;
    key < length;
    isPrimitive, key in obj;
    vvv_tmp8 = context, (iterator, $__.fs.J$__v3645318688_2029_597).call(vvv_tmp8, TAJS_restrictToType(obj[key, 8], 'string'), key, obj, 8, true, $__.uid);
    (key = +key + 1) - 1;
    key < length;
    isPrimitive, key in obj;
    vvv_tmp9 = context, (iterator, $__.fs.J$__v3645318688_2029_597).call(vvv_tmp9, TAJS_restrictToType(obj[key, 9], 'string'), key, obj, 9, true, $__.uid);
    (key = +key + 1) - 1;
    key < length;
    isPrimitive, key in obj;
    vvv_tmp10 = context, (iterator, $__.fs.J$__v3645318688_2029_597).call(vvv_tmp10, TAJS_restrictToType(obj[key, 10], 'string'), key, obj, 10, true, $__.uid);
    (key = +key + 1) - 1;
    key < length;
    isPrimitive, key in obj;
    vvv_tmp11 = context, (iterator, $__.fs.J$__v3645318688_2029_597).call(vvv_tmp11, TAJS_restrictToType(obj[key, 11], 'string'), key, obj, 11, true, $__.uid);
    (key = +key + 1) - 1;
    key < length;
    isPrimitive, key in obj;
    vvv_tmp12 = context, (iterator, $__.fs.J$__v3645318688_2029_597).call(vvv_tmp12, TAJS_restrictToType(obj[key, 12], 'string'), key, obj, 12, true, $__.uid);
    (key = +key + 1) - 1;
    key < length;
    isPrimitive, key in obj;
    vvv_tmp13 = context, (iterator, $__.fs.J$__v3645318688_2029_597).call(vvv_tmp13, TAJS_restrictToType(obj[key, 13], 'string'), key, obj, 13, true, $__.uid);
    (key = +key + 1) - 1;
    key < length;
    isPrimitive, key in obj;
    vvv_tmp14 = context, (iterator, $__.fs.J$__v3645318688_2029_597).call(vvv_tmp14, TAJS_restrictToType(obj[key, 14], 'string'), key, obj, 14, true, $__.uid);
    (key = +key + 1) - 1;
    key < length;
    isPrimitive, key in obj;
    vvv_tmp15 = context, (iterator, $__.fs.J$__v3645318688_2029_597).call(vvv_tmp15, TAJS_restrictToType(obj[key, 15], 'string'), key, obj, 15, true, $__.uid);
    (key = +key + 1) - 1;
    key < length;
    isPrimitive, key in obj;
    vvv_tmp16 = context, (iterator, $__.fs.J$__v3645318688_2029_597).call(vvv_tmp16, TAJS_restrictToType(obj[key, 16], 'string'), key, obj, 16, true, $__.uid);
    (key = +key + 1) - 1;
    key < length;
    isPrimitive, key in obj;
    vvv_tmp17 = context, (iterator, $__.fs.J$__v3645318688_2029_597).call(vvv_tmp17, TAJS_restrictToType(obj[key, 17], 'string'), key, obj, 17, true, $__.uid);
    (key = +key + 1) - 1;
    key < length;
    return obj;
case 12:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 12);
    obj;
    (isFunction, $__.fs.isFunction_29)(obj, 20, true, $__.uid);
    isArray(obj);
    isPrimitive = typeof obj !== 'object';
    key = 0, length = (obj.length, 1);
    key < length;
    isPrimitive, key in obj;
    vvv_tmp0 = context, (iterator, $__.fs.J$__v3645318688_181_722).call(vvv_tmp0, TAJS_restrictToType(obj[key, 0], 'HTMLStyleElement'), key, obj, 0, true, $__.uid);
    (key = +key + 1) - 1;
    key < length;
    return obj;
case 13:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 13);
    obj;
    (isFunction, $__.fs.isFunction_29)(obj, 21, true, $__.uid);
    isArray(obj), (isArrayLike, $__.fs.isArrayLike_7)(obj, 5, true, $__.uid);
    isPrimitive = typeof obj !== 'object';
    key = 0, length = (obj.length, 1);
    key < length;
    isPrimitive, key in obj;
    vvv_tmp0 = context, (iterator, $__.fs.J$__v3645318688_284_723).call(vvv_tmp0, TAJS_restrictToType(obj[key, 0], 'HTMLStyleElement'), key, obj, 0, true, $__.uid);
    (key = +key + 1) - 1;
    key < length;
    return obj;
case 14:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 14);
    obj;
    (isFunction, $__.fs.isFunction_29)(obj, 22, true, $__.uid);
    isArray(obj);
    isPrimitive = typeof obj !== 'object';
    key = 0, length = (obj.length, 4);
    key < length;
    isPrimitive, key in obj;
    vvv_tmp0 = context, (iterator, $__.fs.J$__v3645318688_111_724).call(vvv_tmp0, TAJS_restrictToType(obj[key, 0], 'string'), key, obj, 0, true, $__.uid);
    (key = +key + 1) - 1;
    key < length;
    isPrimitive, key in obj;
    vvv_tmp1 = context, (iterator, $__.fs.J$__v3645318688_111_724).call(vvv_tmp1, TAJS_restrictToType(obj[key, 1], 'string'), key, obj, 1, true, $__.uid);
    (key = +key + 1) - 1;
    key < length;
    isPrimitive, key in obj;
    vvv_tmp2 = context, (iterator, $__.fs.J$__v3645318688_111_724).call(vvv_tmp2, TAJS_restrictToType(obj[key, 2], 'string'), key, obj, 2, true, $__.uid);
    (key = +key + 1) - 1;
    key < length;
    isPrimitive, key in obj;
    vvv_tmp3 = context, (iterator, $__.fs.J$__v3645318688_111_724).call(vvv_tmp3, TAJS_restrictToType(obj[key, 3], 'string'), key, obj, 3, true, $__.uid);
    (key = +key + 1) - 1;
    key < length;
    return obj;
case 15:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 15);
    obj;
    (isFunction, $__.fs.isFunction_29)(obj, 23, true, $__.uid);
    isArray(obj);
    isPrimitive = typeof obj !== 'object';
    key = 0, length = (obj.length, 4);
    key < length;
    isPrimitive, key in obj;
    vvv_tmp0 = context, (iterator, $__.fs.J$__v3645318688_113_725).call(vvv_tmp0, TAJS_restrictToType(obj[key, 0], 'string'), key, obj, 0, true, $__.uid);
    (key = +key + 1) - 1;
    key < length;
    isPrimitive, key in obj;
    vvv_tmp1 = context, (iterator, $__.fs.J$__v3645318688_113_725).call(vvv_tmp1, TAJS_restrictToType(obj[key, 1], 'string'), key, obj, 1, true, $__.uid);
    (key = +key + 1) - 1;
    key < length;
    isPrimitive, key in obj;
    vvv_tmp2 = context, (iterator, $__.fs.J$__v3645318688_113_725).call(vvv_tmp2, TAJS_restrictToType(obj[key, 2], 'string'), key, obj, 2, true, $__.uid);
    (key = +key + 1) - 1;
    key < length;
    isPrimitive, key in obj;
    vvv_tmp3 = context, (iterator, $__.fs.J$__v3645318688_113_725).call(vvv_tmp3, TAJS_restrictToType(obj[key, 3], 'string'), key, obj, 3, true, $__.uid);
    (key = +key + 1) - 1;
    key < length;
    return obj;
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (obj) {
    if (isFunction(obj)) {
        for (key in obj) {
            if (key !== 'prototype' && key !== 'length' && key !== 'name' && obj.hasOwnProperty(key)) {
                iterator.call(context, obj[key], key, obj);
            }
        }
    } else if (isArray(obj) || isArrayLike(obj)) {
        isPrimitive = typeof obj !== 'object';
        for (key = 0, length = obj.length; key < length; key++) {
            if (isPrimitive || key in obj) {
                iterator.call(context, obj[key], key, obj);
            }
        }
    } else if (obj.forEach && obj.forEach !== forEach) {
        obj.forEach(iterator, context, obj);
    } else if (isBlankObject(obj)) {
        for (key in obj) {
            iterator.call(context, obj[key], key, obj);
        }
    } else if (typeof obj.hasOwnProperty === 'function') {
        for (key in obj) {
            if (obj.hasOwnProperty(key)) {
                iterator.call(context, obj[key], key, obj);
            }
        }
    } else {
        for (key in obj) {
            if (hasOwnProperty.call(obj, key)) {
                iterator.call(context, obj[key], key, obj);
            }
        }
    }
}
return obj;});
    forEachSorted = ($__.fs.forEachSorted_9 = function forEachSorted(obj, iterator, context) {
var vvv_return, vvv_switch, keys;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
obj = arguments[0], iterator = arguments[1], context = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
keys = Object.keys(obj).sort();
for (var i = 0; i < keys.length; i++) {
    iterator.call(context, obj[keys[i]], keys[i]);
}
return keys;});
    reverseParams = ($__.fs.reverseParams_10 = function reverseParams(iteratorFn) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
iteratorFn = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return function (value, key) {
    iteratorFn(key, value);
};});
    nextUid = ($__.fs.nextUid_11 = function nextUid() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return ++uid;});
    setHashKey = ($__.fs.setHashKey_12 = function setHashKey(obj, h) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
obj = arguments[0], h = arguments[1];
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    h;
    delete obj.$$hashKey;
    return;
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (h) {
    obj.$$hashKey = h;
} else {
    delete obj.$$hashKey;
}});
    baseExtend = ($__.fs.baseExtend_13 = function baseExtend(dst, objs, deep) {
var vvv_return, vvv_switch, h, i, ii, obj, keys, j, jj, key, src;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
dst = arguments[0], objs = arguments[1], deep = arguments[2];
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    h = TAJS_restrictToType((dst, $__.os.oid1).$$hashKey, 'undefined');
    i = 0;
    ii = (objs.length, 1);
    i < ii;
    obj = (objs[i, 0], $__.os.oid52);
    !(isObject, $__.fs.isObject_24)(obj, 0, true, $__.uid);
    keys = function $__lt6(res) {
        res.length = 34;
        if (res.length != 34)
            TAJS_dumpValue('Possible loss of precision');
        return res;
        ;
        TAJS_makeContextSensitive($__lt6, -2);
    }((Object['keys'](obj), [
        'errorHandlingConfig',
        'bootstrap',
        'copy',
        'extend',
        'merge',
        'equals',
        'element',
        'forEach',
        'injector',
        'noop',
        'bind',
        'toJson',
        'fromJson',
        'identity',
        'isUndefined',
        'isDefined',
        'isString',
        'isFunction',
        'isObject',
        'isNumber',
        'isElement',
        'isArray',
        'version',
        'isDate',
        'lowercase',
        'uppercase',
        'callbacks',
        'getTestability',
        'reloadWithDebugInfo',
        '$$minErr',
        '$$csp',
        '$$encodeUriSegment',
        '$$encodeUriQuery',
        '$$stringify'
    ]));
    j = 0;
    jj = (keys.length, 34);
    j < jj;
    key = TAJS_restrictToType(keys[j, 0], 'string');
    src = TAJS_restrictToType((obj, $__.os.oid52)[key, 'errorHandlingConfig'], 'function');
    deep;
    (dst, $__.os.oid1)[key, 'errorHandlingConfig'] = src;
    (j = +j + 1) - 1;
    j < jj;
    key = TAJS_restrictToType(keys[j, 1], 'string');
    src = TAJS_restrictToType((obj, $__.os.oid52)[key, 'bootstrap'], 'function');
    deep;
    (dst, $__.os.oid1)[key, 'bootstrap'] = src;
    (j = +j + 1) - 1;
    j < jj;
    key = TAJS_restrictToType(keys[j, 2], 'string');
    src = TAJS_restrictToType((obj, $__.os.oid52)[key, 'copy'], 'function');
    deep;
    (dst, $__.os.oid1)[key, 'copy'] = src;
    (j = +j + 1) - 1;
    j < jj;
    key = TAJS_restrictToType(keys[j, 3], 'string');
    src = TAJS_restrictToType((obj, $__.os.oid52)[key, 'extend'], 'function');
    deep;
    (dst, $__.os.oid1)[key, 'extend'] = src;
    (j = +j + 1) - 1;
    j < jj;
    key = TAJS_restrictToType(keys[j, 4], 'string');
    src = TAJS_restrictToType((obj, $__.os.oid52)[key, 'merge'], 'function');
    deep;
    (dst, $__.os.oid1)[key, 'merge'] = src;
    (j = +j + 1) - 1;
    j < jj;
    key = TAJS_restrictToType(keys[j, 5], 'string');
    src = TAJS_restrictToType((obj, $__.os.oid52)[key, 'equals'], 'function');
    deep;
    (dst, $__.os.oid1)[key, 'equals'] = src;
    (j = +j + 1) - 1;
    j < jj;
    key = TAJS_restrictToType(keys[j, 6], 'string');
    src = TAJS_restrictToType((obj, $__.os.oid52)[key, 'element'], 'function');
    deep;
    (dst, $__.os.oid1)[key, 'element'] = src;
    (j = +j + 1) - 1;
    j < jj;
    key = TAJS_restrictToType(keys[j, 7], 'string');
    src = TAJS_restrictToType((obj, $__.os.oid52)[key, 'forEach'], 'function');
    deep;
    (dst, $__.os.oid1)[key, 'forEach'] = src;
    (j = +j + 1) - 1;
    j < jj;
    key = TAJS_restrictToType(keys[j, 8], 'string');
    src = TAJS_restrictToType((obj, $__.os.oid52)[key, 'injector'], 'function');
    deep;
    (dst, $__.os.oid1)[key, 'injector'] = src;
    (j = +j + 1) - 1;
    j < jj;
    key = TAJS_restrictToType(keys[j, 9], 'string');
    src = TAJS_restrictToType((obj, $__.os.oid52)[key, 'noop'], 'function');
    deep;
    (dst, $__.os.oid1)[key, 'noop'] = src;
    (j = +j + 1) - 1;
    j < jj;
    key = TAJS_restrictToType(keys[j, 10], 'string');
    src = TAJS_restrictToType((obj, $__.os.oid52)[key, 'bind'], 'function');
    deep;
    (dst, $__.os.oid1)[key, 'bind'] = src;
    (j = +j + 1) - 1;
    j < jj;
    key = TAJS_restrictToType(keys[j, 11], 'string');
    src = TAJS_restrictToType((obj, $__.os.oid52)[key, 'toJson'], 'function');
    deep;
    (dst, $__.os.oid1)[key, 'toJson'] = src;
    (j = +j + 1) - 1;
    j < jj;
    key = TAJS_restrictToType(keys[j, 12], 'string');
    src = TAJS_restrictToType((obj, $__.os.oid52)[key, 'fromJson'], 'function');
    deep;
    (dst, $__.os.oid1)[key, 'fromJson'] = src;
    (j = +j + 1) - 1;
    j < jj;
    key = TAJS_restrictToType(keys[j, 13], 'string');
    src = TAJS_restrictToType((obj, $__.os.oid52)[key, 'identity'], 'function');
    deep;
    (dst, $__.os.oid1)[key, 'identity'] = src;
    (j = +j + 1) - 1;
    j < jj;
    key = TAJS_restrictToType(keys[j, 14], 'string');
    src = TAJS_restrictToType((obj, $__.os.oid52)[key, 'isUndefined'], 'function');
    deep;
    (dst, $__.os.oid1)[key, 'isUndefined'] = src;
    (j = +j + 1) - 1;
    j < jj;
    key = TAJS_restrictToType(keys[j, 15], 'string');
    src = TAJS_restrictToType((obj, $__.os.oid52)[key, 'isDefined'], 'function');
    deep;
    (dst, $__.os.oid1)[key, 'isDefined'] = src;
    (j = +j + 1) - 1;
    j < jj;
    key = TAJS_restrictToType(keys[j, 16], 'string');
    src = TAJS_restrictToType((obj, $__.os.oid52)[key, 'isString'], 'function');
    deep;
    (dst, $__.os.oid1)[key, 'isString'] = src;
    (j = +j + 1) - 1;
    j < jj;
    key = TAJS_restrictToType(keys[j, 17], 'string');
    src = TAJS_restrictToType((obj, $__.os.oid52)[key, 'isFunction'], 'function');
    deep;
    (dst, $__.os.oid1)[key, 'isFunction'] = src;
    (j = +j + 1) - 1;
    j < jj;
    key = TAJS_restrictToType(keys[j, 18], 'string');
    src = TAJS_restrictToType((obj, $__.os.oid52)[key, 'isObject'], 'function');
    deep;
    (dst, $__.os.oid1)[key, 'isObject'] = src;
    (j = +j + 1) - 1;
    j < jj;
    key = TAJS_restrictToType(keys[j, 19], 'string');
    src = TAJS_restrictToType((obj, $__.os.oid52)[key, 'isNumber'], 'function');
    deep;
    (dst, $__.os.oid1)[key, 'isNumber'] = src;
    (j = +j + 1) - 1;
    j < jj;
    key = TAJS_restrictToType(keys[j, 20], 'string');
    src = TAJS_restrictToType((obj, $__.os.oid52)[key, 'isElement'], 'function');
    deep;
    (dst, $__.os.oid1)[key, 'isElement'] = src;
    (j = +j + 1) - 1;
    j < jj;
    key = TAJS_restrictToType(keys[j, 21], 'string');
    src = TAJS_restrictToType((obj, $__.os.oid52)[key, 'isArray'], 'function');
    deep;
    (dst, $__.os.oid1)[key, 'isArray'] = src;
    (j = +j + 1) - 1;
    j < jj;
    key = TAJS_restrictToType(keys[j, 22], 'string');
    src = ((obj, $__.os.oid52)[key, 'version'], $__.os.oid2);
    deep;
    (dst, $__.os.oid1)[key, 'version'] = src;
    (j = +j + 1) - 1;
    j < jj;
    key = TAJS_restrictToType(keys[j, 23], 'string');
    src = TAJS_restrictToType((obj, $__.os.oid52)[key, 'isDate'], 'function');
    deep;
    (dst, $__.os.oid1)[key, 'isDate'] = src;
    (j = +j + 1) - 1;
    j < jj;
    key = TAJS_restrictToType(keys[j, 24], 'string');
    src = TAJS_restrictToType((obj, $__.os.oid52)[key, 'lowercase'], 'function');
    deep;
    (dst, $__.os.oid1)[key, 'lowercase'] = src;
    (j = +j + 1) - 1;
    j < jj;
    key = TAJS_restrictToType(keys[j, 25], 'string');
    src = TAJS_restrictToType((obj, $__.os.oid52)[key, 'uppercase'], 'function');
    deep;
    (dst, $__.os.oid1)[key, 'uppercase'] = src;
    (j = +j + 1) - 1;
    j < jj;
    key = TAJS_restrictToType(keys[j, 26], 'string');
    src = ((obj, $__.os.oid52)[key, 'callbacks'], $__.os.oid51);
    deep;
    (dst, $__.os.oid1)[key, 'callbacks'] = src;
    (j = +j + 1) - 1;
    j < jj;
    key = TAJS_restrictToType(keys[j, 27], 'string');
    src = TAJS_restrictToType((obj, $__.os.oid52)[key, 'getTestability'], 'function');
    deep;
    (dst, $__.os.oid1)[key, 'getTestability'] = src;
    (j = +j + 1) - 1;
    j < jj;
    key = TAJS_restrictToType(keys[j, 28], 'string');
    src = TAJS_restrictToType((obj, $__.os.oid52)[key, 'reloadWithDebugInfo'], 'function');
    deep;
    (dst, $__.os.oid1)[key, 'reloadWithDebugInfo'] = src;
    (j = +j + 1) - 1;
    j < jj;
    key = TAJS_restrictToType(keys[j, 29], 'string');
    src = TAJS_restrictToType((obj, $__.os.oid52)[key, '$$minErr'], 'function');
    deep;
    (dst, $__.os.oid1)[key, '$$minErr'] = src;
    (j = +j + 1) - 1;
    j < jj;
    key = TAJS_restrictToType(keys[j, 30], 'string');
    src = TAJS_restrictToType((obj, $__.os.oid52)[key, '$$csp'], 'function');
    deep;
    (dst, $__.os.oid1)[key, '$$csp'] = src;
    (j = +j + 1) - 1;
    j < jj;
    key = TAJS_restrictToType(keys[j, 31], 'string');
    src = TAJS_restrictToType((obj, $__.os.oid52)[key, '$$encodeUriSegment'], 'function');
    deep;
    (dst, $__.os.oid1)[key, '$$encodeUriSegment'] = src;
    (j = +j + 1) - 1;
    j < jj;
    key = TAJS_restrictToType(keys[j, 32], 'string');
    src = TAJS_restrictToType((obj, $__.os.oid52)[key, '$$encodeUriQuery'], 'function');
    deep;
    (dst, $__.os.oid1)[key, '$$encodeUriQuery'] = src;
    (j = +j + 1) - 1;
    j < jj;
    key = TAJS_restrictToType(keys[j, 33], 'string');
    src = TAJS_restrictToType((obj, $__.os.oid52)[key, '$$stringify'], 'function');
    deep;
    (dst, $__.os.oid1)[key, '$$stringify'] = src;
    (j = +j + 1) - 1;
    j < jj;
    i = +i + 1;
    i < ii;
    (setHashKey, $__.fs.setHashKey_12)(dst, h, 0, true, $__.uid);
    return dst;
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
h = dst.$$hashKey;
for (var i = 0, ii = objs.length; i < ii; ++i) {
    obj = objs[i];
    if (!isObject(obj) && !isFunction(obj))
        continue;
    keys = Object.keys(obj);
    for (var j = 0, jj = keys.length; j < jj; j++) {
        key = keys[j];
        src = obj[key];
        if (deep && isObject(src)) {
            if (isDate(src)) {
                dst[key] = new Date(src.valueOf());
            } else if (isRegExp(src)) {
                dst[key] = new RegExp(src);
            } else if (src.nodeName) {
                dst[key] = src.cloneNode(true);
            } else if (isElement(src)) {
                dst[key] = src.clone();
            } else {
                if (!isObject(dst[key]))
                    dst[key] = isArray(src) ? [] : {};
                baseExtend(dst[key], [src], true);
            }
        } else {
            dst[key] = src;
        }
    }
}
setHashKey(dst, h);
return dst;});
    extend = ($__.fs.extend_14 = function extend(dst) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
dst = arguments[0];
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    return (baseExtend, $__.fs.baseExtend_13)(dst, function $__lt5(res) {
        res.length = 1;
        if (res.length != 1)
            TAJS_dumpValue('Possible loss of precision');
        return res;
        ;
        TAJS_makeContextSensitive($__lt5, -2);
    }(slice['call'](arguments, 1)), false, 0, true, $__.uid);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return baseExtend(dst, slice.call(arguments, 1), false);});
    merge = ($__.fs.merge_15 = function merge(dst) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
dst = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return baseExtend(dst, slice.call(arguments, 1), true);});
    toInt = ($__.fs.toInt_16 = function toInt(str) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
str = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return parseInt(str, 10);});
    inherit = ($__.fs.inherit_17 = function inherit(parent, extra) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
parent = arguments[0], extra = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return extend(Object.create(parent), extra);});
    noop = ($__.fs.noop_18 = function noop() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');});
    identity = ($__.fs.identity_19 = function identity($) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
$ = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return $;});
    valueFn = ($__.fs.valueFn_20 = function valueFn(value) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
value = arguments[0];
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    return ($__.fs.valueRef_513 = function valueRef() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return value;});
case 1:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 1);
    return ($__.fs.valueRef_514 = function valueRef() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return value;});
case 2:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 2);
    return ($__.fs.valueRef_516 = function valueRef() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return value;});
case 3:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 3);
    return ($__.fs.valueRef_578 = function valueRef() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return value;});
case 4:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 4);
    return ($__.fs.valueRef_595 = function valueRef() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return value;});
case 5:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 5);
    return ($__.fs.valueRef_620 = function valueRef() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return value;});
case 6:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 6);
    return ($__.fs.valueRef_650 = function valueRef() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return value;});
case 7:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 7);
    return ($__.fs.valueRef_658 = function valueRef() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return value;});
case 8:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 8);
    return ($__.fs.valueRef_661 = function valueRef() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return value;});
case 9:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 9);
    return ($__.fs.valueRef_663 = function valueRef() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return value;});
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return function valueRef() {
    return value;
};});
    hasCustomToString = ($__.fs.hasCustomToString_21 = function hasCustomToString(obj) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
obj = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return isFunction(obj.toString) && obj.toString !== toString;});
    isUndefined = ($__.fs.isUndefined_22 = function isUndefined(value) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
value = arguments[0];
switch (vvv_switch) {
case 0:
case 1:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(0 <= vvv_switch && vvv_switch <= 1);
    return typeof value === 'undefined';
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return typeof value === 'undefined';});
    isDefined = ($__.fs.isDefined_23 = function isDefined(value) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
value = arguments[0];
switch (vvv_switch) {
case 0:
case 1:
case 2:
case 3:
case 4:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(0 <= vvv_switch && vvv_switch <= 4);
    return typeof value !== 'undefined';
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return typeof value !== 'undefined';});
    isObject = ($__.fs.isObject_24 = function isObject(value) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
value = arguments[0];
switch (vvv_switch) {
case 0:
case 1:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(0 <= vvv_switch && vvv_switch <= 1);
    return value !== null, typeof value === 'object';
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return value !== null && typeof value === 'object';});
    isBlankObject = ($__.fs.isBlankObject_25 = function isBlankObject(value) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
value = arguments[0];
switch (vvv_switch) {
case 0:
case 1:
case 2:
case 3:
case 4:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(0 <= vvv_switch && vvv_switch <= 4);
    return (value !== null, typeof value === 'object'), !getPrototypeOf(value);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return value !== null && typeof value === 'object' && !getPrototypeOf(value);});
    isString = ($__.fs.isString_26 = function isString(value) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
value = arguments[0];
switch (vvv_switch) {
case 0:
case 1:
case 2:
case 3:
case 4:
case 5:
case 6:
case 7:
case 8:
case 9:
case 10:
case 11:
case 12:
case 13:
case 14:
case 15:
case 16:
case 17:
case 18:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(0 <= vvv_switch && vvv_switch <= 18);
    return typeof value === 'string';
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return typeof value === 'string';});
    isNumber = ($__.fs.isNumber_27 = function isNumber(value) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
value = arguments[0];
switch (vvv_switch) {
case 0:
case 1:
case 2:
case 3:
case 4:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(0 <= vvv_switch && vvv_switch <= 4);
    return typeof value === 'number';
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return typeof value === 'number';});
    isDate = ($__.fs.isDate_28 = function isDate(value) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
value = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return toString.call(value) === '[object Date]';});
    isFunction = ($__.fs.isFunction_29 = function isFunction(value) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
value = arguments[0];
switch (vvv_switch) {
case 0:
case 1:
case 2:
case 3:
case 4:
case 5:
case 6:
case 7:
case 8:
case 9:
case 10:
case 11:
case 12:
case 13:
case 14:
case 15:
case 16:
case 17:
case 18:
case 19:
case 20:
case 21:
case 22:
case 23:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(0 <= vvv_switch && vvv_switch <= 23);
    return typeof value === 'function';
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return typeof value === 'function';});
    isRegExp = ($__.fs.isRegExp_30 = function isRegExp(value) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
value = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return toString.call(value) === '[object RegExp]';});
    isWindow = ($__.fs.isWindow_31 = function isWindow(obj) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
obj = arguments[0];
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    return obj, TAJS_restrictToType((obj, $__.os.oid10).window, 'undefined') === obj;
case 1:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 1);
    return obj, TAJS_restrictToType((obj, $__.os.oid11).window, 'undefined') === obj;
case 2:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 2);
    return obj, TAJS_restrictToType((obj, $__.os.oid12).window, 'undefined') === obj;
case 3:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 3);
    return obj, TAJS_restrictToType((obj, $__.os.oid7).window, 'undefined') === obj;
case 4:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 4);
    return obj, TAJS_restrictToType((obj, $__.os.oid9).window, 'undefined') === obj;
case 5:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 5);
    return obj, TAJS_restrictToType(obj.window, 'undefined') === obj;
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return obj && obj.window === obj;});
    isScope = ($__.fs.isScope_32 = function isScope(obj) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
obj = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return obj && obj.$evalAsync && obj.$watch;});
    isFile = ($__.fs.isFile_33 = function isFile(obj) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
obj = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return toString.call(obj) === '[object File]';});
    isFormData = ($__.fs.isFormData_34 = function isFormData(obj) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
obj = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return toString.call(obj) === '[object FormData]';});
    isBlob = ($__.fs.isBlob_35 = function isBlob(obj) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
obj = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return toString.call(obj) === '[object Blob]';});
    isBoolean = ($__.fs.isBoolean_36 = function isBoolean(value) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
value = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return typeof value === 'boolean';});
    isPromiseLike = ($__.fs.isPromiseLike_37 = function isPromiseLike(obj) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
obj = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return obj && isFunction(obj.then);});
    isTypedArray = ($__.fs.isTypedArray_38 = function isTypedArray(value) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
value = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return value && isNumber(value.length) && TYPED_ARRAY_REGEXP.test(toString.call(value));});
    isArrayBuffer = ($__.fs.isArrayBuffer_39 = function isArrayBuffer(obj) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
obj = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return toString.call(obj) === '[object ArrayBuffer]';});
    isElement = ($__.fs.isElement_40 = function isElement(node) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
node = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return !!(node && (node.nodeName || node.prop && node.attr && node.find));});
    makeMap = ($__.fs.makeMap_41 = function makeMap(str) {
var vvv_return, vvv_switch, obj, items, i;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
str = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
obj = {};
items = str.split(',');
for (i = 0; i < items.length; i++) {
    obj[items[i]] = true;
}
return obj;});
    nodeName_ = ($__.fs.nodeName__42 = function nodeName_(element) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
element = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return lowercase(element.nodeName || element[0] && element[0].nodeName);});
    includes = ($__.fs.includes_43 = function includes(array, obj) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
array = arguments[0], obj = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return Array.prototype.indexOf.call(array, obj) !== -1;});
    arrayRemove = ($__.fs.arrayRemove_44 = function arrayRemove(array, value) {
var vvv_return, vvv_switch, index;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
array = arguments[0], value = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
index = array.indexOf(value);
if (index >= 0) {
    array.splice(index, 1);
}
return index;});
    copy = ($__.fs.copy_45 = function copy(source, destination, maxDepth) {
var vvv_return, vvv_switch, stackSource, stackDest, copyRecurse, copyElement, copyType;
copyRecurse = function copyRecurse(source, destination, maxDepth) {
    maxDepth--;
    if (maxDepth < 0) {
        return '...';
    }
    var h = destination.$$hashKey;
    var key;
    if (isArray(source)) {
        for (var i = 0, ii = source.length; i < ii; i++) {
            destination.push(copyElement(source[i], maxDepth));
        }
    } else if (isBlankObject(source)) {
        for (key in source) {
            destination[key] = copyElement(source[key], maxDepth);
        }
    } else if (source && typeof source.hasOwnProperty === 'function') {
        for (key in source) {
            if (source.hasOwnProperty(key)) {
                destination[key] = copyElement(source[key], maxDepth);
            }
        }
    } else {
        for (key in source) {
            if (hasOwnProperty.call(source, key)) {
                destination[key] = copyElement(source[key], maxDepth);
            }
        }
    }
    setHashKey(destination, h);
    return destination;
};
copyElement = function copyElement(source, maxDepth) {
    if (!isObject(source)) {
        return source;
    }
    var index = stackSource.indexOf(source);
    if (index !== -1) {
        return stackDest[index];
    }
    if (isWindow(source) || isScope(source)) {
        throw ngMinErr('cpws', 'Can\'t copy! Making copies of Window or Scope instances is not supported.');
    }
    var needsRecurse = false;
    var destination = copyType(source);
    if (destination === undefined) {
        destination = isArray(source) ? [] : Object.create(getPrototypeOf(source));
        needsRecurse = true;
    }
    stackSource.push(source);
    stackDest.push(destination);
    return needsRecurse ? copyRecurse(source, destination, maxDepth) : destination;
};
copyType = function copyType(source) {
    switch (toString.call(source)) {
    case '[object Int8Array]':
    case '[object Int16Array]':
    case '[object Int32Array]':
    case '[object Float32Array]':
    case '[object Float64Array]':
    case '[object Uint8Array]':
    case '[object Uint8ClampedArray]':
    case '[object Uint16Array]':
    case '[object Uint32Array]':
        return new source.constructor(copyElement(source.buffer), source.byteOffset, source.length);
    case '[object ArrayBuffer]':
        if (!source.slice) {
            var copied = new ArrayBuffer(source.byteLength);
            new Uint8Array(copied).set(new Uint8Array(source));
            return copied;
        }
        return source.slice(0);
    case '[object Boolean]':
    case '[object Number]':
    case '[object String]':
    case '[object Date]':
        return new source.constructor(source.valueOf());
    case '[object RegExp]':
        var re = new RegExp(source.source, source.toString().match(/[^\/]*$/)[0]);
        re.lastIndex = source.lastIndex;
        return re;
    case '[object Blob]':
        return new source.constructor([source], {
            type: source.type
        });
    }
    if (isFunction(source.cloneNode)) {
        return source.cloneNode(true);
    }
};
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
source = arguments[0], destination = arguments[1], maxDepth = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
stackSource = [];
stackDest = [];
maxDepth = isValidObjectMaxDepth(maxDepth) ? maxDepth : NaN;
if (destination) {
    if (isTypedArray(destination) || isArrayBuffer(destination)) {
        throw ngMinErr('cpta', 'Can\'t copy! TypedArray destination cannot be mutated.');
    }
    if (source === destination) {
        throw ngMinErr('cpi', 'Can\'t copy! Source and destination are identical.');
    }
    if (isArray(destination)) {
        destination.length = 0;
    } else {
        forEach(destination, function (value, key) {
            if (key !== '$$hashKey') {
                delete destination[key];
            }
        });
    }
    stackSource.push(source);
    stackDest.push(destination);
    return copyRecurse(source, destination, maxDepth);
}
return copyElement(source, maxDepth);});
    equals = ($__.fs.equals_46 = function equals(o1, o2) {
var vvv_return, vvv_switch, t1, t2, length, key, keySet;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
o1 = arguments[0], o2 = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (o1 === o2)
    return true;
if (o1 === null || o2 === null)
    return false;
if (o1 !== o1 && o2 !== o2)
    return true;
t1 = typeof o1;
t2 = typeof o2;
if (t1 === t2 && t1 === 'object') {
    if (isArray(o1)) {
        if (!isArray(o2))
            return false;
        if ((length = o1.length) === o2.length) {
            for (key = 0; key < length; key++) {
                if (!equals(o1[key], o2[key]))
                    return false;
            }
            return true;
        }
    } else if (isDate(o1)) {
        if (!isDate(o2))
            return false;
        return equals(o1.getTime(), o2.getTime());
    } else if (isRegExp(o1)) {
        if (!isRegExp(o2))
            return false;
        return o1.toString() === o2.toString();
    } else {
        if (isScope(o1) || isScope(o2) || isWindow(o1) || isWindow(o2) || isArray(o2) || isDate(o2) || isRegExp(o2))
            return false;
        keySet = createMap();
        for (key in o1) {
            if (key.charAt(0) === '$' || isFunction(o1[key]))
                continue;
            if (!equals(o1[key], o2[key]))
                return false;
            keySet[key] = true;
        }
        for (key in o2) {
            if (!(key in keySet) && key.charAt(0) !== '$' && isDefined(o2[key]) && !isFunction(o2[key]))
                return false;
        }
        return true;
    }
}
return false;});
    concat = ($__.fs.concat_47 = function concat(array1, array2, index) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
array1 = arguments[0], array2 = arguments[1], index = arguments[2];
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    return function $__lt9(res) {
        res.length = 1;
        if (res.length != 1)
            TAJS_dumpValue('Possible loss of precision');
        return res;
        ;
        TAJS_makeContextSensitive($__lt9, -2);
    }(array1['concat'](function $__lt8(res) {
        res.length = 1;
        if (res.length != 1)
            TAJS_dumpValue('Possible loss of precision');
        return res;
        ;
        TAJS_makeContextSensitive($__lt8, -2);
    }(slice['call'](array2, index))));
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return array1.concat(slice.call(array2, index));});
    sliceArgs = ($__.fs.sliceArgs_48 = function sliceArgs(args, startIndex) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
args = arguments[0], startIndex = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return slice.call(args, startIndex || 0);});
    bind = ($__.fs.bind_49 = function bind(self, fn) {
var vvv_return, vvv_switch, curryArgs;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
self = arguments[0], fn = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
curryArgs = arguments.length > 2 ? sliceArgs(arguments, 2) : [];
if (isFunction(fn) && !(fn instanceof RegExp)) {
    return curryArgs.length ? function () {
        return arguments.length ? fn.apply(self, concat(curryArgs, arguments, 0)) : fn.apply(self, curryArgs);
    } : function () {
        return arguments.length ? fn.apply(self, arguments) : fn.call(self);
    };
} else {
    return fn;
}});
    toJsonReplacer = ($__.fs.toJsonReplacer_50 = function toJsonReplacer(key, value) {
var vvv_return, vvv_switch, val;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
key = arguments[0], value = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
val = value;
if (typeof key === 'string' && key.charAt(0) === '$' && key.charAt(1) === '$') {
    val = undefined;
} else if (isWindow(value)) {
    val = '$WINDOW';
} else if (value && window.document === value) {
    val = '$DOCUMENT';
} else if (isScope(value)) {
    val = '$SCOPE';
}
return val;});
    toJson = ($__.fs.toJson_51 = function toJson(obj, pretty) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
obj = arguments[0], pretty = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (isUndefined(obj))
    return undefined;
if (!isNumber(pretty)) {
    pretty = pretty ? 2 : null;
}
return JSON.stringify(obj, toJsonReplacer, pretty);});
    fromJson = ($__.fs.fromJson_52 = function fromJson(json) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
json = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return isString(json) ? JSON.parse(json) : json;});
    timezoneToOffset = ($__.fs.timezoneToOffset_53 = function timezoneToOffset(timezone, fallback) {
var vvv_return, vvv_switch, requestedTimezoneOffset;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
timezone = arguments[0], fallback = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
timezone = timezone.replace(ALL_COLONS, '');
requestedTimezoneOffset = Date.parse('Jan 01, 1970 00:00:00 ' + timezone) / 60000;
return isNumberNaN(requestedTimezoneOffset) ? fallback : requestedTimezoneOffset;});
    addDateMinutes = ($__.fs.addDateMinutes_54 = function addDateMinutes(date, minutes) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
date = arguments[0], minutes = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
date = new Date(date.getTime());
date.setMinutes(date.getMinutes() + minutes);
return date;});
    convertTimezoneToLocal = ($__.fs.convertTimezoneToLocal_55 = function convertTimezoneToLocal(date, timezone, reverse) {
var vvv_return, vvv_switch, dateTimezoneOffset, timezoneOffset;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
date = arguments[0], timezone = arguments[1], reverse = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
reverse = reverse ? -1 : 1;
dateTimezoneOffset = date.getTimezoneOffset();
timezoneOffset = timezoneToOffset(timezone, dateTimezoneOffset);
return addDateMinutes(date, reverse * (timezoneOffset - dateTimezoneOffset));});
    startingTag = ($__.fs.startingTag_56 = function startingTag(element) {
var vvv_return, vvv_switch, elemHtml;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
element = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
element = jqLite(element).clone();
try {
    element.empty();
} catch (e) {
}
elemHtml = jqLite('<div>').append(element).html();
try {
    return element[0].nodeType === NODE_TYPE_TEXT ? lowercase(elemHtml) : elemHtml.match(/^(<[^>]+>)/)[1].replace(/^<([\w-]+)/, function (match, nodeName) {
        return '<' + lowercase(nodeName);
    });
} catch (e) {
    return lowercase(elemHtml);
}});
    tryDecodeURIComponent = ($__.fs.tryDecodeURIComponent_57 = function tryDecodeURIComponent(value) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
value = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
try {
    return decodeURIComponent(value);
} catch (e) {
}});
    parseKeyValue = ($__.fs.parseKeyValue_58 = function parseKeyValue(keyValue) {
var vvv_return, vvv_switch, obj;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
keyValue = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
obj = {};
forEach((keyValue || '').split('&'), function (keyValue) {
    var splitPoint, key, val;
    if (keyValue) {
        key = keyValue = keyValue.replace(/\+/g, '%20');
        splitPoint = keyValue.indexOf('=');
        if (splitPoint !== -1) {
            key = keyValue.substring(0, splitPoint);
            val = keyValue.substring(splitPoint + 1);
        }
        key = tryDecodeURIComponent(key);
        if (isDefined(key)) {
            val = isDefined(val) ? tryDecodeURIComponent(val) : true;
            if (!hasOwnProperty.call(obj, key)) {
                obj[key] = val;
            } else if (isArray(obj[key])) {
                obj[key].push(val);
            } else {
                obj[key] = [
                    obj[key],
                    val
                ];
            }
        }
    }
});
return obj;});
    toKeyValue = ($__.fs.toKeyValue_59 = function toKeyValue(obj) {
var vvv_return, vvv_switch, parts;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
obj = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
parts = [];
forEach(obj, function (value, key) {
    if (isArray(value)) {
        forEach(value, function (arrayValue) {
            parts.push(encodeUriQuery(key, true) + (arrayValue === true ? '' : '=' + encodeUriQuery(arrayValue, true)));
        });
    } else {
        parts.push(encodeUriQuery(key, true) + (value === true ? '' : '=' + encodeUriQuery(value, true)));
    }
});
return parts.length ? parts.join('&') : '';});
    encodeUriSegment = ($__.fs.encodeUriSegment_60 = function encodeUriSegment(val) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
val = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return encodeUriQuery(val, true).replace(/%26/gi, '&').replace(/%3D/gi, '=').replace(/%2B/gi, '+');});
    encodeUriQuery = ($__.fs.encodeUriQuery_61 = function encodeUriQuery(val, pctEncodeSpaces) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
val = arguments[0], pctEncodeSpaces = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return encodeURIComponent(val).replace(/%40/gi, '@').replace(/%3A/gi, ':').replace(/%24/g, '$').replace(/%2C/gi, ',').replace(/%3B/gi, ';').replace(/%20/g, pctEncodeSpaces ? '%20' : '+');});
    getNgAttribute = ($__.fs.getNgAttribute_62 = function getNgAttribute(element, ngAttr) {
var vvv_return, vvv_switch, attr, i, ii;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
element = arguments[0], ngAttr = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
ii = ngAttrPrefixes.length;
for (i = 0; i < ii; ++i) {
    attr = ngAttrPrefixes[i] + ngAttr;
    if (isString(attr = element.getAttribute(attr))) {
        return attr;
    }
}
return null;});
    allowAutoBootstrap = ($__.fs.allowAutoBootstrap_63 = function allowAutoBootstrap(document) {
var vvv_return, vvv_switch, script, attributes, srcs;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
document = arguments[0];
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    script = TAJS_restrictToType(document.currentScript, 'HTMLScriptElement');
    !script;
    !(script instanceof TAJS_restrictToType(window.HTMLScriptElement, 'function'));
    attributes = TAJS_restrictToType(script.attributes, 'object');
    srcs = [
        attributes['getNamedItem']('src'),
        attributes['getNamedItem']('href'),
        attributes['getNamedItem']('xlink:href')
    ];
    return srcs['every']((($__.fs.J$__v3645318688_108_275 = function J$__v3645318688_108(src) {
var vvv_return, vvv_switch, link;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
src = arguments[0];
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    !src;
    !TAJS_restrictToType(src.value, 'string');
    link = document['createElement']('a');
    link.href = TAJS_restrictToType(src.value, 'string');
    TAJS_restrictToType(TAJS_restrictToType(document.location, 'object').origin, 'string') === TAJS_restrictToType(link.origin, 'string');
    return true;
case 1:
case 2:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(1 <= vvv_switch && vvv_switch <= 2);
    !src;
    return true;
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (!src) {
    return true;
}
if (!src.value) {
    return false;
}
link = document.createElement('a');
link.href = src.value;
if (document.location.origin === link.origin) {
    return true;
}
switch (link.protocol) {
case 'http:':
case 'https:':
case 'ftp:':
case 'blob:':
case 'file:':
case 'data:':
    return true;
default:
    return false;
}}, $__.fs.J$__v3645318688_108_275_0 = ((function $_mk($_f, ids, isOneShotEscapingFunction) {
    TAJS_makeContextSensitive($_mk, 1);
    TAJS_makeContextSensitive($_mk, 2);
    var nxt = 0;
    function J$__v3645318688_108(src) {
        arguments[arguments.length] = ids[nxt];
        arguments[arguments.length + 1] = isOneShotEscapingFunction;
        arguments[arguments.length + 2] = $__.uid;
        arguments.length += 3;
        if (!isOneShotEscapingFunction) {
            ++nxt;
        }
        return $_f.apply(this, arguments);
    };
    TAJS_makeContextSensitive(J$__v3645318688_108, -2);
    return J$__v3645318688_108;
})($__.fs.J$__v3645318688_108_275, [0, 1, 2], false)), $__.fs.J$__v3645318688_108_275), $__.fs.J$__v3645318688_108_275_0));
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
script = document.currentScript;
if (!script) {
    return true;
}
if (!(script instanceof window.HTMLScriptElement || script instanceof window.SVGScriptElement)) {
    return false;
}
attributes = script.attributes;
srcs = [
    attributes.getNamedItem('src'),
    attributes.getNamedItem('href'),
    attributes.getNamedItem('xlink:href')
];
return srcs.every(function (src) {
    if (!src) {
        return true;
    }
    if (!src.value) {
        return false;
    }
    var link = document.createElement('a');
    link.href = src.value;
    if (document.location.origin === link.origin) {
        return true;
    }
    switch (link.protocol) {
    case 'http:':
    case 'https:':
    case 'ftp:':
    case 'blob:':
    case 'file:':
    case 'data:':
        return true;
    default:
        return false;
    }
});});
    angularInit = ($__.fs.angularInit_64 = function angularInit(element, bootstrap) {
var vvv_return, vvv_switch, appElement, module, config;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
element = arguments[0], bootstrap = arguments[1];
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    config = $__.os.oid60 = {};
    (forEach, $__.fs.forEach_8)(ngAttrPrefixes, ($__.fs.J$__v3645318688_111_724 = function J$__v3645318688_111(prefix) {
var vvv_return, vvv_switch, name;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
prefix = arguments[0];
switch (vvv_switch) {
case 0:
case 1:
case 2:
case 3:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(0 <= vvv_switch && vvv_switch <= 3);
    name = prefix + 'app';
    !appElement, TAJS_restrictToType(element.hasAttribute, 'undefined');
    return;
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
name = prefix + 'app';
if (!appElement && element.hasAttribute && element.hasAttribute(name)) {
    appElement = element;
    module = element.getAttribute(name);
}}, $__.fs.J$__v3645318688_111_724), 14, true, $__.uid);
    (forEach, $__.fs.forEach_8)(ngAttrPrefixes, ($__.fs.J$__v3645318688_113_725 = function J$__v3645318688_113(prefix) {
var vvv_return, vvv_switch, name, candidate;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
prefix = arguments[0];
switch (vvv_switch) {
case 0:
case 1:
case 2:
case 3:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(0 <= vvv_switch && vvv_switch <= 3);
    name = prefix + 'app';
    !appElement, candidate = element['querySelector']('[' + name['replace'](':', '\\:') + ']');
    return;
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
name = prefix + 'app';
if (!appElement && (candidate = element.querySelector('[' + name.replace(':', '\\:') + ']'))) {
    appElement = candidate;
    module = candidate.getAttribute(name);
}}, $__.fs.J$__v3645318688_113_725), 15, true, $__.uid);
    appElement;
    return;
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
config = {};
forEach(ngAttrPrefixes, function (prefix) {
    var name = prefix + 'app';
    if (!appElement && element.hasAttribute && element.hasAttribute(name)) {
        appElement = element;
        module = element.getAttribute(name);
    }
});
forEach(ngAttrPrefixes, function (prefix) {
    var name = prefix + 'app';
    var candidate;
    if (!appElement && (candidate = element.querySelector('[' + name.replace(':', '\\:') + ']'))) {
        appElement = candidate;
        module = candidate.getAttribute(name);
    }
});
if (appElement) {
    if (!isAutoBootstrapAllowed) {
        window.console.error('Angular: disabling automatic bootstrap. <script> protocol indicates ' + 'an extension, document.location.href does not match.');
        return;
    }
    config.strictDi = getNgAttribute(appElement, 'strict-di') !== null;
    bootstrap(appElement, module ? [module] : [], config);
}});
    bootstrap = ($__.fs.bootstrap_65 = function bootstrap(element, modules, config) {
var vvv_return, vvv_switch, defaultConfig, doBootstrap, NG_ENABLE_DEBUG_INFO, NG_DEFER_BOOTSTRAP;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
element = arguments[0], modules = arguments[1], config = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (!isObject(config))
    config = {};
defaultConfig = {
    strictDi: false
};
config = extend(defaultConfig, config);
doBootstrap = function () {
    element = jqLite(element);
    if (element.injector()) {
        var tag = element[0] === window.document ? 'document' : startingTag(element);
        throw ngMinErr('btstrpd', 'App already bootstrapped with this element \'{0}\'', tag.replace(/</, '&lt;').replace(/>/, '&gt;'));
    }
    modules = modules || [];
    modules.unshift([
        '$provide',
        function ($provide) {
            $provide.value('$rootElement', element);
        }
    ]);
    if (config.debugInfoEnabled) {
        modules.push([
            '$compileProvider',
            function ($compileProvider) {
                $compileProvider.debugInfoEnabled(true);
            }
        ]);
    }
    modules.unshift('ng');
    var injector = createInjector(modules, config.strictDi);
    injector.invoke([
        '$rootScope',
        '$rootElement',
        '$compile',
        '$injector',
        function bootstrapApply(scope, element, compile, injector) {
            scope.$apply(function () {
                element.data('$injector', injector);
                compile(element)(scope);
            });
        }
    ]);
    return injector;
};
NG_ENABLE_DEBUG_INFO = /^NG_ENABLE_DEBUG_INFO!/;
NG_DEFER_BOOTSTRAP = /^NG_DEFER_BOOTSTRAP!/;
if (window && NG_ENABLE_DEBUG_INFO.test(window.name)) {
    config.debugInfoEnabled = true;
    window.name = window.name.replace(NG_ENABLE_DEBUG_INFO, '');
}
if (window && !NG_DEFER_BOOTSTRAP.test(window.name)) {
    return doBootstrap();
}
window.name = window.name.replace(NG_DEFER_BOOTSTRAP, '');
angular.resumeBootstrap = function (extraModules) {
    forEach(extraModules, function (module) {
        modules.push(module);
    });
    return doBootstrap();
};
if (isFunction(angular.resumeDeferredBootstrap)) {
    angular.resumeDeferredBootstrap();
}});
    reloadWithDebugInfo = ($__.fs.reloadWithDebugInfo_66 = function reloadWithDebugInfo() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
window.name = 'NG_ENABLE_DEBUG_INFO!' + window.name;
window.location.reload();});
    getTestability = ($__.fs.getTestability_67 = function getTestability(rootElement) {
var vvv_return, vvv_switch, injector;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
rootElement = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
injector = angular.element(rootElement).injector();
if (!injector) {
    throw ngMinErr('test', 'no injector found for element argument to getTestability');
}
return injector.get('$$testability');});
    snake_case = ($__.fs.snake_case_68 = function snake_case(name, separator) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
name = arguments[0], separator = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
separator = separator || '_';
return name.replace(SNAKE_CASE_REGEXP, function (letter, pos) {
    return (pos ? separator : '') + letter.toLowerCase();
});});
    bindJQuery = ($__.fs.bindJQuery_69 = function bindJQuery() {
var vvv_return, vvv_switch, originalCleanData, jqName;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    bindJQueryFired;
    jqName = (jq, $__.fs.J$__v3645318688_78_274)(0, true, $__.uid);
    jQuery = ((isUndefined, $__.fs.isUndefined_22)(jqName, 0, true, $__.uid), TAJS_restrictToType(window.jQuery, 'undefined'));
    jQuery;
    jqLite = JQLite;
    (angular, $__.os.oid1).element = jqLite;
    bindJQueryFired = true;
    return;
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (bindJQueryFired) {
    return;
}
jqName = jq();
jQuery = isUndefined(jqName) ? window.jQuery : !jqName ? undefined : window[jqName];
if (jQuery && jQuery.fn.on) {
    jqLite = jQuery;
    extend(jQuery.fn, {
        scope: JQLitePrototype.scope,
        isolateScope: JQLitePrototype.isolateScope,
        controller: JQLitePrototype.controller,
        injector: JQLitePrototype.injector,
        inheritedData: JQLitePrototype.inheritedData
    });
    originalCleanData = jQuery.cleanData;
    jQuery.cleanData = function (elems) {
        var events;
        for (var i = 0, elem; (elem = elems[i]) != null; i++) {
            events = jQuery._data(elem, 'events');
            if (events && events.$destroy) {
                jQuery(elem).triggerHandler('$destroy');
            }
        }
        originalCleanData(elems);
    };
} else {
    jqLite = JQLite;
}
angular.element = jqLite;
bindJQueryFired = true;});
    assertArg = ($__.fs.assertArg_70 = function assertArg(arg, name, reason) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
arg = arguments[0], name = arguments[1], reason = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (!arg) {
    throw ngMinErr('areq', 'Argument \'{0}\' is {1}', name || '?', reason || 'required');
}
return arg;});
    assertArgFn = ($__.fs.assertArgFn_71 = function assertArgFn(arg, name, acceptArrayAnnotation) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
arg = arguments[0], name = arguments[1], acceptArrayAnnotation = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (acceptArrayAnnotation && isArray(arg)) {
    arg = arg[arg.length - 1];
}
assertArg(isFunction(arg), name, 'not a function, got ' + (arg && typeof arg === 'object' ? arg.constructor.name || 'Object' : typeof arg));
return arg;});
    assertNotHasOwnProperty = ($__.fs.assertNotHasOwnProperty_72 = function assertNotHasOwnProperty(name, context) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
name = arguments[0], context = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (name === 'hasOwnProperty') {
    throw ngMinErr('badname', 'hasOwnProperty is not a valid {0} name', context);
}});
    getter = ($__.fs.getter_73 = function getter(obj, path, bindFnToScope) {
var vvv_return, vvv_switch, keys, key, lastInstance, len;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
obj = arguments[0], path = arguments[1], bindFnToScope = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (!path)
    return obj;
keys = path.split('.');
lastInstance = obj;
len = keys.length;
for (var i = 0; i < len; i++) {
    key = keys[i];
    if (obj) {
        obj = (lastInstance = obj)[key];
    }
}
if (!bindFnToScope && isFunction(obj)) {
    return bind(lastInstance, obj);
}
return obj;});
    getBlockNodes = ($__.fs.getBlockNodes_74 = function getBlockNodes(nodes) {
var vvv_return, vvv_switch, node, endNode, blockNodes;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
nodes = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
node = nodes[0];
endNode = nodes[nodes.length - 1];
for (var i = 1; node !== endNode && (node = node.nextSibling); i++) {
    if (blockNodes || nodes[i] !== node) {
        if (!blockNodes) {
            blockNodes = jqLite(slice.call(nodes, 0, i));
        }
        blockNodes.push(node);
    }
}
return blockNodes || nodes;});
    createMap = ($__.fs.createMap_75 = function createMap() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
switch (vvv_switch) {
case 0:
case 1:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(0 <= vvv_switch && vvv_switch <= 1);
    return Object['create'](null);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return Object.create(null);});
    stringify = ($__.fs.stringify_76 = function stringify(value) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
value = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (value == null) {
    return '';
}
switch (typeof value) {
case 'string':
    break;
case 'number':
    value = '' + value;
    break;
default:
    if (hasCustomToString(value) && !isArray(value) && !isDate(value)) {
        value = value.toString();
    } else {
        value = toJson(value);
    }
}
return value;});
    setupModuleLoader = ($__.fs.setupModuleLoader_77 = function setupModuleLoader(window) {
var vvv_return, vvv_switch, $injectorMinErr, ngMinErr, ensure, angular;
ensure = function ensure(obj, name, factory) {
    return obj[name] || (obj[name] = factory());
};
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
window = arguments[0];
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    ensure = ($__.fs.ensure_674 = function ensure(obj, name, factory) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
obj = arguments[0], name = arguments[1], factory = arguments[2];
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    return obj[name, 'angular'], $__.os.oid1;
case 1:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 1);
    return TAJS_restrictToType((obj, $__.os.oid1)[name, 'module'], 'undefined'), (obj, $__.os.oid1)[name, 'module'] = (factory, $__.fs.J$__v3645318688_161_677)(0, true, $__.uid);
case 2:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 2);
    return TAJS_restrictToType((obj, $__.os.oid53)[name, 'ng'], 'undefined'), (obj, $__.os.oid53)[name, 'ng'] = (factory, $__.fs.J$__v3645318688_158_681)(0, true, $__.uid);
case 3:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 3);
    return TAJS_restrictToType((obj, $__.os.oid53)[name, 'ngLocale'], 'undefined'), (obj, $__.os.oid53)[name, 'ngLocale'] = (factory, $__.fs.J$__v3645318688_158_700)(0, true, $__.uid);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return obj[name] || (obj[name] = factory());});
    $injectorMinErr = (minErr, $__.fs.minErr_4)('$injector', 15, true, $__.uid);
    ngMinErr = (minErr, $__.fs.minErr_4)('ng', 16, true, $__.uid);
    angular = (ensure, $__.fs.ensure_674)(window, 'angular', Object, 0, true, $__.uid);
    (angular, $__.os.oid1).$$minErr = TAJS_restrictToType((angular, $__.os.oid1).$$minErr, 'function');
    return (ensure, $__.fs.ensure_674)(angular, 'module', ($__.fs.J$__v3645318688_161_677 = function J$__v3645318688_161() {
var vvv_return, vvv_switch, modules;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    modules = $__.os.oid53 = {};
    return ($__.fs.module_678 = function module(name, requires, configFn) {
var vvv_return, vvv_switch, info, assertNotHasOwnProperty;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
name = arguments[0], requires = arguments[1], configFn = arguments[2];
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    info = $__.os.oid54 = {};
    assertNotHasOwnProperty = ($__.fs.J$__v3645318688_146_680 = function J$__v3645318688_146(name, context) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
name = arguments[0], context = arguments[1];
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    name === 'hasOwnProperty';
    return;
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (name === 'hasOwnProperty') {
    throw ngMinErr('badname', 'hasOwnProperty is not a valid {0} name', context);
}});
    (assertNotHasOwnProperty, $__.fs.J$__v3645318688_146_680)(name, 'module', 0, true, $__.uid);
    requires, modules['hasOwnProperty'](name);
    return (ensure, $__.fs.ensure_674)(modules, name, ($__.fs.J$__v3645318688_158_681 = function J$__v3645318688_158() {
var vvv_return, vvv_switch, invokeQueue, configBlocks, runBlocks, config, moduleInstance, invokeLater, invokeLaterAndSetModuleName;
invokeLater = function invokeLater(provider, method, insertMethod, queue) {
    if (!queue)
        queue = invokeQueue;
    return function () {
        queue[insertMethod || 'push']([
            provider,
            method,
            arguments
        ]);
        return moduleInstance;
    };
};
invokeLaterAndSetModuleName = function invokeLaterAndSetModuleName(provider, method, queue) {
    if (!queue)
        queue = invokeQueue;
    return function (recipeName, factoryFunction) {
        if (factoryFunction && isFunction(factoryFunction))
            factoryFunction.$$moduleName = name;
        queue.push([
            provider,
            method,
            arguments
        ]);
        return moduleInstance;
    };
};
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    invokeLater = ($__.fs.invokeLater_682 = function invokeLater(provider, method, insertMethod, queue) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
provider = arguments[0], method = arguments[1], insertMethod = arguments[2], queue = arguments[3];
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    !queue;
    return ($__.fs.J$__v3645318688_152_684 = function J$__v3645318688_152() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    queue[insertMethod]([
        provider,
        method,
        arguments
    ]);
    return moduleInstance;
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
queue[insertMethod || 'push']([
    provider,
    method,
    arguments
]);
return moduleInstance;});
case 1:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 1);
    !queue;
    queue = invokeQueue;
    return ($__.fs.J$__v3645318688_152_689 = function J$__v3645318688_152() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
queue[insertMethod || 'push']([
    provider,
    method,
    arguments
]);
return moduleInstance;});
case 2:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 2);
    !queue;
    queue = invokeQueue;
    return ($__.fs.J$__v3645318688_152_690 = function J$__v3645318688_152() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
queue[insertMethod || 'push']([
    provider,
    method,
    arguments
]);
return moduleInstance;});
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (!queue)
    queue = invokeQueue;
return function () {
    queue[insertMethod || 'push']([
        provider,
        method,
        arguments
    ]);
    return moduleInstance;
};});
    invokeLaterAndSetModuleName = ($__.fs.invokeLaterAndSetModuleName_683 = function invokeLaterAndSetModuleName(provider, method, queue) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
provider = arguments[0], method = arguments[1], queue = arguments[2];
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    !queue;
    queue = invokeQueue;
    return ($__.fs.J$__v3645318688_155_686 = function J$__v3645318688_155(recipeName, factoryFunction) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
recipeName = arguments[0], factoryFunction = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (factoryFunction && isFunction(factoryFunction))
    factoryFunction.$$moduleName = name;
queue.push([
    provider,
    method,
    arguments
]);
return moduleInstance;});
case 1:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 1);
    !queue;
    queue = invokeQueue;
    return ($__.fs.J$__v3645318688_155_687 = function J$__v3645318688_155(recipeName, factoryFunction) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
recipeName = arguments[0], factoryFunction = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (factoryFunction && isFunction(factoryFunction))
    factoryFunction.$$moduleName = name;
queue.push([
    provider,
    method,
    arguments
]);
return moduleInstance;});
case 2:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 2);
    !queue;
    queue = invokeQueue;
    return ($__.fs.J$__v3645318688_155_688 = function J$__v3645318688_155(recipeName, factoryFunction) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
recipeName = arguments[0], factoryFunction = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (factoryFunction && isFunction(factoryFunction))
    factoryFunction.$$moduleName = name;
queue.push([
    provider,
    method,
    arguments
]);
return moduleInstance;});
case 3:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 3);
    !queue;
    return ($__.fs.J$__v3645318688_155_691 = function J$__v3645318688_155(recipeName, factoryFunction) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
recipeName = arguments[0], factoryFunction = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (factoryFunction && isFunction(factoryFunction))
    factoryFunction.$$moduleName = name;
queue.push([
    provider,
    method,
    arguments
]);
return moduleInstance;});
case 4:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 4);
    !queue;
    queue = invokeQueue;
    return ($__.fs.J$__v3645318688_155_692 = function J$__v3645318688_155(recipeName, factoryFunction) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
recipeName = arguments[0], factoryFunction = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (factoryFunction && isFunction(factoryFunction))
    factoryFunction.$$moduleName = name;
queue.push([
    provider,
    method,
    arguments
]);
return moduleInstance;});
case 5:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 5);
    !queue;
    queue = invokeQueue;
    return ($__.fs.J$__v3645318688_155_693 = function J$__v3645318688_155(recipeName, factoryFunction) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
recipeName = arguments[0], factoryFunction = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (factoryFunction && isFunction(factoryFunction))
    factoryFunction.$$moduleName = name;
queue.push([
    provider,
    method,
    arguments
]);
return moduleInstance;});
case 6:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 6);
    !queue;
    queue = invokeQueue;
    return ($__.fs.J$__v3645318688_155_694 = function J$__v3645318688_155(recipeName, factoryFunction) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
recipeName = arguments[0], factoryFunction = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (factoryFunction && isFunction(factoryFunction))
    factoryFunction.$$moduleName = name;
queue.push([
    provider,
    method,
    arguments
]);
return moduleInstance;});
case 7:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 7);
    !queue;
    queue = invokeQueue;
    return ($__.fs.J$__v3645318688_155_695 = function J$__v3645318688_155(recipeName, factoryFunction) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
recipeName = arguments[0], factoryFunction = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (factoryFunction && isFunction(factoryFunction))
    factoryFunction.$$moduleName = name;
queue.push([
    provider,
    method,
    arguments
]);
return moduleInstance;});
case 8:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 8);
    !queue;
    queue = invokeQueue;
    return ($__.fs.J$__v3645318688_155_696 = function J$__v3645318688_155(recipeName, factoryFunction) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
recipeName = arguments[0], factoryFunction = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (factoryFunction && isFunction(factoryFunction))
    factoryFunction.$$moduleName = name;
queue.push([
    provider,
    method,
    arguments
]);
return moduleInstance;});
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (!queue)
    queue = invokeQueue;
return function (recipeName, factoryFunction) {
    if (factoryFunction && isFunction(factoryFunction))
        factoryFunction.$$moduleName = name;
    queue.push([
        provider,
        method,
        arguments
    ]);
    return moduleInstance;
};});
    !requires;
    invokeQueue = [];
    configBlocks = [];
    runBlocks = [];
    config = (invokeLater, $__.fs.invokeLater_682)('$injector', 'invoke', 'push', configBlocks, 0, true, $__.uid);
    moduleInstance = $__.os.oid55 = {
        '_invokeQueue': invokeQueue,
        '_configBlocks': configBlocks,
        '_runBlocks': runBlocks,
        'info': ($__.fs.J$__v3645318688_148_685 = function J$__v3645318688_148(value) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
value = arguments[0];
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    (isDefined, $__.fs.isDefined_23)(value, 1, true, $__.uid);
    !(isObject, $__.fs.isObject_24)(value, 1, true, $__.uid);
    info = value;
    return this;
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (isDefined(value)) {
    if (!isObject(value))
        throw ngMinErr('aobj', 'Argument \'{0}\' must be an object', 'value');
    info = value;
    return this;
}
return info;}),
        'requires': requires,
        'name': name,
        'provider': (invokeLaterAndSetModuleName, $__.fs.invokeLaterAndSetModuleName_683)('$provide', 'provider', 0, true, $__.uid),
        'factory': (invokeLaterAndSetModuleName, $__.fs.invokeLaterAndSetModuleName_683)('$provide', 'factory', 1, true, $__.uid),
        'service': (invokeLaterAndSetModuleName, $__.fs.invokeLaterAndSetModuleName_683)('$provide', 'service', 2, true, $__.uid),
        'value': (invokeLater, $__.fs.invokeLater_682)('$provide', 'value', 1, true, $__.uid),
        'constant': (invokeLater, $__.fs.invokeLater_682)('$provide', 'constant', 'unshift', 2, true, $__.uid),
        'decorator': (invokeLaterAndSetModuleName, $__.fs.invokeLaterAndSetModuleName_683)('$provide', 'decorator', configBlocks, 3, true, $__.uid),
        'animation': (invokeLaterAndSetModuleName, $__.fs.invokeLaterAndSetModuleName_683)('$animateProvider', 'register', 4, true, $__.uid),
        'filter': (invokeLaterAndSetModuleName, $__.fs.invokeLaterAndSetModuleName_683)('$filterProvider', 'register', 5, true, $__.uid),
        'controller': (invokeLaterAndSetModuleName, $__.fs.invokeLaterAndSetModuleName_683)('$controllerProvider', 'register', 6, true, $__.uid),
        'directive': (invokeLaterAndSetModuleName, $__.fs.invokeLaterAndSetModuleName_683)('$compileProvider', 'directive', 7, true, $__.uid),
        'component': (invokeLaterAndSetModuleName, $__.fs.invokeLaterAndSetModuleName_683)('$compileProvider', 'component', 8, true, $__.uid),
        'config': config,
        'run': ($__.fs.J$__v3645318688_150_697 = function J$__v3645318688_150(block) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
block = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
runBlocks.push(block);
return this;})
    };
    configFn;
    (config, $__.fs.J$__v3645318688_152_684)(configFn, 0, true, $__.uid);
    return moduleInstance;
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (!requires) {
    throw $injectorMinErr('nomod', 'Module \'{0}\' is not available! You either misspelled ' + 'the module name or forgot to load it. If registering a module ensure that you ' + 'specify the dependencies as the second argument.', name);
}
invokeQueue = [];
configBlocks = [];
runBlocks = [];
config = invokeLater('$injector', 'invoke', 'push', configBlocks);
moduleInstance = {
    _invokeQueue: invokeQueue,
    _configBlocks: configBlocks,
    _runBlocks: runBlocks,
    info: function (value) {
        if (isDefined(value)) {
            if (!isObject(value))
                throw ngMinErr('aobj', 'Argument \'{0}\' must be an object', 'value');
            info = value;
            return this;
        }
        return info;
    },
    requires: requires,
    name: name,
    provider: invokeLaterAndSetModuleName('$provide', 'provider'),
    factory: invokeLaterAndSetModuleName('$provide', 'factory'),
    service: invokeLaterAndSetModuleName('$provide', 'service'),
    value: invokeLater('$provide', 'value'),
    constant: invokeLater('$provide', 'constant', 'unshift'),
    decorator: invokeLaterAndSetModuleName('$provide', 'decorator', configBlocks),
    animation: invokeLaterAndSetModuleName('$animateProvider', 'register'),
    filter: invokeLaterAndSetModuleName('$filterProvider', 'register'),
    controller: invokeLaterAndSetModuleName('$controllerProvider', 'register'),
    directive: invokeLaterAndSetModuleName('$compileProvider', 'directive'),
    component: invokeLaterAndSetModuleName('$compileProvider', 'component'),
    config: config,
    run: function (block) {
        runBlocks.push(block);
        return this;
    }
};
if (configFn) {
    config(configFn);
}
return moduleInstance;}), 2, true, $__.uid);
case 1:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 1);
    info = $__.os.oid57 = {};
    assertNotHasOwnProperty = ($__.fs.J$__v3645318688_146_699 = function J$__v3645318688_146(name, context) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
name = arguments[0], context = arguments[1];
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    name === 'hasOwnProperty';
    return;
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (name === 'hasOwnProperty') {
    throw ngMinErr('badname', 'hasOwnProperty is not a valid {0} name', context);
}});
    (assertNotHasOwnProperty, $__.fs.J$__v3645318688_146_699)(name, 'module', 0, true, $__.uid);
    requires, modules['hasOwnProperty'](name);
    return (ensure, $__.fs.ensure_674)(modules, name, ($__.fs.J$__v3645318688_158_700 = function J$__v3645318688_158() {
var vvv_return, vvv_switch, invokeQueue, configBlocks, runBlocks, config, moduleInstance, invokeLater, invokeLaterAndSetModuleName;
invokeLater = function invokeLater(provider, method, insertMethod, queue) {
    if (!queue)
        queue = invokeQueue;
    return function () {
        queue[insertMethod || 'push']([
            provider,
            method,
            arguments
        ]);
        return moduleInstance;
    };
};
invokeLaterAndSetModuleName = function invokeLaterAndSetModuleName(provider, method, queue) {
    if (!queue)
        queue = invokeQueue;
    return function (recipeName, factoryFunction) {
        if (factoryFunction && isFunction(factoryFunction))
            factoryFunction.$$moduleName = name;
        queue.push([
            provider,
            method,
            arguments
        ]);
        return moduleInstance;
    };
};
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    invokeLater = ($__.fs.invokeLater_701 = function invokeLater(provider, method, insertMethod, queue) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
provider = arguments[0], method = arguments[1], insertMethod = arguments[2], queue = arguments[3];
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    !queue;
    return ($__.fs.J$__v3645318688_152_703 = function J$__v3645318688_152() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    queue[insertMethod]([
        provider,
        method,
        arguments
    ]);
    return moduleInstance;
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
queue[insertMethod || 'push']([
    provider,
    method,
    arguments
]);
return moduleInstance;});
case 1:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 1);
    !queue;
    queue = invokeQueue;
    return ($__.fs.J$__v3645318688_152_708 = function J$__v3645318688_152() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
queue[insertMethod || 'push']([
    provider,
    method,
    arguments
]);
return moduleInstance;});
case 2:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 2);
    !queue;
    queue = invokeQueue;
    return ($__.fs.J$__v3645318688_152_709 = function J$__v3645318688_152() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
queue[insertMethod || 'push']([
    provider,
    method,
    arguments
]);
return moduleInstance;});
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (!queue)
    queue = invokeQueue;
return function () {
    queue[insertMethod || 'push']([
        provider,
        method,
        arguments
    ]);
    return moduleInstance;
};});
    invokeLaterAndSetModuleName = ($__.fs.invokeLaterAndSetModuleName_702 = function invokeLaterAndSetModuleName(provider, method, queue) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
provider = arguments[0], method = arguments[1], queue = arguments[2];
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    !queue;
    queue = invokeQueue;
    return ($__.fs.J$__v3645318688_155_705 = function J$__v3645318688_155(recipeName, factoryFunction) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
recipeName = arguments[0], factoryFunction = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (factoryFunction && isFunction(factoryFunction))
    factoryFunction.$$moduleName = name;
queue.push([
    provider,
    method,
    arguments
]);
return moduleInstance;});
case 1:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 1);
    !queue;
    queue = invokeQueue;
    return ($__.fs.J$__v3645318688_155_706 = function J$__v3645318688_155(recipeName, factoryFunction) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
recipeName = arguments[0], factoryFunction = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (factoryFunction && isFunction(factoryFunction))
    factoryFunction.$$moduleName = name;
queue.push([
    provider,
    method,
    arguments
]);
return moduleInstance;});
case 2:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 2);
    !queue;
    queue = invokeQueue;
    return ($__.fs.J$__v3645318688_155_707 = function J$__v3645318688_155(recipeName, factoryFunction) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
recipeName = arguments[0], factoryFunction = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (factoryFunction && isFunction(factoryFunction))
    factoryFunction.$$moduleName = name;
queue.push([
    provider,
    method,
    arguments
]);
return moduleInstance;});
case 3:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 3);
    !queue;
    return ($__.fs.J$__v3645318688_155_710 = function J$__v3645318688_155(recipeName, factoryFunction) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
recipeName = arguments[0], factoryFunction = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (factoryFunction && isFunction(factoryFunction))
    factoryFunction.$$moduleName = name;
queue.push([
    provider,
    method,
    arguments
]);
return moduleInstance;});
case 4:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 4);
    !queue;
    queue = invokeQueue;
    return ($__.fs.J$__v3645318688_155_711 = function J$__v3645318688_155(recipeName, factoryFunction) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
recipeName = arguments[0], factoryFunction = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (factoryFunction && isFunction(factoryFunction))
    factoryFunction.$$moduleName = name;
queue.push([
    provider,
    method,
    arguments
]);
return moduleInstance;});
case 5:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 5);
    !queue;
    queue = invokeQueue;
    return ($__.fs.J$__v3645318688_155_712 = function J$__v3645318688_155(recipeName, factoryFunction) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
recipeName = arguments[0], factoryFunction = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (factoryFunction && isFunction(factoryFunction))
    factoryFunction.$$moduleName = name;
queue.push([
    provider,
    method,
    arguments
]);
return moduleInstance;});
case 6:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 6);
    !queue;
    queue = invokeQueue;
    return ($__.fs.J$__v3645318688_155_713 = function J$__v3645318688_155(recipeName, factoryFunction) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
recipeName = arguments[0], factoryFunction = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (factoryFunction && isFunction(factoryFunction))
    factoryFunction.$$moduleName = name;
queue.push([
    provider,
    method,
    arguments
]);
return moduleInstance;});
case 7:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 7);
    !queue;
    queue = invokeQueue;
    return ($__.fs.J$__v3645318688_155_714 = function J$__v3645318688_155(recipeName, factoryFunction) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
recipeName = arguments[0], factoryFunction = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (factoryFunction && isFunction(factoryFunction))
    factoryFunction.$$moduleName = name;
queue.push([
    provider,
    method,
    arguments
]);
return moduleInstance;});
case 8:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 8);
    !queue;
    queue = invokeQueue;
    return ($__.fs.J$__v3645318688_155_715 = function J$__v3645318688_155(recipeName, factoryFunction) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
recipeName = arguments[0], factoryFunction = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (factoryFunction && isFunction(factoryFunction))
    factoryFunction.$$moduleName = name;
queue.push([
    provider,
    method,
    arguments
]);
return moduleInstance;});
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (!queue)
    queue = invokeQueue;
return function (recipeName, factoryFunction) {
    if (factoryFunction && isFunction(factoryFunction))
        factoryFunction.$$moduleName = name;
    queue.push([
        provider,
        method,
        arguments
    ]);
    return moduleInstance;
};});
    !requires;
    invokeQueue = [];
    configBlocks = [];
    runBlocks = [];
    config = (invokeLater, $__.fs.invokeLater_701)('$injector', 'invoke', 'push', configBlocks, 0, true, $__.uid);
    moduleInstance = $__.os.oid58 = {
        '_invokeQueue': invokeQueue,
        '_configBlocks': configBlocks,
        '_runBlocks': runBlocks,
        'info': ($__.fs.J$__v3645318688_148_704 = function J$__v3645318688_148(value) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
value = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (isDefined(value)) {
    if (!isObject(value))
        throw ngMinErr('aobj', 'Argument \'{0}\' must be an object', 'value');
    info = value;
    return this;
}
return info;}),
        'requires': requires,
        'name': name,
        'provider': (invokeLaterAndSetModuleName, $__.fs.invokeLaterAndSetModuleName_702)('$provide', 'provider', 0, true, $__.uid),
        'factory': (invokeLaterAndSetModuleName, $__.fs.invokeLaterAndSetModuleName_702)('$provide', 'factory', 1, true, $__.uid),
        'service': (invokeLaterAndSetModuleName, $__.fs.invokeLaterAndSetModuleName_702)('$provide', 'service', 2, true, $__.uid),
        'value': (invokeLater, $__.fs.invokeLater_701)('$provide', 'value', 1, true, $__.uid),
        'constant': (invokeLater, $__.fs.invokeLater_701)('$provide', 'constant', 'unshift', 2, true, $__.uid),
        'decorator': (invokeLaterAndSetModuleName, $__.fs.invokeLaterAndSetModuleName_702)('$provide', 'decorator', configBlocks, 3, true, $__.uid),
        'animation': (invokeLaterAndSetModuleName, $__.fs.invokeLaterAndSetModuleName_702)('$animateProvider', 'register', 4, true, $__.uid),
        'filter': (invokeLaterAndSetModuleName, $__.fs.invokeLaterAndSetModuleName_702)('$filterProvider', 'register', 5, true, $__.uid),
        'controller': (invokeLaterAndSetModuleName, $__.fs.invokeLaterAndSetModuleName_702)('$controllerProvider', 'register', 6, true, $__.uid),
        'directive': (invokeLaterAndSetModuleName, $__.fs.invokeLaterAndSetModuleName_702)('$compileProvider', 'directive', 7, true, $__.uid),
        'component': (invokeLaterAndSetModuleName, $__.fs.invokeLaterAndSetModuleName_702)('$compileProvider', 'component', 8, true, $__.uid),
        'config': config,
        'run': ($__.fs.J$__v3645318688_150_716 = function J$__v3645318688_150(block) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
block = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
runBlocks.push(block);
return this;})
    };
    configFn;
    (config, $__.fs.J$__v3645318688_152_703)(configFn, 0, true, $__.uid);
    return moduleInstance;
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (!requires) {
    throw $injectorMinErr('nomod', 'Module \'{0}\' is not available! You either misspelled ' + 'the module name or forgot to load it. If registering a module ensure that you ' + 'specify the dependencies as the second argument.', name);
}
invokeQueue = [];
configBlocks = [];
runBlocks = [];
config = invokeLater('$injector', 'invoke', 'push', configBlocks);
moduleInstance = {
    _invokeQueue: invokeQueue,
    _configBlocks: configBlocks,
    _runBlocks: runBlocks,
    info: function (value) {
        if (isDefined(value)) {
            if (!isObject(value))
                throw ngMinErr('aobj', 'Argument \'{0}\' must be an object', 'value');
            info = value;
            return this;
        }
        return info;
    },
    requires: requires,
    name: name,
    provider: invokeLaterAndSetModuleName('$provide', 'provider'),
    factory: invokeLaterAndSetModuleName('$provide', 'factory'),
    service: invokeLaterAndSetModuleName('$provide', 'service'),
    value: invokeLater('$provide', 'value'),
    constant: invokeLater('$provide', 'constant', 'unshift'),
    decorator: invokeLaterAndSetModuleName('$provide', 'decorator', configBlocks),
    animation: invokeLaterAndSetModuleName('$animateProvider', 'register'),
    filter: invokeLaterAndSetModuleName('$filterProvider', 'register'),
    controller: invokeLaterAndSetModuleName('$controllerProvider', 'register'),
    directive: invokeLaterAndSetModuleName('$compileProvider', 'directive'),
    component: invokeLaterAndSetModuleName('$compileProvider', 'component'),
    config: config,
    run: function (block) {
        runBlocks.push(block);
        return this;
    }
};
if (configFn) {
    config(configFn);
}
return moduleInstance;}), 3, true, $__.uid);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
info = {};
assertNotHasOwnProperty = function (name, context) {
    if (name === 'hasOwnProperty') {
        throw ngMinErr('badname', 'hasOwnProperty is not a valid {0} name', context);
    }
};
assertNotHasOwnProperty(name, 'module');
if (requires && modules.hasOwnProperty(name)) {
    modules[name] = null;
}
return ensure(modules, name, function () {
    if (!requires) {
        throw $injectorMinErr('nomod', 'Module \'{0}\' is not available! You either misspelled ' + 'the module name or forgot to load it. If registering a module ensure that you ' + 'specify the dependencies as the second argument.', name);
    }
    var invokeQueue = [];
    var configBlocks = [];
    var runBlocks = [];
    var config = invokeLater('$injector', 'invoke', 'push', configBlocks);
    var moduleInstance = {
        _invokeQueue: invokeQueue,
        _configBlocks: configBlocks,
        _runBlocks: runBlocks,
        info: function (value) {
            if (isDefined(value)) {
                if (!isObject(value))
                    throw ngMinErr('aobj', 'Argument \'{0}\' must be an object', 'value');
                info = value;
                return this;
            }
            return info;
        },
        requires: requires,
        name: name,
        provider: invokeLaterAndSetModuleName('$provide', 'provider'),
        factory: invokeLaterAndSetModuleName('$provide', 'factory'),
        service: invokeLaterAndSetModuleName('$provide', 'service'),
        value: invokeLater('$provide', 'value'),
        constant: invokeLater('$provide', 'constant', 'unshift'),
        decorator: invokeLaterAndSetModuleName('$provide', 'decorator', configBlocks),
        animation: invokeLaterAndSetModuleName('$animateProvider', 'register'),
        filter: invokeLaterAndSetModuleName('$filterProvider', 'register'),
        controller: invokeLaterAndSetModuleName('$controllerProvider', 'register'),
        directive: invokeLaterAndSetModuleName('$compileProvider', 'directive'),
        component: invokeLaterAndSetModuleName('$compileProvider', 'component'),
        config: config,
        run: function (block) {
            runBlocks.push(block);
            return this;
        }
    };
    if (configFn) {
        config(configFn);
    }
    return moduleInstance;
    function invokeLater(provider, method, insertMethod, queue) {
        if (!queue)
            queue = invokeQueue;
        return function () {
            queue[insertMethod || 'push']([
                provider,
                method,
                arguments
            ]);
            return moduleInstance;
        };
    }
    function invokeLaterAndSetModuleName(provider, method, queue) {
        if (!queue)
            queue = invokeQueue;
        return function (recipeName, factoryFunction) {
            if (factoryFunction && isFunction(factoryFunction))
                factoryFunction.$$moduleName = name;
            queue.push([
                provider,
                method,
                arguments
            ]);
            return moduleInstance;
        };
    }
});});
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
modules = {};
return function module(name, requires, configFn) {
    var info = {};
    var assertNotHasOwnProperty = function (name, context) {
        if (name === 'hasOwnProperty') {
            throw ngMinErr('badname', 'hasOwnProperty is not a valid {0} name', context);
        }
    };
    assertNotHasOwnProperty(name, 'module');
    if (requires && modules.hasOwnProperty(name)) {
        modules[name] = null;
    }
    return ensure(modules, name, function () {
        if (!requires) {
            throw $injectorMinErr('nomod', 'Module \'{0}\' is not available! You either misspelled ' + 'the module name or forgot to load it. If registering a module ensure that you ' + 'specify the dependencies as the second argument.', name);
        }
        var invokeQueue = [];
        var configBlocks = [];
        var runBlocks = [];
        var config = invokeLater('$injector', 'invoke', 'push', configBlocks);
        var moduleInstance = {
            _invokeQueue: invokeQueue,
            _configBlocks: configBlocks,
            _runBlocks: runBlocks,
            info: function (value) {
                if (isDefined(value)) {
                    if (!isObject(value))
                        throw ngMinErr('aobj', 'Argument \'{0}\' must be an object', 'value');
                    info = value;
                    return this;
                }
                return info;
            },
            requires: requires,
            name: name,
            provider: invokeLaterAndSetModuleName('$provide', 'provider'),
            factory: invokeLaterAndSetModuleName('$provide', 'factory'),
            service: invokeLaterAndSetModuleName('$provide', 'service'),
            value: invokeLater('$provide', 'value'),
            constant: invokeLater('$provide', 'constant', 'unshift'),
            decorator: invokeLaterAndSetModuleName('$provide', 'decorator', configBlocks),
            animation: invokeLaterAndSetModuleName('$animateProvider', 'register'),
            filter: invokeLaterAndSetModuleName('$filterProvider', 'register'),
            controller: invokeLaterAndSetModuleName('$controllerProvider', 'register'),
            directive: invokeLaterAndSetModuleName('$compileProvider', 'directive'),
            component: invokeLaterAndSetModuleName('$compileProvider', 'component'),
            config: config,
            run: function (block) {
                runBlocks.push(block);
                return this;
            }
        };
        if (configFn) {
            config(configFn);
        }
        return moduleInstance;
        function invokeLater(provider, method, insertMethod, queue) {
            if (!queue)
                queue = invokeQueue;
            return function () {
                queue[insertMethod || 'push']([
                    provider,
                    method,
                    arguments
                ]);
                return moduleInstance;
            };
        }
        function invokeLaterAndSetModuleName(provider, method, queue) {
            if (!queue)
                queue = invokeQueue;
            return function (recipeName, factoryFunction) {
                if (factoryFunction && isFunction(factoryFunction))
                    factoryFunction.$$moduleName = name;
                queue.push([
                    provider,
                    method,
                    arguments
                ]);
                return moduleInstance;
            };
        }
    });
};}), 1, true, $__.uid);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
$injectorMinErr = minErr('$injector');
ngMinErr = minErr('ng');
angular = ensure(window, 'angular', Object);
angular.$$minErr = angular.$$minErr || minErr;
return ensure(angular, 'module', function () {
    var modules = {};
    return function module(name, requires, configFn) {
        var info = {};
        var assertNotHasOwnProperty = function (name, context) {
            if (name === 'hasOwnProperty') {
                throw ngMinErr('badname', 'hasOwnProperty is not a valid {0} name', context);
            }
        };
        assertNotHasOwnProperty(name, 'module');
        if (requires && modules.hasOwnProperty(name)) {
            modules[name] = null;
        }
        return ensure(modules, name, function () {
            if (!requires) {
                throw $injectorMinErr('nomod', 'Module \'{0}\' is not available! You either misspelled ' + 'the module name or forgot to load it. If registering a module ensure that you ' + 'specify the dependencies as the second argument.', name);
            }
            var invokeQueue = [];
            var configBlocks = [];
            var runBlocks = [];
            var config = invokeLater('$injector', 'invoke', 'push', configBlocks);
            var moduleInstance = {
                _invokeQueue: invokeQueue,
                _configBlocks: configBlocks,
                _runBlocks: runBlocks,
                info: function (value) {
                    if (isDefined(value)) {
                        if (!isObject(value))
                            throw ngMinErr('aobj', 'Argument \'{0}\' must be an object', 'value');
                        info = value;
                        return this;
                    }
                    return info;
                },
                requires: requires,
                name: name,
                provider: invokeLaterAndSetModuleName('$provide', 'provider'),
                factory: invokeLaterAndSetModuleName('$provide', 'factory'),
                service: invokeLaterAndSetModuleName('$provide', 'service'),
                value: invokeLater('$provide', 'value'),
                constant: invokeLater('$provide', 'constant', 'unshift'),
                decorator: invokeLaterAndSetModuleName('$provide', 'decorator', configBlocks),
                animation: invokeLaterAndSetModuleName('$animateProvider', 'register'),
                filter: invokeLaterAndSetModuleName('$filterProvider', 'register'),
                controller: invokeLaterAndSetModuleName('$controllerProvider', 'register'),
                directive: invokeLaterAndSetModuleName('$compileProvider', 'directive'),
                component: invokeLaterAndSetModuleName('$compileProvider', 'component'),
                config: config,
                run: function (block) {
                    runBlocks.push(block);
                    return this;
                }
            };
            if (configFn) {
                config(configFn);
            }
            return moduleInstance;
            function invokeLater(provider, method, insertMethod, queue) {
                if (!queue)
                    queue = invokeQueue;
                return function () {
                    queue[insertMethod || 'push']([
                        provider,
                        method,
                        arguments
                    ]);
                    return moduleInstance;
                };
            }
            function invokeLaterAndSetModuleName(provider, method, queue) {
                if (!queue)
                    queue = invokeQueue;
                return function (recipeName, factoryFunction) {
                    if (factoryFunction && isFunction(factoryFunction))
                        factoryFunction.$$moduleName = name;
                    queue.push([
                        provider,
                        method,
                        arguments
                    ]);
                    return moduleInstance;
                };
            }
        });
    };
});});
    shallowCopy = ($__.fs.shallowCopy_78 = function shallowCopy(src, dst) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
src = arguments[0], dst = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (isArray(src)) {
    dst = dst || [];
    for (var i = 0, ii = src.length; i < ii; i++) {
        dst[i] = src[i];
    }
} else if (isObject(src)) {
    dst = dst || {};
    for (var key in src) {
        if (!(key.charAt(0) === '$' && key.charAt(1) === '$')) {
            dst[key] = src[key];
        }
    }
}
return dst || src;});
    serializeObject = ($__.fs.serializeObject_79 = function serializeObject(obj, maxDepth) {
var vvv_return, vvv_switch, seen;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
obj = arguments[0], maxDepth = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
seen = [];
if (isValidObjectMaxDepth(maxDepth)) {
    obj = copy(obj, null, maxDepth);
}
return JSON.stringify(obj, function (key, val) {
    val = toJsonReplacer(key, val);
    if (isObject(val)) {
        if (seen.indexOf(val) >= 0)
            return '...';
        seen.push(val);
    }
    return val;
});});
    toDebugString = ($__.fs.toDebugString_80 = function toDebugString(obj, maxDepth) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
obj = arguments[0], maxDepth = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (typeof obj === 'function') {
    return obj.toString().replace(/ \{[\s\S]*$/, '');
} else if (isUndefined(obj)) {
    return 'undefined';
} else if (typeof obj !== 'string') {
    return serializeObject(obj, maxDepth);
}
return obj;});
    publishExternalAPI = ($__.fs.publishExternalAPI_81 = function publishExternalAPI(angular) {
var vvv_return, vvv_switch, vvv_tmp0;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
angular = arguments[0];
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    (extend, $__.fs.extend_14)(angular, $__.os.oid52 = {
        'errorHandlingConfig': errorHandlingConfig,
        'bootstrap': bootstrap,
        'copy': copy,
        'extend': extend,
        'merge': merge,
        'equals': equals,
        'element': jqLite,
        'forEach': forEach,
        'injector': createInjector,
        'noop': noop,
        'bind': bind,
        'toJson': toJson,
        'fromJson': fromJson,
        'identity': identity,
        'isUndefined': isUndefined,
        'isDefined': isDefined,
        'isString': isString,
        'isFunction': isFunction,
        'isObject': isObject,
        'isNumber': isNumber,
        'isElement': isElement,
        'isArray': isArray,
        'version': version,
        'isDate': isDate,
        'lowercase': lowercase,
        'uppercase': uppercase,
        'callbacks': $__.os.oid51 = {
            '$$counter': 0
        },
        'getTestability': getTestability,
        'reloadWithDebugInfo': reloadWithDebugInfo,
        '$$minErr': minErr,
        '$$csp': csp,
        '$$encodeUriSegment': encodeUriSegment,
        '$$encodeUriQuery': encodeUriQuery,
        '$$stringify': stringify
    }, 0, true, $__.uid);
    angularModule = (setupModuleLoader, $__.fs.setupModuleLoader_77)(window, 0, true, $__.uid);
    vvv_tmp0 = (angularModule, $__.fs.module_678)('ng', ['ngLocale'], [
        '$provide',
        ($__.fs.ngModule_679 = function ngModule($provide) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
$provide = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
$provide.provider({
    $$sanitizeUri: $$SanitizeUriProvider
});
$provide.provider('$compile', $CompileProvider).directive({
    a: htmlAnchorDirective,
    input: inputDirective,
    textarea: inputDirective,
    form: formDirective,
    script: scriptDirective,
    select: selectDirective,
    option: optionDirective,
    ngBind: ngBindDirective,
    ngBindHtml: ngBindHtmlDirective,
    ngBindTemplate: ngBindTemplateDirective,
    ngClass: ngClassDirective,
    ngClassEven: ngClassEvenDirective,
    ngClassOdd: ngClassOddDirective,
    ngCloak: ngCloakDirective,
    ngController: ngControllerDirective,
    ngForm: ngFormDirective,
    ngHide: ngHideDirective,
    ngIf: ngIfDirective,
    ngInclude: ngIncludeDirective,
    ngInit: ngInitDirective,
    ngNonBindable: ngNonBindableDirective,
    ngPluralize: ngPluralizeDirective,
    ngRepeat: ngRepeatDirective,
    ngShow: ngShowDirective,
    ngStyle: ngStyleDirective,
    ngSwitch: ngSwitchDirective,
    ngSwitchWhen: ngSwitchWhenDirective,
    ngSwitchDefault: ngSwitchDefaultDirective,
    ngOptions: ngOptionsDirective,
    ngTransclude: ngTranscludeDirective,
    ngModel: ngModelDirective,
    ngList: ngListDirective,
    ngChange: ngChangeDirective,
    pattern: patternDirective,
    ngPattern: patternDirective,
    required: requiredDirective,
    ngRequired: requiredDirective,
    minlength: minlengthDirective,
    ngMinlength: minlengthDirective,
    maxlength: maxlengthDirective,
    ngMaxlength: maxlengthDirective,
    ngValue: ngValueDirective,
    ngModelOptions: ngModelOptionsDirective
}).directive({
    ngInclude: ngIncludeFillContentDirective
}).directive(ngAttributeAliasDirectives).directive(ngEventDirectives);
$provide.provider({
    $anchorScroll: $AnchorScrollProvider,
    $animate: $AnimateProvider,
    $animateCss: $CoreAnimateCssProvider,
    $$animateJs: $$CoreAnimateJsProvider,
    $$animateQueue: $$CoreAnimateQueueProvider,
    $$AnimateRunner: $$AnimateRunnerFactoryProvider,
    $$animateAsyncRun: $$AnimateAsyncRunFactoryProvider,
    $browser: $BrowserProvider,
    $cacheFactory: $CacheFactoryProvider,
    $controller: $ControllerProvider,
    $document: $DocumentProvider,
    $$isDocumentHidden: $$IsDocumentHiddenProvider,
    $exceptionHandler: $ExceptionHandlerProvider,
    $filter: $FilterProvider,
    $$forceReflow: $$ForceReflowProvider,
    $interpolate: $InterpolateProvider,
    $interval: $IntervalProvider,
    $http: $HttpProvider,
    $httpParamSerializer: $HttpParamSerializerProvider,
    $httpParamSerializerJQLike: $HttpParamSerializerJQLikeProvider,
    $httpBackend: $HttpBackendProvider,
    $xhrFactory: $xhrFactoryProvider,
    $jsonpCallbacks: $jsonpCallbacksProvider,
    $location: $LocationProvider,
    $log: $LogProvider,
    $parse: $ParseProvider,
    $rootScope: $RootScopeProvider,
    $q: $QProvider,
    $$q: $$QProvider,
    $sce: $SceProvider,
    $sceDelegate: $SceDelegateProvider,
    $sniffer: $SnifferProvider,
    $templateCache: $TemplateCacheProvider,
    $templateRequest: $TemplateRequestProvider,
    $$testability: $$TestabilityProvider,
    $timeout: $TimeoutProvider,
    $window: $WindowProvider,
    $$rAF: $$RAFProvider,
    $$jqLite: $$jqLiteProvider,
    $$Map: $$MapProvider,
    $$cookieReader: $$CookieReaderProvider
});})
    ], 0, true, $__.uid), 'info', $__.fs.J$__v3645318688_148_685.call(vvv_tmp0, $__.os.oid56 = {
        'angularVersion': '1.6.3'
    }, 0, true, $__.uid);
    return;
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
extend(angular, {
    'errorHandlingConfig': errorHandlingConfig,
    'bootstrap': bootstrap,
    'copy': copy,
    'extend': extend,
    'merge': merge,
    'equals': equals,
    'element': jqLite,
    'forEach': forEach,
    'injector': createInjector,
    'noop': noop,
    'bind': bind,
    'toJson': toJson,
    'fromJson': fromJson,
    'identity': identity,
    'isUndefined': isUndefined,
    'isDefined': isDefined,
    'isString': isString,
    'isFunction': isFunction,
    'isObject': isObject,
    'isNumber': isNumber,
    'isElement': isElement,
    'isArray': isArray,
    'version': version,
    'isDate': isDate,
    'lowercase': lowercase,
    'uppercase': uppercase,
    'callbacks': {
        $$counter: 0
    },
    'getTestability': getTestability,
    'reloadWithDebugInfo': reloadWithDebugInfo,
    '$$minErr': minErr,
    '$$csp': csp,
    '$$encodeUriSegment': encodeUriSegment,
    '$$encodeUriQuery': encodeUriQuery,
    '$$stringify': stringify
});
angularModule = setupModuleLoader(window);
angularModule('ng', ['ngLocale'], [
    '$provide',
    function ngModule($provide) {
        $provide.provider({
            $$sanitizeUri: $$SanitizeUriProvider
        });
        $provide.provider('$compile', $CompileProvider).directive({
            a: htmlAnchorDirective,
            input: inputDirective,
            textarea: inputDirective,
            form: formDirective,
            script: scriptDirective,
            select: selectDirective,
            option: optionDirective,
            ngBind: ngBindDirective,
            ngBindHtml: ngBindHtmlDirective,
            ngBindTemplate: ngBindTemplateDirective,
            ngClass: ngClassDirective,
            ngClassEven: ngClassEvenDirective,
            ngClassOdd: ngClassOddDirective,
            ngCloak: ngCloakDirective,
            ngController: ngControllerDirective,
            ngForm: ngFormDirective,
            ngHide: ngHideDirective,
            ngIf: ngIfDirective,
            ngInclude: ngIncludeDirective,
            ngInit: ngInitDirective,
            ngNonBindable: ngNonBindableDirective,
            ngPluralize: ngPluralizeDirective,
            ngRepeat: ngRepeatDirective,
            ngShow: ngShowDirective,
            ngStyle: ngStyleDirective,
            ngSwitch: ngSwitchDirective,
            ngSwitchWhen: ngSwitchWhenDirective,
            ngSwitchDefault: ngSwitchDefaultDirective,
            ngOptions: ngOptionsDirective,
            ngTransclude: ngTranscludeDirective,
            ngModel: ngModelDirective,
            ngList: ngListDirective,
            ngChange: ngChangeDirective,
            pattern: patternDirective,
            ngPattern: patternDirective,
            required: requiredDirective,
            ngRequired: requiredDirective,
            minlength: minlengthDirective,
            ngMinlength: minlengthDirective,
            maxlength: maxlengthDirective,
            ngMaxlength: maxlengthDirective,
            ngValue: ngValueDirective,
            ngModelOptions: ngModelOptionsDirective
        }).directive({
            ngInclude: ngIncludeFillContentDirective
        }).directive(ngAttributeAliasDirectives).directive(ngEventDirectives);
        $provide.provider({
            $anchorScroll: $AnchorScrollProvider,
            $animate: $AnimateProvider,
            $animateCss: $CoreAnimateCssProvider,
            $$animateJs: $$CoreAnimateJsProvider,
            $$animateQueue: $$CoreAnimateQueueProvider,
            $$AnimateRunner: $$AnimateRunnerFactoryProvider,
            $$animateAsyncRun: $$AnimateAsyncRunFactoryProvider,
            $browser: $BrowserProvider,
            $cacheFactory: $CacheFactoryProvider,
            $controller: $ControllerProvider,
            $document: $DocumentProvider,
            $$isDocumentHidden: $$IsDocumentHiddenProvider,
            $exceptionHandler: $ExceptionHandlerProvider,
            $filter: $FilterProvider,
            $$forceReflow: $$ForceReflowProvider,
            $interpolate: $InterpolateProvider,
            $interval: $IntervalProvider,
            $http: $HttpProvider,
            $httpParamSerializer: $HttpParamSerializerProvider,
            $httpParamSerializerJQLike: $HttpParamSerializerJQLikeProvider,
            $httpBackend: $HttpBackendProvider,
            $xhrFactory: $xhrFactoryProvider,
            $jsonpCallbacks: $jsonpCallbacksProvider,
            $location: $LocationProvider,
            $log: $LogProvider,
            $parse: $ParseProvider,
            $rootScope: $RootScopeProvider,
            $q: $QProvider,
            $$q: $$QProvider,
            $sce: $SceProvider,
            $sceDelegate: $SceDelegateProvider,
            $sniffer: $SnifferProvider,
            $templateCache: $TemplateCacheProvider,
            $templateRequest: $TemplateRequestProvider,
            $$testability: $$TestabilityProvider,
            $timeout: $TimeoutProvider,
            $window: $WindowProvider,
            $$rAF: $$RAFProvider,
            $$jqLite: $$jqLiteProvider,
            $$Map: $$MapProvider,
            $$cookieReader: $$CookieReaderProvider
        });
    }
]).info({
    angularVersion: '1.6.3'
});});
    jqNextId = ($__.fs.jqNextId_82 = function jqNextId() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return ++jqId;});
    cssKebabToCamel = ($__.fs.cssKebabToCamel_83 = function cssKebabToCamel(name) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
name = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return kebabToCamel(name.replace(MS_HACK_REGEXP, 'ms-'));});
    fnCamelCaseReplace = ($__.fs.fnCamelCaseReplace_84 = function fnCamelCaseReplace(all, letter) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
all = arguments[0], letter = arguments[1];
switch (vvv_switch) {
case 0:
case 1:
case 2:
case 3:
case 4:
case 5:
case 6:
case 7:
case 8:
case 9:
case 10:
case 11:
case 12:
case 13:
case 14:
case 15:
case 16:
case 17:
case 18:
case 19:
case 20:
case 21:
case 22:
case 23:
case 24:
case 25:
case 26:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(0 <= vvv_switch && vvv_switch <= 26);
    return letter['toUpperCase']();
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return letter.toUpperCase();}, $__.fs.fnCamelCaseReplace_84_121 = ((function $_mk($_f, ids, isOneShotEscapingFunction) {
    TAJS_makeContextSensitive($_mk, 1);
    TAJS_makeContextSensitive($_mk, 2);
    var nxt = 0;
    function fnCamelCaseReplace(all, letter) {
        arguments[arguments.length] = ids[nxt];
        arguments[arguments.length + 1] = isOneShotEscapingFunction;
        arguments[arguments.length + 2] = $__.uid;
        arguments.length += 3;
        if (!isOneShotEscapingFunction) {
            ++nxt;
        }
        return $_f.apply(this, arguments);
    };
    TAJS_makeContextSensitive(fnCamelCaseReplace, -2);
    return fnCamelCaseReplace;
})($__.fs.fnCamelCaseReplace_84, [0], false)), $__.fs.fnCamelCaseReplace_84_123 = ((function $_mk($_f, ids, isOneShotEscapingFunction) {
    TAJS_makeContextSensitive($_mk, 1);
    TAJS_makeContextSensitive($_mk, 2);
    var nxt = 0;
    function fnCamelCaseReplace(all, letter) {
        arguments[arguments.length] = ids[nxt];
        arguments[arguments.length + 1] = isOneShotEscapingFunction;
        arguments[arguments.length + 2] = $__.uid;
        arguments.length += 3;
        if (!isOneShotEscapingFunction) {
            ++nxt;
        }
        return $_f.apply(this, arguments);
    };
    TAJS_makeContextSensitive(fnCamelCaseReplace, -2);
    return fnCamelCaseReplace;
})($__.fs.fnCamelCaseReplace_84, [1], false)), $__.fs.fnCamelCaseReplace_84_125 = ((function $_mk($_f, ids, isOneShotEscapingFunction) {
    TAJS_makeContextSensitive($_mk, 1);
    TAJS_makeContextSensitive($_mk, 2);
    var nxt = 0;
    function fnCamelCaseReplace(all, letter) {
        arguments[arguments.length] = ids[nxt];
        arguments[arguments.length + 1] = isOneShotEscapingFunction;
        arguments[arguments.length + 2] = $__.uid;
        arguments.length += 3;
        if (!isOneShotEscapingFunction) {
            ++nxt;
        }
        return $_f.apply(this, arguments);
    };
    TAJS_makeContextSensitive(fnCamelCaseReplace, -2);
    return fnCamelCaseReplace;
})($__.fs.fnCamelCaseReplace_84, [2], false)), $__.fs.fnCamelCaseReplace_84_127 = ((function $_mk($_f, ids, isOneShotEscapingFunction) {
    TAJS_makeContextSensitive($_mk, 1);
    TAJS_makeContextSensitive($_mk, 2);
    var nxt = 0;
    function fnCamelCaseReplace(all, letter) {
        arguments[arguments.length] = ids[nxt];
        arguments[arguments.length + 1] = isOneShotEscapingFunction;
        arguments[arguments.length + 2] = $__.uid;
        arguments.length += 3;
        if (!isOneShotEscapingFunction) {
            ++nxt;
        }
        return $_f.apply(this, arguments);
    };
    TAJS_makeContextSensitive(fnCamelCaseReplace, -2);
    return fnCamelCaseReplace;
})($__.fs.fnCamelCaseReplace_84, [3], false)), $__.fs.fnCamelCaseReplace_84_129 = ((function $_mk($_f, ids, isOneShotEscapingFunction) {
    TAJS_makeContextSensitive($_mk, 1);
    TAJS_makeContextSensitive($_mk, 2);
    var nxt = 0;
    function fnCamelCaseReplace(all, letter) {
        arguments[arguments.length] = ids[nxt];
        arguments[arguments.length + 1] = isOneShotEscapingFunction;
        arguments[arguments.length + 2] = $__.uid;
        arguments.length += 3;
        if (!isOneShotEscapingFunction) {
            ++nxt;
        }
        return $_f.apply(this, arguments);
    };
    TAJS_makeContextSensitive(fnCamelCaseReplace, -2);
    return fnCamelCaseReplace;
})($__.fs.fnCamelCaseReplace_84, [4], false)), $__.fs.fnCamelCaseReplace_84_131 = ((function $_mk($_f, ids, isOneShotEscapingFunction) {
    TAJS_makeContextSensitive($_mk, 1);
    TAJS_makeContextSensitive($_mk, 2);
    var nxt = 0;
    function fnCamelCaseReplace(all, letter) {
        arguments[arguments.length] = ids[nxt];
        arguments[arguments.length + 1] = isOneShotEscapingFunction;
        arguments[arguments.length + 2] = $__.uid;
        arguments.length += 3;
        if (!isOneShotEscapingFunction) {
            ++nxt;
        }
        return $_f.apply(this, arguments);
    };
    TAJS_makeContextSensitive(fnCamelCaseReplace, -2);
    return fnCamelCaseReplace;
})($__.fs.fnCamelCaseReplace_84, [5], false)), $__.fs.fnCamelCaseReplace_84_139 = ((function $_mk($_f, ids, isOneShotEscapingFunction) {
    TAJS_makeContextSensitive($_mk, 1);
    TAJS_makeContextSensitive($_mk, 2);
    var nxt = 0;
    function fnCamelCaseReplace(all, letter) {
        arguments[arguments.length] = ids[nxt];
        arguments[arguments.length + 1] = isOneShotEscapingFunction;
        arguments[arguments.length + 2] = $__.uid;
        arguments.length += 3;
        if (!isOneShotEscapingFunction) {
            ++nxt;
        }
        return $_f.apply(this, arguments);
    };
    TAJS_makeContextSensitive(fnCamelCaseReplace, -2);
    return fnCamelCaseReplace;
})($__.fs.fnCamelCaseReplace_84, [6], false)), $__.fs.fnCamelCaseReplace_84_141 = ((function $_mk($_f, ids, isOneShotEscapingFunction) {
    TAJS_makeContextSensitive($_mk, 1);
    TAJS_makeContextSensitive($_mk, 2);
    var nxt = 0;
    function fnCamelCaseReplace(all, letter) {
        arguments[arguments.length] = ids[nxt];
        arguments[arguments.length + 1] = isOneShotEscapingFunction;
        arguments[arguments.length + 2] = $__.uid;
        arguments.length += 3;
        if (!isOneShotEscapingFunction) {
            ++nxt;
        }
        return $_f.apply(this, arguments);
    };
    TAJS_makeContextSensitive(fnCamelCaseReplace, -2);
    return fnCamelCaseReplace;
})($__.fs.fnCamelCaseReplace_84, [7], false)), $__.fs.fnCamelCaseReplace_84_143 = ((function $_mk($_f, ids, isOneShotEscapingFunction) {
    TAJS_makeContextSensitive($_mk, 1);
    TAJS_makeContextSensitive($_mk, 2);
    var nxt = 0;
    function fnCamelCaseReplace(all, letter) {
        arguments[arguments.length] = ids[nxt];
        arguments[arguments.length + 1] = isOneShotEscapingFunction;
        arguments[arguments.length + 2] = $__.uid;
        arguments.length += 3;
        if (!isOneShotEscapingFunction) {
            ++nxt;
        }
        return $_f.apply(this, arguments);
    };
    TAJS_makeContextSensitive(fnCamelCaseReplace, -2);
    return fnCamelCaseReplace;
})($__.fs.fnCamelCaseReplace_84, [8], false)), $__.fs.fnCamelCaseReplace_84_150 = ((function $_mk($_f, ids, isOneShotEscapingFunction) {
    TAJS_makeContextSensitive($_mk, 1);
    TAJS_makeContextSensitive($_mk, 2);
    var nxt = 0;
    function fnCamelCaseReplace(all, letter) {
        arguments[arguments.length] = ids[nxt];
        arguments[arguments.length + 1] = isOneShotEscapingFunction;
        arguments[arguments.length + 2] = $__.uid;
        arguments.length += 3;
        if (!isOneShotEscapingFunction) {
            ++nxt;
        }
        return $_f.apply(this, arguments);
    };
    TAJS_makeContextSensitive(fnCamelCaseReplace, -2);
    return fnCamelCaseReplace;
})($__.fs.fnCamelCaseReplace_84, [9], false)), $__.fs.fnCamelCaseReplace_84_152 = ((function $_mk($_f, ids, isOneShotEscapingFunction) {
    TAJS_makeContextSensitive($_mk, 1);
    TAJS_makeContextSensitive($_mk, 2);
    var nxt = 0;
    function fnCamelCaseReplace(all, letter) {
        arguments[arguments.length] = ids[nxt];
        arguments[arguments.length + 1] = isOneShotEscapingFunction;
        arguments[arguments.length + 2] = $__.uid;
        arguments.length += 3;
        if (!isOneShotEscapingFunction) {
            ++nxt;
        }
        return $_f.apply(this, arguments);
    };
    TAJS_makeContextSensitive(fnCamelCaseReplace, -2);
    return fnCamelCaseReplace;
})($__.fs.fnCamelCaseReplace_84, [10], false)), $__.fs.fnCamelCaseReplace_84_154 = ((function $_mk($_f, ids, isOneShotEscapingFunction) {
    TAJS_makeContextSensitive($_mk, 1);
    TAJS_makeContextSensitive($_mk, 2);
    var nxt = 0;
    function fnCamelCaseReplace(all, letter) {
        arguments[arguments.length] = ids[nxt];
        arguments[arguments.length + 1] = isOneShotEscapingFunction;
        arguments[arguments.length + 2] = $__.uid;
        arguments.length += 3;
        if (!isOneShotEscapingFunction) {
            ++nxt;
        }
        return $_f.apply(this, arguments);
    };
    TAJS_makeContextSensitive(fnCamelCaseReplace, -2);
    return fnCamelCaseReplace;
})($__.fs.fnCamelCaseReplace_84, [11], false)), $__.fs.fnCamelCaseReplace_84_156 = ((function $_mk($_f, ids, isOneShotEscapingFunction) {
    TAJS_makeContextSensitive($_mk, 1);
    TAJS_makeContextSensitive($_mk, 2);
    var nxt = 0;
    function fnCamelCaseReplace(all, letter) {
        arguments[arguments.length] = ids[nxt];
        arguments[arguments.length + 1] = isOneShotEscapingFunction;
        arguments[arguments.length + 2] = $__.uid;
        arguments.length += 3;
        if (!isOneShotEscapingFunction) {
            ++nxt;
        }
        return $_f.apply(this, arguments);
    };
    TAJS_makeContextSensitive(fnCamelCaseReplace, -2);
    return fnCamelCaseReplace;
})($__.fs.fnCamelCaseReplace_84, [12], false)), $__.fs.fnCamelCaseReplace_84_158 = ((function $_mk($_f, ids, isOneShotEscapingFunction) {
    TAJS_makeContextSensitive($_mk, 1);
    TAJS_makeContextSensitive($_mk, 2);
    var nxt = 0;
    function fnCamelCaseReplace(all, letter) {
        arguments[arguments.length] = ids[nxt];
        arguments[arguments.length + 1] = isOneShotEscapingFunction;
        arguments[arguments.length + 2] = $__.uid;
        arguments.length += 3;
        if (!isOneShotEscapingFunction) {
            ++nxt;
        }
        return $_f.apply(this, arguments);
    };
    TAJS_makeContextSensitive(fnCamelCaseReplace, -2);
    return fnCamelCaseReplace;
})($__.fs.fnCamelCaseReplace_84, [13], false)), $__.fs.fnCamelCaseReplace_84_160 = ((function $_mk($_f, ids, isOneShotEscapingFunction) {
    TAJS_makeContextSensitive($_mk, 1);
    TAJS_makeContextSensitive($_mk, 2);
    var nxt = 0;
    function fnCamelCaseReplace(all, letter) {
        arguments[arguments.length] = ids[nxt];
        arguments[arguments.length + 1] = isOneShotEscapingFunction;
        arguments[arguments.length + 2] = $__.uid;
        arguments.length += 3;
        if (!isOneShotEscapingFunction) {
            ++nxt;
        }
        return $_f.apply(this, arguments);
    };
    TAJS_makeContextSensitive(fnCamelCaseReplace, -2);
    return fnCamelCaseReplace;
})($__.fs.fnCamelCaseReplace_84, [14], false)), $__.fs.fnCamelCaseReplace_84_162 = ((function $_mk($_f, ids, isOneShotEscapingFunction) {
    TAJS_makeContextSensitive($_mk, 1);
    TAJS_makeContextSensitive($_mk, 2);
    var nxt = 0;
    function fnCamelCaseReplace(all, letter) {
        arguments[arguments.length] = ids[nxt];
        arguments[arguments.length + 1] = isOneShotEscapingFunction;
        arguments[arguments.length + 2] = $__.uid;
        arguments.length += 3;
        if (!isOneShotEscapingFunction) {
            ++nxt;
        }
        return $_f.apply(this, arguments);
    };
    TAJS_makeContextSensitive(fnCamelCaseReplace, -2);
    return fnCamelCaseReplace;
})($__.fs.fnCamelCaseReplace_84, [15], false)), $__.fs.fnCamelCaseReplace_84_164 = ((function $_mk($_f, ids, isOneShotEscapingFunction) {
    TAJS_makeContextSensitive($_mk, 1);
    TAJS_makeContextSensitive($_mk, 2);
    var nxt = 0;
    function fnCamelCaseReplace(all, letter) {
        arguments[arguments.length] = ids[nxt];
        arguments[arguments.length + 1] = isOneShotEscapingFunction;
        arguments[arguments.length + 2] = $__.uid;
        arguments.length += 3;
        if (!isOneShotEscapingFunction) {
            ++nxt;
        }
        return $_f.apply(this, arguments);
    };
    TAJS_makeContextSensitive(fnCamelCaseReplace, -2);
    return fnCamelCaseReplace;
})($__.fs.fnCamelCaseReplace_84, [16], false)), $__.fs.fnCamelCaseReplace_84_166 = ((function $_mk($_f, ids, isOneShotEscapingFunction) {
    TAJS_makeContextSensitive($_mk, 1);
    TAJS_makeContextSensitive($_mk, 2);
    var nxt = 0;
    function fnCamelCaseReplace(all, letter) {
        arguments[arguments.length] = ids[nxt];
        arguments[arguments.length + 1] = isOneShotEscapingFunction;
        arguments[arguments.length + 2] = $__.uid;
        arguments.length += 3;
        if (!isOneShotEscapingFunction) {
            ++nxt;
        }
        return $_f.apply(this, arguments);
    };
    TAJS_makeContextSensitive(fnCamelCaseReplace, -2);
    return fnCamelCaseReplace;
})($__.fs.fnCamelCaseReplace_84, [17], false)), $__.fs.fnCamelCaseReplace_84_168 = ((function $_mk($_f, ids, isOneShotEscapingFunction) {
    TAJS_makeContextSensitive($_mk, 1);
    TAJS_makeContextSensitive($_mk, 2);
    var nxt = 0;
    function fnCamelCaseReplace(all, letter) {
        arguments[arguments.length] = ids[nxt];
        arguments[arguments.length + 1] = isOneShotEscapingFunction;
        arguments[arguments.length + 2] = $__.uid;
        arguments.length += 3;
        if (!isOneShotEscapingFunction) {
            ++nxt;
        }
        return $_f.apply(this, arguments);
    };
    TAJS_makeContextSensitive(fnCamelCaseReplace, -2);
    return fnCamelCaseReplace;
})($__.fs.fnCamelCaseReplace_84, [18], false)), $__.fs.fnCamelCaseReplace_84_170 = ((function $_mk($_f, ids, isOneShotEscapingFunction) {
    TAJS_makeContextSensitive($_mk, 1);
    TAJS_makeContextSensitive($_mk, 2);
    var nxt = 0;
    function fnCamelCaseReplace(all, letter) {
        arguments[arguments.length] = ids[nxt];
        arguments[arguments.length + 1] = isOneShotEscapingFunction;
        arguments[arguments.length + 2] = $__.uid;
        arguments.length += 3;
        if (!isOneShotEscapingFunction) {
            ++nxt;
        }
        return $_f.apply(this, arguments);
    };
    TAJS_makeContextSensitive(fnCamelCaseReplace, -2);
    return fnCamelCaseReplace;
})($__.fs.fnCamelCaseReplace_84, [19], false)), $__.fs.fnCamelCaseReplace_84_172 = ((function $_mk($_f, ids, isOneShotEscapingFunction) {
    TAJS_makeContextSensitive($_mk, 1);
    TAJS_makeContextSensitive($_mk, 2);
    var nxt = 0;
    function fnCamelCaseReplace(all, letter) {
        arguments[arguments.length] = ids[nxt];
        arguments[arguments.length + 1] = isOneShotEscapingFunction;
        arguments[arguments.length + 2] = $__.uid;
        arguments.length += 3;
        if (!isOneShotEscapingFunction) {
            ++nxt;
        }
        return $_f.apply(this, arguments);
    };
    TAJS_makeContextSensitive(fnCamelCaseReplace, -2);
    return fnCamelCaseReplace;
})($__.fs.fnCamelCaseReplace_84, [20], false)), $__.fs.fnCamelCaseReplace_84_174 = ((function $_mk($_f, ids, isOneShotEscapingFunction) {
    TAJS_makeContextSensitive($_mk, 1);
    TAJS_makeContextSensitive($_mk, 2);
    var nxt = 0;
    function fnCamelCaseReplace(all, letter) {
        arguments[arguments.length] = ids[nxt];
        arguments[arguments.length + 1] = isOneShotEscapingFunction;
        arguments[arguments.length + 2] = $__.uid;
        arguments.length += 3;
        if (!isOneShotEscapingFunction) {
            ++nxt;
        }
        return $_f.apply(this, arguments);
    };
    TAJS_makeContextSensitive(fnCamelCaseReplace, -2);
    return fnCamelCaseReplace;
})($__.fs.fnCamelCaseReplace_84, [21], false)), $__.fs.fnCamelCaseReplace_84_176 = ((function $_mk($_f, ids, isOneShotEscapingFunction) {
    TAJS_makeContextSensitive($_mk, 1);
    TAJS_makeContextSensitive($_mk, 2);
    var nxt = 0;
    function fnCamelCaseReplace(all, letter) {
        arguments[arguments.length] = ids[nxt];
        arguments[arguments.length + 1] = isOneShotEscapingFunction;
        arguments[arguments.length + 2] = $__.uid;
        arguments.length += 3;
        if (!isOneShotEscapingFunction) {
            ++nxt;
        }
        return $_f.apply(this, arguments);
    };
    TAJS_makeContextSensitive(fnCamelCaseReplace, -2);
    return fnCamelCaseReplace;
})($__.fs.fnCamelCaseReplace_84, [22], false)), $__.fs.fnCamelCaseReplace_84_178 = ((function $_mk($_f, ids, isOneShotEscapingFunction) {
    TAJS_makeContextSensitive($_mk, 1);
    TAJS_makeContextSensitive($_mk, 2);
    var nxt = 0;
    function fnCamelCaseReplace(all, letter) {
        arguments[arguments.length] = ids[nxt];
        arguments[arguments.length + 1] = isOneShotEscapingFunction;
        arguments[arguments.length + 2] = $__.uid;
        arguments.length += 3;
        if (!isOneShotEscapingFunction) {
            ++nxt;
        }
        return $_f.apply(this, arguments);
    };
    TAJS_makeContextSensitive(fnCamelCaseReplace, -2);
    return fnCamelCaseReplace;
})($__.fs.fnCamelCaseReplace_84, [23], false)), $__.fs.fnCamelCaseReplace_84_180 = ((function $_mk($_f, ids, isOneShotEscapingFunction) {
    TAJS_makeContextSensitive($_mk, 1);
    TAJS_makeContextSensitive($_mk, 2);
    var nxt = 0;
    function fnCamelCaseReplace(all, letter) {
        arguments[arguments.length] = ids[nxt];
        arguments[arguments.length + 1] = isOneShotEscapingFunction;
        arguments[arguments.length + 2] = $__.uid;
        arguments.length += 3;
        if (!isOneShotEscapingFunction) {
            ++nxt;
        }
        return $_f.apply(this, arguments);
    };
    TAJS_makeContextSensitive(fnCamelCaseReplace, -2);
    return fnCamelCaseReplace;
})($__.fs.fnCamelCaseReplace_84, [24], false)), $__.fs.fnCamelCaseReplace_84_182 = ((function $_mk($_f, ids, isOneShotEscapingFunction) {
    TAJS_makeContextSensitive($_mk, 1);
    TAJS_makeContextSensitive($_mk, 2);
    var nxt = 0;
    function fnCamelCaseReplace(all, letter) {
        arguments[arguments.length] = ids[nxt];
        arguments[arguments.length + 1] = isOneShotEscapingFunction;
        arguments[arguments.length + 2] = $__.uid;
        arguments.length += 3;
        if (!isOneShotEscapingFunction) {
            ++nxt;
        }
        return $_f.apply(this, arguments);
    };
    TAJS_makeContextSensitive(fnCamelCaseReplace, -2);
    return fnCamelCaseReplace;
})($__.fs.fnCamelCaseReplace_84, [25], false)), $__.fs.fnCamelCaseReplace_84_184 = ((function $_mk($_f, ids, isOneShotEscapingFunction) {
    TAJS_makeContextSensitive($_mk, 1);
    TAJS_makeContextSensitive($_mk, 2);
    var nxt = 0;
    function fnCamelCaseReplace(all, letter) {
        arguments[arguments.length] = ids[nxt];
        arguments[arguments.length + 1] = isOneShotEscapingFunction;
        arguments[arguments.length + 2] = $__.uid;
        arguments.length += 3;
        if (!isOneShotEscapingFunction) {
            ++nxt;
        }
        return $_f.apply(this, arguments);
    };
    TAJS_makeContextSensitive(fnCamelCaseReplace, -2);
    return fnCamelCaseReplace;
})($__.fs.fnCamelCaseReplace_84, [26], false)), $__.fs.fnCamelCaseReplace_84);
    kebabToCamel = ($__.fs.kebabToCamel_85 = function kebabToCamel(name) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
name = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return name.replace(DASH_LOWERCASE_REGEXP, fnCamelCaseReplace);});
    jqLiteIsTextNode = ($__.fs.jqLiteIsTextNode_86 = function jqLiteIsTextNode(html) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
html = arguments[0];
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    return !HTML_REGEXP['test'](html);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return !HTML_REGEXP.test(html);});
    jqLiteAcceptsData = ($__.fs.jqLiteAcceptsData_87 = function jqLiteAcceptsData(node) {
var vvv_return, vvv_switch, nodeType;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
node = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
nodeType = node.nodeType;
return nodeType === NODE_TYPE_ELEMENT || !nodeType || nodeType === NODE_TYPE_DOCUMENT;});
    jqLiteHasData = ($__.fs.jqLiteHasData_88 = function jqLiteHasData(node) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
node = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
for (var key in jqCache[node.ng339]) {
    return true;
}
return false;}, $__.fs.jqLiteHasData_88_20 = $__.fs.jqLiteHasData_88, $__.fs.jqLiteHasData_88);
    jqLiteCleanData = ($__.fs.jqLiteCleanData_89 = function jqLiteCleanData(nodes) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
nodes = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
for (var i = 0, ii = nodes.length; i < ii; i++) {
    jqLiteRemoveData(nodes[i]);
}}, $__.fs.jqLiteCleanData_89_22 = $__.fs.jqLiteCleanData_89, $__.fs.jqLiteCleanData_89);
    jqLiteBuildFragment = ($__.fs.jqLiteBuildFragment_90 = function jqLiteBuildFragment(html, context) {
var vvv_return, vvv_switch, tmp, tag, wrap, fragment, nodes, i;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
html = arguments[0], context = arguments[1];
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    fragment = context['createDocumentFragment']();
    nodes = [];
    (jqLiteIsTextNode, $__.fs.jqLiteIsTextNode_86)(html, 0, true, $__.uid);
    tmp = fragment['appendChild'](context['createElement']('div'));
    tag = TAJS_restrictToType(function $__lt7(res) {
        res.length = 2;
        if (res.length != 2)
            TAJS_dumpValue('Possible loss of precision');
        return res;
        ;
        TAJS_makeContextSensitive($__lt7, -2);
    }(TAG_NAME_REGEXP['exec'](html))[1, 1], 'string')['toLowerCase']();
    wrap = (TAJS_restrictToType((wrapMap, $__.os.oid5)[tag, 'style'], 'undefined'), TAJS_restrictToType((wrapMap, $__.os.oid5)._default, 'object'));
    tmp.innerHTML = TAJS_restrictToType(wrap[1, 1], 'string') + html['replace'](XHTML_TAG_REGEXP, '<$1></$2>') + TAJS_restrictToType(wrap[2, 2], 'string');
    i = (wrap[0, 0], 0);
    (i = +i - 1) + 1;
    nodes = (concat, $__.fs.concat_47)(nodes, TAJS_restrictToType(tmp.childNodes, 'object'), 0, true, $__.uid);
    tmp = TAJS_restrictToType(fragment.firstChild, 'HTMLDivElement');
    tmp.textContent = '';
    fragment.textContent = '';
    fragment.innerHTML = '';
    (forEach, $__.fs.forEach_8)(nodes, ($__.fs.J$__v3645318688_181_722 = function J$__v3645318688_181(node) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
node = arguments[0];
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    fragment['appendChild'](node);
    return;
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
fragment.appendChild(node);}, $__.fs.J$__v3645318688_181_722), 12, true, $__.uid);
    return fragment;
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
fragment = context.createDocumentFragment();
nodes = [];
if (jqLiteIsTextNode(html)) {
    nodes.push(context.createTextNode(html));
} else {
    tmp = fragment.appendChild(context.createElement('div'));
    tag = (TAG_NAME_REGEXP.exec(html) || [
        '',
        ''
    ])[1].toLowerCase();
    wrap = wrapMap[tag] || wrapMap._default;
    tmp.innerHTML = wrap[1] + html.replace(XHTML_TAG_REGEXP, '<$1></$2>') + wrap[2];
    i = wrap[0];
    while (i--) {
        tmp = tmp.lastChild;
    }
    nodes = concat(nodes, tmp.childNodes);
    tmp = fragment.firstChild;
    tmp.textContent = '';
}
fragment.textContent = '';
fragment.innerHTML = '';
forEach(nodes, function (node) {
    fragment.appendChild(node);
});
return fragment;});
    jqLiteParseHTML = ($__.fs.jqLiteParseHTML_91 = function jqLiteParseHTML(html, context) {
var vvv_return, vvv_switch, parsed;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
html = arguments[0], context = arguments[1];
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    context = (context, TAJS_restrictToType(window.document, 'HTMLDocument'));
    parsed = SINGLE_TAG_REGEXP['exec'](html);
    parsed = (jqLiteBuildFragment, $__.fs.jqLiteBuildFragment_90)(html, context, 0, true, $__.uid);
    return TAJS_restrictToType(parsed.childNodes, 'object');
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
context = context || window.document;
if (parsed = SINGLE_TAG_REGEXP.exec(html)) {
    return [context.createElement(parsed[1])];
}
if (parsed = jqLiteBuildFragment(html, context)) {
    return parsed.childNodes;
}
return [];});
    jqLiteWrapNode = ($__.fs.jqLiteWrapNode_92 = function jqLiteWrapNode(node, wrapper) {
var vvv_return, vvv_switch, parent;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
node = arguments[0], wrapper = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
parent = node.parentNode;
if (parent) {
    parent.replaceChild(wrapper, node);
}
wrapper.appendChild(node);});
    JQLite = ($__.fs.JQLite_93 = function JQLite(element) {
var vvv_return, vvv_switch, argIsString;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
element = arguments[0];
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    element instanceof JQLite;
    (isString, $__.fs.isString_26)((element, $__.fs.J$__v3645318688_2422_717), 13, true, $__.uid);
    !(this instanceof JQLite);
    argIsString;
    (isFunction, $__.fs.isFunction_29)((element, $__.fs.J$__v3645318688_2422_717), 18, true, $__.uid);
    (jqLiteReady, $__.fs.jqLiteReady_109)((element, $__.fs.J$__v3645318688_2422_717), 0, true, $__.uid);
    return;
case 1:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 1);
    element instanceof JQLite;
    (isString, $__.fs.isString_26)((element, $__.fs.J$__v3645318688_2422_717), 12, true, $__.uid);
    !(this instanceof JQLite);
    argIsString;
    return new (JQLite, $__.fs.JQLite_93)((element, $__.fs.J$__v3645318688_2422_717), 0, true, $__.uid);
case 2:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 2);
    element instanceof JQLite;
    (isString, $__.fs.isString_26)(element, 15, true, $__.uid);
    !(this instanceof JQLite);
    argIsString;
    (isFunction, $__.fs.isFunction_29)(element, 19, true, $__.uid);
    (jqLiteAddNodes, $__.fs.jqLiteAddNodes_103)(this, element, 0, true, $__.uid);
    return;
case 3:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 3);
    element instanceof JQLite;
    (isString, $__.fs.isString_26)(element, 14, true, $__.uid);
    !(this instanceof JQLite);
    argIsString;
    return new (JQLite, $__.fs.JQLite_93)(element, 2, true, $__.uid);
case 4:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 4);
    element instanceof JQLite;
    (isString, $__.fs.isString_26)(element, 16, true, $__.uid);
    element = (trim, $__.fs.J$__v3645318688_59_271)(element, 0, true, $__.uid);
    argIsString = true;
    !(this instanceof JQLite);
    argIsString;
    (jqLiteAddNodes, $__.fs.jqLiteAddNodes_103)(this, (jqLiteParseHTML, $__.fs.jqLiteParseHTML_91)(element, 0, true, $__.uid), 1, true, $__.uid);
    return;
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (element instanceof JQLite) {
    return element;
}
if (isString(element)) {
    element = trim(element);
    argIsString = true;
}
if (!(this instanceof JQLite)) {
    if (argIsString && element.charAt(0) !== '<') {
        throw jqLiteMinErr('nosel', 'Looking up elements via selectors is not supported by jqLite! See: http://docs.angularjs.org/api/angular.element');
    }
    return new JQLite(element);
}
if (argIsString) {
    jqLiteAddNodes(this, jqLiteParseHTML(element));
} else if (isFunction(element)) {
    jqLiteReady(element);
} else {
    jqLiteAddNodes(this, element);
}});
    jqLiteClone = ($__.fs.jqLiteClone_94 = function jqLiteClone(element) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
element = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return element.cloneNode(true);}, $__.fs.jqLiteClone_94_92 = $__.fs.jqLiteClone_94, $__.fs.jqLiteClone_94);
    jqLiteDealoc = ($__.fs.jqLiteDealoc_95 = function jqLiteDealoc(element, onlyDescendants) {
var vvv_return, vvv_switch, descendants;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
element = arguments[0], onlyDescendants = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (!onlyDescendants)
    jqLiteRemoveData(element);
if (element.querySelectorAll) {
    descendants = element.querySelectorAll('*');
    for (var i = 0, l = descendants.length; i < l; i++) {
        jqLiteRemoveData(descendants[i]);
    }
}});
    jqLiteOff = ($__.fs.jqLiteOff_96 = function jqLiteOff(element, type, fn, unsupported) {
var vvv_return, vvv_switch, expandoStore, events, handle, removeHandler;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
element = arguments[0], type = arguments[1], fn = arguments[2], unsupported = arguments[3];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (isDefined(unsupported))
    throw jqLiteMinErr('offargs', 'jqLite#off() does not support the `selector` argument');
expandoStore = jqLiteExpandoStore(element);
events = expandoStore && expandoStore.events;
handle = expandoStore && expandoStore.handle;
if (!handle)
    return;
if (!type) {
    for (type in events) {
        if (type !== '$destroy') {
            element.removeEventListener(type, handle);
        }
        delete events[type];
    }
} else {
    removeHandler = function (type) {
        var listenerFns = events[type];
        if (isDefined(fn)) {
            arrayRemove(listenerFns || [], fn);
        }
        if (!(isDefined(fn) && listenerFns && listenerFns.length > 0)) {
            element.removeEventListener(type, handle);
            delete events[type];
        }
    };
    forEach(type.split(' '), function (type) {
        removeHandler(type);
        if (MOUSE_EVENT_MAP[type]) {
            removeHandler(MOUSE_EVENT_MAP[type]);
        }
    });
}}, $__.fs.jqLiteOff_96_58 = $__.fs.jqLiteOff_96, $__.fs.jqLiteOff_96);
    jqLiteRemoveData = ($__.fs.jqLiteRemoveData_97 = function jqLiteRemoveData(element, name) {
var vvv_return, vvv_switch, expandoId, expandoStore;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
element = arguments[0], name = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
expandoId = element.ng339;
expandoStore = expandoId && jqCache[expandoId];
if (expandoStore) {
    if (name) {
        delete expandoStore.data[name];
        return;
    }
    if (expandoStore.handle) {
        if (expandoStore.events.$destroy) {
            expandoStore.handle({}, '$destroy');
        }
        jqLiteOff(element);
    }
    delete jqCache[expandoId];
    element.ng339 = undefined;
}}, $__.fs.jqLiteRemoveData_97_18 = $__.fs.jqLiteRemoveData_97, $__.fs.jqLiteRemoveData_97_54 = $__.fs.jqLiteRemoveData_97, $__.fs.jqLiteRemoveData_97);
    jqLiteExpandoStore = ($__.fs.jqLiteExpandoStore_98 = function jqLiteExpandoStore(element, createIfNecessary) {
var vvv_return, vvv_switch, expandoId, expandoStore;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
element = arguments[0], createIfNecessary = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
expandoId = element.ng339;
expandoStore = expandoId && jqCache[expandoId];
if (createIfNecessary && !expandoStore) {
    element.ng339 = expandoId = jqNextId();
    expandoStore = jqCache[expandoId] = {
        events: {},
        data: {},
        handle: undefined
    };
}
return expandoStore;});
    jqLiteData = ($__.fs.jqLiteData_99 = function jqLiteData(element, key, value) {
var vvv_return, vvv_switch, prop, isSimpleSetter, isSimpleGetter, massGetter, expandoStore, data;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
element = arguments[0], key = arguments[1], value = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (jqLiteAcceptsData(element)) {
    isSimpleSetter = isDefined(value);
    isSimpleGetter = !isSimpleSetter && key && !isObject(key);
    massGetter = !key;
    expandoStore = jqLiteExpandoStore(element, !isSimpleGetter);
    data = expandoStore && expandoStore.data;
    if (isSimpleSetter) {
        data[kebabToCamel(key)] = value;
    } else {
        if (massGetter) {
            return data;
        } else {
            if (isSimpleGetter) {
                return data && data[kebabToCamel(key)];
            } else {
                for (prop in key) {
                    data[kebabToCamel(prop)] = key[prop];
                }
            }
        }
    }
}}, $__.fs.jqLiteData_99_16 = $__.fs.jqLiteData_99, $__.fs.jqLiteData_99_24 = $__.fs.jqLiteData_99, $__.fs.jqLiteData_99);
    jqLiteHasClass = ($__.fs.jqLiteHasClass_100 = function jqLiteHasClass(element, selector) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
element = arguments[0], selector = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (!element.getAttribute)
    return false;
return (' ' + (element.getAttribute('class') || '') + ' ').replace(/[\n\t]/g, ' ').indexOf(' ' + selector + ' ') > -1;}, $__.fs.jqLiteHasClass_100_38 = $__.fs.jqLiteHasClass_100, $__.fs.jqLiteHasClass_100);
    jqLiteRemoveClass = ($__.fs.jqLiteRemoveClass_101 = function jqLiteRemoveClass(element, cssClasses) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
element = arguments[0], cssClasses = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (cssClasses && element.setAttribute) {
    forEach(cssClasses.split(' '), function (cssClass) {
        element.setAttribute('class', trim((' ' + (element.getAttribute('class') || '') + ' ').replace(/[\n\t]/g, ' ').replace(' ' + trim(cssClass) + ' ', ' ')));
    });
}}, $__.fs.jqLiteRemoveClass_101_82 = $__.fs.jqLiteRemoveClass_101, $__.fs.jqLiteRemoveClass_101);
    jqLiteAddClass = ($__.fs.jqLiteAddClass_102 = function jqLiteAddClass(element, cssClasses) {
var vvv_return, vvv_switch, existingClasses;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
element = arguments[0], cssClasses = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (cssClasses && element.setAttribute) {
    existingClasses = (' ' + (element.getAttribute('class') || '') + ' ').replace(/[\n\t]/g, ' ');
    forEach(cssClasses.split(' '), function (cssClass) {
        cssClass = trim(cssClass);
        if (existingClasses.indexOf(' ' + cssClass + ' ') === -1) {
            existingClasses += cssClass + ' ';
        }
    });
    element.setAttribute('class', trim(existingClasses));
}}, $__.fs.jqLiteAddClass_102_80 = $__.fs.jqLiteAddClass_102, $__.fs.jqLiteAddClass_102);
    jqLiteAddNodes = ($__.fs.jqLiteAddNodes_103 = function jqLiteAddNodes(root, elements) {
var vvv_return, vvv_switch, vvv_tmp0, length, i;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
root = arguments[0], elements = arguments[1];
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    elements;
    elements.nodeType, 1;
    root[((vvv_tmp0 = root).length = (vvv_tmp0.length, 0) + 1) - 1, 0] = elements;
    return;
case 1:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 1);
    elements;
    TAJS_restrictToType(elements.nodeType, 'undefined');
    length = (elements.length, 1);
    typeof length === 'number', TAJS_restrictToType(elements.window, 'undefined') !== elements;
    length;
    i = 0;
    i < length;
    root[((vvv_tmp0 = root).length = (vvv_tmp0.length, 0) + 1) - 1, 0] = TAJS_restrictToType(elements[i, 0], 'HTMLStyleElement');
    (i = +i + 1) - 1;
    i < length;
    return;
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (elements) {
    if (elements.nodeType) {
        root[root.length++] = elements;
    } else {
        length = elements.length;
        if (typeof length === 'number' && elements.window !== elements) {
            if (length) {
                for (var i = 0; i < length; i++) {
                    root[root.length++] = elements[i];
                }
            }
        } else {
            root[root.length++] = elements;
        }
    }
}});
    jqLiteController = ($__.fs.jqLiteController_104 = function jqLiteController(element, name) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
element = arguments[0], name = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return jqLiteInheritedData(element, '$' + (name || 'ngController') + 'Controller');}, $__.fs.jqLiteController_104_32 = $__.fs.jqLiteController_104, $__.fs.jqLiteController_104);
    jqLiteInheritedData = ($__.fs.jqLiteInheritedData_105 = function jqLiteInheritedData(element, name, value) {
var vvv_return, vvv_switch, names;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
element = arguments[0], name = arguments[1], value = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (element.nodeType === NODE_TYPE_DOCUMENT) {
    element = element.documentElement;
}
names = isArray(name) ? name : [name];
while (element) {
    for (var i = 0, ii = names.length; i < ii; i++) {
        if (isDefined(value = jqLite.data(element, names[i])))
            return value;
    }
    element = element.parentNode || element.nodeType === NODE_TYPE_DOCUMENT_FRAGMENT && element.host;
}}, $__.fs.jqLiteInheritedData_105_26 = $__.fs.jqLiteInheritedData_105, $__.fs.jqLiteInheritedData_105);
    jqLiteEmpty = ($__.fs.jqLiteEmpty_106 = function jqLiteEmpty(element) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
element = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
jqLiteDealoc(element, true);
while (element.firstChild) {
    element.removeChild(element.firstChild);
}}, $__.fs.jqLiteEmpty_106_52 = $__.fs.jqLiteEmpty_106, $__.fs.jqLiteEmpty_106);
    jqLiteRemove = ($__.fs.jqLiteRemove_107 = function jqLiteRemove(element, keepData) {
var vvv_return, vvv_switch, parent;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
element = arguments[0], keepData = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (!keepData)
    jqLiteDealoc(element);
parent = element.parentNode;
if (parent)
    parent.removeChild(element);}, $__.fs.jqLiteRemove_107_74 = $__.fs.jqLiteRemove_107, $__.fs.jqLiteRemove_107);
    jqLiteDocumentLoaded = ($__.fs.jqLiteDocumentLoaded_108 = function jqLiteDocumentLoaded(action, win) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
action = arguments[0], win = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
win = win || window;
if (win.document.readyState === 'complete') {
    win.setTimeout(action);
} else {
    jqLite(win).on('load', action);
}});
    jqLiteReady = ($__.fs.jqLiteReady_109 = function jqLiteReady(fn) {
var vvv_return, vvv_switch, trigger;
trigger = function trigger() {
    window.document.removeEventListener('DOMContentLoaded', trigger);
    window.removeEventListener('load', trigger);
    fn();
};
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
fn = arguments[0];
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    trigger = ($__.fs.trigger_718 = function trigger() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    TAJS_restrictToType(window.document, 'HTMLDocument')['removeEventListener']('DOMContentLoaded', (((trigger, $__.fs.trigger_718), $__.fs.trigger_718_189), $__.fs.trigger_718_185));
    window['removeEventListener']('load', (((trigger, $__.fs.trigger_718), $__.fs.trigger_718_190), $__.fs.trigger_718_186));
    (fn, $__.fs.J$__v3645318688_2422_717)(0, true, $__.uid);
    return;
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
window.document.removeEventListener('DOMContentLoaded', trigger);
window.removeEventListener('load', trigger);
fn();}, $__.fs.trigger_718_185 = ((function $_mk($_f, ids, isOneShotEscapingFunction) {
    TAJS_makeContextSensitive($_mk, 1);
    TAJS_makeContextSensitive($_mk, 2);
    var nxt = 0;
    function trigger() {
        arguments[arguments.length] = ids[nxt];
        arguments[arguments.length + 1] = isOneShotEscapingFunction;
        arguments[arguments.length + 2] = $__.uid;
        arguments.length += 3;
        if (!isOneShotEscapingFunction) {
            ++nxt;
        }
        return $_f.apply(this, arguments);
    };
    TAJS_makeContextSensitive(trigger, -2);
    return trigger;
})($__.fs.trigger_718, [0], true)), $__.fs.trigger_718_186 = function() {}, $__.fs.trigger_718_189 = $__.fs.trigger_718, $__.fs.trigger_718_190 = $__.fs.trigger_718, $__.fs.trigger_718);
    TAJS_restrictToType(TAJS_restrictToType(window.document, 'HTMLDocument').readyState, 'string') === 'complete';
    TAJS_restrictToType(window.document, 'HTMLDocument')['addEventListener']('DOMContentLoaded', ((trigger, $__.fs.trigger_718), $__.fs.trigger_718_185));
    window['addEventListener']('load', ((trigger, $__.fs.trigger_718), $__.fs.trigger_718_186));
    return;
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (window.document.readyState === 'complete') {
    window.setTimeout(fn);
} else {
    window.document.addEventListener('DOMContentLoaded', trigger);
    window.addEventListener('load', trigger);
}});
    getBooleanAttrName = ($__.fs.getBooleanAttrName_110 = function getBooleanAttrName(element, name) {
var vvv_return, vvv_switch, booleanAttr;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
element = arguments[0], name = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
booleanAttr = BOOLEAN_ATTR[name.toLowerCase()];
return booleanAttr && BOOLEAN_ELEMENTS[nodeName_(element)] && booleanAttr;});
    getAliasedAttrName = ($__.fs.getAliasedAttrName_111 = function getAliasedAttrName(name) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
name = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return ALIASED_ATTR[name];});
    createEventHandler = ($__.fs.createEventHandler_112 = function createEventHandler(element, events) {
var vvv_return, vvv_switch, eventHandler;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
element = arguments[0], events = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
eventHandler = function (event, type) {
    event.isDefaultPrevented = function () {
        return event.defaultPrevented;
    };
    var eventFns = events[type || event.type];
    var eventFnsLength = eventFns ? eventFns.length : 0;
    if (!eventFnsLength)
        return;
    if (isUndefined(event.immediatePropagationStopped)) {
        var originalStopImmediatePropagation = event.stopImmediatePropagation;
        event.stopImmediatePropagation = function () {
            event.immediatePropagationStopped = true;
            if (event.stopPropagation) {
                event.stopPropagation();
            }
            if (originalStopImmediatePropagation) {
                originalStopImmediatePropagation.call(event);
            }
        };
    }
    event.isImmediatePropagationStopped = function () {
        return event.immediatePropagationStopped === true;
    };
    var handlerWrapper = eventFns.specialHandlerWrapper || defaultHandlerWrapper;
    if (eventFnsLength > 1) {
        eventFns = shallowCopy(eventFns);
    }
    for (var i = 0; i < eventFnsLength; i++) {
        if (!event.isImmediatePropagationStopped()) {
            handlerWrapper(element, event, eventFns[i]);
        }
    }
};
eventHandler.elem = element;
return eventHandler;});
    defaultHandlerWrapper = ($__.fs.defaultHandlerWrapper_113 = function defaultHandlerWrapper(element, event, handler) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
element = arguments[0], event = arguments[1], handler = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
handler.call(element, event);});
    specialMouseHandlerWrapper = ($__.fs.specialMouseHandlerWrapper_114 = function specialMouseHandlerWrapper(target, event, handler) {
var vvv_return, vvv_switch, related;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
target = arguments[0], event = arguments[1], handler = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
related = event.relatedTarget;
if (!related || related !== target && !jqLiteContains.call(target, related)) {
    handler.call(target, event);
}});
    $$jqLiteProvider = ($__.fs.$$jqLiteProvider_115 = function $$jqLiteProvider() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.$get = function $$jqLite() {
    return extend(JQLite, {
        hasClass: function (node, classes) {
            if (node.attr)
                node = node[0];
            return jqLiteHasClass(node, classes);
        },
        addClass: function (node, classes) {
            if (node.attr)
                node = node[0];
            return jqLiteAddClass(node, classes);
        },
        removeClass: function (node, classes) {
            if (node.attr)
                node = node[0];
            return jqLiteRemoveClass(node, classes);
        }
    });
};});
    hashKey = ($__.fs.hashKey_116 = function hashKey(obj, nextUidFn) {
var vvv_return, vvv_switch, key, objType;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
obj = arguments[0], nextUidFn = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
key = obj && obj.$$hashKey;
if (key) {
    if (typeof key === 'function') {
        key = obj.$$hashKey();
    }
    return key;
}
objType = typeof obj;
if (objType === 'function' || objType === 'object' && obj !== null) {
    key = obj.$$hashKey = objType + ':' + (nextUidFn || nextUid)();
} else {
    key = objType + ':' + obj;
}
return key;});
    NgMapShim = ($__.fs.NgMapShim_117 = function NgMapShim() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this._keys = [];
this._values = [];
this._lastKey = NaN;
this._lastIndex = -1;});
    stringifyFn = ($__.fs.stringifyFn_118 = function stringifyFn(fn) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
fn = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return Function.prototype.toString.call(fn);});
    extractArgs = ($__.fs.extractArgs_119 = function extractArgs(fn) {
var vvv_return, vvv_switch, fnText, args;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
fn = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
fnText = stringifyFn(fn).replace(STRIP_COMMENTS, '');
args = fnText.match(ARROW_ARG) || fnText.match(FN_ARGS);
return args;});
    anonFn = ($__.fs.anonFn_120 = function anonFn(fn) {
var vvv_return, vvv_switch, args;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
fn = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
args = extractArgs(fn);
if (args) {
    return 'function(' + (args[1] || '').replace(/[\s\r\n]+/, ' ') + ')';
}
return 'fn';});
    annotate = ($__.fs.annotate_121 = function annotate(fn, strictDi, name) {
var vvv_return, vvv_switch, $inject, argDecl, last;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
fn = arguments[0], strictDi = arguments[1], name = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (typeof fn === 'function') {
    if (!($inject = fn.$inject)) {
        $inject = [];
        if (fn.length) {
            if (strictDi) {
                if (!isString(name) || !name) {
                    name = fn.name || anonFn(fn);
                }
                throw $injectorMinErr('strictdi', '{0} is not using explicit annotation and cannot be invoked in strict mode', name);
            }
            argDecl = extractArgs(fn);
            forEach(argDecl[1].split(FN_ARG_SPLIT), function (arg) {
                arg.replace(FN_ARG, function (all, underscore, name) {
                    $inject.push(name);
                });
            });
        }
        fn.$inject = $inject;
    }
} else if (isArray(fn)) {
    last = fn.length - 1;
    assertArgFn(fn[last], 'fn');
    $inject = fn.slice(0, last);
} else {
    assertArgFn(fn, 'fn', true);
}
return $inject;});
    createInjector = ($__.fs.createInjector_122 = function createInjector(modulesToLoad, strictDi) {
var vvv_return, vvv_switch, INSTANTIATING, providerSuffix, path, loadedModules, providerCache, providerInjector, instanceCache, protoInstanceInjector, instanceInjector, runBlocks, supportObject, provider, enforceReturnValue, factory, service, value, constant, decorator, loadModules, createInternalInjector;
supportObject = function supportObject(delegate) {
    return function (key, value) {
        if (isObject(key)) {
            forEach(key, reverseParams(delegate));
        } else {
            return delegate(key, value);
        }
    };
};
provider = function provider(name, provider_) {
    assertNotHasOwnProperty(name, 'service');
    if (isFunction(provider_) || isArray(provider_)) {
        provider_ = providerInjector.instantiate(provider_);
    }
    if (!provider_.$get) {
        throw $injectorMinErr('pget', 'Provider \'{0}\' must define $get factory method.', name);
    }
    return providerCache[name + providerSuffix] = provider_;
};
enforceReturnValue = function enforceReturnValue(name, factory) {
    return function enforcedReturnValue() {
        var result = instanceInjector.invoke(factory, this);
        if (isUndefined(result)) {
            throw $injectorMinErr('undef', 'Provider \'{0}\' must return a value from $get factory method.', name);
        }
        return result;
    };
};
factory = function factory(name, factoryFn, enforce) {
    return provider(name, {
        $get: enforce !== false ? enforceReturnValue(name, factoryFn) : factoryFn
    });
};
service = function service(name, constructor) {
    return factory(name, [
        '$injector',
        function ($injector) {
            return $injector.instantiate(constructor);
        }
    ]);
};
value = function value(name, val) {
    return factory(name, valueFn(val), false);
};
constant = function constant(name, value) {
    assertNotHasOwnProperty(name, 'constant');
    providerCache[name] = value;
    instanceCache[name] = value;
};
decorator = function decorator(serviceName, decorFn) {
    var origProvider = providerInjector.get(serviceName + providerSuffix), orig$get = origProvider.$get;
    origProvider.$get = function () {
        var origInstance = instanceInjector.invoke(orig$get, origProvider);
        return instanceInjector.invoke(decorFn, null, {
            $delegate: origInstance
        });
    };
};
loadModules = function loadModules(modulesToLoad) {
    assertArg(isUndefined(modulesToLoad) || isArray(modulesToLoad), 'modulesToLoad', 'not an array');
    var runBlocks = [], moduleFn;
    forEach(modulesToLoad, function (module) {
        if (loadedModules.get(module))
            return;
        loadedModules.set(module, true);
        function runInvokeQueue(queue) {
            var i, ii;
            for (i = 0, ii = queue.length; i < ii; i++) {
                var invokeArgs = queue[i], provider = providerInjector.get(invokeArgs[0]);
                provider[invokeArgs[1]].apply(provider, invokeArgs[2]);
            }
        }
        try {
            if (isString(module)) {
                moduleFn = angularModule(module);
                instanceInjector.modules[module] = moduleFn;
                runBlocks = runBlocks.concat(loadModules(moduleFn.requires)).concat(moduleFn._runBlocks);
                runInvokeQueue(moduleFn._invokeQueue);
                runInvokeQueue(moduleFn._configBlocks);
            } else if (isFunction(module)) {
                runBlocks.push(providerInjector.invoke(module));
            } else if (isArray(module)) {
                runBlocks.push(providerInjector.invoke(module));
            } else {
                assertArgFn(module, 'module');
            }
        } catch (e) {
            if (isArray(module)) {
                module = module[module.length - 1];
            }
            if (e.message && e.stack && e.stack.indexOf(e.message) === -1) {
                e = e.message + '\n' + e.stack;
            }
            throw $injectorMinErr('modulerr', 'Failed to instantiate module {0} due to:\n{1}', module, e.stack || e.message || e);
        }
    });
    return runBlocks;
};
createInternalInjector = function createInternalInjector(cache, factory) {
    function getService(serviceName, caller) {
        if (cache.hasOwnProperty(serviceName)) {
            if (cache[serviceName] === INSTANTIATING) {
                throw $injectorMinErr('cdep', 'Circular dependency found: {0}', serviceName + ' <- ' + path.join(' <- '));
            }
            return cache[serviceName];
        } else {
            try {
                path.unshift(serviceName);
                cache[serviceName] = INSTANTIATING;
                cache[serviceName] = factory(serviceName, caller);
                return cache[serviceName];
            } catch (err) {
                if (cache[serviceName] === INSTANTIATING) {
                    delete cache[serviceName];
                }
                throw err;
            } finally {
                path.shift();
            }
        }
    }
    function injectionArgs(fn, locals, serviceName) {
        var args = [], $inject = createInjector.$$annotate(fn, strictDi, serviceName);
        for (var i = 0, length = $inject.length; i < length; i++) {
            var key = $inject[i];
            if (typeof key !== 'string') {
                throw $injectorMinErr('itkn', 'Incorrect injection token! Expected service name as string, got {0}', key);
            }
            args.push(locals && locals.hasOwnProperty(key) ? locals[key] : getService(key, serviceName));
        }
        return args;
    }
    function isClass(func) {
        if (msie || typeof func !== 'function') {
            return false;
        }
        var result = func.$$ngIsClass;
        if (!isBoolean(result)) {
            result = func.$$ngIsClass = /^(?:class\b|constructor\()/.test(stringifyFn(func));
        }
        return result;
    }
    function invoke(fn, self, locals, serviceName) {
        if (typeof locals === 'string') {
            serviceName = locals;
            locals = null;
        }
        var args = injectionArgs(fn, locals, serviceName);
        if (isArray(fn)) {
            fn = fn[fn.length - 1];
        }
        if (!isClass(fn)) {
            return fn.apply(self, args);
        } else {
            args.unshift(null);
            return new (Function.prototype.bind.apply(fn, args))();
        }
    }
    function instantiate(Type, locals, serviceName) {
        var ctor = isArray(Type) ? Type[Type.length - 1] : Type;
        var args = injectionArgs(Type, locals, serviceName);
        args.unshift(null);
        return new (Function.prototype.bind.apply(ctor, args))();
    }
    return {
        invoke: invoke,
        instantiate: instantiate,
        get: getService,
        annotate: createInjector.$$annotate,
        has: function (name) {
            return providerCache.hasOwnProperty(name + providerSuffix) || cache.hasOwnProperty(name);
        }
    };
};
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
modulesToLoad = arguments[0], strictDi = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
strictDi = strictDi === true;
INSTANTIATING = {};
providerSuffix = 'Provider';
path = [];
loadedModules = new NgMap();
providerCache = {
    $provide: {
        provider: supportObject(provider),
        factory: supportObject(factory),
        service: supportObject(service),
        value: supportObject(value),
        constant: supportObject(constant),
        decorator: decorator
    }
};
providerInjector = providerCache.$injector = createInternalInjector(providerCache, function (serviceName, caller) {
    if (angular.isString(caller)) {
        path.push(caller);
    }
    throw $injectorMinErr('unpr', 'Unknown provider: {0}', path.join(' <- '));
});
instanceCache = {};
protoInstanceInjector = createInternalInjector(instanceCache, function (serviceName, caller) {
    var provider = providerInjector.get(serviceName + providerSuffix, caller);
    return instanceInjector.invoke(provider.$get, provider, undefined, serviceName);
});
instanceInjector = protoInstanceInjector;
providerCache['$injector' + providerSuffix] = {
    $get: valueFn(protoInstanceInjector)
};
instanceInjector.modules = providerInjector.modules = createMap();
runBlocks = loadModules(modulesToLoad);
instanceInjector = protoInstanceInjector.get('$injector');
instanceInjector.strictDi = strictDi;
forEach(runBlocks, function (fn) {
    if (fn)
        instanceInjector.invoke(fn);
});
return instanceInjector;});
    $AnchorScrollProvider = ($__.fs.$AnchorScrollProvider_123 = function $AnchorScrollProvider() {
var vvv_return, vvv_switch, autoScrollingEnabled;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
autoScrollingEnabled = true;
this.disableAutoScrolling = function () {
    autoScrollingEnabled = false;
};
this.$get = [
    '$window',
    '$location',
    '$rootScope',
    function ($window, $location, $rootScope) {
        var document = $window.document;
        function getFirstAnchor(list) {
            var result = null;
            Array.prototype.some.call(list, function (element) {
                if (nodeName_(element) === 'a') {
                    result = element;
                    return true;
                }
            });
            return result;
        }
        function getYOffset() {
            var offset = scroll.yOffset;
            if (isFunction(offset)) {
                offset = offset();
            } else if (isElement(offset)) {
                var elem = offset[0];
                var style = $window.getComputedStyle(elem);
                if (style.position !== 'fixed') {
                    offset = 0;
                } else {
                    offset = elem.getBoundingClientRect().bottom;
                }
            } else if (!isNumber(offset)) {
                offset = 0;
            }
            return offset;
        }
        function scrollTo(elem) {
            if (elem) {
                elem.scrollIntoView();
                var offset = getYOffset();
                if (offset) {
                    var elemTop = elem.getBoundingClientRect().top;
                    $window.scrollBy(0, elemTop - offset);
                }
            } else {
                $window.scrollTo(0, 0);
            }
        }
        function scroll(hash) {
            hash = isString(hash) ? hash : isNumber(hash) ? hash.toString() : $location.hash();
            var elm;
            if (!hash)
                scrollTo(null);
            else if (elm = document.getElementById(hash))
                scrollTo(elm);
            else if (elm = getFirstAnchor(document.getElementsByName(hash)))
                scrollTo(elm);
            else if (hash === 'top')
                scrollTo(null);
        }
        if (autoScrollingEnabled) {
            $rootScope.$watch(function autoScrollWatch() {
                return $location.hash();
            }, function autoScrollWatchAction(newVal, oldVal) {
                if (newVal === oldVal && newVal === '')
                    return;
                jqLiteDocumentLoaded(function () {
                    $rootScope.$evalAsync(scroll);
                });
            });
        }
        return scroll;
    }
];});
    mergeClasses = ($__.fs.mergeClasses_124 = function mergeClasses(a, b) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
a = arguments[0], b = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (!a && !b)
    return '';
if (!a)
    return b;
if (!b)
    return a;
if (isArray(a))
    a = a.join(' ');
if (isArray(b))
    b = b.join(' ');
return a + ' ' + b;});
    extractElementNode = ($__.fs.extractElementNode_125 = function extractElementNode(element) {
var vvv_return, vvv_switch, elm;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
element = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
for (var i = 0; i < element.length; i++) {
    elm = element[i];
    if (elm.nodeType === ELEMENT_NODE) {
        return elm;
    }
}});
    splitClasses = ($__.fs.splitClasses_126 = function splitClasses(classes) {
var vvv_return, vvv_switch, obj;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
classes = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (isString(classes)) {
    classes = classes.split(' ');
}
obj = createMap();
forEach(classes, function (klass) {
    if (klass.length) {
        obj[klass] = true;
    }
});
return obj;});
    prepareAnimateOptions = ($__.fs.prepareAnimateOptions_127 = function prepareAnimateOptions(options) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
options = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return isObject(options) ? options : {};});
    Browser = ($__.fs.Browser_128 = function Browser(window, document, $log, $sniffer) {
var vvv_return, vvv_switch, self, location, history, setTimeout, clearTimeout, pendingDeferIds, outstandingRequestCount, outstandingRequestCallbacks, completeOutstandingRequest, getHash, cachedState, lastHistoryState, lastBrowserUrl, baseElement, pendingLocation, getCurrentState, urlChangeListeners, urlChangeInit, cacheStateAndFireUrlChange, lastCachedState, cacheState, fireStateOrUrlChange;
completeOutstandingRequest = function completeOutstandingRequest(fn) {
    try {
        fn.apply(null, sliceArgs(arguments, 1));
    } finally {
        outstandingRequestCount--;
        if (outstandingRequestCount === 0) {
            while (outstandingRequestCallbacks.length) {
                try {
                    outstandingRequestCallbacks.pop()();
                } catch (e) {
                    $log.error(e);
                }
            }
        }
    }
};
getHash = function getHash(url) {
    var index = url.indexOf('#');
    return index === -1 ? '' : url.substr(index);
};
cacheStateAndFireUrlChange = function cacheStateAndFireUrlChange() {
    pendingLocation = null;
    fireStateOrUrlChange();
};
cacheState = function cacheState() {
    cachedState = getCurrentState();
    cachedState = isUndefined(cachedState) ? null : cachedState;
    if (equals(cachedState, lastCachedState)) {
        cachedState = lastCachedState;
    }
    lastCachedState = cachedState;
    lastHistoryState = cachedState;
};
fireStateOrUrlChange = function fireStateOrUrlChange() {
    var prevLastHistoryState = lastHistoryState;
    cacheState();
    if (lastBrowserUrl === self.url() && prevLastHistoryState === cachedState) {
        return;
    }
    lastBrowserUrl = self.url();
    lastHistoryState = cachedState;
    forEach(urlChangeListeners, function (listener) {
        listener(self.url(), cachedState);
    });
};
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
window = arguments[0], document = arguments[1], $log = arguments[2], $sniffer = arguments[3];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
self = this;
location = window.location;
history = window.history;
setTimeout = window.setTimeout;
clearTimeout = window.clearTimeout;
pendingDeferIds = {};
self.isMock = false;
outstandingRequestCount = 0;
outstandingRequestCallbacks = [];
self.$$completeOutstandingRequest = completeOutstandingRequest;
self.$$incOutstandingRequestCount = function () {
    outstandingRequestCount++;
};
self.notifyWhenNoOutstandingRequests = function (callback) {
    if (outstandingRequestCount === 0) {
        callback();
    } else {
        outstandingRequestCallbacks.push(callback);
    }
};
lastBrowserUrl = location.href;
baseElement = document.find('base');
pendingLocation = null;
getCurrentState = !$sniffer.history ? noop : function getCurrentState() {
    try {
        return history.state;
    } catch (e) {
    }
};
cacheState();
self.url = function (url, replace, state) {
    if (isUndefined(state)) {
        state = null;
    }
    if (location !== window.location)
        location = window.location;
    if (history !== window.history)
        history = window.history;
    if (url) {
        var sameState = lastHistoryState === state;
        if (lastBrowserUrl === url && (!$sniffer.history || sameState)) {
            return self;
        }
        var sameBase = lastBrowserUrl && stripHash(lastBrowserUrl) === stripHash(url);
        lastBrowserUrl = url;
        lastHistoryState = state;
        if ($sniffer.history && (!sameBase || !sameState)) {
            history[replace ? 'replaceState' : 'pushState'](state, '', url);
            cacheState();
        } else {
            if (!sameBase) {
                pendingLocation = url;
            }
            if (replace) {
                location.replace(url);
            } else if (!sameBase) {
                location.href = url;
            } else {
                location.hash = getHash(url);
            }
            if (location.href !== url) {
                pendingLocation = url;
            }
        }
        if (pendingLocation) {
            pendingLocation = url;
        }
        return self;
    } else {
        return pendingLocation || location.href.replace(/%27/g, '\'');
    }
};
self.state = function () {
    return cachedState;
};
urlChangeListeners = [];
urlChangeInit = false;
lastCachedState = null;
self.onUrlChange = function (callback) {
    if (!urlChangeInit) {
        if ($sniffer.history)
            jqLite(window).on('popstate', cacheStateAndFireUrlChange);
        jqLite(window).on('hashchange', cacheStateAndFireUrlChange);
        urlChangeInit = true;
    }
    urlChangeListeners.push(callback);
    return callback;
};
self.$$applicationDestroyed = function () {
    jqLite(window).off('hashchange popstate', cacheStateAndFireUrlChange);
};
self.$$checkUrlChange = fireStateOrUrlChange;
self.baseHref = function () {
    var href = baseElement.attr('href');
    return href ? href.replace(/^(https?:)?\/\/[^\/]*/, '') : '';
};
self.defer = function (fn, delay) {
    var timeoutId;
    outstandingRequestCount++;
    timeoutId = setTimeout(function () {
        delete pendingDeferIds[timeoutId];
        completeOutstandingRequest(fn);
    }, delay || 0);
    pendingDeferIds[timeoutId] = true;
    return timeoutId;
};
self.defer.cancel = function (deferId) {
    if (pendingDeferIds[deferId]) {
        delete pendingDeferIds[deferId];
        clearTimeout(deferId);
        completeOutstandingRequest(noop);
        return true;
    }
    return false;
};});
    $BrowserProvider = ($__.fs.$BrowserProvider_129 = function $BrowserProvider() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.$get = [
    '$window',
    '$log',
    '$sniffer',
    '$document',
    function ($window, $log, $sniffer, $document) {
        return new Browser($window, $document, $log, $sniffer);
    }
];});
    $CacheFactoryProvider = ($__.fs.$CacheFactoryProvider_130 = function $CacheFactoryProvider() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.$get = function () {
    var caches = {};
    function cacheFactory(cacheId, options) {
        if (cacheId in caches) {
            throw minErr('$cacheFactory')('iid', 'CacheId \'{0}\' is already taken!', cacheId);
        }
        var size = 0, stats = extend({}, options, {
                id: cacheId
            }), data = createMap(), capacity = options && options.capacity || Number.MAX_VALUE, lruHash = createMap(), freshEnd = null, staleEnd = null;
        return caches[cacheId] = {
            put: function (key, value) {
                if (isUndefined(value))
                    return;
                if (capacity < Number.MAX_VALUE) {
                    var lruEntry = lruHash[key] || (lruHash[key] = {
                        key: key
                    });
                    refresh(lruEntry);
                }
                if (!(key in data))
                    size++;
                data[key] = value;
                if (size > capacity) {
                    this.remove(staleEnd.key);
                }
                return value;
            },
            get: function (key) {
                if (capacity < Number.MAX_VALUE) {
                    var lruEntry = lruHash[key];
                    if (!lruEntry)
                        return;
                    refresh(lruEntry);
                }
                return data[key];
            },
            remove: function (key) {
                if (capacity < Number.MAX_VALUE) {
                    var lruEntry = lruHash[key];
                    if (!lruEntry)
                        return;
                    if (lruEntry === freshEnd)
                        freshEnd = lruEntry.p;
                    if (lruEntry === staleEnd)
                        staleEnd = lruEntry.n;
                    link(lruEntry.n, lruEntry.p);
                    delete lruHash[key];
                }
                if (!(key in data))
                    return;
                delete data[key];
                size--;
            },
            removeAll: function () {
                data = createMap();
                size = 0;
                lruHash = createMap();
                freshEnd = staleEnd = null;
            },
            destroy: function () {
                data = null;
                stats = null;
                lruHash = null;
                delete caches[cacheId];
            },
            info: function () {
                return extend({}, stats, {
                    size: size
                });
            }
        };
        function refresh(entry) {
            if (entry !== freshEnd) {
                if (!staleEnd) {
                    staleEnd = entry;
                } else if (staleEnd === entry) {
                    staleEnd = entry.n;
                }
                link(entry.n, entry.p);
                link(entry, freshEnd);
                freshEnd = entry;
                freshEnd.n = null;
            }
        }
        function link(nextEntry, prevEntry) {
            if (nextEntry !== prevEntry) {
                if (nextEntry)
                    nextEntry.p = prevEntry;
                if (prevEntry)
                    prevEntry.n = nextEntry;
            }
        }
    }
    cacheFactory.info = function () {
        var info = {};
        forEach(caches, function (cache, cacheId) {
            info[cacheId] = cache.info();
        });
        return info;
    };
    cacheFactory.get = function (cacheId) {
        return caches[cacheId];
    };
    return cacheFactory;
};});
    $TemplateCacheProvider = ($__.fs.$TemplateCacheProvider_131 = function $TemplateCacheProvider() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.$get = [
    '$cacheFactory',
    function ($cacheFactory) {
        return $cacheFactory('templates');
    }
];});
    UNINITIALIZED_VALUE = ($__.fs.UNINITIALIZED_VALUE_132 = function UNINITIALIZED_VALUE() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    return;
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');});
    $CompileProvider = ($__.fs.$CompileProvider_133 = function $CompileProvider($provide, $$sanitizeUriProvider) {
var vvv_return, vvv_switch, hasDirectives, Suffix, COMMENT_DIRECTIVE_REGEXP, CLASS_DIRECTIVE_REGEXP, ALL_OR_NOTHING_ATTRS, REQUIRE_PREFIX_REGEXP, EVENT_HANDLER_ATTR_REGEXP, bindingCache, parseIsolateBindings, parseDirectiveBindings, assertValidDirectiveName, getDirectiveRequire, getDirectiveRestrict, debugInfoEnabled, preAssignBindingsEnabled, TTL, commentDirectivesEnabledConfig, cssClassDirectivesEnabledConfig;
parseIsolateBindings = function parseIsolateBindings(scope, directiveName, isController) {
    var LOCAL_REGEXP = /^\s*([@&<]|=(\*?))(\??)\s*([\w$]*)\s*$/;
    var bindings = createMap();
    forEach(scope, function (definition, scopeName) {
        if (definition in bindingCache) {
            bindings[scopeName] = bindingCache[definition];
            return;
        }
        var match = definition.match(LOCAL_REGEXP);
        if (!match) {
            throw $compileMinErr('iscp', 'Invalid {3} for directive \'{0}\'.' + ' Definition: {... {1}: \'{2}\' ...}', directiveName, scopeName, definition, isController ? 'controller bindings definition' : 'isolate scope definition');
        }
        bindings[scopeName] = {
            mode: match[1][0],
            collection: match[2] === '*',
            optional: match[3] === '?',
            attrName: match[4] || scopeName
        };
        if (match[4]) {
            bindingCache[definition] = bindings[scopeName];
        }
    });
    return bindings;
};
parseDirectiveBindings = function parseDirectiveBindings(directive, directiveName) {
    var bindings = {
        isolateScope: null,
        bindToController: null
    };
    if (isObject(directive.scope)) {
        if (directive.bindToController === true) {
            bindings.bindToController = parseIsolateBindings(directive.scope, directiveName, true);
            bindings.isolateScope = {};
        } else {
            bindings.isolateScope = parseIsolateBindings(directive.scope, directiveName, false);
        }
    }
    if (isObject(directive.bindToController)) {
        bindings.bindToController = parseIsolateBindings(directive.bindToController, directiveName, true);
    }
    if (bindings.bindToController && !directive.controller) {
        throw $compileMinErr('noctrl', 'Cannot bind to controller without directive \'{0}\'s controller.', directiveName);
    }
    return bindings;
};
assertValidDirectiveName = function assertValidDirectiveName(name) {
    var letter = name.charAt(0);
    if (!letter || letter !== lowercase(letter)) {
        throw $compileMinErr('baddir', 'Directive/Component name \'{0}\' is invalid. The first character must be a lowercase letter', name);
    }
    if (name !== name.trim()) {
        throw $compileMinErr('baddir', 'Directive/Component name \'{0}\' is invalid. The name should not contain leading or trailing whitespaces', name);
    }
};
getDirectiveRequire = function getDirectiveRequire(directive) {
    var require = directive.require || directive.controller && directive.name;
    if (!isArray(require) && isObject(require)) {
        forEach(require, function (value, key) {
            var match = value.match(REQUIRE_PREFIX_REGEXP);
            var name = value.substring(match[0].length);
            if (!name)
                require[key] = match[0] + key;
        });
    }
    return require;
};
getDirectiveRestrict = function getDirectiveRestrict(restrict, name) {
    if (restrict && !(isString(restrict) && /[EACM]/.test(restrict))) {
        throw $compileMinErr('badrestrict', 'Restrict property \'{0}\' of directive \'{1}\' is invalid', restrict, name);
    }
    return restrict || 'EA';
};
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
$provide = arguments[0], $$sanitizeUriProvider = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
hasDirectives = {};
Suffix = 'Directive';
COMMENT_DIRECTIVE_REGEXP = /^\s*directive:\s*([\w-]+)\s+(.*)$/;
CLASS_DIRECTIVE_REGEXP = /(([\w-]+)(?::([^;]+))?;?)/;
ALL_OR_NOTHING_ATTRS = makeMap('ngSrc,ngSrcset,src,srcset');
REQUIRE_PREFIX_REGEXP = /^(?:(\^\^?)?(\?)?(\^\^?)?)?/;
EVENT_HANDLER_ATTR_REGEXP = /^(on[a-z]+|formaction)$/;
bindingCache = createMap();
this.directive = function registerDirective(name, directiveFactory) {
    assertArg(name, 'name');
    assertNotHasOwnProperty(name, 'directive');
    if (isString(name)) {
        assertValidDirectiveName(name);
        assertArg(directiveFactory, 'directiveFactory');
        if (!hasDirectives.hasOwnProperty(name)) {
            hasDirectives[name] = [];
            $provide.factory(name + Suffix, [
                '$injector',
                '$exceptionHandler',
                function ($injector, $exceptionHandler) {
                    var directives = [];
                    forEach(hasDirectives[name], function (directiveFactory, index) {
                        try {
                            var directive = $injector.invoke(directiveFactory);
                            if (isFunction(directive)) {
                                directive = {
                                    compile: valueFn(directive)
                                };
                            } else if (!directive.compile && directive.link) {
                                directive.compile = valueFn(directive.link);
                            }
                            directive.priority = directive.priority || 0;
                            directive.index = index;
                            directive.name = directive.name || name;
                            directive.require = getDirectiveRequire(directive);
                            directive.restrict = getDirectiveRestrict(directive.restrict, name);
                            directive.$$moduleName = directiveFactory.$$moduleName;
                            directives.push(directive);
                        } catch (e) {
                            $exceptionHandler(e);
                        }
                    });
                    return directives;
                }
            ]);
        }
        hasDirectives[name].push(directiveFactory);
    } else {
        forEach(name, reverseParams(registerDirective));
    }
    return this;
};
this.component = function registerComponent(name, options) {
    var controller = options.controller || function () {
    };
    function factory($injector) {
        function makeInjectable(fn) {
            if (isFunction(fn) || isArray(fn)) {
                return function (tElement, tAttrs) {
                    return $injector.invoke(fn, this, {
                        $element: tElement,
                        $attrs: tAttrs
                    });
                };
            } else {
                return fn;
            }
        }
        var template = !options.template && !options.templateUrl ? '' : options.template;
        var ddo = {
            controller: controller,
            controllerAs: identifierForController(options.controller) || options.controllerAs || '$ctrl',
            template: makeInjectable(template),
            templateUrl: makeInjectable(options.templateUrl),
            transclude: options.transclude,
            scope: {},
            bindToController: options.bindings || {},
            restrict: 'E',
            require: options.require
        };
        forEach(options, function (val, key) {
            if (key.charAt(0) === '$')
                ddo[key] = val;
        });
        return ddo;
    }
    forEach(options, function (val, key) {
        if (key.charAt(0) === '$') {
            factory[key] = val;
            if (isFunction(controller))
                controller[key] = val;
        }
    });
    factory.$inject = ['$injector'];
    return this.directive(name, factory);
};
this.aHrefSanitizationWhitelist = function (regexp) {
    if (isDefined(regexp)) {
        $$sanitizeUriProvider.aHrefSanitizationWhitelist(regexp);
        return this;
    } else {
        return $$sanitizeUriProvider.aHrefSanitizationWhitelist();
    }
};
this.imgSrcSanitizationWhitelist = function (regexp) {
    if (isDefined(regexp)) {
        $$sanitizeUriProvider.imgSrcSanitizationWhitelist(regexp);
        return this;
    } else {
        return $$sanitizeUriProvider.imgSrcSanitizationWhitelist();
    }
};
debugInfoEnabled = true;
this.debugInfoEnabled = function (enabled) {
    if (isDefined(enabled)) {
        debugInfoEnabled = enabled;
        return this;
    }
    return debugInfoEnabled;
};
preAssignBindingsEnabled = false;
this.preAssignBindingsEnabled = function (enabled) {
    if (isDefined(enabled)) {
        preAssignBindingsEnabled = enabled;
        return this;
    }
    return preAssignBindingsEnabled;
};
TTL = 10;
this.onChangesTtl = function (value) {
    if (arguments.length) {
        TTL = value;
        return this;
    }
    return TTL;
};
commentDirectivesEnabledConfig = true;
this.commentDirectivesEnabled = function (value) {
    if (arguments.length) {
        commentDirectivesEnabledConfig = value;
        return this;
    }
    return commentDirectivesEnabledConfig;
};
cssClassDirectivesEnabledConfig = true;
this.cssClassDirectivesEnabled = function (value) {
    if (arguments.length) {
        cssClassDirectivesEnabledConfig = value;
        return this;
    }
    return cssClassDirectivesEnabledConfig;
};
this.$get = [
    '$injector',
    '$interpolate',
    '$exceptionHandler',
    '$templateRequest',
    '$parse',
    '$controller',
    '$rootScope',
    '$sce',
    '$animate',
    '$$sanitizeUri',
    function ($injector, $interpolate, $exceptionHandler, $templateRequest, $parse, $controller, $rootScope, $sce, $animate, $$sanitizeUri) {
        var SIMPLE_ATTR_NAME = /^\w/;
        var specialAttrHolder = window.document.createElement('div');
        var commentDirectivesEnabled = commentDirectivesEnabledConfig;
        var cssClassDirectivesEnabled = cssClassDirectivesEnabledConfig;
        var onChangesTtl = TTL;
        var onChangesQueue;
        function flushOnChangesQueue() {
            try {
                if (!--onChangesTtl) {
                    onChangesQueue = undefined;
                    throw $compileMinErr('infchng', '{0} $onChanges() iterations reached. Aborting!\n', TTL);
                }
                $rootScope.$apply(function () {
                    var errors = [];
                    for (var i = 0, ii = onChangesQueue.length; i < ii; ++i) {
                        try {
                            onChangesQueue[i]();
                        } catch (e) {
                            errors.push(e);
                        }
                    }
                    onChangesQueue = undefined;
                    if (errors.length) {
                        throw errors;
                    }
                });
            } finally {
                onChangesTtl++;
            }
        }
        function Attributes(element, attributesToCopy) {
            if (attributesToCopy) {
                var keys = Object.keys(attributesToCopy);
                var i, l, key;
                for (i = 0, l = keys.length; i < l; i++) {
                    key = keys[i];
                    this[key] = attributesToCopy[key];
                }
            } else {
                this.$attr = {};
            }
            this.$$element = element;
        }
        Attributes.prototype = {
            $normalize: directiveNormalize,
            $addClass: function (classVal) {
                if (classVal && classVal.length > 0) {
                    $animate.addClass(this.$$element, classVal);
                }
            },
            $removeClass: function (classVal) {
                if (classVal && classVal.length > 0) {
                    $animate.removeClass(this.$$element, classVal);
                }
            },
            $updateClass: function (newClasses, oldClasses) {
                var toAdd = tokenDifference(newClasses, oldClasses);
                if (toAdd && toAdd.length) {
                    $animate.addClass(this.$$element, toAdd);
                }
                var toRemove = tokenDifference(oldClasses, newClasses);
                if (toRemove && toRemove.length) {
                    $animate.removeClass(this.$$element, toRemove);
                }
            },
            $set: function (key, value, writeAttr, attrName) {
                var node = this.$$element[0], booleanKey = getBooleanAttrName(node, key), aliasedKey = getAliasedAttrName(key), observer = key, nodeName;
                if (booleanKey) {
                    this.$$element.prop(key, value);
                    attrName = booleanKey;
                } else if (aliasedKey) {
                    this[aliasedKey] = value;
                    observer = aliasedKey;
                }
                this[key] = value;
                if (attrName) {
                    this.$attr[key] = attrName;
                } else {
                    attrName = this.$attr[key];
                    if (!attrName) {
                        this.$attr[key] = attrName = snake_case(key, '-');
                    }
                }
                nodeName = nodeName_(this.$$element);
                if (nodeName === 'a' && (key === 'href' || key === 'xlinkHref') || nodeName === 'img' && key === 'src') {
                    this[key] = value = $$sanitizeUri(value, key === 'src');
                } else if (nodeName === 'img' && key === 'srcset' && isDefined(value)) {
                    var result = '';
                    var trimmedSrcset = trim(value);
                    var srcPattern = /(\s+\d+x\s*,|\s+\d+w\s*,|\s+,|,\s+)/;
                    var pattern = /\s/.test(trimmedSrcset) ? srcPattern : /(,)/;
                    var rawUris = trimmedSrcset.split(pattern);
                    var nbrUrisWith2parts = Math.floor(rawUris.length / 2);
                    for (var i = 0; i < nbrUrisWith2parts; i++) {
                        var innerIdx = i * 2;
                        result += $$sanitizeUri(trim(rawUris[innerIdx]), true);
                        result += ' ' + trim(rawUris[innerIdx + 1]);
                    }
                    var lastTuple = trim(rawUris[i * 2]).split(/\s/);
                    result += $$sanitizeUri(trim(lastTuple[0]), true);
                    if (lastTuple.length === 2) {
                        result += ' ' + trim(lastTuple[1]);
                    }
                    this[key] = value = result;
                }
                if (writeAttr !== false) {
                    if (value === null || isUndefined(value)) {
                        this.$$element.removeAttr(attrName);
                    } else {
                        if (SIMPLE_ATTR_NAME.test(attrName)) {
                            this.$$element.attr(attrName, value);
                        } else {
                            setSpecialAttr(this.$$element[0], attrName, value);
                        }
                    }
                }
                var $$observers = this.$$observers;
                if ($$observers) {
                    forEach($$observers[observer], function (fn) {
                        try {
                            fn(value);
                        } catch (e) {
                            $exceptionHandler(e);
                        }
                    });
                }
            },
            $observe: function (key, fn) {
                var attrs = this, $$observers = attrs.$$observers || (attrs.$$observers = createMap()), listeners = $$observers[key] || ($$observers[key] = []);
                listeners.push(fn);
                $rootScope.$evalAsync(function () {
                    if (!listeners.$$inter && attrs.hasOwnProperty(key) && !isUndefined(attrs[key])) {
                        fn(attrs[key]);
                    }
                });
                return function () {
                    arrayRemove(listeners, fn);
                };
            }
        };
        function setSpecialAttr(element, attrName, value) {
            specialAttrHolder.innerHTML = '<span ' + attrName + '>';
            var attributes = specialAttrHolder.firstChild.attributes;
            var attribute = attributes[0];
            attributes.removeNamedItem(attribute.name);
            attribute.value = value;
            element.attributes.setNamedItem(attribute);
        }
        function safeAddClass($element, className) {
            try {
                $element.addClass(className);
            } catch (e) {
            }
        }
        var startSymbol = $interpolate.startSymbol(), endSymbol = $interpolate.endSymbol(), denormalizeTemplate = startSymbol === '{{' && endSymbol === '}}' ? identity : function denormalizeTemplate(template) {
                return template.replace(/\{\{/g, startSymbol).replace(/}}/g, endSymbol);
            }, NG_ATTR_BINDING = /^ngAttr[A-Z]/;
        var MULTI_ELEMENT_DIR_RE = /^(.+)Start$/;
        compile.$$addBindingInfo = debugInfoEnabled ? function $$addBindingInfo($element, binding) {
            var bindings = $element.data('$binding') || [];
            if (isArray(binding)) {
                bindings = bindings.concat(binding);
            } else {
                bindings.push(binding);
            }
            $element.data('$binding', bindings);
        } : noop;
        compile.$$addBindingClass = debugInfoEnabled ? function $$addBindingClass($element) {
            safeAddClass($element, 'ng-binding');
        } : noop;
        compile.$$addScopeInfo = debugInfoEnabled ? function $$addScopeInfo($element, scope, isolated, noTemplate) {
            var dataName = isolated ? noTemplate ? '$isolateScopeNoTemplate' : '$isolateScope' : '$scope';
            $element.data(dataName, scope);
        } : noop;
        compile.$$addScopeClass = debugInfoEnabled ? function $$addScopeClass($element, isolated) {
            safeAddClass($element, isolated ? 'ng-isolate-scope' : 'ng-scope');
        } : noop;
        compile.$$createComment = function (directiveName, comment) {
            var content = '';
            if (debugInfoEnabled) {
                content = ' ' + (directiveName || '') + ': ';
                if (comment)
                    content += comment + ' ';
            }
            return window.document.createComment(content);
        };
        return compile;
        function compile($compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext) {
            if (!($compileNodes instanceof jqLite)) {
                $compileNodes = jqLite($compileNodes);
            }
            var compositeLinkFn = compileNodes($compileNodes, transcludeFn, $compileNodes, maxPriority, ignoreDirective, previousCompileContext);
            compile.$$addScopeClass($compileNodes);
            var namespace = null;
            return function publicLinkFn(scope, cloneConnectFn, options) {
                if (!$compileNodes) {
                    throw $compileMinErr('multilink', 'This element has already been linked.');
                }
                assertArg(scope, 'scope');
                if (previousCompileContext && previousCompileContext.needsNewScope) {
                    scope = scope.$parent.$new();
                }
                options = options || {};
                var parentBoundTranscludeFn = options.parentBoundTranscludeFn, transcludeControllers = options.transcludeControllers, futureParentElement = options.futureParentElement;
                if (parentBoundTranscludeFn && parentBoundTranscludeFn.$$boundTransclude) {
                    parentBoundTranscludeFn = parentBoundTranscludeFn.$$boundTransclude;
                }
                if (!namespace) {
                    namespace = detectNamespaceForChildElements(futureParentElement);
                }
                var $linkNode;
                if (namespace !== 'html') {
                    $linkNode = jqLite(wrapTemplate(namespace, jqLite('<div>').append($compileNodes).html()));
                } else if (cloneConnectFn) {
                    $linkNode = JQLitePrototype.clone.call($compileNodes);
                } else {
                    $linkNode = $compileNodes;
                }
                if (transcludeControllers) {
                    for (var controllerName in transcludeControllers) {
                        $linkNode.data('$' + controllerName + 'Controller', transcludeControllers[controllerName].instance);
                    }
                }
                compile.$$addScopeInfo($linkNode, scope);
                if (cloneConnectFn)
                    cloneConnectFn($linkNode, scope);
                if (compositeLinkFn)
                    compositeLinkFn(scope, $linkNode, $linkNode, parentBoundTranscludeFn);
                if (!cloneConnectFn) {
                    $compileNodes = compositeLinkFn = null;
                }
                return $linkNode;
            };
        }
        function detectNamespaceForChildElements(parentElement) {
            var node = parentElement && parentElement[0];
            if (!node) {
                return 'html';
            } else {
                return nodeName_(node) !== 'foreignobject' && toString.call(node).match(/SVG/) ? 'svg' : 'html';
            }
        }
        function compileNodes(nodeList, transcludeFn, $rootElement, maxPriority, ignoreDirective, previousCompileContext) {
            var linkFns = [], notLiveList = isArray(nodeList) || nodeList instanceof jqLite, attrs, directives, nodeLinkFn, childNodes, childLinkFn, linkFnFound, nodeLinkFnFound;
            for (var i = 0; i < nodeList.length; i++) {
                attrs = new Attributes();
                if (msie === 11) {
                    mergeConsecutiveTextNodes(nodeList, i, notLiveList);
                }
                directives = collectDirectives(nodeList[i], [], attrs, i === 0 ? maxPriority : undefined, ignoreDirective);
                nodeLinkFn = directives.length ? applyDirectivesToNode(directives, nodeList[i], attrs, transcludeFn, $rootElement, null, [], [], previousCompileContext) : null;
                if (nodeLinkFn && nodeLinkFn.scope) {
                    compile.$$addScopeClass(attrs.$$element);
                }
                childLinkFn = nodeLinkFn && nodeLinkFn.terminal || !(childNodes = nodeList[i].childNodes) || !childNodes.length ? null : compileNodes(childNodes, nodeLinkFn ? (nodeLinkFn.transcludeOnThisElement || !nodeLinkFn.templateOnThisElement) && nodeLinkFn.transclude : transcludeFn);
                if (nodeLinkFn || childLinkFn) {
                    linkFns.push(i, nodeLinkFn, childLinkFn);
                    linkFnFound = true;
                    nodeLinkFnFound = nodeLinkFnFound || nodeLinkFn;
                }
                previousCompileContext = null;
            }
            return linkFnFound ? compositeLinkFn : null;
            function compositeLinkFn(scope, nodeList, $rootElement, parentBoundTranscludeFn) {
                var nodeLinkFn, childLinkFn, node, childScope, i, ii, idx, childBoundTranscludeFn;
                var stableNodeList;
                if (nodeLinkFnFound) {
                    var nodeListLength = nodeList.length;
                    stableNodeList = new Array(nodeListLength);
                    for (i = 0; i < linkFns.length; i += 3) {
                        idx = linkFns[i];
                        stableNodeList[idx] = nodeList[idx];
                    }
                } else {
                    stableNodeList = nodeList;
                }
                for (i = 0, ii = linkFns.length; i < ii;) {
                    node = stableNodeList[linkFns[i++]];
                    nodeLinkFn = linkFns[i++];
                    childLinkFn = linkFns[i++];
                    if (nodeLinkFn) {
                        if (nodeLinkFn.scope) {
                            childScope = scope.$new();
                            compile.$$addScopeInfo(jqLite(node), childScope);
                        } else {
                            childScope = scope;
                        }
                        if (nodeLinkFn.transcludeOnThisElement) {
                            childBoundTranscludeFn = createBoundTranscludeFn(scope, nodeLinkFn.transclude, parentBoundTranscludeFn);
                        } else if (!nodeLinkFn.templateOnThisElement && parentBoundTranscludeFn) {
                            childBoundTranscludeFn = parentBoundTranscludeFn;
                        } else if (!parentBoundTranscludeFn && transcludeFn) {
                            childBoundTranscludeFn = createBoundTranscludeFn(scope, transcludeFn);
                        } else {
                            childBoundTranscludeFn = null;
                        }
                        nodeLinkFn(childLinkFn, childScope, node, $rootElement, childBoundTranscludeFn);
                    } else if (childLinkFn) {
                        childLinkFn(scope, node.childNodes, undefined, parentBoundTranscludeFn);
                    }
                }
            }
        }
        function mergeConsecutiveTextNodes(nodeList, idx, notLiveList) {
            var node = nodeList[idx];
            var parent = node.parentNode;
            var sibling;
            if (node.nodeType !== NODE_TYPE_TEXT) {
                return;
            }
            while (true) {
                sibling = parent ? node.nextSibling : nodeList[idx + 1];
                if (!sibling || sibling.nodeType !== NODE_TYPE_TEXT) {
                    break;
                }
                node.nodeValue = node.nodeValue + sibling.nodeValue;
                if (sibling.parentNode) {
                    sibling.parentNode.removeChild(sibling);
                }
                if (notLiveList && sibling === nodeList[idx + 1]) {
                    nodeList.splice(idx + 1, 1);
                }
            }
        }
        function createBoundTranscludeFn(scope, transcludeFn, previousBoundTranscludeFn) {
            function boundTranscludeFn(transcludedScope, cloneFn, controllers, futureParentElement, containingScope) {
                if (!transcludedScope) {
                    transcludedScope = scope.$new(false, containingScope);
                    transcludedScope.$$transcluded = true;
                }
                return transcludeFn(transcludedScope, cloneFn, {
                    parentBoundTranscludeFn: previousBoundTranscludeFn,
                    transcludeControllers: controllers,
                    futureParentElement: futureParentElement
                });
            }
            var boundSlots = boundTranscludeFn.$$slots = createMap();
            for (var slotName in transcludeFn.$$slots) {
                if (transcludeFn.$$slots[slotName]) {
                    boundSlots[slotName] = createBoundTranscludeFn(scope, transcludeFn.$$slots[slotName], previousBoundTranscludeFn);
                } else {
                    boundSlots[slotName] = null;
                }
            }
            return boundTranscludeFn;
        }
        function collectDirectives(node, directives, attrs, maxPriority, ignoreDirective) {
            var nodeType = node.nodeType, attrsMap = attrs.$attr, match, nodeName, className;
            switch (nodeType) {
            case NODE_TYPE_ELEMENT:
                nodeName = nodeName_(node);
                addDirective(directives, directiveNormalize(nodeName), 'E', maxPriority, ignoreDirective);
                for (var attr, name, nName, ngAttrName, value, isNgAttr, nAttrs = node.attributes, j = 0, jj = nAttrs && nAttrs.length; j < jj; j++) {
                    var attrStartName = false;
                    var attrEndName = false;
                    attr = nAttrs[j];
                    name = attr.name;
                    value = attr.value;
                    ngAttrName = directiveNormalize(name);
                    isNgAttr = NG_ATTR_BINDING.test(ngAttrName);
                    if (isNgAttr) {
                        name = name.replace(PREFIX_REGEXP, '').substr(8).replace(/_(.)/g, function (match, letter) {
                            return letter.toUpperCase();
                        });
                    }
                    var multiElementMatch = ngAttrName.match(MULTI_ELEMENT_DIR_RE);
                    if (multiElementMatch && directiveIsMultiElement(multiElementMatch[1])) {
                        attrStartName = name;
                        attrEndName = name.substr(0, name.length - 5) + 'end';
                        name = name.substr(0, name.length - 6);
                    }
                    nName = directiveNormalize(name.toLowerCase());
                    attrsMap[nName] = name;
                    if (isNgAttr || !attrs.hasOwnProperty(nName)) {
                        attrs[nName] = value;
                        if (getBooleanAttrName(node, nName)) {
                            attrs[nName] = true;
                        }
                    }
                    addAttrInterpolateDirective(node, directives, value, nName, isNgAttr);
                    addDirective(directives, nName, 'A', maxPriority, ignoreDirective, attrStartName, attrEndName);
                }
                if (nodeName === 'input' && node.getAttribute('type') === 'hidden') {
                    node.setAttribute('autocomplete', 'off');
                }
                if (!cssClassDirectivesEnabled)
                    break;
                className = node.className;
                if (isObject(className)) {
                    className = className.animVal;
                }
                if (isString(className) && className !== '') {
                    while (match = CLASS_DIRECTIVE_REGEXP.exec(className)) {
                        nName = directiveNormalize(match[2]);
                        if (addDirective(directives, nName, 'C', maxPriority, ignoreDirective)) {
                            attrs[nName] = trim(match[3]);
                        }
                        className = className.substr(match.index + match[0].length);
                    }
                }
                break;
            case NODE_TYPE_TEXT:
                addTextInterpolateDirective(directives, node.nodeValue);
                break;
            case NODE_TYPE_COMMENT:
                if (!commentDirectivesEnabled)
                    break;
                collectCommentDirectives(node, directives, attrs, maxPriority, ignoreDirective);
                break;
            }
            directives.sort(byPriority);
            return directives;
        }
        function collectCommentDirectives(node, directives, attrs, maxPriority, ignoreDirective) {
            try {
                var match = COMMENT_DIRECTIVE_REGEXP.exec(node.nodeValue);
                if (match) {
                    var nName = directiveNormalize(match[1]);
                    if (addDirective(directives, nName, 'M', maxPriority, ignoreDirective)) {
                        attrs[nName] = trim(match[2]);
                    }
                }
            } catch (e) {
            }
        }
        function groupScan(node, attrStart, attrEnd) {
            var nodes = [];
            var depth = 0;
            if (attrStart && node.hasAttribute && node.hasAttribute(attrStart)) {
                do {
                    if (!node) {
                        throw $compileMinErr('uterdir', 'Unterminated attribute, found \'{0}\' but no matching \'{1}\' found.', attrStart, attrEnd);
                    }
                    if (node.nodeType === NODE_TYPE_ELEMENT) {
                        if (node.hasAttribute(attrStart))
                            depth++;
                        if (node.hasAttribute(attrEnd))
                            depth--;
                    }
                    nodes.push(node);
                    node = node.nextSibling;
                } while (depth > 0);
            } else {
                nodes.push(node);
            }
            return jqLite(nodes);
        }
        function groupElementsLinkFnWrapper(linkFn, attrStart, attrEnd) {
            return function groupedElementsLink(scope, element, attrs, controllers, transcludeFn) {
                element = groupScan(element[0], attrStart, attrEnd);
                return linkFn(scope, element, attrs, controllers, transcludeFn);
            };
        }
        function compilationGenerator(eager, $compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext) {
            var compiled;
            if (eager) {
                return compile($compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext);
            }
            return function lazyCompilation() {
                if (!compiled) {
                    compiled = compile($compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext);
                    $compileNodes = transcludeFn = previousCompileContext = null;
                }
                return compiled.apply(this, arguments);
            };
        }
        function applyDirectivesToNode(directives, compileNode, templateAttrs, transcludeFn, jqCollection, originalReplaceDirective, preLinkFns, postLinkFns, previousCompileContext) {
            previousCompileContext = previousCompileContext || {};
            var terminalPriority = -Number.MAX_VALUE, newScopeDirective = previousCompileContext.newScopeDirective, controllerDirectives = previousCompileContext.controllerDirectives, newIsolateScopeDirective = previousCompileContext.newIsolateScopeDirective, templateDirective = previousCompileContext.templateDirective, nonTlbTranscludeDirective = previousCompileContext.nonTlbTranscludeDirective, hasTranscludeDirective = false, hasTemplate = false, hasElementTranscludeDirective = previousCompileContext.hasElementTranscludeDirective, $compileNode = templateAttrs.$$element = jqLite(compileNode), directive, directiveName, $template, replaceDirective = originalReplaceDirective, childTranscludeFn = transcludeFn, linkFn, didScanForMultipleTransclusion = false, mightHaveMultipleTransclusionError = false, directiveValue;
            for (var i = 0, ii = directives.length; i < ii; i++) {
                directive = directives[i];
                var attrStart = directive.$$start;
                var attrEnd = directive.$$end;
                if (attrStart) {
                    $compileNode = groupScan(compileNode, attrStart, attrEnd);
                }
                $template = undefined;
                if (terminalPriority > directive.priority) {
                    break;
                }
                directiveValue = directive.scope;
                if (directiveValue) {
                    if (!directive.templateUrl) {
                        if (isObject(directiveValue)) {
                            assertNoDuplicate('new/isolated scope', newIsolateScopeDirective || newScopeDirective, directive, $compileNode);
                            newIsolateScopeDirective = directive;
                        } else {
                            assertNoDuplicate('new/isolated scope', newIsolateScopeDirective, directive, $compileNode);
                        }
                    }
                    newScopeDirective = newScopeDirective || directive;
                }
                directiveName = directive.name;
                if (!didScanForMultipleTransclusion && (directive.replace && (directive.templateUrl || directive.template) || directive.transclude && !directive.$$tlb)) {
                    var candidateDirective;
                    for (var scanningIndex = i + 1; candidateDirective = directives[scanningIndex++];) {
                        if (candidateDirective.transclude && !candidateDirective.$$tlb || candidateDirective.replace && (candidateDirective.templateUrl || candidateDirective.template)) {
                            mightHaveMultipleTransclusionError = true;
                            break;
                        }
                    }
                    didScanForMultipleTransclusion = true;
                }
                if (!directive.templateUrl && directive.controller) {
                    controllerDirectives = controllerDirectives || createMap();
                    assertNoDuplicate('\'' + directiveName + '\' controller', controllerDirectives[directiveName], directive, $compileNode);
                    controllerDirectives[directiveName] = directive;
                }
                directiveValue = directive.transclude;
                if (directiveValue) {
                    hasTranscludeDirective = true;
                    if (!directive.$$tlb) {
                        assertNoDuplicate('transclusion', nonTlbTranscludeDirective, directive, $compileNode);
                        nonTlbTranscludeDirective = directive;
                    }
                    if (directiveValue === 'element') {
                        hasElementTranscludeDirective = true;
                        terminalPriority = directive.priority;
                        $template = $compileNode;
                        $compileNode = templateAttrs.$$element = jqLite(compile.$$createComment(directiveName, templateAttrs[directiveName]));
                        compileNode = $compileNode[0];
                        replaceWith(jqCollection, sliceArgs($template), compileNode);
                        $template[0].$$parentNode = $template[0].parentNode;
                        childTranscludeFn = compilationGenerator(mightHaveMultipleTransclusionError, $template, transcludeFn, terminalPriority, replaceDirective && replaceDirective.name, {
                            nonTlbTranscludeDirective: nonTlbTranscludeDirective
                        });
                    } else {
                        var slots = createMap();
                        if (!isObject(directiveValue)) {
                            $template = jqLite(jqLiteClone(compileNode)).contents();
                        } else {
                            $template = [];
                            var slotMap = createMap();
                            var filledSlots = createMap();
                            forEach(directiveValue, function (elementSelector, slotName) {
                                var optional = elementSelector.charAt(0) === '?';
                                elementSelector = optional ? elementSelector.substring(1) : elementSelector;
                                slotMap[elementSelector] = slotName;
                                slots[slotName] = null;
                                filledSlots[slotName] = optional;
                            });
                            forEach($compileNode.contents(), function (node) {
                                var slotName = slotMap[directiveNormalize(nodeName_(node))];
                                if (slotName) {
                                    filledSlots[slotName] = true;
                                    slots[slotName] = slots[slotName] || [];
                                    slots[slotName].push(node);
                                } else {
                                    $template.push(node);
                                }
                            });
                            forEach(filledSlots, function (filled, slotName) {
                                if (!filled) {
                                    throw $compileMinErr('reqslot', 'Required transclusion slot `{0}` was not filled.', slotName);
                                }
                            });
                            for (var slotName in slots) {
                                if (slots[slotName]) {
                                    slots[slotName] = compilationGenerator(mightHaveMultipleTransclusionError, slots[slotName], transcludeFn);
                                }
                            }
                        }
                        $compileNode.empty();
                        childTranscludeFn = compilationGenerator(mightHaveMultipleTransclusionError, $template, transcludeFn, undefined, undefined, {
                            needsNewScope: directive.$$isolateScope || directive.$$newScope
                        });
                        childTranscludeFn.$$slots = slots;
                    }
                }
                if (directive.template) {
                    hasTemplate = true;
                    assertNoDuplicate('template', templateDirective, directive, $compileNode);
                    templateDirective = directive;
                    directiveValue = isFunction(directive.template) ? directive.template($compileNode, templateAttrs) : directive.template;
                    directiveValue = denormalizeTemplate(directiveValue);
                    if (directive.replace) {
                        replaceDirective = directive;
                        if (jqLiteIsTextNode(directiveValue)) {
                            $template = [];
                        } else {
                            $template = removeComments(wrapTemplate(directive.templateNamespace, trim(directiveValue)));
                        }
                        compileNode = $template[0];
                        if ($template.length !== 1 || compileNode.nodeType !== NODE_TYPE_ELEMENT) {
                            throw $compileMinErr('tplrt', 'Template for directive \'{0}\' must have exactly one root element. {1}', directiveName, '');
                        }
                        replaceWith(jqCollection, $compileNode, compileNode);
                        var newTemplateAttrs = {
                            $attr: {}
                        };
                        var templateDirectives = collectDirectives(compileNode, [], newTemplateAttrs);
                        var unprocessedDirectives = directives.splice(i + 1, directives.length - (i + 1));
                        if (newIsolateScopeDirective || newScopeDirective) {
                            markDirectiveScope(templateDirectives, newIsolateScopeDirective, newScopeDirective);
                        }
                        directives = directives.concat(templateDirectives).concat(unprocessedDirectives);
                        mergeTemplateAttributes(templateAttrs, newTemplateAttrs);
                        ii = directives.length;
                    } else {
                        $compileNode.html(directiveValue);
                    }
                }
                if (directive.templateUrl) {
                    hasTemplate = true;
                    assertNoDuplicate('template', templateDirective, directive, $compileNode);
                    templateDirective = directive;
                    if (directive.replace) {
                        replaceDirective = directive;
                    }
                    nodeLinkFn = compileTemplateUrl(directives.splice(i, directives.length - i), $compileNode, templateAttrs, jqCollection, hasTranscludeDirective && childTranscludeFn, preLinkFns, postLinkFns, {
                        controllerDirectives: controllerDirectives,
                        newScopeDirective: newScopeDirective !== directive && newScopeDirective,
                        newIsolateScopeDirective: newIsolateScopeDirective,
                        templateDirective: templateDirective,
                        nonTlbTranscludeDirective: nonTlbTranscludeDirective
                    });
                    ii = directives.length;
                } else if (directive.compile) {
                    try {
                        linkFn = directive.compile($compileNode, templateAttrs, childTranscludeFn);
                        var context = directive.$$originalDirective || directive;
                        if (isFunction(linkFn)) {
                            addLinkFns(null, bind(context, linkFn), attrStart, attrEnd);
                        } else if (linkFn) {
                            addLinkFns(bind(context, linkFn.pre), bind(context, linkFn.post), attrStart, attrEnd);
                        }
                    } catch (e) {
                        $exceptionHandler(e, startingTag($compileNode));
                    }
                }
                if (directive.terminal) {
                    nodeLinkFn.terminal = true;
                    terminalPriority = Math.max(terminalPriority, directive.priority);
                }
            }
            nodeLinkFn.scope = newScopeDirective && newScopeDirective.scope === true;
            nodeLinkFn.transcludeOnThisElement = hasTranscludeDirective;
            nodeLinkFn.templateOnThisElement = hasTemplate;
            nodeLinkFn.transclude = childTranscludeFn;
            previousCompileContext.hasElementTranscludeDirective = hasElementTranscludeDirective;
            return nodeLinkFn;
            function addLinkFns(pre, post, attrStart, attrEnd) {
                if (pre) {
                    if (attrStart)
                        pre = groupElementsLinkFnWrapper(pre, attrStart, attrEnd);
                    pre.require = directive.require;
                    pre.directiveName = directiveName;
                    if (newIsolateScopeDirective === directive || directive.$$isolateScope) {
                        pre = cloneAndAnnotateFn(pre, {
                            isolateScope: true
                        });
                    }
                    preLinkFns.push(pre);
                }
                if (post) {
                    if (attrStart)
                        post = groupElementsLinkFnWrapper(post, attrStart, attrEnd);
                    post.require = directive.require;
                    post.directiveName = directiveName;
                    if (newIsolateScopeDirective === directive || directive.$$isolateScope) {
                        post = cloneAndAnnotateFn(post, {
                            isolateScope: true
                        });
                    }
                    postLinkFns.push(post);
                }
            }
            function nodeLinkFn(childLinkFn, scope, linkNode, $rootElement, boundTranscludeFn) {
                var i, ii, linkFn, isolateScope, controllerScope, elementControllers, transcludeFn, $element, attrs, scopeBindingInfo;
                if (compileNode === linkNode) {
                    attrs = templateAttrs;
                    $element = templateAttrs.$$element;
                } else {
                    $element = jqLite(linkNode);
                    attrs = new Attributes($element, templateAttrs);
                }
                controllerScope = scope;
                if (newIsolateScopeDirective) {
                    isolateScope = scope.$new(true);
                } else if (newScopeDirective) {
                    controllerScope = scope.$parent;
                }
                if (boundTranscludeFn) {
                    transcludeFn = controllersBoundTransclude;
                    transcludeFn.$$boundTransclude = boundTranscludeFn;
                    transcludeFn.isSlotFilled = function (slotName) {
                        return !!boundTranscludeFn.$$slots[slotName];
                    };
                }
                if (controllerDirectives) {
                    elementControllers = setupControllers($element, attrs, transcludeFn, controllerDirectives, isolateScope, scope, newIsolateScopeDirective);
                }
                if (newIsolateScopeDirective) {
                    compile.$$addScopeInfo($element, isolateScope, true, !(templateDirective && (templateDirective === newIsolateScopeDirective || templateDirective === newIsolateScopeDirective.$$originalDirective)));
                    compile.$$addScopeClass($element, true);
                    isolateScope.$$isolateBindings = newIsolateScopeDirective.$$isolateBindings;
                    scopeBindingInfo = initializeDirectiveBindings(scope, attrs, isolateScope, isolateScope.$$isolateBindings, newIsolateScopeDirective);
                    if (scopeBindingInfo.removeWatches) {
                        isolateScope.$on('$destroy', scopeBindingInfo.removeWatches);
                    }
                }
                for (var name in elementControllers) {
                    var controllerDirective = controllerDirectives[name];
                    var controller = elementControllers[name];
                    var bindings = controllerDirective.$$bindings.bindToController;
                    if (preAssignBindingsEnabled) {
                        if (bindings) {
                            controller.bindingInfo = initializeDirectiveBindings(controllerScope, attrs, controller.instance, bindings, controllerDirective);
                        } else {
                            controller.bindingInfo = {};
                        }
                        var controllerResult = controller();
                        if (controllerResult !== controller.instance) {
                            controller.instance = controllerResult;
                            $element.data('$' + controllerDirective.name + 'Controller', controllerResult);
                            if (controller.bindingInfo.removeWatches) {
                                controller.bindingInfo.removeWatches();
                            }
                            controller.bindingInfo = initializeDirectiveBindings(controllerScope, attrs, controller.instance, bindings, controllerDirective);
                        }
                    } else {
                        controller.instance = controller();
                        $element.data('$' + controllerDirective.name + 'Controller', controller.instance);
                        controller.bindingInfo = initializeDirectiveBindings(controllerScope, attrs, controller.instance, bindings, controllerDirective);
                    }
                }
                forEach(controllerDirectives, function (controllerDirective, name) {
                    var require = controllerDirective.require;
                    if (controllerDirective.bindToController && !isArray(require) && isObject(require)) {
                        extend(elementControllers[name].instance, getControllers(name, require, $element, elementControllers));
                    }
                });
                forEach(elementControllers, function (controller) {
                    var controllerInstance = controller.instance;
                    if (isFunction(controllerInstance.$onChanges)) {
                        try {
                            controllerInstance.$onChanges(controller.bindingInfo.initialChanges);
                        } catch (e) {
                            $exceptionHandler(e);
                        }
                    }
                    if (isFunction(controllerInstance.$onInit)) {
                        try {
                            controllerInstance.$onInit();
                        } catch (e) {
                            $exceptionHandler(e);
                        }
                    }
                    if (isFunction(controllerInstance.$doCheck)) {
                        controllerScope.$watch(function () {
                            controllerInstance.$doCheck();
                        });
                        controllerInstance.$doCheck();
                    }
                    if (isFunction(controllerInstance.$onDestroy)) {
                        controllerScope.$on('$destroy', function callOnDestroyHook() {
                            controllerInstance.$onDestroy();
                        });
                    }
                });
                for (i = 0, ii = preLinkFns.length; i < ii; i++) {
                    linkFn = preLinkFns[i];
                    invokeLinkFn(linkFn, linkFn.isolateScope ? isolateScope : scope, $element, attrs, linkFn.require && getControllers(linkFn.directiveName, linkFn.require, $element, elementControllers), transcludeFn);
                }
                var scopeToChild = scope;
                if (newIsolateScopeDirective && (newIsolateScopeDirective.template || newIsolateScopeDirective.templateUrl === null)) {
                    scopeToChild = isolateScope;
                }
                if (childLinkFn) {
                    childLinkFn(scopeToChild, linkNode.childNodes, undefined, boundTranscludeFn);
                }
                for (i = postLinkFns.length - 1; i >= 0; i--) {
                    linkFn = postLinkFns[i];
                    invokeLinkFn(linkFn, linkFn.isolateScope ? isolateScope : scope, $element, attrs, linkFn.require && getControllers(linkFn.directiveName, linkFn.require, $element, elementControllers), transcludeFn);
                }
                forEach(elementControllers, function (controller) {
                    var controllerInstance = controller.instance;
                    if (isFunction(controllerInstance.$postLink)) {
                        controllerInstance.$postLink();
                    }
                });
                function controllersBoundTransclude(scope, cloneAttachFn, futureParentElement, slotName) {
                    var transcludeControllers;
                    if (!isScope(scope)) {
                        slotName = futureParentElement;
                        futureParentElement = cloneAttachFn;
                        cloneAttachFn = scope;
                        scope = undefined;
                    }
                    if (hasElementTranscludeDirective) {
                        transcludeControllers = elementControllers;
                    }
                    if (!futureParentElement) {
                        futureParentElement = hasElementTranscludeDirective ? $element.parent() : $element;
                    }
                    if (slotName) {
                        var slotTranscludeFn = boundTranscludeFn.$$slots[slotName];
                        if (slotTranscludeFn) {
                            return slotTranscludeFn(scope, cloneAttachFn, transcludeControllers, futureParentElement, scopeToChild);
                        } else if (isUndefined(slotTranscludeFn)) {
                            throw $compileMinErr('noslot', 'No parent directive that requires a transclusion with slot name "{0}". ' + 'Element: {1}', slotName, startingTag($element));
                        }
                    } else {
                        return boundTranscludeFn(scope, cloneAttachFn, transcludeControllers, futureParentElement, scopeToChild);
                    }
                }
            }
        }
        function getControllers(directiveName, require, $element, elementControllers) {
            var value;
            if (isString(require)) {
                var match = require.match(REQUIRE_PREFIX_REGEXP);
                var name = require.substring(match[0].length);
                var inheritType = match[1] || match[3];
                var optional = match[2] === '?';
                if (inheritType === '^^') {
                    $element = $element.parent();
                } else {
                    value = elementControllers && elementControllers[name];
                    value = value && value.instance;
                }
                if (!value) {
                    var dataName = '$' + name + 'Controller';
                    value = inheritType ? $element.inheritedData(dataName) : $element.data(dataName);
                }
                if (!value && !optional) {
                    throw $compileMinErr('ctreq', 'Controller \'{0}\', required by directive \'{1}\', can\'t be found!', name, directiveName);
                }
            } else if (isArray(require)) {
                value = [];
                for (var i = 0, ii = require.length; i < ii; i++) {
                    value[i] = getControllers(directiveName, require[i], $element, elementControllers);
                }
            } else if (isObject(require)) {
                value = {};
                forEach(require, function (controller, property) {
                    value[property] = getControllers(directiveName, controller, $element, elementControllers);
                });
            }
            return value || null;
        }
        function setupControllers($element, attrs, transcludeFn, controllerDirectives, isolateScope, scope, newIsolateScopeDirective) {
            var elementControllers = createMap();
            for (var controllerKey in controllerDirectives) {
                var directive = controllerDirectives[controllerKey];
                var locals = {
                    $scope: directive === newIsolateScopeDirective || directive.$$isolateScope ? isolateScope : scope,
                    $element: $element,
                    $attrs: attrs,
                    $transclude: transcludeFn
                };
                var controller = directive.controller;
                if (controller === '@') {
                    controller = attrs[directive.name];
                }
                var controllerInstance = $controller(controller, locals, true, directive.controllerAs);
                elementControllers[directive.name] = controllerInstance;
                $element.data('$' + directive.name + 'Controller', controllerInstance.instance);
            }
            return elementControllers;
        }
        function markDirectiveScope(directives, isolateScope, newScope) {
            for (var j = 0, jj = directives.length; j < jj; j++) {
                directives[j] = inherit(directives[j], {
                    $$isolateScope: isolateScope,
                    $$newScope: newScope
                });
            }
        }
        function addDirective(tDirectives, name, location, maxPriority, ignoreDirective, startAttrName, endAttrName) {
            if (name === ignoreDirective)
                return null;
            var match = null;
            if (hasDirectives.hasOwnProperty(name)) {
                for (var directive, directives = $injector.get(name + Suffix), i = 0, ii = directives.length; i < ii; i++) {
                    directive = directives[i];
                    if ((isUndefined(maxPriority) || maxPriority > directive.priority) && directive.restrict.indexOf(location) !== -1) {
                        if (startAttrName) {
                            directive = inherit(directive, {
                                $$start: startAttrName,
                                $$end: endAttrName
                            });
                        }
                        if (!directive.$$bindings) {
                            var bindings = directive.$$bindings = parseDirectiveBindings(directive, directive.name);
                            if (isObject(bindings.isolateScope)) {
                                directive.$$isolateBindings = bindings.isolateScope;
                            }
                        }
                        tDirectives.push(directive);
                        match = directive;
                    }
                }
            }
            return match;
        }
        function directiveIsMultiElement(name) {
            if (hasDirectives.hasOwnProperty(name)) {
                for (var directive, directives = $injector.get(name + Suffix), i = 0, ii = directives.length; i < ii; i++) {
                    directive = directives[i];
                    if (directive.multiElement) {
                        return true;
                    }
                }
            }
            return false;
        }
        function mergeTemplateAttributes(dst, src) {
            var srcAttr = src.$attr, dstAttr = dst.$attr;
            forEach(dst, function (value, key) {
                if (key.charAt(0) !== '$') {
                    if (src[key] && src[key] !== value) {
                        if (value.length) {
                            value += (key === 'style' ? ';' : ' ') + src[key];
                        } else {
                            value = src[key];
                        }
                    }
                    dst.$set(key, value, true, srcAttr[key]);
                }
            });
            forEach(src, function (value, key) {
                if (!dst.hasOwnProperty(key) && key.charAt(0) !== '$') {
                    dst[key] = value;
                    if (key !== 'class' && key !== 'style') {
                        dstAttr[key] = srcAttr[key];
                    }
                }
            });
        }
        function compileTemplateUrl(directives, $compileNode, tAttrs, $rootElement, childTranscludeFn, preLinkFns, postLinkFns, previousCompileContext) {
            var linkQueue = [], afterTemplateNodeLinkFn, afterTemplateChildLinkFn, beforeTemplateCompileNode = $compileNode[0], origAsyncDirective = directives.shift(), derivedSyncDirective = inherit(origAsyncDirective, {
                    templateUrl: null,
                    transclude: null,
                    replace: null,
                    $$originalDirective: origAsyncDirective
                }), templateUrl = isFunction(origAsyncDirective.templateUrl) ? origAsyncDirective.templateUrl($compileNode, tAttrs) : origAsyncDirective.templateUrl, templateNamespace = origAsyncDirective.templateNamespace;
            $compileNode.empty();
            $templateRequest(templateUrl).then(function (content) {
                var compileNode, tempTemplateAttrs, $template, childBoundTranscludeFn;
                content = denormalizeTemplate(content);
                if (origAsyncDirective.replace) {
                    if (jqLiteIsTextNode(content)) {
                        $template = [];
                    } else {
                        $template = removeComments(wrapTemplate(templateNamespace, trim(content)));
                    }
                    compileNode = $template[0];
                    if ($template.length !== 1 || compileNode.nodeType !== NODE_TYPE_ELEMENT) {
                        throw $compileMinErr('tplrt', 'Template for directive \'{0}\' must have exactly one root element. {1}', origAsyncDirective.name, templateUrl);
                    }
                    tempTemplateAttrs = {
                        $attr: {}
                    };
                    replaceWith($rootElement, $compileNode, compileNode);
                    var templateDirectives = collectDirectives(compileNode, [], tempTemplateAttrs);
                    if (isObject(origAsyncDirective.scope)) {
                        markDirectiveScope(templateDirectives, true);
                    }
                    directives = templateDirectives.concat(directives);
                    mergeTemplateAttributes(tAttrs, tempTemplateAttrs);
                } else {
                    compileNode = beforeTemplateCompileNode;
                    $compileNode.html(content);
                }
                directives.unshift(derivedSyncDirective);
                afterTemplateNodeLinkFn = applyDirectivesToNode(directives, compileNode, tAttrs, childTranscludeFn, $compileNode, origAsyncDirective, preLinkFns, postLinkFns, previousCompileContext);
                forEach($rootElement, function (node, i) {
                    if (node === compileNode) {
                        $rootElement[i] = $compileNode[0];
                    }
                });
                afterTemplateChildLinkFn = compileNodes($compileNode[0].childNodes, childTranscludeFn);
                while (linkQueue.length) {
                    var scope = linkQueue.shift(), beforeTemplateLinkNode = linkQueue.shift(), linkRootElement = linkQueue.shift(), boundTranscludeFn = linkQueue.shift(), linkNode = $compileNode[0];
                    if (scope.$$destroyed)
                        continue;
                    if (beforeTemplateLinkNode !== beforeTemplateCompileNode) {
                        var oldClasses = beforeTemplateLinkNode.className;
                        if (!(previousCompileContext.hasElementTranscludeDirective && origAsyncDirective.replace)) {
                            linkNode = jqLiteClone(compileNode);
                        }
                        replaceWith(linkRootElement, jqLite(beforeTemplateLinkNode), linkNode);
                        safeAddClass(jqLite(linkNode), oldClasses);
                    }
                    if (afterTemplateNodeLinkFn.transcludeOnThisElement) {
                        childBoundTranscludeFn = createBoundTranscludeFn(scope, afterTemplateNodeLinkFn.transclude, boundTranscludeFn);
                    } else {
                        childBoundTranscludeFn = boundTranscludeFn;
                    }
                    afterTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, linkNode, $rootElement, childBoundTranscludeFn);
                }
                linkQueue = null;
            }).catch(function (error) {
                if (error instanceof Error) {
                    $exceptionHandler(error);
                }
            });
            return function delayedNodeLinkFn(ignoreChildLinkFn, scope, node, rootElement, boundTranscludeFn) {
                var childBoundTranscludeFn = boundTranscludeFn;
                if (scope.$$destroyed)
                    return;
                if (linkQueue) {
                    linkQueue.push(scope, node, rootElement, childBoundTranscludeFn);
                } else {
                    if (afterTemplateNodeLinkFn.transcludeOnThisElement) {
                        childBoundTranscludeFn = createBoundTranscludeFn(scope, afterTemplateNodeLinkFn.transclude, boundTranscludeFn);
                    }
                    afterTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, node, rootElement, childBoundTranscludeFn);
                }
            };
        }
        function byPriority(a, b) {
            var diff = b.priority - a.priority;
            if (diff !== 0)
                return diff;
            if (a.name !== b.name)
                return a.name < b.name ? -1 : 1;
            return a.index - b.index;
        }
        function assertNoDuplicate(what, previousDirective, directive, element) {
            function wrapModuleNameIfDefined(moduleName) {
                return moduleName ? ' (module: ' + moduleName + ')' : '';
            }
            if (previousDirective) {
                throw $compileMinErr('multidir', 'Multiple directives [{0}{1}, {2}{3}] asking for {4} on: {5}', previousDirective.name, wrapModuleNameIfDefined(previousDirective.$$moduleName), directive.name, wrapModuleNameIfDefined(directive.$$moduleName), what, startingTag(element));
            }
        }
        function addTextInterpolateDirective(directives, text) {
            var interpolateFn = $interpolate(text, true);
            if (interpolateFn) {
                directives.push({
                    priority: 0,
                    compile: function textInterpolateCompileFn(templateNode) {
                        var templateNodeParent = templateNode.parent(), hasCompileParent = !!templateNodeParent.length;
                        if (hasCompileParent)
                            compile.$$addBindingClass(templateNodeParent);
                        return function textInterpolateLinkFn(scope, node) {
                            var parent = node.parent();
                            if (!hasCompileParent)
                                compile.$$addBindingClass(parent);
                            compile.$$addBindingInfo(parent, interpolateFn.expressions);
                            scope.$watch(interpolateFn, function interpolateFnWatchAction(value) {
                                node[0].nodeValue = value;
                            });
                        };
                    }
                });
            }
        }
        function wrapTemplate(type, template) {
            type = lowercase(type || 'html');
            switch (type) {
            case 'svg':
            case 'math':
                var wrapper = window.document.createElement('div');
                wrapper.innerHTML = '<' + type + '>' + template + '</' + type + '>';
                return wrapper.childNodes[0].childNodes;
            default:
                return template;
            }
        }
        function getTrustedContext(node, attrNormalizedName) {
            if (attrNormalizedName === 'srcdoc') {
                return $sce.HTML;
            }
            var tag = nodeName_(node);
            if (attrNormalizedName === 'src' || attrNormalizedName === 'ngSrc') {
                if ([
                        'img',
                        'video',
                        'audio',
                        'source',
                        'track'
                    ].indexOf(tag) === -1) {
                    return $sce.RESOURCE_URL;
                }
            } else if (attrNormalizedName === 'xlinkHref' || tag === 'form' && attrNormalizedName === 'action' || tag === 'link' && attrNormalizedName === 'href') {
                return $sce.RESOURCE_URL;
            }
        }
        function addAttrInterpolateDirective(node, directives, value, name, isNgAttr) {
            var trustedContext = getTrustedContext(node, name);
            var mustHaveExpression = !isNgAttr;
            var allOrNothing = ALL_OR_NOTHING_ATTRS[name] || isNgAttr;
            var interpolateFn = $interpolate(value, mustHaveExpression, trustedContext, allOrNothing);
            if (!interpolateFn)
                return;
            if (name === 'multiple' && nodeName_(node) === 'select') {
                throw $compileMinErr('selmulti', 'Binding to the \'multiple\' attribute is not supported. Element: {0}', startingTag(node));
            }
            if (EVENT_HANDLER_ATTR_REGEXP.test(name)) {
                throw $compileMinErr('nodomevents', 'Interpolations for HTML DOM event attributes are disallowed.  Please use the ' + 'ng- versions (such as ng-click instead of onclick) instead.');
            }
            directives.push({
                priority: 100,
                compile: function () {
                    return {
                        pre: function attrInterpolatePreLinkFn(scope, element, attr) {
                            var $$observers = attr.$$observers || (attr.$$observers = createMap());
                            var newValue = attr[name];
                            if (newValue !== value) {
                                interpolateFn = newValue && $interpolate(newValue, true, trustedContext, allOrNothing);
                                value = newValue;
                            }
                            if (!interpolateFn)
                                return;
                            attr[name] = interpolateFn(scope);
                            ($$observers[name] || ($$observers[name] = [])).$$inter = true;
                            (attr.$$observers && attr.$$observers[name].$$scope || scope).$watch(interpolateFn, function interpolateFnWatchAction(newValue, oldValue) {
                                if (name === 'class' && newValue !== oldValue) {
                                    attr.$updateClass(newValue, oldValue);
                                } else {
                                    attr.$set(name, newValue);
                                }
                            });
                        }
                    };
                }
            });
        }
        function replaceWith($rootElement, elementsToRemove, newNode) {
            var firstElementToRemove = elementsToRemove[0], removeCount = elementsToRemove.length, parent = firstElementToRemove.parentNode, i, ii;
            if ($rootElement) {
                for (i = 0, ii = $rootElement.length; i < ii; i++) {
                    if ($rootElement[i] === firstElementToRemove) {
                        $rootElement[i++] = newNode;
                        for (var j = i, j2 = j + removeCount - 1, jj = $rootElement.length; j < jj; j++, j2++) {
                            if (j2 < jj) {
                                $rootElement[j] = $rootElement[j2];
                            } else {
                                delete $rootElement[j];
                            }
                        }
                        $rootElement.length -= removeCount - 1;
                        if ($rootElement.context === firstElementToRemove) {
                            $rootElement.context = newNode;
                        }
                        break;
                    }
                }
            }
            if (parent) {
                parent.replaceChild(newNode, firstElementToRemove);
            }
            var fragment = window.document.createDocumentFragment();
            for (i = 0; i < removeCount; i++) {
                fragment.appendChild(elementsToRemove[i]);
            }
            if (jqLite.hasData(firstElementToRemove)) {
                jqLite.data(newNode, jqLite.data(firstElementToRemove));
                jqLite(firstElementToRemove).off('$destroy');
            }
            jqLite.cleanData(fragment.querySelectorAll('*'));
            for (i = 1; i < removeCount; i++) {
                delete elementsToRemove[i];
            }
            elementsToRemove[0] = newNode;
            elementsToRemove.length = 1;
        }
        function cloneAndAnnotateFn(fn, annotation) {
            return extend(function () {
                return fn.apply(null, arguments);
            }, fn, annotation);
        }
        function invokeLinkFn(linkFn, scope, $element, attrs, controllers, transcludeFn) {
            try {
                linkFn(scope, $element, attrs, controllers, transcludeFn);
            } catch (e) {
                $exceptionHandler(e, startingTag($element));
            }
        }
        function initializeDirectiveBindings(scope, attrs, destination, bindings, directive) {
            var removeWatchCollection = [];
            var initialChanges = {};
            var changes;
            forEach(bindings, function initializeBinding(definition, scopeName) {
                var attrName = definition.attrName, optional = definition.optional, mode = definition.mode, lastValue, parentGet, parentSet, compare, removeWatch;
                switch (mode) {
                case '@':
                    if (!optional && !hasOwnProperty.call(attrs, attrName)) {
                        destination[scopeName] = attrs[attrName] = undefined;
                    }
                    removeWatch = attrs.$observe(attrName, function (value) {
                        if (isString(value) || isBoolean(value)) {
                            var oldValue = destination[scopeName];
                            recordChanges(scopeName, value, oldValue);
                            destination[scopeName] = value;
                        }
                    });
                    attrs.$$observers[attrName].$$scope = scope;
                    lastValue = attrs[attrName];
                    if (isString(lastValue)) {
                        destination[scopeName] = $interpolate(lastValue)(scope);
                    } else if (isBoolean(lastValue)) {
                        destination[scopeName] = lastValue;
                    }
                    initialChanges[scopeName] = new SimpleChange(_UNINITIALIZED_VALUE, destination[scopeName]);
                    removeWatchCollection.push(removeWatch);
                    break;
                case '=':
                    if (!hasOwnProperty.call(attrs, attrName)) {
                        if (optional)
                            break;
                        attrs[attrName] = undefined;
                    }
                    if (optional && !attrs[attrName])
                        break;
                    parentGet = $parse(attrs[attrName]);
                    if (parentGet.literal) {
                        compare = equals;
                    } else {
                        compare = function simpleCompare(a, b) {
                            return a === b || a !== a && b !== b;
                        };
                    }
                    parentSet = parentGet.assign || function () {
                        lastValue = destination[scopeName] = parentGet(scope);
                        throw $compileMinErr('nonassign', 'Expression \'{0}\' in attribute \'{1}\' used with directive \'{2}\' is non-assignable!', attrs[attrName], attrName, directive.name);
                    };
                    lastValue = destination[scopeName] = parentGet(scope);
                    var parentValueWatch = function parentValueWatch(parentValue) {
                        if (!compare(parentValue, destination[scopeName])) {
                            if (!compare(parentValue, lastValue)) {
                                destination[scopeName] = parentValue;
                            } else {
                                parentSet(scope, parentValue = destination[scopeName]);
                            }
                        }
                        lastValue = parentValue;
                        return lastValue;
                    };
                    parentValueWatch.$stateful = true;
                    if (definition.collection) {
                        removeWatch = scope.$watchCollection(attrs[attrName], parentValueWatch);
                    } else {
                        removeWatch = scope.$watch($parse(attrs[attrName], parentValueWatch), null, parentGet.literal);
                    }
                    removeWatchCollection.push(removeWatch);
                    break;
                case '<':
                    if (!hasOwnProperty.call(attrs, attrName)) {
                        if (optional)
                            break;
                        attrs[attrName] = undefined;
                    }
                    if (optional && !attrs[attrName])
                        break;
                    parentGet = $parse(attrs[attrName]);
                    var deepWatch = parentGet.literal;
                    var initialValue = destination[scopeName] = parentGet(scope);
                    initialChanges[scopeName] = new SimpleChange(_UNINITIALIZED_VALUE, destination[scopeName]);
                    removeWatch = scope.$watch(parentGet, function parentValueWatchAction(newValue, oldValue) {
                        if (oldValue === newValue) {
                            if (oldValue === initialValue || deepWatch && equals(oldValue, initialValue)) {
                                return;
                            }
                            oldValue = initialValue;
                        }
                        recordChanges(scopeName, newValue, oldValue);
                        destination[scopeName] = newValue;
                    }, deepWatch);
                    removeWatchCollection.push(removeWatch);
                    break;
                case '&':
                    parentGet = attrs.hasOwnProperty(attrName) ? $parse(attrs[attrName]) : noop;
                    if (parentGet === noop && optional)
                        break;
                    destination[scopeName] = function (locals) {
                        return parentGet(scope, locals);
                    };
                    break;
                }
            });
            function recordChanges(key, currentValue, previousValue) {
                if (isFunction(destination.$onChanges) && currentValue !== previousValue && (currentValue === currentValue || previousValue === previousValue)) {
                    if (!onChangesQueue) {
                        scope.$$postDigest(flushOnChangesQueue);
                        onChangesQueue = [];
                    }
                    if (!changes) {
                        changes = {};
                        onChangesQueue.push(triggerOnChangesHook);
                    }
                    if (changes[key]) {
                        previousValue = changes[key].previousValue;
                    }
                    changes[key] = new SimpleChange(previousValue, currentValue);
                }
            }
            function triggerOnChangesHook() {
                destination.$onChanges(changes);
                changes = undefined;
            }
            return {
                initialChanges: initialChanges,
                removeWatches: removeWatchCollection.length && function removeWatches() {
                    for (var i = 0, ii = removeWatchCollection.length; i < ii; ++i) {
                        removeWatchCollection[i]();
                    }
                }
            };
        }
    }
];});
    SimpleChange = ($__.fs.SimpleChange_134 = function SimpleChange(previous, current) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
previous = arguments[0], current = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.previousValue = previous;
this.currentValue = current;});
    directiveNormalize = ($__.fs.directiveNormalize_135 = function directiveNormalize(name) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
name = arguments[0];
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    return name['replace'](PREFIX_REGEXP, '')['replace'](SPECIAL_CHARS_REGEXP, ((fnCamelCaseReplace, $__.fs.fnCamelCaseReplace_84), $__.fs.fnCamelCaseReplace_84_121));
case 1:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 1);
    return name['replace'](PREFIX_REGEXP, '')['replace'](SPECIAL_CHARS_REGEXP, ((fnCamelCaseReplace, $__.fs.fnCamelCaseReplace_84), $__.fs.fnCamelCaseReplace_84_123));
case 2:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 2);
    return name['replace'](PREFIX_REGEXP, '')['replace'](SPECIAL_CHARS_REGEXP, ((fnCamelCaseReplace, $__.fs.fnCamelCaseReplace_84), $__.fs.fnCamelCaseReplace_84_125));
case 3:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 3);
    return name['replace'](PREFIX_REGEXP, '')['replace'](SPECIAL_CHARS_REGEXP, ((fnCamelCaseReplace, $__.fs.fnCamelCaseReplace_84), $__.fs.fnCamelCaseReplace_84_127));
case 4:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 4);
    return name['replace'](PREFIX_REGEXP, '')['replace'](SPECIAL_CHARS_REGEXP, ((fnCamelCaseReplace, $__.fs.fnCamelCaseReplace_84), $__.fs.fnCamelCaseReplace_84_129));
case 5:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 5);
    return name['replace'](PREFIX_REGEXP, '')['replace'](SPECIAL_CHARS_REGEXP, ((fnCamelCaseReplace, $__.fs.fnCamelCaseReplace_84), $__.fs.fnCamelCaseReplace_84_131));
case 6:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 6);
    return name['replace'](PREFIX_REGEXP, '')['replace'](SPECIAL_CHARS_REGEXP, ((fnCamelCaseReplace, $__.fs.fnCamelCaseReplace_84), $__.fs.fnCamelCaseReplace_84_139));
case 7:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 7);
    return name['replace'](PREFIX_REGEXP, '')['replace'](SPECIAL_CHARS_REGEXP, ((fnCamelCaseReplace, $__.fs.fnCamelCaseReplace_84), $__.fs.fnCamelCaseReplace_84_141));
case 8:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 8);
    return name['replace'](PREFIX_REGEXP, '')['replace'](SPECIAL_CHARS_REGEXP, ((fnCamelCaseReplace, $__.fs.fnCamelCaseReplace_84), $__.fs.fnCamelCaseReplace_84_143));
case 9:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 9);
    return name['replace'](PREFIX_REGEXP, '')['replace'](SPECIAL_CHARS_REGEXP, ((fnCamelCaseReplace, $__.fs.fnCamelCaseReplace_84), $__.fs.fnCamelCaseReplace_84_150));
case 10:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 10);
    return name['replace'](PREFIX_REGEXP, '')['replace'](SPECIAL_CHARS_REGEXP, ((fnCamelCaseReplace, $__.fs.fnCamelCaseReplace_84), $__.fs.fnCamelCaseReplace_84_152));
case 11:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 11);
    return name['replace'](PREFIX_REGEXP, '')['replace'](SPECIAL_CHARS_REGEXP, ((fnCamelCaseReplace, $__.fs.fnCamelCaseReplace_84), $__.fs.fnCamelCaseReplace_84_154));
case 12:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 12);
    return name['replace'](PREFIX_REGEXP, '')['replace'](SPECIAL_CHARS_REGEXP, ((fnCamelCaseReplace, $__.fs.fnCamelCaseReplace_84), $__.fs.fnCamelCaseReplace_84_156));
case 13:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 13);
    return name['replace'](PREFIX_REGEXP, '')['replace'](SPECIAL_CHARS_REGEXP, ((fnCamelCaseReplace, $__.fs.fnCamelCaseReplace_84), $__.fs.fnCamelCaseReplace_84_158));
case 14:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 14);
    return name['replace'](PREFIX_REGEXP, '')['replace'](SPECIAL_CHARS_REGEXP, ((fnCamelCaseReplace, $__.fs.fnCamelCaseReplace_84), $__.fs.fnCamelCaseReplace_84_160));
case 15:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 15);
    return name['replace'](PREFIX_REGEXP, '')['replace'](SPECIAL_CHARS_REGEXP, ((fnCamelCaseReplace, $__.fs.fnCamelCaseReplace_84), $__.fs.fnCamelCaseReplace_84_162));
case 16:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 16);
    return name['replace'](PREFIX_REGEXP, '')['replace'](SPECIAL_CHARS_REGEXP, ((fnCamelCaseReplace, $__.fs.fnCamelCaseReplace_84), $__.fs.fnCamelCaseReplace_84_164));
case 17:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 17);
    return name['replace'](PREFIX_REGEXP, '')['replace'](SPECIAL_CHARS_REGEXP, ((fnCamelCaseReplace, $__.fs.fnCamelCaseReplace_84), $__.fs.fnCamelCaseReplace_84_166));
case 18:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 18);
    return name['replace'](PREFIX_REGEXP, '')['replace'](SPECIAL_CHARS_REGEXP, ((fnCamelCaseReplace, $__.fs.fnCamelCaseReplace_84), $__.fs.fnCamelCaseReplace_84_168));
case 19:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 19);
    return name['replace'](PREFIX_REGEXP, '')['replace'](SPECIAL_CHARS_REGEXP, ((fnCamelCaseReplace, $__.fs.fnCamelCaseReplace_84), $__.fs.fnCamelCaseReplace_84_170));
case 20:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 20);
    return name['replace'](PREFIX_REGEXP, '')['replace'](SPECIAL_CHARS_REGEXP, ((fnCamelCaseReplace, $__.fs.fnCamelCaseReplace_84), $__.fs.fnCamelCaseReplace_84_172));
case 21:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 21);
    return name['replace'](PREFIX_REGEXP, '')['replace'](SPECIAL_CHARS_REGEXP, ((fnCamelCaseReplace, $__.fs.fnCamelCaseReplace_84), $__.fs.fnCamelCaseReplace_84_174));
case 22:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 22);
    return name['replace'](PREFIX_REGEXP, '')['replace'](SPECIAL_CHARS_REGEXP, ((fnCamelCaseReplace, $__.fs.fnCamelCaseReplace_84), $__.fs.fnCamelCaseReplace_84_176));
case 23:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 23);
    return name['replace'](PREFIX_REGEXP, '')['replace'](SPECIAL_CHARS_REGEXP, ((fnCamelCaseReplace, $__.fs.fnCamelCaseReplace_84), $__.fs.fnCamelCaseReplace_84_178));
case 24:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 24);
    return name['replace'](PREFIX_REGEXP, '')['replace'](SPECIAL_CHARS_REGEXP, ((fnCamelCaseReplace, $__.fs.fnCamelCaseReplace_84), $__.fs.fnCamelCaseReplace_84_180));
case 25:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 25);
    return name['replace'](PREFIX_REGEXP, '')['replace'](SPECIAL_CHARS_REGEXP, ((fnCamelCaseReplace, $__.fs.fnCamelCaseReplace_84), $__.fs.fnCamelCaseReplace_84_182));
case 26:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 26);
    return name['replace'](PREFIX_REGEXP, '')['replace'](SPECIAL_CHARS_REGEXP, ((fnCamelCaseReplace, $__.fs.fnCamelCaseReplace_84), $__.fs.fnCamelCaseReplace_84_184));
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return name.replace(PREFIX_REGEXP, '').replace(SPECIAL_CHARS_REGEXP, fnCamelCaseReplace);});
    nodesetLinkingFn = ($__.fs.nodesetLinkingFn_136 = function nodesetLinkingFn(scope, nodeList, rootElement, boundTranscludeFn) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
scope = arguments[0], nodeList = arguments[1], rootElement = arguments[2], boundTranscludeFn = arguments[3];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');});
    directiveLinkingFn = ($__.fs.directiveLinkingFn_137 = function directiveLinkingFn(nodesetLinkingFn, scope, node, rootElement, boundTranscludeFn) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
nodesetLinkingFn = arguments[0], scope = arguments[1], node = arguments[2], rootElement = arguments[3], boundTranscludeFn = arguments[4];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');});
    tokenDifference = ($__.fs.tokenDifference_138 = function tokenDifference(str1, str2) {
var vvv_return, vvv_switch, values, tokens1, tokens2, token;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
str1 = arguments[0], str2 = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
values = '';
tokens1 = str1.split(/\s+/);
tokens2 = str2.split(/\s+/);
outer:
    for (var i = 0; i < tokens1.length; i++) {
        token = tokens1[i];
        for (var j = 0; j < tokens2.length; j++) {
            if (token === tokens2[j])
                continue outer;
        }
        values += (values.length > 0 ? ' ' : '') + token;
    }
return values;});
    removeComments = ($__.fs.removeComments_139 = function removeComments(jqNodes) {
var vvv_return, vvv_switch, i, node;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
jqNodes = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
jqNodes = jqLite(jqNodes);
i = jqNodes.length;
if (i <= 1) {
    return jqNodes;
}
while (i--) {
    node = jqNodes[i];
    if (node.nodeType === NODE_TYPE_COMMENT || node.nodeType === NODE_TYPE_TEXT && node.nodeValue.trim() === '') {
        splice.call(jqNodes, i, 1);
    }
}
return jqNodes;});
    identifierForController = ($__.fs.identifierForController_140 = function identifierForController(controller, ident) {
var vvv_return, vvv_switch, match;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
controller = arguments[0], ident = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (ident && isString(ident))
    return ident;
if (isString(controller)) {
    match = CNTRL_REG.exec(controller);
    if (match)
        return match[3];
}});
    $ControllerProvider = ($__.fs.$ControllerProvider_141 = function $ControllerProvider() {
var vvv_return, vvv_switch, controllers, globals;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
controllers = {};
globals = false;
this.has = function (name) {
    return controllers.hasOwnProperty(name);
};
this.register = function (name, constructor) {
    assertNotHasOwnProperty(name, 'controller');
    if (isObject(name)) {
        extend(controllers, name);
    } else {
        controllers[name] = constructor;
    }
};
this.allowGlobals = function () {
    globals = true;
};
this.$get = [
    '$injector',
    '$window',
    function ($injector, $window) {
        return function $controller(expression, locals, later, ident) {
            var instance, match, constructor, identifier;
            later = later === true;
            if (ident && isString(ident)) {
                identifier = ident;
            }
            if (isString(expression)) {
                match = expression.match(CNTRL_REG);
                if (!match) {
                    throw $controllerMinErr('ctrlfmt', 'Badly formed controller string \'{0}\'. ' + 'Must match `__name__ as __id__` or `__name__`.', expression);
                }
                constructor = match[1];
                identifier = identifier || match[3];
                expression = controllers.hasOwnProperty(constructor) ? controllers[constructor] : getter(locals.$scope, constructor, true) || (globals ? getter($window, constructor, true) : undefined);
                if (!expression) {
                    throw $controllerMinErr('ctrlreg', 'The controller with the name \'{0}\' is not registered.', constructor);
                }
                assertArgFn(expression, constructor, true);
            }
            if (later) {
                var controllerPrototype = (isArray(expression) ? expression[expression.length - 1] : expression).prototype;
                instance = Object.create(controllerPrototype || null);
                if (identifier) {
                    addIdentifier(locals, identifier, instance, constructor || expression.name);
                }
                return extend(function $controllerInit() {
                    var result = $injector.invoke(expression, instance, locals, constructor);
                    if (result !== instance && (isObject(result) || isFunction(result))) {
                        instance = result;
                        if (identifier) {
                            addIdentifier(locals, identifier, instance, constructor || expression.name);
                        }
                    }
                    return instance;
                }, {
                    instance: instance,
                    identifier: identifier
                });
            }
            instance = $injector.instantiate(expression, locals, constructor);
            if (identifier) {
                addIdentifier(locals, identifier, instance, constructor || expression.name);
            }
            return instance;
        };
        function addIdentifier(locals, identifier, instance, name) {
            if (!(locals && isObject(locals.$scope))) {
                throw minErr('$controller')('noscp', 'Cannot export controller \'{0}\' as \'{1}\'! No $scope object provided via `locals`.', name, identifier);
            }
            locals.$scope[identifier] = instance;
        }
    }
];});
    $DocumentProvider = ($__.fs.$DocumentProvider_142 = function $DocumentProvider() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.$get = [
    '$window',
    function (window) {
        return jqLite(window.document);
    }
];});
    $$IsDocumentHiddenProvider = ($__.fs.$$IsDocumentHiddenProvider_143 = function $$IsDocumentHiddenProvider() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.$get = [
    '$document',
    '$rootScope',
    function ($document, $rootScope) {
        var doc = $document[0];
        var hidden = doc && doc.hidden;
        $document.on('visibilitychange', changeListener);
        $rootScope.$on('$destroy', function () {
            $document.off('visibilitychange', changeListener);
        });
        function changeListener() {
            hidden = doc.hidden;
        }
        return function () {
            return hidden;
        };
    }
];});
    $ExceptionHandlerProvider = ($__.fs.$ExceptionHandlerProvider_144 = function $ExceptionHandlerProvider() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.$get = [
    '$log',
    function ($log) {
        return function (exception, cause) {
            $log.error.apply($log, arguments);
        };
    }
];});
    serializeValue = ($__.fs.serializeValue_145 = function serializeValue(v) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
v = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (isObject(v)) {
    return isDate(v) ? v.toISOString() : toJson(v);
}
return v;});
    $HttpParamSerializerProvider = ($__.fs.$HttpParamSerializerProvider_146 = function $HttpParamSerializerProvider() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.$get = function () {
    return function ngParamSerializer(params) {
        if (!params)
            return '';
        var parts = [];
        forEachSorted(params, function (value, key) {
            if (value === null || isUndefined(value))
                return;
            if (isArray(value)) {
                forEach(value, function (v) {
                    parts.push(encodeUriQuery(key) + '=' + encodeUriQuery(serializeValue(v)));
                });
            } else {
                parts.push(encodeUriQuery(key) + '=' + encodeUriQuery(serializeValue(value)));
            }
        });
        return parts.join('&');
    };
};});
    $HttpParamSerializerJQLikeProvider = ($__.fs.$HttpParamSerializerJQLikeProvider_147 = function $HttpParamSerializerJQLikeProvider() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.$get = function () {
    return function jQueryLikeParamSerializer(params) {
        if (!params)
            return '';
        var parts = [];
        serialize(params, '', true);
        return parts.join('&');
        function serialize(toSerialize, prefix, topLevel) {
            if (toSerialize === null || isUndefined(toSerialize))
                return;
            if (isArray(toSerialize)) {
                forEach(toSerialize, function (value, index) {
                    serialize(value, prefix + '[' + (isObject(value) ? index : '') + ']');
                });
            } else if (isObject(toSerialize) && !isDate(toSerialize)) {
                forEachSorted(toSerialize, function (value, key) {
                    serialize(value, prefix + (topLevel ? '' : '[') + key + (topLevel ? '' : ']'));
                });
            } else {
                parts.push(encodeUriQuery(prefix) + '=' + encodeUriQuery(serializeValue(toSerialize)));
            }
        }
    };
};});
    defaultHttpResponseTransform = ($__.fs.defaultHttpResponseTransform_148 = function defaultHttpResponseTransform(data, headers) {
var vvv_return, vvv_switch, tempData, contentType;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
data = arguments[0], headers = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (isString(data)) {
    tempData = data.replace(JSON_PROTECTION_PREFIX, '').trim();
    if (tempData) {
        contentType = headers('Content-Type');
        if (contentType && contentType.indexOf(APPLICATION_JSON) === 0 || isJsonLike(tempData)) {
            data = fromJson(tempData);
        }
    }
}
return data;});
    isJsonLike = ($__.fs.isJsonLike_149 = function isJsonLike(str) {
var vvv_return, vvv_switch, jsonStart;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
str = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
jsonStart = str.match(JSON_START);
return jsonStart && JSON_ENDS[jsonStart[0]].test(str);});
    parseHeaders = ($__.fs.parseHeaders_150 = function parseHeaders(headers) {
var vvv_return, vvv_switch, parsed, i, fillInParsed;
fillInParsed = function fillInParsed(key, val) {
    if (key) {
        parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
    }
};
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
headers = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
parsed = createMap();
if (isString(headers)) {
    forEach(headers.split('\n'), function (line) {
        i = line.indexOf(':');
        fillInParsed(lowercase(trim(line.substr(0, i))), trim(line.substr(i + 1)));
    });
} else if (isObject(headers)) {
    forEach(headers, function (headerVal, headerKey) {
        fillInParsed(lowercase(headerKey), trim(headerVal));
    });
}
return parsed;});
    headersGetter = ($__.fs.headersGetter_151 = function headersGetter(headers) {
var vvv_return, vvv_switch, headersObj;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
headers = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return function (name) {
    if (!headersObj)
        headersObj = parseHeaders(headers);
    if (name) {
        var value = headersObj[lowercase(name)];
        if (value === undefined) {
            value = null;
        }
        return value;
    }
    return headersObj;
};});
    transformData = ($__.fs.transformData_152 = function transformData(data, headers, status, fns) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
data = arguments[0], headers = arguments[1], status = arguments[2], fns = arguments[3];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (isFunction(fns)) {
    return fns(data, headers, status);
}
forEach(fns, function (fn) {
    data = fn(data, headers, status);
});
return data;});
    isSuccess = ($__.fs.isSuccess_153 = function isSuccess(status) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
status = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return 200 <= status && status < 300;});
    $HttpProvider = ($__.fs.$HttpProvider_154 = function $HttpProvider() {
var vvv_return, vvv_switch, defaults, useApplyAsync, interceptorFactories;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
defaults = this.defaults = {
    transformResponse: [defaultHttpResponseTransform],
    transformRequest: [function (d) {
            return isObject(d) && !isFile(d) && !isBlob(d) && !isFormData(d) ? toJson(d) : d;
        }],
    headers: {
        common: {
            'Accept': 'application/json, text/plain, */*'
        },
        post: shallowCopy(CONTENT_TYPE_APPLICATION_JSON),
        put: shallowCopy(CONTENT_TYPE_APPLICATION_JSON),
        patch: shallowCopy(CONTENT_TYPE_APPLICATION_JSON)
    },
    xsrfCookieName: 'XSRF-TOKEN',
    xsrfHeaderName: 'X-XSRF-TOKEN',
    paramSerializer: '$httpParamSerializer',
    jsonpCallbackParam: 'callback'
};
useApplyAsync = false;
this.useApplyAsync = function (value) {
    if (isDefined(value)) {
        useApplyAsync = !!value;
        return this;
    }
    return useApplyAsync;
};
interceptorFactories = this.interceptors = [];
this.$get = [
    '$browser',
    '$httpBackend',
    '$$cookieReader',
    '$cacheFactory',
    '$rootScope',
    '$q',
    '$injector',
    '$sce',
    function ($browser, $httpBackend, $$cookieReader, $cacheFactory, $rootScope, $q, $injector, $sce) {
        var defaultCache = $cacheFactory('$http');
        defaults.paramSerializer = isString(defaults.paramSerializer) ? $injector.get(defaults.paramSerializer) : defaults.paramSerializer;
        var reversedInterceptors = [];
        forEach(interceptorFactories, function (interceptorFactory) {
            reversedInterceptors.unshift(isString(interceptorFactory) ? $injector.get(interceptorFactory) : $injector.invoke(interceptorFactory));
        });
        function $http(requestConfig) {
            if (!isObject(requestConfig)) {
                throw minErr('$http')('badreq', 'Http request configuration must be an object.  Received: {0}', requestConfig);
            }
            if (!isString($sce.valueOf(requestConfig.url))) {
                throw minErr('$http')('badreq', 'Http request configuration url must be a string or a $sce trusted object.  Received: {0}', requestConfig.url);
            }
            var config = extend({
                method: 'get',
                transformRequest: defaults.transformRequest,
                transformResponse: defaults.transformResponse,
                paramSerializer: defaults.paramSerializer,
                jsonpCallbackParam: defaults.jsonpCallbackParam
            }, requestConfig);
            config.headers = mergeHeaders(requestConfig);
            config.method = uppercase(config.method);
            config.paramSerializer = isString(config.paramSerializer) ? $injector.get(config.paramSerializer) : config.paramSerializer;
            $browser.$$incOutstandingRequestCount();
            var requestInterceptors = [];
            var responseInterceptors = [];
            var promise = $q.resolve(config);
            forEach(reversedInterceptors, function (interceptor) {
                if (interceptor.request || interceptor.requestError) {
                    requestInterceptors.unshift(interceptor.request, interceptor.requestError);
                }
                if (interceptor.response || interceptor.responseError) {
                    responseInterceptors.push(interceptor.response, interceptor.responseError);
                }
            });
            promise = chainInterceptors(promise, requestInterceptors);
            promise = promise.then(serverRequest);
            promise = chainInterceptors(promise, responseInterceptors);
            promise = promise.finally(completeOutstandingRequest);
            return promise;
            function chainInterceptors(promise, interceptors) {
                for (var i = 0, ii = interceptors.length; i < ii;) {
                    var thenFn = interceptors[i++];
                    var rejectFn = interceptors[i++];
                    promise = promise.then(thenFn, rejectFn);
                }
                interceptors.length = 0;
                return promise;
            }
            function completeOutstandingRequest() {
                $browser.$$completeOutstandingRequest(noop);
            }
            function executeHeaderFns(headers, config) {
                var headerContent, processedHeaders = {};
                forEach(headers, function (headerFn, header) {
                    if (isFunction(headerFn)) {
                        headerContent = headerFn(config);
                        if (headerContent != null) {
                            processedHeaders[header] = headerContent;
                        }
                    } else {
                        processedHeaders[header] = headerFn;
                    }
                });
                return processedHeaders;
            }
            function mergeHeaders(config) {
                var defHeaders = defaults.headers, reqHeaders = extend({}, config.headers), defHeaderName, lowercaseDefHeaderName, reqHeaderName;
                defHeaders = extend({}, defHeaders.common, defHeaders[lowercase(config.method)]);
                defaultHeadersIteration:
                    for (defHeaderName in defHeaders) {
                        lowercaseDefHeaderName = lowercase(defHeaderName);
                        for (reqHeaderName in reqHeaders) {
                            if (lowercase(reqHeaderName) === lowercaseDefHeaderName) {
                                continue defaultHeadersIteration;
                            }
                        }
                        reqHeaders[defHeaderName] = defHeaders[defHeaderName];
                    }
                return executeHeaderFns(reqHeaders, shallowCopy(config));
            }
            function serverRequest(config) {
                var headers = config.headers;
                var reqData = transformData(config.data, headersGetter(headers), undefined, config.transformRequest);
                if (isUndefined(reqData)) {
                    forEach(headers, function (value, header) {
                        if (lowercase(header) === 'content-type') {
                            delete headers[header];
                        }
                    });
                }
                if (isUndefined(config.withCredentials) && !isUndefined(defaults.withCredentials)) {
                    config.withCredentials = defaults.withCredentials;
                }
                return sendReq(config, reqData).then(transformResponse, transformResponse);
            }
            function transformResponse(response) {
                var resp = extend({}, response);
                resp.data = transformData(response.data, response.headers, response.status, config.transformResponse);
                return isSuccess(response.status) ? resp : $q.reject(resp);
            }
        }
        $http.pendingRequests = [];
        createShortMethods('get', 'delete', 'head', 'jsonp');
        createShortMethodsWithData('post', 'put', 'patch');
        $http.defaults = defaults;
        return $http;
        function createShortMethods(names) {
            forEach(arguments, function (name) {
                $http[name] = function (url, config) {
                    return $http(extend({}, config || {}, {
                        method: name,
                        url: url
                    }));
                };
            });
        }
        function createShortMethodsWithData(name) {
            forEach(arguments, function (name) {
                $http[name] = function (url, data, config) {
                    return $http(extend({}, config || {}, {
                        method: name,
                        url: url,
                        data: data
                    }));
                };
            });
        }
        function sendReq(config, reqData) {
            var deferred = $q.defer(), promise = deferred.promise, cache, cachedResp, reqHeaders = config.headers, isJsonp = lowercase(config.method) === 'jsonp', url = config.url;
            if (isJsonp) {
                url = $sce.getTrustedResourceUrl(url);
            } else if (!isString(url)) {
                url = $sce.valueOf(url);
            }
            url = buildUrl(url, config.paramSerializer(config.params));
            if (isJsonp) {
                url = sanitizeJsonpCallbackParam(url, config.jsonpCallbackParam);
            }
            $http.pendingRequests.push(config);
            promise.then(removePendingReq, removePendingReq);
            if ((config.cache || defaults.cache) && config.cache !== false && (config.method === 'GET' || config.method === 'JSONP')) {
                cache = isObject(config.cache) ? config.cache : isObject(defaults.cache) ? defaults.cache : defaultCache;
            }
            if (cache) {
                cachedResp = cache.get(url);
                if (isDefined(cachedResp)) {
                    if (isPromiseLike(cachedResp)) {
                        cachedResp.then(resolvePromiseWithResult, resolvePromiseWithResult);
                    } else {
                        if (isArray(cachedResp)) {
                            resolvePromise(cachedResp[1], cachedResp[0], shallowCopy(cachedResp[2]), cachedResp[3]);
                        } else {
                            resolvePromise(cachedResp, 200, {}, 'OK');
                        }
                    }
                } else {
                    cache.put(url, promise);
                }
            }
            if (isUndefined(cachedResp)) {
                var xsrfValue = urlIsSameOrigin(config.url) ? $$cookieReader()[config.xsrfCookieName || defaults.xsrfCookieName] : undefined;
                if (xsrfValue) {
                    reqHeaders[config.xsrfHeaderName || defaults.xsrfHeaderName] = xsrfValue;
                }
                $httpBackend(config.method, url, reqData, done, reqHeaders, config.timeout, config.withCredentials, config.responseType, createApplyHandlers(config.eventHandlers), createApplyHandlers(config.uploadEventHandlers));
            }
            return promise;
            function createApplyHandlers(eventHandlers) {
                if (eventHandlers) {
                    var applyHandlers = {};
                    forEach(eventHandlers, function (eventHandler, key) {
                        applyHandlers[key] = function (event) {
                            if (useApplyAsync) {
                                $rootScope.$applyAsync(callEventHandler);
                            } else if ($rootScope.$$phase) {
                                callEventHandler();
                            } else {
                                $rootScope.$apply(callEventHandler);
                            }
                            function callEventHandler() {
                                eventHandler(event);
                            }
                        };
                    });
                    return applyHandlers;
                }
            }
            function done(status, response, headersString, statusText) {
                if (cache) {
                    if (isSuccess(status)) {
                        cache.put(url, [
                            status,
                            response,
                            parseHeaders(headersString),
                            statusText
                        ]);
                    } else {
                        cache.remove(url);
                    }
                }
                function resolveHttpPromise() {
                    resolvePromise(response, status, headersString, statusText);
                }
                if (useApplyAsync) {
                    $rootScope.$applyAsync(resolveHttpPromise);
                } else {
                    resolveHttpPromise();
                    if (!$rootScope.$$phase)
                        $rootScope.$apply();
                }
            }
            function resolvePromise(response, status, headers, statusText) {
                status = status >= -1 ? status : 0;
                (isSuccess(status) ? deferred.resolve : deferred.reject)({
                    data: response,
                    status: status,
                    headers: headersGetter(headers),
                    config: config,
                    statusText: statusText
                });
            }
            function resolvePromiseWithResult(result) {
                resolvePromise(result.data, result.status, shallowCopy(result.headers()), result.statusText);
            }
            function removePendingReq() {
                var idx = $http.pendingRequests.indexOf(config);
                if (idx !== -1)
                    $http.pendingRequests.splice(idx, 1);
            }
        }
        function buildUrl(url, serializedParams) {
            if (serializedParams.length > 0) {
                url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
            }
            return url;
        }
        function sanitizeJsonpCallbackParam(url, key) {
            if (/[&?][^=]+=JSON_CALLBACK/.test(url)) {
                throw $httpMinErr('badjsonp', 'Illegal use of JSON_CALLBACK in url, "{0}"', url);
            }
            var callbackParamRegex = new RegExp('[&?]' + key + '=');
            if (callbackParamRegex.test(url)) {
                throw $httpMinErr('badjsonp', 'Illegal use of callback param, "{0}", in url, "{1}"', key, url);
            }
            url += (url.indexOf('?') === -1 ? '?' : '&') + key + '=JSON_CALLBACK';
            return url;
        }
    }
];});
    $xhrFactoryProvider = ($__.fs.$xhrFactoryProvider_155 = function $xhrFactoryProvider() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.$get = function () {
    return function createXhr() {
        return new window.XMLHttpRequest();
    };
};});
    $HttpBackendProvider = ($__.fs.$HttpBackendProvider_156 = function $HttpBackendProvider() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.$get = [
    '$browser',
    '$jsonpCallbacks',
    '$document',
    '$xhrFactory',
    function ($browser, $jsonpCallbacks, $document, $xhrFactory) {
        return createHttpBackend($browser, $xhrFactory, $browser.defer, $jsonpCallbacks, $document[0]);
    }
];});
    createHttpBackend = ($__.fs.createHttpBackend_157 = function createHttpBackend($browser, createXhr, $browserDefer, callbacks, rawDocument) {
var vvv_return, vvv_switch, jsonpReq;
jsonpReq = function jsonpReq(url, callbackPath, done) {
    url = url.replace('JSON_CALLBACK', callbackPath);
    var script = rawDocument.createElement('script'), callback = null;
    script.type = 'text/javascript';
    script.src = url;
    script.async = true;
    callback = function (event) {
        script.removeEventListener('load', callback);
        script.removeEventListener('error', callback);
        rawDocument.body.removeChild(script);
        script = null;
        var status = -1;
        var text = 'unknown';
        if (event) {
            if (event.type === 'load' && !callbacks.wasCalled(callbackPath)) {
                event = {
                    type: 'error'
                };
            }
            text = event.type;
            status = event.type === 'error' ? 404 : 200;
        }
        if (done) {
            done(status, text);
        }
    };
    script.addEventListener('load', callback);
    script.addEventListener('error', callback);
    rawDocument.body.appendChild(script);
    return callback;
};
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
$browser = arguments[0], createXhr = arguments[1], $browserDefer = arguments[2], callbacks = arguments[3], rawDocument = arguments[4];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return function (method, url, post, callback, headers, timeout, withCredentials, responseType, eventHandlers, uploadEventHandlers) {
    url = url || $browser.url();
    if (lowercase(method) === 'jsonp') {
        var callbackPath = callbacks.createCallback(url);
        var jsonpDone = jsonpReq(url, callbackPath, function (status, text) {
            var response = status === 200 && callbacks.getResponse(callbackPath);
            completeRequest(callback, status, response, '', text);
            callbacks.removeCallback(callbackPath);
        });
    } else {
        var xhr = createXhr(method, url);
        xhr.open(method, url, true);
        forEach(headers, function (value, key) {
            if (isDefined(value)) {
                xhr.setRequestHeader(key, value);
            }
        });
        xhr.onload = function requestLoaded() {
            var statusText = xhr.statusText || '';
            var response = 'response' in xhr ? xhr.response : xhr.responseText;
            var status = xhr.status === 1223 ? 204 : xhr.status;
            if (status === 0) {
                status = response ? 200 : urlResolve(url).protocol === 'file' ? 404 : 0;
            }
            completeRequest(callback, status, response, xhr.getAllResponseHeaders(), statusText);
        };
        var requestError = function () {
            completeRequest(callback, -1, null, null, '');
        };
        xhr.onerror = requestError;
        xhr.onabort = requestError;
        xhr.ontimeout = requestError;
        forEach(eventHandlers, function (value, key) {
            xhr.addEventListener(key, value);
        });
        forEach(uploadEventHandlers, function (value, key) {
            xhr.upload.addEventListener(key, value);
        });
        if (withCredentials) {
            xhr.withCredentials = true;
        }
        if (responseType) {
            try {
                xhr.responseType = responseType;
            } catch (e) {
                if (responseType !== 'json') {
                    throw e;
                }
            }
        }
        xhr.send(isUndefined(post) ? null : post);
    }
    if (timeout > 0) {
        var timeoutId = $browserDefer(timeoutRequest, timeout);
    } else if (isPromiseLike(timeout)) {
        timeout.then(timeoutRequest);
    }
    function timeoutRequest() {
        if (jsonpDone) {
            jsonpDone();
        }
        if (xhr) {
            xhr.abort();
        }
    }
    function completeRequest(callback, status, response, headersString, statusText) {
        if (isDefined(timeoutId)) {
            $browserDefer.cancel(timeoutId);
        }
        jsonpDone = xhr = null;
        callback(status, response, headersString, statusText);
    }
};});
    $InterpolateProvider = ($__.fs.$InterpolateProvider_158 = function $InterpolateProvider() {
var vvv_return, vvv_switch, startSymbol, endSymbol;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
startSymbol = '{{';
endSymbol = '}}';
this.startSymbol = function (value) {
    if (value) {
        startSymbol = value;
        return this;
    } else {
        return startSymbol;
    }
};
this.endSymbol = function (value) {
    if (value) {
        endSymbol = value;
        return this;
    } else {
        return endSymbol;
    }
};
this.$get = [
    '$parse',
    '$exceptionHandler',
    '$sce',
    function ($parse, $exceptionHandler, $sce) {
        var startSymbolLength = startSymbol.length, endSymbolLength = endSymbol.length, escapedStartRegexp = new RegExp(startSymbol.replace(/./g, escape), 'g'), escapedEndRegexp = new RegExp(endSymbol.replace(/./g, escape), 'g');
        function escape(ch) {
            return '\\\\\\' + ch;
        }
        function unescapeText(text) {
            return text.replace(escapedStartRegexp, startSymbol).replace(escapedEndRegexp, endSymbol);
        }
        function constantWatchDelegate(scope, listener, objectEquality, constantInterp) {
            var unwatch = scope.$watch(function constantInterpolateWatch(scope) {
                unwatch();
                return constantInterp(scope);
            }, listener, objectEquality);
            return unwatch;
        }
        function $interpolate(text, mustHaveExpression, trustedContext, allOrNothing) {
            if (!text.length || text.indexOf(startSymbol) === -1) {
                var constantInterp;
                if (!mustHaveExpression) {
                    var unescapedText = unescapeText(text);
                    constantInterp = valueFn(unescapedText);
                    constantInterp.exp = text;
                    constantInterp.expressions = [];
                    constantInterp.$$watchDelegate = constantWatchDelegate;
                }
                return constantInterp;
            }
            allOrNothing = !!allOrNothing;
            var startIndex, endIndex, index = 0, expressions = [], parseFns = [], textLength = text.length, exp, concat = [], expressionPositions = [];
            while (index < textLength) {
                if ((startIndex = text.indexOf(startSymbol, index)) !== -1 && (endIndex = text.indexOf(endSymbol, startIndex + startSymbolLength)) !== -1) {
                    if (index !== startIndex) {
                        concat.push(unescapeText(text.substring(index, startIndex)));
                    }
                    exp = text.substring(startIndex + startSymbolLength, endIndex);
                    expressions.push(exp);
                    parseFns.push($parse(exp, parseStringifyInterceptor));
                    index = endIndex + endSymbolLength;
                    expressionPositions.push(concat.length);
                    concat.push('');
                } else {
                    if (index !== textLength) {
                        concat.push(unescapeText(text.substring(index)));
                    }
                    break;
                }
            }
            if (trustedContext && concat.length > 1) {
                $interpolateMinErr.throwNoconcat(text);
            }
            if (!mustHaveExpression || expressions.length) {
                var compute = function (values) {
                    for (var i = 0, ii = expressions.length; i < ii; i++) {
                        if (allOrNothing && isUndefined(values[i]))
                            return;
                        concat[expressionPositions[i]] = values[i];
                    }
                    return concat.join('');
                };
                var getValue = function (value) {
                    return trustedContext ? $sce.getTrusted(trustedContext, value) : $sce.valueOf(value);
                };
                return extend(function interpolationFn(context) {
                    var i = 0;
                    var ii = expressions.length;
                    var values = new Array(ii);
                    try {
                        for (; i < ii; i++) {
                            values[i] = parseFns[i](context);
                        }
                        return compute(values);
                    } catch (err) {
                        $exceptionHandler($interpolateMinErr.interr(text, err));
                    }
                }, {
                    exp: text,
                    expressions: expressions,
                    $$watchDelegate: function (scope, listener) {
                        var lastValue;
                        return scope.$watchGroup(parseFns, function interpolateFnWatcher(values, oldValues) {
                            var currValue = compute(values);
                            if (isFunction(listener)) {
                                listener.call(this, currValue, values !== oldValues ? lastValue : currValue, scope);
                            }
                            lastValue = currValue;
                        });
                    }
                });
            }
            function parseStringifyInterceptor(value) {
                try {
                    value = getValue(value);
                    return allOrNothing && !isDefined(value) ? value : stringify(value);
                } catch (err) {
                    $exceptionHandler($interpolateMinErr.interr(text, err));
                }
            }
        }
        $interpolate.startSymbol = function () {
            return startSymbol;
        };
        $interpolate.endSymbol = function () {
            return endSymbol;
        };
        return $interpolate;
    }
];});
    $IntervalProvider = ($__.fs.$IntervalProvider_159 = function $IntervalProvider() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.$get = [
    '$rootScope',
    '$window',
    '$q',
    '$$q',
    '$browser',
    function ($rootScope, $window, $q, $$q, $browser) {
        var intervals = {};
        function interval(fn, delay, count, invokeApply) {
            var hasParams = arguments.length > 4, args = hasParams ? sliceArgs(arguments, 4) : [], setInterval = $window.setInterval, clearInterval = $window.clearInterval, iteration = 0, skipApply = isDefined(invokeApply) && !invokeApply, deferred = (skipApply ? $$q : $q).defer(), promise = deferred.promise;
            count = isDefined(count) ? count : 0;
            promise.$$intervalId = setInterval(function tick() {
                if (skipApply) {
                    $browser.defer(callback);
                } else {
                    $rootScope.$evalAsync(callback);
                }
                deferred.notify(iteration++);
                if (count > 0 && iteration >= count) {
                    deferred.resolve(iteration);
                    clearInterval(promise.$$intervalId);
                    delete intervals[promise.$$intervalId];
                }
                if (!skipApply)
                    $rootScope.$apply();
            }, delay);
            intervals[promise.$$intervalId] = deferred;
            return promise;
            function callback() {
                if (!hasParams) {
                    fn(iteration);
                } else {
                    fn.apply(null, args);
                }
            }
        }
        interval.cancel = function (promise) {
            if (promise && promise.$$intervalId in intervals) {
                intervals[promise.$$intervalId].promise.catch(noop);
                intervals[promise.$$intervalId].reject('canceled');
                $window.clearInterval(promise.$$intervalId);
                delete intervals[promise.$$intervalId];
                return true;
            }
            return false;
        };
        return interval;
    }
];});
    encodePath = ($__.fs.encodePath_160 = function encodePath(path) {
var vvv_return, vvv_switch, segments, i;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
path = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
segments = path.split('/');
i = segments.length;
while (i--) {
    segments[i] = encodeUriSegment(segments[i]);
}
return segments.join('/');});
    parseAbsoluteUrl = ($__.fs.parseAbsoluteUrl_161 = function parseAbsoluteUrl(absoluteUrl, locationObj) {
var vvv_return, vvv_switch, parsedUrl;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
absoluteUrl = arguments[0], locationObj = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
parsedUrl = urlResolve(absoluteUrl);
locationObj.$$protocol = parsedUrl.protocol;
locationObj.$$host = parsedUrl.hostname;
locationObj.$$port = toInt(parsedUrl.port) || DEFAULT_PORTS[parsedUrl.protocol] || null;});
    parseAppUrl = ($__.fs.parseAppUrl_162 = function parseAppUrl(url, locationObj) {
var vvv_return, vvv_switch, prefixed, match;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
url = arguments[0], locationObj = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (DOUBLE_SLASH_REGEX.test(url)) {
    throw $locationMinErr('badpath', 'Invalid url "{0}".', url);
}
prefixed = url.charAt(0) !== '/';
if (prefixed) {
    url = '/' + url;
}
match = urlResolve(url);
locationObj.$$path = decodeURIComponent(prefixed && match.pathname.charAt(0) === '/' ? match.pathname.substring(1) : match.pathname);
locationObj.$$search = parseKeyValue(match.search);
locationObj.$$hash = decodeURIComponent(match.hash);
if (locationObj.$$path && locationObj.$$path.charAt(0) !== '/') {
    locationObj.$$path = '/' + locationObj.$$path;
}});
    startsWith = ($__.fs.startsWith_163 = function startsWith(str, search) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
str = arguments[0], search = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return str.slice(0, search.length) === search;});
    stripBaseUrl = ($__.fs.stripBaseUrl_164 = function stripBaseUrl(base, url) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
base = arguments[0], url = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (startsWith(url, base)) {
    return url.substr(base.length);
}});
    stripHash = ($__.fs.stripHash_165 = function stripHash(url) {
var vvv_return, vvv_switch, index;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
url = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
index = url.indexOf('#');
return index === -1 ? url : url.substr(0, index);});
    trimEmptyHash = ($__.fs.trimEmptyHash_166 = function trimEmptyHash(url) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
url = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return url.replace(/(#.+)|#$/, '$1');});
    stripFile = ($__.fs.stripFile_167 = function stripFile(url) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
url = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return url.substr(0, stripHash(url).lastIndexOf('/') + 1);});
    serverBase = ($__.fs.serverBase_168 = function serverBase(url) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
url = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return url.substring(0, url.indexOf('/', url.indexOf('//') + 2));});
    LocationHtml5Url = ($__.fs.LocationHtml5Url_169 = function LocationHtml5Url(appBase, appBaseNoFile, basePrefix) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
appBase = arguments[0], appBaseNoFile = arguments[1], basePrefix = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.$$html5 = true;
basePrefix = basePrefix || '';
parseAbsoluteUrl(appBase, this);
this.$$parse = function (url) {
    var pathUrl = stripBaseUrl(appBaseNoFile, url);
    if (!isString(pathUrl)) {
        throw $locationMinErr('ipthprfx', 'Invalid url "{0}", missing path prefix "{1}".', url, appBaseNoFile);
    }
    parseAppUrl(pathUrl, this);
    if (!this.$$path) {
        this.$$path = '/';
    }
    this.$$compose();
};
this.$$compose = function () {
    var search = toKeyValue(this.$$search), hash = this.$$hash ? '#' + encodeUriSegment(this.$$hash) : '';
    this.$$url = encodePath(this.$$path) + (search ? '?' + search : '') + hash;
    this.$$absUrl = appBaseNoFile + this.$$url.substr(1);
    this.$$urlUpdatedByLocation = true;
};
this.$$parseLinkUrl = function (url, relHref) {
    if (relHref && relHref[0] === '#') {
        this.hash(relHref.slice(1));
        return true;
    }
    var appUrl, prevAppUrl;
    var rewrittenUrl;
    if (isDefined(appUrl = stripBaseUrl(appBase, url))) {
        prevAppUrl = appUrl;
        if (basePrefix && isDefined(appUrl = stripBaseUrl(basePrefix, appUrl))) {
            rewrittenUrl = appBaseNoFile + (stripBaseUrl('/', appUrl) || appUrl);
        } else {
            rewrittenUrl = appBase + prevAppUrl;
        }
    } else if (isDefined(appUrl = stripBaseUrl(appBaseNoFile, url))) {
        rewrittenUrl = appBaseNoFile + appUrl;
    } else if (appBaseNoFile === url + '/') {
        rewrittenUrl = appBaseNoFile;
    }
    if (rewrittenUrl) {
        this.$$parse(rewrittenUrl);
    }
    return !!rewrittenUrl;
};}, $__.fs.LocationHtml5Url_169_100 = $__.fs.LocationHtml5Url_169, $__.fs.LocationHtml5Url_169);
    LocationHashbangUrl = ($__.fs.LocationHashbangUrl_170 = function LocationHashbangUrl(appBase, appBaseNoFile, hashPrefix) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
appBase = arguments[0], appBaseNoFile = arguments[1], hashPrefix = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
parseAbsoluteUrl(appBase, this);
this.$$parse = function (url) {
    var withoutBaseUrl = stripBaseUrl(appBase, url) || stripBaseUrl(appBaseNoFile, url);
    var withoutHashUrl;
    if (!isUndefined(withoutBaseUrl) && withoutBaseUrl.charAt(0) === '#') {
        withoutHashUrl = stripBaseUrl(hashPrefix, withoutBaseUrl);
        if (isUndefined(withoutHashUrl)) {
            withoutHashUrl = withoutBaseUrl;
        }
    } else {
        if (this.$$html5) {
            withoutHashUrl = withoutBaseUrl;
        } else {
            withoutHashUrl = '';
            if (isUndefined(withoutBaseUrl)) {
                appBase = url;
                this.replace();
            }
        }
    }
    parseAppUrl(withoutHashUrl, this);
    this.$$path = removeWindowsDriveName(this.$$path, withoutHashUrl, appBase);
    this.$$compose();
    function removeWindowsDriveName(path, url, base) {
        var windowsFilePathExp = /^\/[A-Z]:(\/.*)/;
        var firstPathSegmentMatch;
        if (startsWith(url, base)) {
            url = url.replace(base, '');
        }
        if (windowsFilePathExp.exec(url)) {
            return path;
        }
        firstPathSegmentMatch = windowsFilePathExp.exec(path);
        return firstPathSegmentMatch ? firstPathSegmentMatch[1] : path;
    }
};
this.$$compose = function () {
    var search = toKeyValue(this.$$search), hash = this.$$hash ? '#' + encodeUriSegment(this.$$hash) : '';
    this.$$url = encodePath(this.$$path) + (search ? '?' + search : '') + hash;
    this.$$absUrl = appBase + (this.$$url ? hashPrefix + this.$$url : '');
    this.$$urlUpdatedByLocation = true;
};
this.$$parseLinkUrl = function (url, relHref) {
    if (stripHash(appBase) === stripHash(url)) {
        this.$$parse(url);
        return true;
    }
    return false;
};}, $__.fs.LocationHashbangUrl_170_98 = $__.fs.LocationHashbangUrl_170, $__.fs.LocationHashbangUrl_170);
    LocationHashbangInHtml5Url = ($__.fs.LocationHashbangInHtml5Url_171 = function LocationHashbangInHtml5Url(appBase, appBaseNoFile, hashPrefix) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
appBase = arguments[0], appBaseNoFile = arguments[1], hashPrefix = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.$$html5 = true;
LocationHashbangUrl.apply(this, arguments);
this.$$parseLinkUrl = function (url, relHref) {
    if (relHref && relHref[0] === '#') {
        this.hash(relHref.slice(1));
        return true;
    }
    var rewrittenUrl;
    var appUrl;
    if (appBase === stripHash(url)) {
        rewrittenUrl = url;
    } else if (appUrl = stripBaseUrl(appBaseNoFile, url)) {
        rewrittenUrl = appBase + hashPrefix + appUrl;
    } else if (appBaseNoFile === url + '/') {
        rewrittenUrl = appBaseNoFile;
    }
    if (rewrittenUrl) {
        this.$$parse(rewrittenUrl);
    }
    return !!rewrittenUrl;
};
this.$$compose = function () {
    var search = toKeyValue(this.$$search), hash = this.$$hash ? '#' + encodeUriSegment(this.$$hash) : '';
    this.$$url = encodePath(this.$$path) + (search ? '?' + search : '') + hash;
    this.$$absUrl = appBase + hashPrefix + this.$$url;
    this.$$urlUpdatedByLocation = true;
};}, $__.fs.LocationHashbangInHtml5Url_171_96 = $__.fs.LocationHashbangInHtml5Url_171, $__.fs.LocationHashbangInHtml5Url_171);
    locationGetter = ($__.fs.locationGetter_172 = function locationGetter(property) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
property = arguments[0];
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    return ($__.fs.J$__v3645318688_994_371 = function J$__v3645318688_994() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return this[property];});
case 1:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 1);
    return ($__.fs.J$__v3645318688_994_373 = function J$__v3645318688_994() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return this[property];});
case 2:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 2);
    return ($__.fs.J$__v3645318688_994_374 = function J$__v3645318688_994() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return this[property];});
case 3:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 3);
    return ($__.fs.J$__v3645318688_994_375 = function J$__v3645318688_994() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return this[property];});
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return function () {
    return this[property];
};});
    locationGetterSetter = ($__.fs.locationGetterSetter_173 = function locationGetterSetter(property, preprocess) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
property = arguments[0], preprocess = arguments[1];
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    return ($__.fs.J$__v3645318688_997_377 = function J$__v3645318688_997(value) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
value = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (isUndefined(value)) {
    return this[property];
}
this[property] = preprocess(value);
this.$$compose();
return this;});
case 1:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 1);
    return ($__.fs.J$__v3645318688_997_380 = function J$__v3645318688_997(value) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
value = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (isUndefined(value)) {
    return this[property];
}
this[property] = preprocess(value);
this.$$compose();
return this;});
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return function (value) {
    if (isUndefined(value)) {
        return this[property];
    }
    this[property] = preprocess(value);
    this.$$compose();
    return this;
};});
    $LocationProvider = ($__.fs.$LocationProvider_174 = function $LocationProvider() {
var vvv_return, vvv_switch, hashPrefix, html5Mode;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
hashPrefix = '!';
html5Mode = {
    enabled: false,
    requireBase: true,
    rewriteLinks: true
};
this.hashPrefix = function (prefix) {
    if (isDefined(prefix)) {
        hashPrefix = prefix;
        return this;
    } else {
        return hashPrefix;
    }
};
this.html5Mode = function (mode) {
    if (isBoolean(mode)) {
        html5Mode.enabled = mode;
        return this;
    } else if (isObject(mode)) {
        if (isBoolean(mode.enabled)) {
            html5Mode.enabled = mode.enabled;
        }
        if (isBoolean(mode.requireBase)) {
            html5Mode.requireBase = mode.requireBase;
        }
        if (isBoolean(mode.rewriteLinks) || isString(mode.rewriteLinks)) {
            html5Mode.rewriteLinks = mode.rewriteLinks;
        }
        return this;
    } else {
        return html5Mode;
    }
};
this.$get = [
    '$rootScope',
    '$browser',
    '$sniffer',
    '$rootElement',
    '$window',
    function ($rootScope, $browser, $sniffer, $rootElement, $window) {
        var $location, LocationMode, baseHref = $browser.baseHref(), initialUrl = $browser.url(), appBase;
        if (html5Mode.enabled) {
            if (!baseHref && html5Mode.requireBase) {
                throw $locationMinErr('nobase', '$location in HTML5 mode requires a <base> tag to be present!');
            }
            appBase = serverBase(initialUrl) + (baseHref || '/');
            LocationMode = $sniffer.history ? LocationHtml5Url : LocationHashbangInHtml5Url;
        } else {
            appBase = stripHash(initialUrl);
            LocationMode = LocationHashbangUrl;
        }
        var appBaseNoFile = stripFile(appBase);
        $location = new LocationMode(appBase, appBaseNoFile, '#' + hashPrefix);
        $location.$$parseLinkUrl(initialUrl, initialUrl);
        $location.$$state = $browser.state();
        var IGNORE_URI_REGEXP = /^\s*(javascript|mailto):/i;
        function setBrowserUrlWithFallback(url, replace, state) {
            var oldUrl = $location.url();
            var oldState = $location.$$state;
            try {
                $browser.url(url, replace, state);
                $location.$$state = $browser.state();
            } catch (e) {
                $location.url(oldUrl);
                $location.$$state = oldState;
                throw e;
            }
        }
        $rootElement.on('click', function (event) {
            var rewriteLinks = html5Mode.rewriteLinks;
            if (!rewriteLinks || event.ctrlKey || event.metaKey || event.shiftKey || event.which === 2 || event.button === 2)
                return;
            var elm = jqLite(event.target);
            while (nodeName_(elm[0]) !== 'a') {
                if (elm[0] === $rootElement[0] || !(elm = elm.parent())[0])
                    return;
            }
            if (isString(rewriteLinks) && isUndefined(elm.attr(rewriteLinks)))
                return;
            var absHref = elm.prop('href');
            var relHref = elm.attr('href') || elm.attr('xlink:href');
            if (isObject(absHref) && absHref.toString() === '[object SVGAnimatedString]') {
                absHref = urlResolve(absHref.animVal).href;
            }
            if (IGNORE_URI_REGEXP.test(absHref))
                return;
            if (absHref && !elm.attr('target') && !event.isDefaultPrevented()) {
                if ($location.$$parseLinkUrl(absHref, relHref)) {
                    event.preventDefault();
                    if ($location.absUrl() !== $browser.url()) {
                        $rootScope.$apply();
                        $window.angular['ff-684208-preventDefault'] = true;
                    }
                }
            }
        });
        if (trimEmptyHash($location.absUrl()) !== trimEmptyHash(initialUrl)) {
            $browser.url($location.absUrl(), true);
        }
        var initializing = true;
        $browser.onUrlChange(function (newUrl, newState) {
            if (!startsWith(newUrl, appBaseNoFile)) {
                $window.location.href = newUrl;
                return;
            }
            $rootScope.$evalAsync(function () {
                var oldUrl = $location.absUrl();
                var oldState = $location.$$state;
                var defaultPrevented;
                newUrl = trimEmptyHash(newUrl);
                $location.$$parse(newUrl);
                $location.$$state = newState;
                defaultPrevented = $rootScope.$broadcast('$locationChangeStart', newUrl, oldUrl, newState, oldState).defaultPrevented;
                if ($location.absUrl() !== newUrl)
                    return;
                if (defaultPrevented) {
                    $location.$$parse(oldUrl);
                    $location.$$state = oldState;
                    setBrowserUrlWithFallback(oldUrl, false, oldState);
                } else {
                    initializing = false;
                    afterLocationChange(oldUrl, oldState);
                }
            });
            if (!$rootScope.$$phase)
                $rootScope.$digest();
        });
        $rootScope.$watch(function $locationWatch() {
            if (initializing || $location.$$urlUpdatedByLocation) {
                $location.$$urlUpdatedByLocation = false;
                var oldUrl = trimEmptyHash($browser.url());
                var newUrl = trimEmptyHash($location.absUrl());
                var oldState = $browser.state();
                var currentReplace = $location.$$replace;
                var urlOrStateChanged = oldUrl !== newUrl || $location.$$html5 && $sniffer.history && oldState !== $location.$$state;
                if (initializing || urlOrStateChanged) {
                    initializing = false;
                    $rootScope.$evalAsync(function () {
                        var newUrl = $location.absUrl();
                        var defaultPrevented = $rootScope.$broadcast('$locationChangeStart', newUrl, oldUrl, $location.$$state, oldState).defaultPrevented;
                        if ($location.absUrl() !== newUrl)
                            return;
                        if (defaultPrevented) {
                            $location.$$parse(oldUrl);
                            $location.$$state = oldState;
                        } else {
                            if (urlOrStateChanged) {
                                setBrowserUrlWithFallback(newUrl, currentReplace, oldState === $location.$$state ? null : $location.$$state);
                            }
                            afterLocationChange(oldUrl, oldState);
                        }
                    });
                }
            }
            $location.$$replace = false;
        });
        return $location;
        function afterLocationChange(oldUrl, oldState) {
            $rootScope.$broadcast('$locationChangeSuccess', $location.absUrl(), oldUrl, $location.$$state, oldState);
        }
    }
];});
    $LogProvider = ($__.fs.$LogProvider_175 = function $LogProvider() {
var vvv_return, vvv_switch, debug, self;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
debug = true;
self = this;
this.debugEnabled = function (flag) {
    if (isDefined(flag)) {
        debug = flag;
        return this;
    } else {
        return debug;
    }
};
this.$get = [
    '$window',
    function ($window) {
        var formatStackTrace = msie || /\bEdge\//.test($window.navigator && $window.navigator.userAgent);
        return {
            log: consoleLog('log'),
            info: consoleLog('info'),
            warn: consoleLog('warn'),
            error: consoleLog('error'),
            debug: function () {
                var fn = consoleLog('debug');
                return function () {
                    if (debug) {
                        fn.apply(self, arguments);
                    }
                };
            }()
        };
        function formatError(arg) {
            if (arg instanceof Error) {
                if (arg.stack && formatStackTrace) {
                    arg = arg.message && arg.stack.indexOf(arg.message) === -1 ? 'Error: ' + arg.message + '\n' + arg.stack : arg.stack;
                } else if (arg.sourceURL) {
                    arg = arg.message + '\n' + arg.sourceURL + ':' + arg.line;
                }
            }
            return arg;
        }
        function consoleLog(type) {
            var console = $window.console || {}, logFn = console[type] || console.log || noop, hasApply = false;
            try {
                hasApply = !!logFn.apply;
            } catch (e) {
            }
            if (hasApply) {
                return function () {
                    var args = [];
                    forEach(arguments, function (arg) {
                        args.push(formatError(arg));
                    });
                    return logFn.apply(console, args);
                };
            }
            return function (arg1, arg2) {
                logFn(arg1, arg2 == null ? '' : arg2);
            };
        }
    }
];});
    getStringValue = ($__.fs.getStringValue_176 = function getStringValue(name) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
name = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return name + '';});
    ifDefined = ($__.fs.ifDefined_177 = function ifDefined(v, d) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
v = arguments[0], d = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return typeof v !== 'undefined' ? v : d;});
    plusFn = ($__.fs.plusFn_178 = function plusFn(l, r) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
l = arguments[0], r = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (typeof l === 'undefined')
    return r;
if (typeof r === 'undefined')
    return l;
return l + r;});
    isStateless = ($__.fs.isStateless_179 = function isStateless($filter, filterName) {
var vvv_return, vvv_switch, fn;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
$filter = arguments[0], filterName = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
fn = $filter(filterName);
return !fn.$stateful;});
    findConstantAndWatchExpressions = ($__.fs.findConstantAndWatchExpressions_180 = function findConstantAndWatchExpressions(ast, $filter) {
var vvv_return, vvv_switch, allConstants, argsToWatch, isStatelessFilter;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
ast = arguments[0], $filter = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
switch (ast.type) {
case AST.Program:
    allConstants = true;
    forEach(ast.body, function (expr) {
        findConstantAndWatchExpressions(expr.expression, $filter);
        allConstants = allConstants && expr.expression.constant;
    });
    ast.constant = allConstants;
    break;
case AST.Literal:
    ast.constant = true;
    ast.toWatch = [];
    break;
case AST.UnaryExpression:
    findConstantAndWatchExpressions(ast.argument, $filter);
    ast.constant = ast.argument.constant;
    ast.toWatch = ast.argument.toWatch;
    break;
case AST.BinaryExpression:
    findConstantAndWatchExpressions(ast.left, $filter);
    findConstantAndWatchExpressions(ast.right, $filter);
    ast.constant = ast.left.constant && ast.right.constant;
    ast.toWatch = ast.left.toWatch.concat(ast.right.toWatch);
    break;
case AST.LogicalExpression:
    findConstantAndWatchExpressions(ast.left, $filter);
    findConstantAndWatchExpressions(ast.right, $filter);
    ast.constant = ast.left.constant && ast.right.constant;
    ast.toWatch = ast.constant ? [] : [ast];
    break;
case AST.ConditionalExpression:
    findConstantAndWatchExpressions(ast.test, $filter);
    findConstantAndWatchExpressions(ast.alternate, $filter);
    findConstantAndWatchExpressions(ast.consequent, $filter);
    ast.constant = ast.test.constant && ast.alternate.constant && ast.consequent.constant;
    ast.toWatch = ast.constant ? [] : [ast];
    break;
case AST.Identifier:
    ast.constant = false;
    ast.toWatch = [ast];
    break;
case AST.MemberExpression:
    findConstantAndWatchExpressions(ast.object, $filter);
    if (ast.computed) {
        findConstantAndWatchExpressions(ast.property, $filter);
    }
    ast.constant = ast.object.constant && (!ast.computed || ast.property.constant);
    ast.toWatch = [ast];
    break;
case AST.CallExpression:
    isStatelessFilter = ast.filter ? isStateless($filter, ast.callee.name) : false;
    allConstants = isStatelessFilter;
    argsToWatch = [];
    forEach(ast.arguments, function (expr) {
        findConstantAndWatchExpressions(expr, $filter);
        allConstants = allConstants && expr.constant;
        if (!expr.constant) {
            argsToWatch.push.apply(argsToWatch, expr.toWatch);
        }
    });
    ast.constant = allConstants;
    ast.toWatch = isStatelessFilter ? argsToWatch : [ast];
    break;
case AST.AssignmentExpression:
    findConstantAndWatchExpressions(ast.left, $filter);
    findConstantAndWatchExpressions(ast.right, $filter);
    ast.constant = ast.left.constant && ast.right.constant;
    ast.toWatch = [ast];
    break;
case AST.ArrayExpression:
    allConstants = true;
    argsToWatch = [];
    forEach(ast.elements, function (expr) {
        findConstantAndWatchExpressions(expr, $filter);
        allConstants = allConstants && expr.constant;
        if (!expr.constant) {
            argsToWatch.push.apply(argsToWatch, expr.toWatch);
        }
    });
    ast.constant = allConstants;
    ast.toWatch = argsToWatch;
    break;
case AST.ObjectExpression:
    allConstants = true;
    argsToWatch = [];
    forEach(ast.properties, function (property) {
        findConstantAndWatchExpressions(property.value, $filter);
        allConstants = allConstants && property.value.constant && !property.computed;
        if (!property.value.constant) {
            argsToWatch.push.apply(argsToWatch, property.value.toWatch);
        }
        if (property.computed) {
            findConstantAndWatchExpressions(property.key, $filter);
            if (!property.key.constant) {
                argsToWatch.push.apply(argsToWatch, property.key.toWatch);
            }
        }
    });
    ast.constant = allConstants;
    ast.toWatch = argsToWatch;
    break;
case AST.ThisExpression:
    ast.constant = false;
    ast.toWatch = [];
    break;
case AST.LocalsExpression:
    ast.constant = false;
    ast.toWatch = [];
    break;
}});
    getInputs = ($__.fs.getInputs_181 = function getInputs(body) {
var vvv_return, vvv_switch, lastExpression, candidate;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
body = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (body.length !== 1)
    return;
lastExpression = body[0].expression;
candidate = lastExpression.toWatch;
if (candidate.length !== 1)
    return candidate;
return candidate[0] !== lastExpression ? candidate : undefined;});
    isAssignable = ($__.fs.isAssignable_182 = function isAssignable(ast) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
ast = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return ast.type === AST.Identifier || ast.type === AST.MemberExpression;});
    assignableAST = ($__.fs.assignableAST_183 = function assignableAST(ast) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
ast = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (ast.body.length === 1 && isAssignable(ast.body[0].expression)) {
    return {
        type: AST.AssignmentExpression,
        left: ast.body[0].expression,
        right: {
            type: AST.NGValueParameter
        },
        operator: '='
    };
}});
    isLiteral = ($__.fs.isLiteral_184 = function isLiteral(ast) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
ast = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return ast.body.length === 0 || ast.body.length === 1 && (ast.body[0].expression.type === AST.Literal || ast.body[0].expression.type === AST.ArrayExpression || ast.body[0].expression.type === AST.ObjectExpression);});
    isConstant = ($__.fs.isConstant_185 = function isConstant(ast) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
ast = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return ast.constant;});
    ASTCompiler = ($__.fs.ASTCompiler_186 = function ASTCompiler(astBuilder, $filter) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
astBuilder = arguments[0], $filter = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.astBuilder = astBuilder;
this.$filter = $filter;});
    ASTInterpreter = ($__.fs.ASTInterpreter_187 = function ASTInterpreter(astBuilder, $filter) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
astBuilder = arguments[0], $filter = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.astBuilder = astBuilder;
this.$filter = $filter;});
    getValueOf = ($__.fs.getValueOf_188 = function getValueOf(value) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
value = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return isFunction(value.valueOf) ? value.valueOf() : objectValueOf.call(value);});
    $ParseProvider = ($__.fs.$ParseProvider_189 = function $ParseProvider() {
var vvv_return, vvv_switch, cache, literals, identStart, identContinue;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
cache = createMap();
literals = {
    'true': true,
    'false': false,
    'null': null,
    'undefined': undefined
};
this.addLiteral = function (literalName, literalValue) {
    literals[literalName] = literalValue;
};
this.setIdentifierFns = function (identifierStart, identifierContinue) {
    identStart = identifierStart;
    identContinue = identifierContinue;
    return this;
};
this.$get = [
    '$filter',
    function ($filter) {
        var noUnsafeEval = csp().noUnsafeEval;
        var $parseOptions = {
            csp: noUnsafeEval,
            literals: copy(literals),
            isIdentifierStart: isFunction(identStart) && identStart,
            isIdentifierContinue: isFunction(identContinue) && identContinue
        };
        return $parse;
        function $parse(exp, interceptorFn) {
            var parsedExpression, oneTime, cacheKey;
            switch (typeof exp) {
            case 'string':
                exp = exp.trim();
                cacheKey = exp;
                parsedExpression = cache[cacheKey];
                if (!parsedExpression) {
                    if (exp.charAt(0) === ':' && exp.charAt(1) === ':') {
                        oneTime = true;
                        exp = exp.substring(2);
                    }
                    var lexer = new Lexer($parseOptions);
                    var parser = new Parser(lexer, $filter, $parseOptions);
                    parsedExpression = parser.parse(exp);
                    if (parsedExpression.constant) {
                        parsedExpression.$$watchDelegate = constantWatchDelegate;
                    } else if (oneTime) {
                        parsedExpression.$$watchDelegate = parsedExpression.literal ? oneTimeLiteralWatchDelegate : oneTimeWatchDelegate;
                    } else if (parsedExpression.inputs) {
                        parsedExpression.$$watchDelegate = inputsWatchDelegate;
                    }
                    cache[cacheKey] = parsedExpression;
                }
                return addInterceptor(parsedExpression, interceptorFn);
            case 'function':
                return addInterceptor(exp, interceptorFn);
            default:
                return addInterceptor(noop, interceptorFn);
            }
        }
        function expressionInputDirtyCheck(newValue, oldValueOfValue, compareObjectIdentity) {
            if (newValue == null || oldValueOfValue == null) {
                return newValue === oldValueOfValue;
            }
            if (typeof newValue === 'object' && !compareObjectIdentity) {
                newValue = getValueOf(newValue);
                if (typeof newValue === 'object') {
                    return false;
                }
            }
            return newValue === oldValueOfValue || newValue !== newValue && oldValueOfValue !== oldValueOfValue;
        }
        function inputsWatchDelegate(scope, listener, objectEquality, parsedExpression, prettyPrintExpression) {
            var inputExpressions = parsedExpression.inputs;
            var lastResult;
            if (inputExpressions.length === 1) {
                var oldInputValueOf = expressionInputDirtyCheck;
                inputExpressions = inputExpressions[0];
                return scope.$watch(function expressionInputWatch(scope) {
                    var newInputValue = inputExpressions(scope);
                    if (!expressionInputDirtyCheck(newInputValue, oldInputValueOf, parsedExpression.literal)) {
                        lastResult = parsedExpression(scope, undefined, undefined, [newInputValue]);
                        oldInputValueOf = newInputValue && getValueOf(newInputValue);
                    }
                    return lastResult;
                }, listener, objectEquality, prettyPrintExpression);
            }
            var oldInputValueOfValues = [];
            var oldInputValues = [];
            for (var i = 0, ii = inputExpressions.length; i < ii; i++) {
                oldInputValueOfValues[i] = expressionInputDirtyCheck;
                oldInputValues[i] = null;
            }
            return scope.$watch(function expressionInputsWatch(scope) {
                var changed = false;
                for (var i = 0, ii = inputExpressions.length; i < ii; i++) {
                    var newInputValue = inputExpressions[i](scope);
                    if (changed || (changed = !expressionInputDirtyCheck(newInputValue, oldInputValueOfValues[i], parsedExpression.literal))) {
                        oldInputValues[i] = newInputValue;
                        oldInputValueOfValues[i] = newInputValue && getValueOf(newInputValue);
                    }
                }
                if (changed) {
                    lastResult = parsedExpression(scope, undefined, undefined, oldInputValues);
                }
                return lastResult;
            }, listener, objectEquality, prettyPrintExpression);
        }
        function oneTimeWatchDelegate(scope, listener, objectEquality, parsedExpression, prettyPrintExpression) {
            var unwatch, lastValue;
            if (parsedExpression.inputs) {
                unwatch = inputsWatchDelegate(scope, oneTimeListener, objectEquality, parsedExpression, prettyPrintExpression);
            } else {
                unwatch = scope.$watch(oneTimeWatch, oneTimeListener, objectEquality);
            }
            return unwatch;
            function oneTimeWatch(scope) {
                return parsedExpression(scope);
            }
            function oneTimeListener(value, old, scope) {
                lastValue = value;
                if (isFunction(listener)) {
                    listener(value, old, scope);
                }
                if (isDefined(value)) {
                    scope.$$postDigest(function () {
                        if (isDefined(lastValue)) {
                            unwatch();
                        }
                    });
                }
            }
        }
        function oneTimeLiteralWatchDelegate(scope, listener, objectEquality, parsedExpression) {
            var unwatch, lastValue;
            unwatch = scope.$watch(function oneTimeWatch(scope) {
                return parsedExpression(scope);
            }, function oneTimeListener(value, old, scope) {
                lastValue = value;
                if (isFunction(listener)) {
                    listener(value, old, scope);
                }
                if (isAllDefined(value)) {
                    scope.$$postDigest(function () {
                        if (isAllDefined(lastValue))
                            unwatch();
                    });
                }
            }, objectEquality);
            return unwatch;
            function isAllDefined(value) {
                var allDefined = true;
                forEach(value, function (val) {
                    if (!isDefined(val))
                        allDefined = false;
                });
                return allDefined;
            }
        }
        function constantWatchDelegate(scope, listener, objectEquality, parsedExpression) {
            var unwatch = scope.$watch(function constantWatch(scope) {
                unwatch();
                return parsedExpression(scope);
            }, listener, objectEquality);
            return unwatch;
        }
        function addInterceptor(parsedExpression, interceptorFn) {
            if (!interceptorFn)
                return parsedExpression;
            var watchDelegate = parsedExpression.$$watchDelegate;
            var useInputs = false;
            var regularWatch = watchDelegate !== oneTimeLiteralWatchDelegate && watchDelegate !== oneTimeWatchDelegate;
            var fn = regularWatch ? function regularInterceptedExpression(scope, locals, assign, inputs) {
                var value = useInputs && inputs ? inputs[0] : parsedExpression(scope, locals, assign, inputs);
                return interceptorFn(value, scope, locals);
            } : function oneTimeInterceptedExpression(scope, locals, assign, inputs) {
                var value = parsedExpression(scope, locals, assign, inputs);
                var result = interceptorFn(value, scope, locals);
                return isDefined(value) ? result : value;
            };
            useInputs = !parsedExpression.inputs;
            if (parsedExpression.$$watchDelegate && parsedExpression.$$watchDelegate !== inputsWatchDelegate) {
                fn.$$watchDelegate = parsedExpression.$$watchDelegate;
                fn.inputs = parsedExpression.inputs;
            } else if (!interceptorFn.$stateful) {
                fn.$$watchDelegate = inputsWatchDelegate;
                fn.inputs = parsedExpression.inputs ? parsedExpression.inputs : [parsedExpression];
            }
            return fn;
        }
    }
];});
    $QProvider = ($__.fs.$QProvider_190 = function $QProvider() {
var vvv_return, vvv_switch, errorOnUnhandledRejections;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
errorOnUnhandledRejections = true;
this.$get = [
    '$rootScope',
    '$exceptionHandler',
    function ($rootScope, $exceptionHandler) {
        return qFactory(function (callback) {
            $rootScope.$evalAsync(callback);
        }, $exceptionHandler, errorOnUnhandledRejections);
    }
];
this.errorOnUnhandledRejections = function (value) {
    if (isDefined(value)) {
        errorOnUnhandledRejections = value;
        return this;
    } else {
        return errorOnUnhandledRejections;
    }
};});
    $$QProvider = ($__.fs.$$QProvider_191 = function $$QProvider() {
var vvv_return, vvv_switch, errorOnUnhandledRejections;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
errorOnUnhandledRejections = true;
this.$get = [
    '$browser',
    '$exceptionHandler',
    function ($browser, $exceptionHandler) {
        return qFactory(function (callback) {
            $browser.defer(callback);
        }, $exceptionHandler, errorOnUnhandledRejections);
    }
];
this.errorOnUnhandledRejections = function (value) {
    if (isDefined(value)) {
        errorOnUnhandledRejections = value;
        return this;
    } else {
        return errorOnUnhandledRejections;
    }
};});
    qFactory = ($__.fs.qFactory_192 = function qFactory(nextTick, exceptionHandler, errorOnUnhandledRejections) {
var vvv_return, vvv_switch, $qMinErr, queueSize, checkQueue, defer, Deferred, Promise, processQueue, processChecks, scheduleProcessQueue, resolvePromise, $$resolve, rejectPromise, $$reject, notifyPromise, reject, handleCallback, when, resolve, all, race, $Q;
defer = function defer() {
    return new Deferred();
};
Deferred = function Deferred() {
    var promise = this.promise = new Promise();
    this.resolve = function (val) {
        resolvePromise(promise, val);
    };
    this.reject = function (reason) {
        rejectPromise(promise, reason);
    };
    this.notify = function (progress) {
        notifyPromise(promise, progress);
    };
};
Promise = function Promise() {
    this.$$state = {
        status: 0
    };
};
processQueue = function processQueue(state) {
    var fn, promise, pending;
    pending = state.pending;
    state.processScheduled = false;
    state.pending = undefined;
    try {
        for (var i = 0, ii = pending.length; i < ii; ++i) {
            state.pur = true;
            promise = pending[i][0];
            fn = pending[i][state.status];
            try {
                if (isFunction(fn)) {
                    resolvePromise(promise, fn(state.value));
                } else if (state.status === 1) {
                    resolvePromise(promise, state.value);
                } else {
                    rejectPromise(promise, state.value);
                }
            } catch (e) {
                rejectPromise(promise, e);
            }
        }
    } finally {
        --queueSize;
        if (errorOnUnhandledRejections && queueSize === 0) {
            nextTick(processChecks);
        }
    }
};
processChecks = function processChecks() {
    while (!queueSize && checkQueue.length) {
        var toCheck = checkQueue.shift();
        if (!toCheck.pur) {
            toCheck.pur = true;
            var errorMessage = 'Possibly unhandled rejection: ' + toDebugString(toCheck.value);
            if (toCheck.value instanceof Error) {
                exceptionHandler(toCheck.value, errorMessage);
            } else {
                exceptionHandler(errorMessage);
            }
        }
    }
};
scheduleProcessQueue = function scheduleProcessQueue(state) {
    if (errorOnUnhandledRejections && !state.pending && state.status === 2 && !state.pur) {
        if (queueSize === 0 && checkQueue.length === 0) {
            nextTick(processChecks);
        }
        checkQueue.push(state);
    }
    if (state.processScheduled || !state.pending)
        return;
    state.processScheduled = true;
    ++queueSize;
    nextTick(function () {
        processQueue(state);
    });
};
resolvePromise = function resolvePromise(promise, val) {
    if (promise.$$state.status)
        return;
    if (val === promise) {
        $$reject(promise, $qMinErr('qcycle', 'Expected promise to be resolved with value other than itself \'{0}\'', val));
    } else {
        $$resolve(promise, val);
    }
};
$$resolve = function $$resolve(promise, val) {
    var then;
    var done = false;
    try {
        if (isObject(val) || isFunction(val))
            then = val.then;
        if (isFunction(then)) {
            promise.$$state.status = -1;
            then.call(val, doResolve, doReject, doNotify);
        } else {
            promise.$$state.value = val;
            promise.$$state.status = 1;
            scheduleProcessQueue(promise.$$state);
        }
    } catch (e) {
        doReject(e);
    }
    function doResolve(val) {
        if (done)
            return;
        done = true;
        $$resolve(promise, val);
    }
    function doReject(val) {
        if (done)
            return;
        done = true;
        $$reject(promise, val);
    }
    function doNotify(progress) {
        notifyPromise(promise, progress);
    }
};
rejectPromise = function rejectPromise(promise, reason) {
    if (promise.$$state.status)
        return;
    $$reject(promise, reason);
};
$$reject = function $$reject(promise, reason) {
    promise.$$state.value = reason;
    promise.$$state.status = 2;
    scheduleProcessQueue(promise.$$state);
};
notifyPromise = function notifyPromise(promise, progress) {
    var callbacks = promise.$$state.pending;
    if (promise.$$state.status <= 0 && callbacks && callbacks.length) {
        nextTick(function () {
            var callback, result;
            for (var i = 0, ii = callbacks.length; i < ii; i++) {
                result = callbacks[i][0];
                callback = callbacks[i][3];
                try {
                    notifyPromise(result, isFunction(callback) ? callback(progress) : progress);
                } catch (e) {
                    exceptionHandler(e);
                }
            }
        });
    }
};
reject = function reject(reason) {
    var result = new Promise();
    rejectPromise(result, reason);
    return result;
};
handleCallback = function handleCallback(value, resolver, callback) {
    var callbackOutput = null;
    try {
        if (isFunction(callback))
            callbackOutput = callback();
    } catch (e) {
        return reject(e);
    }
    if (isPromiseLike(callbackOutput)) {
        return callbackOutput.then(function () {
            return resolver(value);
        }, reject);
    } else {
        return resolver(value);
    }
};
when = function when(value, callback, errback, progressBack) {
    var result = new Promise();
    resolvePromise(result, value);
    return result.then(callback, errback, progressBack);
};
all = function all(promises) {
    var result = new Promise(), counter = 0, results = isArray(promises) ? [] : {};
    forEach(promises, function (promise, key) {
        counter++;
        when(promise).then(function (value) {
            results[key] = value;
            if (!--counter)
                resolvePromise(result, results);
        }, function (reason) {
            rejectPromise(result, reason);
        });
    });
    if (counter === 0) {
        resolvePromise(result, results);
    }
    return result;
};
race = function race(promises) {
    var deferred = defer();
    forEach(promises, function (promise) {
        when(promise).then(deferred.resolve, deferred.reject);
    });
    return deferred.promise;
};
$Q = function $Q(resolver) {
    if (!isFunction(resolver)) {
        throw $qMinErr('norslvr', 'Expected resolverFn, got \'{0}\'', resolver);
    }
    var promise = new Promise();
    function resolveFn(value) {
        resolvePromise(promise, value);
    }
    function rejectFn(reason) {
        rejectPromise(promise, reason);
    }
    resolver(resolveFn, rejectFn);
    return promise;
};
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
nextTick = arguments[0], exceptionHandler = arguments[1], errorOnUnhandledRejections = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
$qMinErr = minErr('$q', TypeError);
queueSize = 0;
checkQueue = [];
extend(Promise.prototype, {
    then: function (onFulfilled, onRejected, progressBack) {
        if (isUndefined(onFulfilled) && isUndefined(onRejected) && isUndefined(progressBack)) {
            return this;
        }
        var result = new Promise();
        this.$$state.pending = this.$$state.pending || [];
        this.$$state.pending.push([
            result,
            onFulfilled,
            onRejected,
            progressBack
        ]);
        if (this.$$state.status > 0)
            scheduleProcessQueue(this.$$state);
        return result;
    },
    'catch': function (callback) {
        return this.then(null, callback);
    },
    'finally': function (callback, progressBack) {
        return this.then(function (value) {
            return handleCallback(value, resolve, callback);
        }, function (error) {
            return handleCallback(error, reject, callback);
        }, progressBack);
    }
});
resolve = when;
$Q.prototype = Promise.prototype;
$Q.defer = defer;
$Q.reject = reject;
$Q.when = when;
$Q.resolve = resolve;
$Q.all = all;
$Q.race = race;
return $Q;});
    $$RAFProvider = ($__.fs.$$RAFProvider_193 = function $$RAFProvider() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.$get = [
    '$window',
    '$timeout',
    function ($window, $timeout) {
        var requestAnimationFrame = $window.requestAnimationFrame || $window.webkitRequestAnimationFrame;
        var cancelAnimationFrame = $window.cancelAnimationFrame || $window.webkitCancelAnimationFrame || $window.webkitCancelRequestAnimationFrame;
        var rafSupported = !!requestAnimationFrame;
        var raf = rafSupported ? function (fn) {
            var id = requestAnimationFrame(fn);
            return function () {
                cancelAnimationFrame(id);
            };
        } : function (fn) {
            var timer = $timeout(fn, 16.66, false);
            return function () {
                $timeout.cancel(timer);
            };
        };
        raf.supported = rafSupported;
        return raf;
    }
];});
    $RootScopeProvider = ($__.fs.$RootScopeProvider_194 = function $RootScopeProvider() {
var vvv_return, vvv_switch, TTL, $rootScopeMinErr, lastDirtyWatch, applyAsyncId, createChildScopeClass;
createChildScopeClass = function createChildScopeClass(parent) {
    function ChildScope() {
        this.$$watchers = this.$$nextSibling = this.$$childHead = this.$$childTail = null;
        this.$$listeners = {};
        this.$$listenerCount = {};
        this.$$watchersCount = 0;
        this.$id = nextUid();
        this.$$ChildScope = null;
    }
    ChildScope.prototype = parent;
    return ChildScope;
};
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
TTL = 10;
$rootScopeMinErr = minErr('$rootScope');
lastDirtyWatch = null;
applyAsyncId = null;
this.digestTtl = function (value) {
    if (arguments.length) {
        TTL = value;
    }
    return TTL;
};
this.$get = [
    '$exceptionHandler',
    '$parse',
    '$browser',
    function ($exceptionHandler, $parse, $browser) {
        function destroyChildScope($event) {
            $event.currentScope.$$destroyed = true;
        }
        function cleanUpScope($scope) {
            if (msie === 9) {
                if ($scope.$$childHead) {
                    cleanUpScope($scope.$$childHead);
                }
                if ($scope.$$nextSibling) {
                    cleanUpScope($scope.$$nextSibling);
                }
            }
            $scope.$parent = $scope.$$nextSibling = $scope.$$prevSibling = $scope.$$childHead = $scope.$$childTail = $scope.$root = $scope.$$watchers = null;
        }
        function Scope() {
            this.$id = nextUid();
            this.$$phase = this.$parent = this.$$watchers = this.$$nextSibling = this.$$prevSibling = this.$$childHead = this.$$childTail = null;
            this.$root = this;
            this.$$destroyed = false;
            this.$$listeners = {};
            this.$$listenerCount = {};
            this.$$watchersCount = 0;
            this.$$isolateBindings = null;
        }
        Scope.prototype = {
            constructor: Scope,
            $new: function (isolate, parent) {
                var child;
                parent = parent || this;
                if (isolate) {
                    child = new Scope();
                    child.$root = this.$root;
                } else {
                    if (!this.$$ChildScope) {
                        this.$$ChildScope = createChildScopeClass(this);
                    }
                    child = new this.$$ChildScope();
                }
                child.$parent = parent;
                child.$$prevSibling = parent.$$childTail;
                if (parent.$$childHead) {
                    parent.$$childTail.$$nextSibling = child;
                    parent.$$childTail = child;
                } else {
                    parent.$$childHead = parent.$$childTail = child;
                }
                if (isolate || parent !== this)
                    child.$on('$destroy', destroyChildScope);
                return child;
            },
            $watch: function (watchExp, listener, objectEquality, prettyPrintExpression) {
                var get = $parse(watchExp);
                if (get.$$watchDelegate) {
                    return get.$$watchDelegate(this, listener, objectEquality, get, watchExp);
                }
                var scope = this, array = scope.$$watchers, watcher = {
                        fn: listener,
                        last: initWatchVal,
                        get: get,
                        exp: prettyPrintExpression || watchExp,
                        eq: !!objectEquality
                    };
                lastDirtyWatch = null;
                if (!isFunction(listener)) {
                    watcher.fn = noop;
                }
                if (!array) {
                    array = scope.$$watchers = [];
                    array.$$digestWatchIndex = -1;
                }
                array.unshift(watcher);
                array.$$digestWatchIndex++;
                incrementWatchersCount(this, 1);
                return function deregisterWatch() {
                    var index = arrayRemove(array, watcher);
                    if (index >= 0) {
                        incrementWatchersCount(scope, -1);
                        if (index < array.$$digestWatchIndex) {
                            array.$$digestWatchIndex--;
                        }
                    }
                    lastDirtyWatch = null;
                };
            },
            $watchGroup: function (watchExpressions, listener) {
                var oldValues = new Array(watchExpressions.length);
                var newValues = new Array(watchExpressions.length);
                var deregisterFns = [];
                var self = this;
                var changeReactionScheduled = false;
                var firstRun = true;
                if (!watchExpressions.length) {
                    var shouldCall = true;
                    self.$evalAsync(function () {
                        if (shouldCall)
                            listener(newValues, newValues, self);
                    });
                    return function deregisterWatchGroup() {
                        shouldCall = false;
                    };
                }
                if (watchExpressions.length === 1) {
                    return this.$watch(watchExpressions[0], function watchGroupAction(value, oldValue, scope) {
                        newValues[0] = value;
                        oldValues[0] = oldValue;
                        listener(newValues, value === oldValue ? newValues : oldValues, scope);
                    });
                }
                forEach(watchExpressions, function (expr, i) {
                    var unwatchFn = self.$watch(expr, function watchGroupSubAction(value, oldValue) {
                        newValues[i] = value;
                        oldValues[i] = oldValue;
                        if (!changeReactionScheduled) {
                            changeReactionScheduled = true;
                            self.$evalAsync(watchGroupAction);
                        }
                    });
                    deregisterFns.push(unwatchFn);
                });
                function watchGroupAction() {
                    changeReactionScheduled = false;
                    if (firstRun) {
                        firstRun = false;
                        listener(newValues, newValues, self);
                    } else {
                        listener(newValues, oldValues, self);
                    }
                }
                return function deregisterWatchGroup() {
                    while (deregisterFns.length) {
                        deregisterFns.shift()();
                    }
                };
            },
            $watchCollection: function (obj, listener) {
                $watchCollectionInterceptor.$stateful = true;
                var self = this;
                var newValue;
                var oldValue;
                var veryOldValue;
                var trackVeryOldValue = listener.length > 1;
                var changeDetected = 0;
                var changeDetector = $parse(obj, $watchCollectionInterceptor);
                var internalArray = [];
                var internalObject = {};
                var initRun = true;
                var oldLength = 0;
                function $watchCollectionInterceptor(_value) {
                    newValue = _value;
                    var newLength, key, bothNaN, newItem, oldItem;
                    if (isUndefined(newValue))
                        return;
                    if (!isObject(newValue)) {
                        if (oldValue !== newValue) {
                            oldValue = newValue;
                            changeDetected++;
                        }
                    } else if (isArrayLike(newValue)) {
                        if (oldValue !== internalArray) {
                            oldValue = internalArray;
                            oldLength = oldValue.length = 0;
                            changeDetected++;
                        }
                        newLength = newValue.length;
                        if (oldLength !== newLength) {
                            changeDetected++;
                            oldValue.length = oldLength = newLength;
                        }
                        for (var i = 0; i < newLength; i++) {
                            oldItem = oldValue[i];
                            newItem = newValue[i];
                            bothNaN = oldItem !== oldItem && newItem !== newItem;
                            if (!bothNaN && oldItem !== newItem) {
                                changeDetected++;
                                oldValue[i] = newItem;
                            }
                        }
                    } else {
                        if (oldValue !== internalObject) {
                            oldValue = internalObject = {};
                            oldLength = 0;
                            changeDetected++;
                        }
                        newLength = 0;
                        for (key in newValue) {
                            if (hasOwnProperty.call(newValue, key)) {
                                newLength++;
                                newItem = newValue[key];
                                oldItem = oldValue[key];
                                if (key in oldValue) {
                                    bothNaN = oldItem !== oldItem && newItem !== newItem;
                                    if (!bothNaN && oldItem !== newItem) {
                                        changeDetected++;
                                        oldValue[key] = newItem;
                                    }
                                } else {
                                    oldLength++;
                                    oldValue[key] = newItem;
                                    changeDetected++;
                                }
                            }
                        }
                        if (oldLength > newLength) {
                            changeDetected++;
                            for (key in oldValue) {
                                if (!hasOwnProperty.call(newValue, key)) {
                                    oldLength--;
                                    delete oldValue[key];
                                }
                            }
                        }
                    }
                    return changeDetected;
                }
                function $watchCollectionAction() {
                    if (initRun) {
                        initRun = false;
                        listener(newValue, newValue, self);
                    } else {
                        listener(newValue, veryOldValue, self);
                    }
                    if (trackVeryOldValue) {
                        if (!isObject(newValue)) {
                            veryOldValue = newValue;
                        } else if (isArrayLike(newValue)) {
                            veryOldValue = new Array(newValue.length);
                            for (var i = 0; i < newValue.length; i++) {
                                veryOldValue[i] = newValue[i];
                            }
                        } else {
                            veryOldValue = {};
                            for (var key in newValue) {
                                if (hasOwnProperty.call(newValue, key)) {
                                    veryOldValue[key] = newValue[key];
                                }
                            }
                        }
                    }
                }
                return this.$watch(changeDetector, $watchCollectionAction);
            },
            $digest: function () {
                var watch, value, last, fn, get, watchers, dirty, ttl = TTL, next, current, target = this, watchLog = [], logIdx, asyncTask;
                beginPhase('$digest');
                $browser.$$checkUrlChange();
                if (this === $rootScope && applyAsyncId !== null) {
                    $browser.defer.cancel(applyAsyncId);
                    flushApplyAsync();
                }
                lastDirtyWatch = null;
                do {
                    dirty = false;
                    current = target;
                    for (var asyncQueuePosition = 0; asyncQueuePosition < asyncQueue.length; asyncQueuePosition++) {
                        try {
                            asyncTask = asyncQueue[asyncQueuePosition];
                            fn = asyncTask.fn;
                            fn(asyncTask.scope, asyncTask.locals);
                        } catch (e) {
                            $exceptionHandler(e);
                        }
                        lastDirtyWatch = null;
                    }
                    asyncQueue.length = 0;
                    traverseScopesLoop:
                        do {
                            if (watchers = current.$$watchers) {
                                watchers.$$digestWatchIndex = watchers.length;
                                while (watchers.$$digestWatchIndex--) {
                                    try {
                                        watch = watchers[watchers.$$digestWatchIndex];
                                        if (watch) {
                                            get = watch.get;
                                            if ((value = get(current)) !== (last = watch.last) && !(watch.eq ? equals(value, last) : isNumberNaN(value) && isNumberNaN(last))) {
                                                dirty = true;
                                                lastDirtyWatch = watch;
                                                watch.last = watch.eq ? copy(value, null) : value;
                                                fn = watch.fn;
                                                fn(value, last === initWatchVal ? value : last, current);
                                                if (ttl < 5) {
                                                    logIdx = 4 - ttl;
                                                    if (!watchLog[logIdx])
                                                        watchLog[logIdx] = [];
                                                    watchLog[logIdx].push({
                                                        msg: isFunction(watch.exp) ? 'fn: ' + (watch.exp.name || watch.exp.toString()) : watch.exp,
                                                        newVal: value,
                                                        oldVal: last
                                                    });
                                                }
                                            } else if (watch === lastDirtyWatch) {
                                                dirty = false;
                                                break traverseScopesLoop;
                                            }
                                        }
                                    } catch (e) {
                                        $exceptionHandler(e);
                                    }
                                }
                            }
                            if (!(next = current.$$watchersCount && current.$$childHead || current !== target && current.$$nextSibling)) {
                                while (current !== target && !(next = current.$$nextSibling)) {
                                    current = current.$parent;
                                }
                            }
                        } while (current = next);
                    if ((dirty || asyncQueue.length) && !ttl--) {
                        clearPhase();
                        throw $rootScopeMinErr('infdig', '{0} $digest() iterations reached. Aborting!\n' + 'Watchers fired in the last 5 iterations: {1}', TTL, watchLog);
                    }
                } while (dirty || asyncQueue.length);
                clearPhase();
                while (postDigestQueuePosition < postDigestQueue.length) {
                    try {
                        postDigestQueue[postDigestQueuePosition++]();
                    } catch (e) {
                        $exceptionHandler(e);
                    }
                }
                postDigestQueue.length = postDigestQueuePosition = 0;
                $browser.$$checkUrlChange();
            },
            $destroy: function () {
                if (this.$$destroyed)
                    return;
                var parent = this.$parent;
                this.$broadcast('$destroy');
                this.$$destroyed = true;
                if (this === $rootScope) {
                    $browser.$$applicationDestroyed();
                }
                incrementWatchersCount(this, -this.$$watchersCount);
                for (var eventName in this.$$listenerCount) {
                    decrementListenerCount(this, this.$$listenerCount[eventName], eventName);
                }
                if (parent && parent.$$childHead === this)
                    parent.$$childHead = this.$$nextSibling;
                if (parent && parent.$$childTail === this)
                    parent.$$childTail = this.$$prevSibling;
                if (this.$$prevSibling)
                    this.$$prevSibling.$$nextSibling = this.$$nextSibling;
                if (this.$$nextSibling)
                    this.$$nextSibling.$$prevSibling = this.$$prevSibling;
                this.$destroy = this.$digest = this.$apply = this.$evalAsync = this.$applyAsync = noop;
                this.$on = this.$watch = this.$watchGroup = function () {
                    return noop;
                };
                this.$$listeners = {};
                this.$$nextSibling = null;
                cleanUpScope(this);
            },
            $eval: function (expr, locals) {
                return $parse(expr)(this, locals);
            },
            $evalAsync: function (expr, locals) {
                if (!$rootScope.$$phase && !asyncQueue.length) {
                    $browser.defer(function () {
                        if (asyncQueue.length) {
                            $rootScope.$digest();
                        }
                    });
                }
                asyncQueue.push({
                    scope: this,
                    fn: $parse(expr),
                    locals: locals
                });
            },
            $$postDigest: function (fn) {
                postDigestQueue.push(fn);
            },
            $apply: function (expr) {
                try {
                    beginPhase('$apply');
                    try {
                        return this.$eval(expr);
                    } finally {
                        clearPhase();
                    }
                } catch (e) {
                    $exceptionHandler(e);
                } finally {
                    try {
                        $rootScope.$digest();
                    } catch (e) {
                        $exceptionHandler(e);
                        throw e;
                    }
                }
            },
            $applyAsync: function (expr) {
                var scope = this;
                if (expr) {
                    applyAsyncQueue.push($applyAsyncExpression);
                }
                expr = $parse(expr);
                scheduleApplyAsync();
                function $applyAsyncExpression() {
                    scope.$eval(expr);
                }
            },
            $on: function (name, listener) {
                var namedListeners = this.$$listeners[name];
                if (!namedListeners) {
                    this.$$listeners[name] = namedListeners = [];
                }
                namedListeners.push(listener);
                var current = this;
                do {
                    if (!current.$$listenerCount[name]) {
                        current.$$listenerCount[name] = 0;
                    }
                    current.$$listenerCount[name]++;
                } while (current = current.$parent);
                var self = this;
                return function () {
                    var indexOfListener = namedListeners.indexOf(listener);
                    if (indexOfListener !== -1) {
                        namedListeners[indexOfListener] = null;
                        decrementListenerCount(self, 1, name);
                    }
                };
            },
            $emit: function (name, args) {
                var empty = [], namedListeners, scope = this, stopPropagation = false, event = {
                        name: name,
                        targetScope: scope,
                        stopPropagation: function () {
                            stopPropagation = true;
                        },
                        preventDefault: function () {
                            event.defaultPrevented = true;
                        },
                        defaultPrevented: false
                    }, listenerArgs = concat([event], arguments, 1), i, length;
                do {
                    namedListeners = scope.$$listeners[name] || empty;
                    event.currentScope = scope;
                    for (i = 0, length = namedListeners.length; i < length; i++) {
                        if (!namedListeners[i]) {
                            namedListeners.splice(i, 1);
                            i--;
                            length--;
                            continue;
                        }
                        try {
                            namedListeners[i].apply(null, listenerArgs);
                        } catch (e) {
                            $exceptionHandler(e);
                        }
                    }
                    if (stopPropagation) {
                        event.currentScope = null;
                        return event;
                    }
                    scope = scope.$parent;
                } while (scope);
                event.currentScope = null;
                return event;
            },
            $broadcast: function (name, args) {
                var target = this, current = target, next = target, event = {
                        name: name,
                        targetScope: target,
                        preventDefault: function () {
                            event.defaultPrevented = true;
                        },
                        defaultPrevented: false
                    };
                if (!target.$$listenerCount[name])
                    return event;
                var listenerArgs = concat([event], arguments, 1), listeners, i, length;
                while (current = next) {
                    event.currentScope = current;
                    listeners = current.$$listeners[name] || [];
                    for (i = 0, length = listeners.length; i < length; i++) {
                        if (!listeners[i]) {
                            listeners.splice(i, 1);
                            i--;
                            length--;
                            continue;
                        }
                        try {
                            listeners[i].apply(null, listenerArgs);
                        } catch (e) {
                            $exceptionHandler(e);
                        }
                    }
                    if (!(next = current.$$listenerCount[name] && current.$$childHead || current !== target && current.$$nextSibling)) {
                        while (current !== target && !(next = current.$$nextSibling)) {
                            current = current.$parent;
                        }
                    }
                }
                event.currentScope = null;
                return event;
            }
        };
        var $rootScope = new Scope();
        var asyncQueue = $rootScope.$$asyncQueue = [];
        var postDigestQueue = $rootScope.$$postDigestQueue = [];
        var applyAsyncQueue = $rootScope.$$applyAsyncQueue = [];
        var postDigestQueuePosition = 0;
        return $rootScope;
        function beginPhase(phase) {
            if ($rootScope.$$phase) {
                throw $rootScopeMinErr('inprog', '{0} already in progress', $rootScope.$$phase);
            }
            $rootScope.$$phase = phase;
        }
        function clearPhase() {
            $rootScope.$$phase = null;
        }
        function incrementWatchersCount(current, count) {
            do {
                current.$$watchersCount += count;
            } while (current = current.$parent);
        }
        function decrementListenerCount(current, count, name) {
            do {
                current.$$listenerCount[name] -= count;
                if (current.$$listenerCount[name] === 0) {
                    delete current.$$listenerCount[name];
                }
            } while (current = current.$parent);
        }
        function initWatchVal() {
        }
        function flushApplyAsync() {
            while (applyAsyncQueue.length) {
                try {
                    applyAsyncQueue.shift()();
                } catch (e) {
                    $exceptionHandler(e);
                }
            }
            applyAsyncId = null;
        }
        function scheduleApplyAsync() {
            if (applyAsyncId === null) {
                applyAsyncId = $browser.defer(function () {
                    $rootScope.$apply(flushApplyAsync);
                });
            }
        }
    }
];});
    $$SanitizeUriProvider = ($__.fs.$$SanitizeUriProvider_195 = function $$SanitizeUriProvider() {
var vvv_return, vvv_switch, aHrefSanitizationWhitelist, imgSrcSanitizationWhitelist;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
aHrefSanitizationWhitelist = /^\s*(https?|ftp|mailto|tel|file):/;
imgSrcSanitizationWhitelist = /^\s*((https?|ftp|file|blob):|data:image\/)/;
this.aHrefSanitizationWhitelist = function (regexp) {
    if (isDefined(regexp)) {
        aHrefSanitizationWhitelist = regexp;
        return this;
    }
    return aHrefSanitizationWhitelist;
};
this.imgSrcSanitizationWhitelist = function (regexp) {
    if (isDefined(regexp)) {
        imgSrcSanitizationWhitelist = regexp;
        return this;
    }
    return imgSrcSanitizationWhitelist;
};
this.$get = function () {
    return function sanitizeUri(uri, isImage) {
        var regex = isImage ? imgSrcSanitizationWhitelist : aHrefSanitizationWhitelist;
        var normalizedVal;
        normalizedVal = urlResolve(uri).href;
        if (normalizedVal !== '' && !normalizedVal.match(regex)) {
            return 'unsafe:' + normalizedVal;
        }
        return uri;
    };
};});
    snakeToCamel = ($__.fs.snakeToCamel_196 = function snakeToCamel(name) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
name = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return name.replace(UNDERSCORE_LOWERCASE_REGEXP, fnCamelCaseReplace);});
    adjustMatcher = ($__.fs.adjustMatcher_197 = function adjustMatcher(matcher) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
matcher = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (matcher === 'self') {
    return matcher;
} else if (isString(matcher)) {
    if (matcher.indexOf('***') > -1) {
        throw $sceMinErr('iwcard', 'Illegal sequence *** in string matcher.  String: {0}', matcher);
    }
    matcher = escapeForRegexp(matcher).replace(/\\\*\\\*/g, '.*').replace(/\\\*/g, '[^:/.?&;]*');
    return new RegExp('^' + matcher + '$');
} else if (isRegExp(matcher)) {
    return new RegExp('^' + matcher.source + '$');
} else {
    throw $sceMinErr('imatcher', 'Matchers may only be "self", string patterns or RegExp objects');
}});
    adjustMatchers = ($__.fs.adjustMatchers_198 = function adjustMatchers(matchers) {
var vvv_return, vvv_switch, adjustedMatchers;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
matchers = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
adjustedMatchers = [];
if (isDefined(matchers)) {
    forEach(matchers, function (matcher) {
        adjustedMatchers.push(adjustMatcher(matcher));
    });
}
return adjustedMatchers;});
    $SceDelegateProvider = ($__.fs.$SceDelegateProvider_199 = function $SceDelegateProvider() {
var vvv_return, vvv_switch, resourceUrlWhitelist, resourceUrlBlacklist;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.SCE_CONTEXTS = SCE_CONTEXTS;
resourceUrlWhitelist = ['self'];
resourceUrlBlacklist = [];
this.resourceUrlWhitelist = function (value) {
    if (arguments.length) {
        resourceUrlWhitelist = adjustMatchers(value);
    }
    return resourceUrlWhitelist;
};
this.resourceUrlBlacklist = function (value) {
    if (arguments.length) {
        resourceUrlBlacklist = adjustMatchers(value);
    }
    return resourceUrlBlacklist;
};
this.$get = [
    '$injector',
    function ($injector) {
        var htmlSanitizer = function htmlSanitizer(html) {
            throw $sceMinErr('unsafe', 'Attempting to use an unsafe value in a safe context.');
        };
        if ($injector.has('$sanitize')) {
            htmlSanitizer = $injector.get('$sanitize');
        }
        function matchUrl(matcher, parsedUrl) {
            if (matcher === 'self') {
                return urlIsSameOrigin(parsedUrl);
            } else {
                return !!matcher.exec(parsedUrl.href);
            }
        }
        function isResourceUrlAllowedByPolicy(url) {
            var parsedUrl = urlResolve(url.toString());
            var i, n, allowed = false;
            for (i = 0, n = resourceUrlWhitelist.length; i < n; i++) {
                if (matchUrl(resourceUrlWhitelist[i], parsedUrl)) {
                    allowed = true;
                    break;
                }
            }
            if (allowed) {
                for (i = 0, n = resourceUrlBlacklist.length; i < n; i++) {
                    if (matchUrl(resourceUrlBlacklist[i], parsedUrl)) {
                        allowed = false;
                        break;
                    }
                }
            }
            return allowed;
        }
        function generateHolderType(Base) {
            var holderType = function TrustedValueHolderType(trustedValue) {
                this.$$unwrapTrustedValue = function () {
                    return trustedValue;
                };
            };
            if (Base) {
                holderType.prototype = new Base();
            }
            holderType.prototype.valueOf = function sceValueOf() {
                return this.$$unwrapTrustedValue();
            };
            holderType.prototype.toString = function sceToString() {
                return this.$$unwrapTrustedValue().toString();
            };
            return holderType;
        }
        var trustedValueHolderBase = generateHolderType(), byType = {};
        byType[SCE_CONTEXTS.HTML] = generateHolderType(trustedValueHolderBase);
        byType[SCE_CONTEXTS.CSS] = generateHolderType(trustedValueHolderBase);
        byType[SCE_CONTEXTS.URL] = generateHolderType(trustedValueHolderBase);
        byType[SCE_CONTEXTS.JS] = generateHolderType(trustedValueHolderBase);
        byType[SCE_CONTEXTS.RESOURCE_URL] = generateHolderType(byType[SCE_CONTEXTS.URL]);
        function trustAs(type, trustedValue) {
            var Constructor = byType.hasOwnProperty(type) ? byType[type] : null;
            if (!Constructor) {
                throw $sceMinErr('icontext', 'Attempted to trust a value in invalid context. Context: {0}; Value: {1}', type, trustedValue);
            }
            if (trustedValue === null || isUndefined(trustedValue) || trustedValue === '') {
                return trustedValue;
            }
            if (typeof trustedValue !== 'string') {
                throw $sceMinErr('itype', 'Attempted to trust a non-string value in a content requiring a string: Context: {0}', type);
            }
            return new Constructor(trustedValue);
        }
        function valueOf(maybeTrusted) {
            if (maybeTrusted instanceof trustedValueHolderBase) {
                return maybeTrusted.$$unwrapTrustedValue();
            } else {
                return maybeTrusted;
            }
        }
        function getTrusted(type, maybeTrusted) {
            if (maybeTrusted === null || isUndefined(maybeTrusted) || maybeTrusted === '') {
                return maybeTrusted;
            }
            var constructor = byType.hasOwnProperty(type) ? byType[type] : null;
            if (constructor && maybeTrusted instanceof constructor) {
                return maybeTrusted.$$unwrapTrustedValue();
            }
            if (type === SCE_CONTEXTS.RESOURCE_URL) {
                if (isResourceUrlAllowedByPolicy(maybeTrusted)) {
                    return maybeTrusted;
                } else {
                    throw $sceMinErr('insecurl', 'Blocked loading resource from url not allowed by $sceDelegate policy.  URL: {0}', maybeTrusted.toString());
                }
            } else if (type === SCE_CONTEXTS.HTML) {
                return htmlSanitizer(maybeTrusted);
            }
            throw $sceMinErr('unsafe', 'Attempting to use an unsafe value in a safe context.');
        }
        return {
            trustAs: trustAs,
            getTrusted: getTrusted,
            valueOf: valueOf
        };
    }
];});
    $SceProvider = ($__.fs.$SceProvider_200 = function $SceProvider() {
var vvv_return, vvv_switch, enabled;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
enabled = true;
this.enabled = function (value) {
    if (arguments.length) {
        enabled = !!value;
    }
    return enabled;
};
this.$get = [
    '$parse',
    '$sceDelegate',
    function ($parse, $sceDelegate) {
        if (enabled && msie < 8) {
            throw $sceMinErr('iequirks', 'Strict Contextual Escaping does not support Internet Explorer version < 11 in quirks ' + 'mode.  You can fix this by adding the text <!doctype html> to the top of your HTML ' + 'document.  See http://docs.angularjs.org/api/ng.$sce for more information.');
        }
        var sce = shallowCopy(SCE_CONTEXTS);
        sce.isEnabled = function () {
            return enabled;
        };
        sce.trustAs = $sceDelegate.trustAs;
        sce.getTrusted = $sceDelegate.getTrusted;
        sce.valueOf = $sceDelegate.valueOf;
        if (!enabled) {
            sce.trustAs = sce.getTrusted = function (type, value) {
                return value;
            };
            sce.valueOf = identity;
        }
        sce.parseAs = function sceParseAs(type, expr) {
            var parsed = $parse(expr);
            if (parsed.literal && parsed.constant) {
                return parsed;
            } else {
                return $parse(expr, function (value) {
                    return sce.getTrusted(type, value);
                });
            }
        };
        var parse = sce.parseAs, getTrusted = sce.getTrusted, trustAs = sce.trustAs;
        forEach(SCE_CONTEXTS, function (enumValue, name) {
            var lName = lowercase(name);
            sce[snakeToCamel('parse_as_' + lName)] = function (expr) {
                return parse(enumValue, expr);
            };
            sce[snakeToCamel('get_trusted_' + lName)] = function (value) {
                return getTrusted(enumValue, value);
            };
            sce[snakeToCamel('trust_as_' + lName)] = function (value) {
                return trustAs(enumValue, value);
            };
        });
        return sce;
    }
];});
    $SnifferProvider = ($__.fs.$SnifferProvider_201 = function $SnifferProvider() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.$get = [
    '$window',
    '$document',
    function ($window, $document) {
        var eventSupport = {}, isNw = $window.nw && $window.nw.process, isChromePackagedApp = !isNw && $window.chrome && ($window.chrome.app && $window.chrome.app.runtime || !$window.chrome.app && $window.chrome.runtime && $window.chrome.runtime.id), hasHistoryPushState = !isChromePackagedApp && $window.history && $window.history.pushState, android = toInt((/android (\d+)/.exec(lowercase(($window.navigator || {}).userAgent)) || [])[1]), boxee = /Boxee/i.test(($window.navigator || {}).userAgent), document = $document[0] || {}, bodyStyle = document.body && document.body.style, transitions = false, animations = false;
        if (bodyStyle) {
            transitions = !!('transition' in bodyStyle || 'webkitTransition' in bodyStyle);
            animations = !!('animation' in bodyStyle || 'webkitAnimation' in bodyStyle);
        }
        return {
            history: !!(hasHistoryPushState && !(android < 4) && !boxee),
            hasEvent: function (event) {
                if (event === 'input' && msie)
                    return false;
                if (isUndefined(eventSupport[event])) {
                    var divElm = document.createElement('div');
                    eventSupport[event] = 'on' + event in divElm;
                }
                return eventSupport[event];
            },
            csp: csp(),
            transitions: transitions,
            animations: animations,
            android: android
        };
    }
];});
    $TemplateRequestProvider = ($__.fs.$TemplateRequestProvider_202 = function $TemplateRequestProvider() {
var vvv_return, vvv_switch, httpOptions;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.httpOptions = function (val) {
    if (val) {
        httpOptions = val;
        return this;
    }
    return httpOptions;
};
this.$get = [
    '$exceptionHandler',
    '$templateCache',
    '$http',
    '$q',
    '$sce',
    function ($exceptionHandler, $templateCache, $http, $q, $sce) {
        function handleRequestFn(tpl, ignoreRequestError) {
            handleRequestFn.totalPendingRequests++;
            if (!isString(tpl) || isUndefined($templateCache.get(tpl))) {
                tpl = $sce.getTrustedResourceUrl(tpl);
            }
            var transformResponse = $http.defaults && $http.defaults.transformResponse;
            if (isArray(transformResponse)) {
                transformResponse = transformResponse.filter(function (transformer) {
                    return transformer !== defaultHttpResponseTransform;
                });
            } else if (transformResponse === defaultHttpResponseTransform) {
                transformResponse = null;
            }
            return $http.get(tpl, extend({
                cache: $templateCache,
                transformResponse: transformResponse
            }, httpOptions)).finally(function () {
                handleRequestFn.totalPendingRequests--;
            }).then(function (response) {
                $templateCache.put(tpl, response.data);
                return response.data;
            }, handleError);
            function handleError(resp) {
                if (!ignoreRequestError) {
                    resp = $templateRequestMinErr('tpload', 'Failed to load template: {0} (HTTP status: {1} {2})', tpl, resp.status, resp.statusText);
                    $exceptionHandler(resp);
                }
                return $q.reject(resp);
            }
        }
        handleRequestFn.totalPendingRequests = 0;
        return handleRequestFn;
    }
];});
    $$TestabilityProvider = ($__.fs.$$TestabilityProvider_203 = function $$TestabilityProvider() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.$get = [
    '$rootScope',
    '$browser',
    '$location',
    function ($rootScope, $browser, $location) {
        var testability = {};
        testability.findBindings = function (element, expression, opt_exactMatch) {
            var bindings = element.getElementsByClassName('ng-binding');
            var matches = [];
            forEach(bindings, function (binding) {
                var dataBinding = angular.element(binding).data('$binding');
                if (dataBinding) {
                    forEach(dataBinding, function (bindingName) {
                        if (opt_exactMatch) {
                            var matcher = new RegExp('(^|\\s)' + escapeForRegexp(expression) + '(\\s|\\||$)');
                            if (matcher.test(bindingName)) {
                                matches.push(binding);
                            }
                        } else {
                            if (bindingName.indexOf(expression) !== -1) {
                                matches.push(binding);
                            }
                        }
                    });
                }
            });
            return matches;
        };
        testability.findModels = function (element, expression, opt_exactMatch) {
            var prefixes = [
                'ng-',
                'data-ng-',
                'ng\\:'
            ];
            for (var p = 0; p < prefixes.length; ++p) {
                var attributeEquals = opt_exactMatch ? '=' : '*=';
                var selector = '[' + prefixes[p] + 'model' + attributeEquals + '"' + expression + '"]';
                var elements = element.querySelectorAll(selector);
                if (elements.length) {
                    return elements;
                }
            }
        };
        testability.getLocation = function () {
            return $location.url();
        };
        testability.setLocation = function (url) {
            if (url !== $location.url()) {
                $location.url(url);
                $rootScope.$digest();
            }
        };
        testability.whenStable = function (callback) {
            $browser.notifyWhenNoOutstandingRequests(callback);
        };
        return testability;
    }
];});
    $TimeoutProvider = ($__.fs.$TimeoutProvider_204 = function $TimeoutProvider() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.$get = [
    '$rootScope',
    '$browser',
    '$q',
    '$$q',
    '$exceptionHandler',
    function ($rootScope, $browser, $q, $$q, $exceptionHandler) {
        var deferreds = {};
        function timeout(fn, delay, invokeApply) {
            if (!isFunction(fn)) {
                invokeApply = delay;
                delay = fn;
                fn = noop;
            }
            var args = sliceArgs(arguments, 3), skipApply = isDefined(invokeApply) && !invokeApply, deferred = (skipApply ? $$q : $q).defer(), promise = deferred.promise, timeoutId;
            timeoutId = $browser.defer(function () {
                try {
                    deferred.resolve(fn.apply(null, args));
                } catch (e) {
                    deferred.reject(e);
                    $exceptionHandler(e);
                } finally {
                    delete deferreds[promise.$$timeoutId];
                }
                if (!skipApply)
                    $rootScope.$apply();
            }, delay);
            promise.$$timeoutId = timeoutId;
            deferreds[timeoutId] = deferred;
            return promise;
        }
        timeout.cancel = function (promise) {
            if (promise && promise.$$timeoutId in deferreds) {
                deferreds[promise.$$timeoutId].promise.catch(noop);
                deferreds[promise.$$timeoutId].reject('canceled');
                delete deferreds[promise.$$timeoutId];
                return $browser.defer.cancel(promise.$$timeoutId);
            }
            return false;
        };
        return timeout;
    }
];});
    urlResolve = ($__.fs.urlResolve_205 = function urlResolve(url) {
var vvv_return, vvv_switch, href;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
url = arguments[0];
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    href = url;
    msie;
    urlParsingNode['setAttribute']('href', href);
    return $__.os.oid29 = {
        'href': TAJS_restrictToType(urlParsingNode.href, 'string'),
        'protocol': (TAJS_restrictToType(urlParsingNode.protocol, 'string'), TAJS_restrictToType(urlParsingNode.protocol, 'string')['replace'](/:$/, '')),
        'host': TAJS_restrictToType(urlParsingNode.host, 'string'),
        'search': (TAJS_restrictToType(urlParsingNode.search, 'string'), ''),
        'hash': (TAJS_restrictToType(urlParsingNode.hash, 'string'), ''),
        'hostname': TAJS_restrictToType(urlParsingNode.hostname, 'string'),
        'port': TAJS_restrictToType(urlParsingNode.port, 'string'),
        'pathname': (TAJS_restrictToType(urlParsingNode.pathname, 'string')['charAt'](0) === '/', TAJS_restrictToType(urlParsingNode.pathname, 'string'))
    };
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
href = url;
if (msie) {
    urlParsingNode.setAttribute('href', href);
    href = urlParsingNode.href;
}
urlParsingNode.setAttribute('href', href);
return {
    href: urlParsingNode.href,
    protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
    host: urlParsingNode.host,
    search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
    hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
    hostname: urlParsingNode.hostname,
    port: urlParsingNode.port,
    pathname: urlParsingNode.pathname.charAt(0) === '/' ? urlParsingNode.pathname : '/' + urlParsingNode.pathname
};});
    urlIsSameOrigin = ($__.fs.urlIsSameOrigin_206 = function urlIsSameOrigin(requestUrl) {
var vvv_return, vvv_switch, parsed;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
requestUrl = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
parsed = isString(requestUrl) ? urlResolve(requestUrl) : requestUrl;
return parsed.protocol === originUrl.protocol && parsed.host === originUrl.host;});
    $WindowProvider = ($__.fs.$WindowProvider_207 = function $WindowProvider() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.$get = valueFn(window);});
    $$CookieReader = ($__.fs.$$CookieReader_208 = function $$CookieReader($document) {
var vvv_return, vvv_switch, rawDocument, lastCookies, lastCookieString, safeGetCookie, safeDecodeURIComponent;
safeGetCookie = function safeGetCookie(rawDocument) {
    try {
        return rawDocument.cookie || '';
    } catch (e) {
        return '';
    }
};
safeDecodeURIComponent = function safeDecodeURIComponent(str) {
    try {
        return decodeURIComponent(str);
    } catch (e) {
        return str;
    }
};
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
$document = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
rawDocument = $document[0] || {};
lastCookies = {};
lastCookieString = '';
return function () {
    var cookieArray, cookie, i, index, name;
    var currentCookieString = safeGetCookie(rawDocument);
    if (currentCookieString !== lastCookieString) {
        lastCookieString = currentCookieString;
        cookieArray = lastCookieString.split('; ');
        lastCookies = {};
        for (i = 0; i < cookieArray.length; i++) {
            cookie = cookieArray[i];
            index = cookie.indexOf('=');
            if (index > 0) {
                name = safeDecodeURIComponent(cookie.substring(0, index));
                if (isUndefined(lastCookies[name])) {
                    lastCookies[name] = safeDecodeURIComponent(cookie.substring(index + 1));
                }
            }
        }
    }
    return lastCookies;
};});
    $$CookieReaderProvider = ($__.fs.$$CookieReaderProvider_209 = function $$CookieReaderProvider() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.$get = $$CookieReader;});
    $FilterProvider = ($__.fs.$FilterProvider_210 = function $FilterProvider($provide) {
var vvv_return, vvv_switch, suffix, register;
register = function register(name, factory) {
    if (isObject(name)) {
        var filters = {};
        forEach(name, function (filter, key) {
            filters[key] = register(key, filter);
        });
        return filters;
    } else {
        return $provide.factory(name + suffix, factory);
    }
};
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
$provide = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
suffix = 'Filter';
this.register = register;
this.$get = [
    '$injector',
    function ($injector) {
        return function (name) {
            return $injector.get(name + suffix);
        };
    }
];
register('currency', currencyFilter);
register('date', dateFilter);
register('filter', filterFilter);
register('json', jsonFilter);
register('limitTo', limitToFilter);
register('lowercase', lowercaseFilter);
register('number', numberFilter);
register('orderBy', orderByFilter);
register('uppercase', uppercaseFilter);});
    filterFilter = ($__.fs.filterFilter_211 = function filterFilter() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return function (array, expression, comparator, anyPropertyKey) {
    if (!isArrayLike(array)) {
        if (array == null) {
            return array;
        } else {
            throw minErr('filter')('notarray', 'Expected array but received: {0}', array);
        }
    }
    anyPropertyKey = anyPropertyKey || '$';
    var expressionType = getTypeForFilter(expression);
    var predicateFn;
    var matchAgainstAnyProp;
    switch (expressionType) {
    case 'function':
        predicateFn = expression;
        break;
    case 'boolean':
    case 'null':
    case 'number':
    case 'string':
        matchAgainstAnyProp = true;
    case 'object':
        predicateFn = createPredicateFn(expression, comparator, anyPropertyKey, matchAgainstAnyProp);
        break;
    default:
        return array;
    }
    return Array.prototype.filter.call(array, predicateFn);
};});
    createPredicateFn = ($__.fs.createPredicateFn_212 = function createPredicateFn(expression, comparator, anyPropertyKey, matchAgainstAnyProp) {
var vvv_return, vvv_switch, shouldMatchPrimitives, predicateFn;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
expression = arguments[0], comparator = arguments[1], anyPropertyKey = arguments[2], matchAgainstAnyProp = arguments[3];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
shouldMatchPrimitives = isObject(expression) && anyPropertyKey in expression;
if (comparator === true) {
    comparator = equals;
} else if (!isFunction(comparator)) {
    comparator = function (actual, expected) {
        if (isUndefined(actual)) {
            return false;
        }
        if (actual === null || expected === null) {
            return actual === expected;
        }
        if (isObject(expected) || isObject(actual) && !hasCustomToString(actual)) {
            return false;
        }
        actual = lowercase('' + actual);
        expected = lowercase('' + expected);
        return actual.indexOf(expected) !== -1;
    };
}
predicateFn = function (item) {
    if (shouldMatchPrimitives && !isObject(item)) {
        return deepCompare(item, expression[anyPropertyKey], comparator, anyPropertyKey, false);
    }
    return deepCompare(item, expression, comparator, anyPropertyKey, matchAgainstAnyProp);
};
return predicateFn;});
    deepCompare = ($__.fs.deepCompare_213 = function deepCompare(actual, expected, comparator, anyPropertyKey, matchAgainstAnyProp, dontMatchWholeObject) {
var vvv_return, vvv_switch, actualType, expectedType, key, expectedVal, matchAnyProperty, actualVal;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
actual = arguments[0], expected = arguments[1], comparator = arguments[2], anyPropertyKey = arguments[3], matchAgainstAnyProp = arguments[4], dontMatchWholeObject = arguments[5];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
actualType = getTypeForFilter(actual);
expectedType = getTypeForFilter(expected);
if (expectedType === 'string' && expected.charAt(0) === '!') {
    return !deepCompare(actual, expected.substring(1), comparator, anyPropertyKey, matchAgainstAnyProp);
} else if (isArray(actual)) {
    return actual.some(function (item) {
        return deepCompare(item, expected, comparator, anyPropertyKey, matchAgainstAnyProp);
    });
}
switch (actualType) {
case 'object':
    if (matchAgainstAnyProp) {
        for (key in actual) {
            if (key.charAt && key.charAt(0) !== '$' && deepCompare(actual[key], expected, comparator, anyPropertyKey, true)) {
                return true;
            }
        }
        return dontMatchWholeObject ? false : deepCompare(actual, expected, comparator, anyPropertyKey, false);
    } else if (expectedType === 'object') {
        for (key in expected) {
            expectedVal = expected[key];
            if (isFunction(expectedVal) || isUndefined(expectedVal)) {
                continue;
            }
            matchAnyProperty = key === anyPropertyKey;
            actualVal = matchAnyProperty ? actual : actual[key];
            if (!deepCompare(actualVal, expectedVal, comparator, anyPropertyKey, matchAnyProperty, matchAnyProperty)) {
                return false;
            }
        }
        return true;
    } else {
        return comparator(actual, expected);
    }
case 'function':
    return false;
default:
    return comparator(actual, expected);
}});
    getTypeForFilter = ($__.fs.getTypeForFilter_214 = function getTypeForFilter(val) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
val = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return val === null ? 'null' : typeof val;});
    currencyFilter = ($__.fs.currencyFilter_215 = function currencyFilter($locale) {
var vvv_return, vvv_switch, formats;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
$locale = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
formats = $locale.NUMBER_FORMATS;
return function (amount, currencySymbol, fractionSize) {
    if (isUndefined(currencySymbol)) {
        currencySymbol = formats.CURRENCY_SYM;
    }
    if (isUndefined(fractionSize)) {
        fractionSize = formats.PATTERNS[1].maxFrac;
    }
    return amount == null ? amount : formatNumber(amount, formats.PATTERNS[1], formats.GROUP_SEP, formats.DECIMAL_SEP, fractionSize).replace(/\u00A4/g, currencySymbol);
};});
    numberFilter = ($__.fs.numberFilter_216 = function numberFilter($locale) {
var vvv_return, vvv_switch, formats;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
$locale = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
formats = $locale.NUMBER_FORMATS;
return function (number, fractionSize) {
    return number == null ? number : formatNumber(number, formats.PATTERNS[0], formats.GROUP_SEP, formats.DECIMAL_SEP, fractionSize);
};});
    parse = ($__.fs.parse_217 = function parse(numStr) {
var vvv_return, vvv_switch, exponent, digits, numberOfIntegerDigits, i, j, zeros;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
numStr = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
exponent = 0;
if ((numberOfIntegerDigits = numStr.indexOf(DECIMAL_SEP)) > -1) {
    numStr = numStr.replace(DECIMAL_SEP, '');
}
if ((i = numStr.search(/e/i)) > 0) {
    if (numberOfIntegerDigits < 0)
        numberOfIntegerDigits = i;
    numberOfIntegerDigits += +numStr.slice(i + 1);
    numStr = numStr.substring(0, i);
} else if (numberOfIntegerDigits < 0) {
    numberOfIntegerDigits = numStr.length;
}
for (i = 0; numStr.charAt(i) === ZERO_CHAR; i++) {
}
if (i === (zeros = numStr.length)) {
    digits = [0];
    numberOfIntegerDigits = 1;
} else {
    zeros--;
    while (numStr.charAt(zeros) === ZERO_CHAR)
        zeros--;
    numberOfIntegerDigits -= i;
    digits = [];
    for (j = 0; i <= zeros; i++, j++) {
        digits[j] = +numStr.charAt(i);
    }
}
if (numberOfIntegerDigits > MAX_DIGITS) {
    digits = digits.splice(0, MAX_DIGITS - 1);
    exponent = numberOfIntegerDigits - 1;
    numberOfIntegerDigits = 1;
}
return {
    d: digits,
    e: exponent,
    i: numberOfIntegerDigits
};});
    roundNumber = ($__.fs.roundNumber_218 = function roundNumber(parsedNumber, fractionSize, minFrac, maxFrac) {
var vvv_return, vvv_switch, digits, fractionLen, roundAt, digit, carry;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
parsedNumber = arguments[0], fractionSize = arguments[1], minFrac = arguments[2], maxFrac = arguments[3];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
digits = parsedNumber.d;
fractionLen = digits.length - parsedNumber.i;
fractionSize = isUndefined(fractionSize) ? Math.min(Math.max(minFrac, fractionLen), maxFrac) : +fractionSize;
roundAt = fractionSize + parsedNumber.i;
digit = digits[roundAt];
if (roundAt > 0) {
    digits.splice(Math.max(parsedNumber.i, roundAt));
    for (var j = roundAt; j < digits.length; j++) {
        digits[j] = 0;
    }
} else {
    fractionLen = Math.max(0, fractionLen);
    parsedNumber.i = 1;
    digits.length = Math.max(1, roundAt = fractionSize + 1);
    digits[0] = 0;
    for (var i = 1; i < roundAt; i++)
        digits[i] = 0;
}
if (digit >= 5) {
    if (roundAt - 1 < 0) {
        for (var k = 0; k > roundAt; k--) {
            digits.unshift(0);
            parsedNumber.i++;
        }
        digits.unshift(1);
        parsedNumber.i++;
    } else {
        digits[roundAt - 1]++;
    }
}
for (; fractionLen < Math.max(0, fractionSize); fractionLen++)
    digits.push(0);
carry = digits.reduceRight(function (carry, d, i, digits) {
    d = d + carry;
    digits[i] = d % 10;
    return Math.floor(d / 10);
}, 0);
if (carry) {
    digits.unshift(carry);
    parsedNumber.i++;
}});
    formatNumber = ($__.fs.formatNumber_219 = function formatNumber(number, pattern, groupSep, decimalSep, fractionSize) {
var vvv_return, vvv_switch, isInfinity, isZero, numStr, formattedText, parsedNumber, digits, integerLen, exponent, decimals, groups;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
number = arguments[0], pattern = arguments[1], groupSep = arguments[2], decimalSep = arguments[3], fractionSize = arguments[4];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (!(isString(number) || isNumber(number)) || isNaN(number))
    return '';
isInfinity = !isFinite(number);
isZero = false;
numStr = Math.abs(number) + '';
formattedText = '';
if (isInfinity) {
    formattedText = '\u221E';
} else {
    parsedNumber = parse(numStr);
    roundNumber(parsedNumber, fractionSize, pattern.minFrac, pattern.maxFrac);
    digits = parsedNumber.d;
    integerLen = parsedNumber.i;
    exponent = parsedNumber.e;
    decimals = [];
    isZero = digits.reduce(function (isZero, d) {
        return isZero && !d;
    }, true);
    while (integerLen < 0) {
        digits.unshift(0);
        integerLen++;
    }
    if (integerLen > 0) {
        decimals = digits.splice(integerLen, digits.length);
    } else {
        decimals = digits;
        digits = [0];
    }
    groups = [];
    if (digits.length >= pattern.lgSize) {
        groups.unshift(digits.splice(-pattern.lgSize, digits.length).join(''));
    }
    while (digits.length > pattern.gSize) {
        groups.unshift(digits.splice(-pattern.gSize, digits.length).join(''));
    }
    if (digits.length) {
        groups.unshift(digits.join(''));
    }
    formattedText = groups.join(groupSep);
    if (decimals.length) {
        formattedText += decimalSep + decimals.join('');
    }
    if (exponent) {
        formattedText += 'e+' + exponent;
    }
}
if (number < 0 && !isZero) {
    return pattern.negPre + formattedText + pattern.negSuf;
} else {
    return pattern.posPre + formattedText + pattern.posSuf;
}});
    padNumber = ($__.fs.padNumber_220 = function padNumber(num, digits, trim, negWrap) {
var vvv_return, vvv_switch, neg;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
num = arguments[0], digits = arguments[1], trim = arguments[2], negWrap = arguments[3];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
neg = '';
if (num < 0 || negWrap && num <= 0) {
    if (negWrap) {
        num = -num + 1;
    } else {
        num = -num;
        neg = '-';
    }
}
num = '' + num;
while (num.length < digits)
    num = ZERO_CHAR + num;
if (trim) {
    num = num.substr(num.length - digits);
}
return neg + num;});
    dateGetter = ($__.fs.dateGetter_221 = function dateGetter(name, size, offset, trim, negWrap) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
name = arguments[0], size = arguments[1], offset = arguments[2], trim = arguments[3], negWrap = arguments[4];
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    offset = (offset, 0);
    return ($__.fs.J$__v3645318688_1711_490 = function J$__v3645318688_1711(date) {
var vvv_return, vvv_switch, value;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
date = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
value = date['get' + name]();
if (offset > 0 || value > -offset) {
    value += offset;
}
if (value === 0 && offset === -12)
    value = 12;
return padNumber(value, size, trim, negWrap);});
case 1:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 1);
    offset = (offset, 0);
    return ($__.fs.J$__v3645318688_1711_491 = function J$__v3645318688_1711(date) {
var vvv_return, vvv_switch, value;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
date = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
value = date['get' + name]();
if (offset > 0 || value > -offset) {
    value += offset;
}
if (value === 0 && offset === -12)
    value = 12;
return padNumber(value, size, trim, negWrap);});
case 2:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 2);
    offset = (offset, 0);
    return ($__.fs.J$__v3645318688_1711_492 = function J$__v3645318688_1711(date) {
var vvv_return, vvv_switch, value;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
date = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
value = date['get' + name]();
if (offset > 0 || value > -offset) {
    value += offset;
}
if (value === 0 && offset === -12)
    value = 12;
return padNumber(value, size, trim, negWrap);});
case 3:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 3);
    offset = offset;
    return ($__.fs.J$__v3645318688_1711_495 = function J$__v3645318688_1711(date) {
var vvv_return, vvv_switch, value;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
date = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
value = date['get' + name]();
if (offset > 0 || value > -offset) {
    value += offset;
}
if (value === 0 && offset === -12)
    value = 12;
return padNumber(value, size, trim, negWrap);});
case 4:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 4);
    offset = offset;
    return ($__.fs.J$__v3645318688_1711_496 = function J$__v3645318688_1711(date) {
var vvv_return, vvv_switch, value;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
date = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
value = date['get' + name]();
if (offset > 0 || value > -offset) {
    value += offset;
}
if (value === 0 && offset === -12)
    value = 12;
return padNumber(value, size, trim, negWrap);});
case 5:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 5);
    offset = (offset, 0);
    return ($__.fs.J$__v3645318688_1711_498 = function J$__v3645318688_1711(date) {
var vvv_return, vvv_switch, value;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
date = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
value = date['get' + name]();
if (offset > 0 || value > -offset) {
    value += offset;
}
if (value === 0 && offset === -12)
    value = 12;
return padNumber(value, size, trim, negWrap);});
case 6:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 6);
    offset = (offset, 0);
    return ($__.fs.J$__v3645318688_1711_499 = function J$__v3645318688_1711(date) {
var vvv_return, vvv_switch, value;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
date = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
value = date['get' + name]();
if (offset > 0 || value > -offset) {
    value += offset;
}
if (value === 0 && offset === -12)
    value = 12;
return padNumber(value, size, trim, negWrap);});
case 7:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 7);
    offset = (offset, 0);
    return ($__.fs.J$__v3645318688_1711_500 = function J$__v3645318688_1711(date) {
var vvv_return, vvv_switch, value;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
date = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
value = date['get' + name]();
if (offset > 0 || value > -offset) {
    value += offset;
}
if (value === 0 && offset === -12)
    value = 12;
return padNumber(value, size, trim, negWrap);});
case 8:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 8);
    offset = (offset, 0);
    return ($__.fs.J$__v3645318688_1711_501 = function J$__v3645318688_1711(date) {
var vvv_return, vvv_switch, value;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
date = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
value = date['get' + name]();
if (offset > 0 || value > -offset) {
    value += offset;
}
if (value === 0 && offset === -12)
    value = 12;
return padNumber(value, size, trim, negWrap);});
case 9:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 9);
    offset = offset;
    return ($__.fs.J$__v3645318688_1711_502 = function J$__v3645318688_1711(date) {
var vvv_return, vvv_switch, value;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
date = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
value = date['get' + name]();
if (offset > 0 || value > -offset) {
    value += offset;
}
if (value === 0 && offset === -12)
    value = 12;
return padNumber(value, size, trim, negWrap);});
case 10:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 10);
    offset = offset;
    return ($__.fs.J$__v3645318688_1711_503 = function J$__v3645318688_1711(date) {
var vvv_return, vvv_switch, value;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
date = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
value = date['get' + name]();
if (offset > 0 || value > -offset) {
    value += offset;
}
if (value === 0 && offset === -12)
    value = 12;
return padNumber(value, size, trim, negWrap);});
case 11:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 11);
    offset = (offset, 0);
    return ($__.fs.J$__v3645318688_1711_504 = function J$__v3645318688_1711(date) {
var vvv_return, vvv_switch, value;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
date = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
value = date['get' + name]();
if (offset > 0 || value > -offset) {
    value += offset;
}
if (value === 0 && offset === -12)
    value = 12;
return padNumber(value, size, trim, negWrap);});
case 12:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 12);
    offset = (offset, 0);
    return ($__.fs.J$__v3645318688_1711_505 = function J$__v3645318688_1711(date) {
var vvv_return, vvv_switch, value;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
date = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
value = date['get' + name]();
if (offset > 0 || value > -offset) {
    value += offset;
}
if (value === 0 && offset === -12)
    value = 12;
return padNumber(value, size, trim, negWrap);});
case 13:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 13);
    offset = (offset, 0);
    return ($__.fs.J$__v3645318688_1711_506 = function J$__v3645318688_1711(date) {
var vvv_return, vvv_switch, value;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
date = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
value = date['get' + name]();
if (offset > 0 || value > -offset) {
    value += offset;
}
if (value === 0 && offset === -12)
    value = 12;
return padNumber(value, size, trim, negWrap);});
case 14:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 14);
    offset = (offset, 0);
    return ($__.fs.J$__v3645318688_1711_507 = function J$__v3645318688_1711(date) {
var vvv_return, vvv_switch, value;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
date = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
value = date['get' + name]();
if (offset > 0 || value > -offset) {
    value += offset;
}
if (value === 0 && offset === -12)
    value = 12;
return padNumber(value, size, trim, negWrap);});
case 15:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 15);
    offset = (offset, 0);
    return ($__.fs.J$__v3645318688_1711_508 = function J$__v3645318688_1711(date) {
var vvv_return, vvv_switch, value;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
date = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
value = date['get' + name]();
if (offset > 0 || value > -offset) {
    value += offset;
}
if (value === 0 && offset === -12)
    value = 12;
return padNumber(value, size, trim, negWrap);});
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
offset = offset || 0;
return function (date) {
    var value = date['get' + name]();
    if (offset > 0 || value > -offset) {
        value += offset;
    }
    if (value === 0 && offset === -12)
        value = 12;
    return padNumber(value, size, trim, negWrap);
};});
    dateStrGetter = ($__.fs.dateStrGetter_222 = function dateStrGetter(name, shortForm, standAlone) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
name = arguments[0], shortForm = arguments[1], standAlone = arguments[2];
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    return ($__.fs.J$__v3645318688_1714_493 = function J$__v3645318688_1714(date, formats) {
var vvv_return, vvv_switch, value, propPrefix, get;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
date = arguments[0], formats = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
value = date['get' + name]();
propPrefix = (standAlone ? 'STANDALONE' : '') + (shortForm ? 'SHORT' : '');
get = uppercase(propPrefix + name);
return formats[get][value];});
case 1:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 1);
    return ($__.fs.J$__v3645318688_1714_494 = function J$__v3645318688_1714(date, formats) {
var vvv_return, vvv_switch, value, propPrefix, get;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
date = arguments[0], formats = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
value = date['get' + name]();
propPrefix = (standAlone ? 'STANDALONE' : '') + (shortForm ? 'SHORT' : '');
get = uppercase(propPrefix + name);
return formats[get][value];});
case 2:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 2);
    return ($__.fs.J$__v3645318688_1714_497 = function J$__v3645318688_1714(date, formats) {
var vvv_return, vvv_switch, value, propPrefix, get;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
date = arguments[0], formats = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
value = date['get' + name]();
propPrefix = (standAlone ? 'STANDALONE' : '') + (shortForm ? 'SHORT' : '');
get = uppercase(propPrefix + name);
return formats[get][value];});
case 3:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 3);
    return ($__.fs.J$__v3645318688_1714_509 = function J$__v3645318688_1714(date, formats) {
var vvv_return, vvv_switch, value, propPrefix, get;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
date = arguments[0], formats = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
value = date['get' + name]();
propPrefix = (standAlone ? 'STANDALONE' : '') + (shortForm ? 'SHORT' : '');
get = uppercase(propPrefix + name);
return formats[get][value];});
case 4:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 4);
    return ($__.fs.J$__v3645318688_1714_510 = function J$__v3645318688_1714(date, formats) {
var vvv_return, vvv_switch, value, propPrefix, get;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
date = arguments[0], formats = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
value = date['get' + name]();
propPrefix = (standAlone ? 'STANDALONE' : '') + (shortForm ? 'SHORT' : '');
get = uppercase(propPrefix + name);
return formats[get][value];});
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return function (date, formats) {
    var value = date['get' + name]();
    var propPrefix = (standAlone ? 'STANDALONE' : '') + (shortForm ? 'SHORT' : '');
    var get = uppercase(propPrefix + name);
    return formats[get][value];
};});
    timeZoneGetter = ($__.fs.timeZoneGetter_223 = function timeZoneGetter(date, formats, offset) {
var vvv_return, vvv_switch, zone, paddedZone;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
date = arguments[0], formats = arguments[1], offset = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
zone = -1 * offset;
paddedZone = zone >= 0 ? '+' : '';
paddedZone += padNumber(Math[zone > 0 ? 'floor' : 'ceil'](zone / 60), 2) + padNumber(Math.abs(zone % 60), 2);
return paddedZone;});
    getFirstThursdayOfYear = ($__.fs.getFirstThursdayOfYear_224 = function getFirstThursdayOfYear(year) {
var vvv_return, vvv_switch, dayOfWeekOnFirst;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
year = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
dayOfWeekOnFirst = new Date(year, 0, 1).getDay();
return new Date(year, 0, (dayOfWeekOnFirst <= 4 ? 5 : 12) - dayOfWeekOnFirst);});
    getThursdayThisWeek = ($__.fs.getThursdayThisWeek_225 = function getThursdayThisWeek(datetime) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
datetime = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return new Date(datetime.getFullYear(), datetime.getMonth(), datetime.getDate() + (4 - datetime.getDay()));});
    weekGetter = ($__.fs.weekGetter_226 = function weekGetter(size) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
size = arguments[0];
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    return ($__.fs.J$__v3645318688_1720_511 = function J$__v3645318688_1720(date) {
var vvv_return, vvv_switch, firstThurs, thisThurs, diff, result;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
date = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
firstThurs = getFirstThursdayOfYear(date.getFullYear());
thisThurs = getThursdayThisWeek(date);
diff = +thisThurs - +firstThurs;
result = 1 + Math.round(diff / 604800000);
return padNumber(result, size);});
case 1:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 1);
    return ($__.fs.J$__v3645318688_1720_512 = function J$__v3645318688_1720(date) {
var vvv_return, vvv_switch, firstThurs, thisThurs, diff, result;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
date = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
firstThurs = getFirstThursdayOfYear(date.getFullYear());
thisThurs = getThursdayThisWeek(date);
diff = +thisThurs - +firstThurs;
result = 1 + Math.round(diff / 604800000);
return padNumber(result, size);});
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return function (date) {
    var firstThurs = getFirstThursdayOfYear(date.getFullYear()), thisThurs = getThursdayThisWeek(date);
    var diff = +thisThurs - +firstThurs, result = 1 + Math.round(diff / 604800000);
    return padNumber(result, size);
};});
    ampmGetter = ($__.fs.ampmGetter_227 = function ampmGetter(date, formats) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
date = arguments[0], formats = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return date.getHours() < 12 ? formats.AMPMS[0] : formats.AMPMS[1];});
    eraGetter = ($__.fs.eraGetter_228 = function eraGetter(date, formats) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
date = arguments[0], formats = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return date.getFullYear() <= 0 ? formats.ERAS[0] : formats.ERAS[1];});
    longEraGetter = ($__.fs.longEraGetter_229 = function longEraGetter(date, formats) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
date = arguments[0], formats = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return date.getFullYear() <= 0 ? formats.ERANAMES[0] : formats.ERANAMES[1];});
    dateFilter = ($__.fs.dateFilter_230 = function dateFilter($locale) {
var vvv_return, vvv_switch, R_ISO8601_STR, jsonStringToDate;
jsonStringToDate = function jsonStringToDate(string) {
    var match;
    if (match = string.match(R_ISO8601_STR)) {
        var date = new Date(0), tzHour = 0, tzMin = 0, dateSetter = match[8] ? date.setUTCFullYear : date.setFullYear, timeSetter = match[8] ? date.setUTCHours : date.setHours;
        if (match[9]) {
            tzHour = toInt(match[9] + match[10]);
            tzMin = toInt(match[9] + match[11]);
        }
        dateSetter.call(date, toInt(match[1]), toInt(match[2]) - 1, toInt(match[3]));
        var h = toInt(match[4] || 0) - tzHour;
        var m = toInt(match[5] || 0) - tzMin;
        var s = toInt(match[6] || 0);
        var ms = Math.round(parseFloat('0.' + (match[7] || 0)) * 1000);
        timeSetter.call(date, h, m, s, ms);
        return date;
    }
    return string;
};
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
$locale = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
R_ISO8601_STR = /^(\d{4})-?(\d\d)-?(\d\d)(?:T(\d\d)(?::?(\d\d)(?::?(\d\d)(?:\.(\d+))?)?)?(Z|([+-])(\d\d):?(\d\d))?)?$/;
return function (date, format, timezone) {
    var text = '', parts = [], fn, match;
    format = format || 'mediumDate';
    format = $locale.DATETIME_FORMATS[format] || format;
    if (isString(date)) {
        date = NUMBER_STRING.test(date) ? toInt(date) : jsonStringToDate(date);
    }
    if (isNumber(date)) {
        date = new Date(date);
    }
    if (!isDate(date) || !isFinite(date.getTime())) {
        return date;
    }
    while (format) {
        match = DATE_FORMATS_SPLIT.exec(format);
        if (match) {
            parts = concat(parts, match, 1);
            format = parts.pop();
        } else {
            parts.push(format);
            format = null;
        }
    }
    var dateTimezoneOffset = date.getTimezoneOffset();
    if (timezone) {
        dateTimezoneOffset = timezoneToOffset(timezone, dateTimezoneOffset);
        date = convertTimezoneToLocal(date, timezone, true);
    }
    forEach(parts, function (value) {
        fn = DATE_FORMATS[value];
        text += fn ? fn(date, $locale.DATETIME_FORMATS, dateTimezoneOffset) : value === '\'\'' ? '\'' : value.replace(/(^'|'$)/g, '').replace(/''/g, '\'');
    });
    return text;
};});
    jsonFilter = ($__.fs.jsonFilter_231 = function jsonFilter() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return function (object, spacing) {
    if (isUndefined(spacing)) {
        spacing = 2;
    }
    return toJson(object, spacing);
};});
    limitToFilter = ($__.fs.limitToFilter_232 = function limitToFilter() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return function (input, limit, begin) {
    if (Math.abs(Number(limit)) === Infinity) {
        limit = Number(limit);
    } else {
        limit = toInt(limit);
    }
    if (isNumberNaN(limit))
        return input;
    if (isNumber(input))
        input = input.toString();
    if (!isArrayLike(input))
        return input;
    begin = !begin || isNaN(begin) ? 0 : toInt(begin);
    begin = begin < 0 ? Math.max(0, input.length + begin) : begin;
    if (limit >= 0) {
        return sliceFn(input, begin, begin + limit);
    } else {
        if (begin === 0) {
            return sliceFn(input, limit, input.length);
        } else {
            return sliceFn(input, Math.max(0, begin + limit), begin);
        }
    }
};});
    sliceFn = ($__.fs.sliceFn_233 = function sliceFn(input, begin, end) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
input = arguments[0], begin = arguments[1], end = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (isString(input))
    return input.slice(begin, end);
return slice.call(input, begin, end);});
    orderByFilter = ($__.fs.orderByFilter_234 = function orderByFilter($parse) {
var vvv_return, vvv_switch, processPredicates, isPrimitive, objectValue, getPredicateValue, defaultCompare;
processPredicates = function processPredicates(sortPredicates) {
    return sortPredicates.map(function (predicate) {
        var descending = 1, get = identity;
        if (isFunction(predicate)) {
            get = predicate;
        } else if (isString(predicate)) {
            if (predicate.charAt(0) === '+' || predicate.charAt(0) === '-') {
                descending = predicate.charAt(0) === '-' ? -1 : 1;
                predicate = predicate.substring(1);
            }
            if (predicate !== '') {
                get = $parse(predicate);
                if (get.constant) {
                    var key = get();
                    get = function (value) {
                        return value[key];
                    };
                }
            }
        }
        return {
            get: get,
            descending: descending
        };
    });
};
isPrimitive = function isPrimitive(value) {
    switch (typeof value) {
    case 'number':
    case 'boolean':
    case 'string':
        return true;
    default:
        return false;
    }
};
objectValue = function objectValue(value) {
    if (isFunction(value.valueOf)) {
        value = value.valueOf();
        if (isPrimitive(value))
            return value;
    }
    if (hasCustomToString(value)) {
        value = value.toString();
        if (isPrimitive(value))
            return value;
    }
    return value;
};
getPredicateValue = function getPredicateValue(value, index) {
    var type = typeof value;
    if (value === null) {
        type = 'string';
        value = 'null';
    } else if (type === 'object') {
        value = objectValue(value);
    }
    return {
        value: value,
        type: type,
        index: index
    };
};
defaultCompare = function defaultCompare(v1, v2) {
    var result = 0;
    var type1 = v1.type;
    var type2 = v2.type;
    if (type1 === type2) {
        var value1 = v1.value;
        var value2 = v2.value;
        if (type1 === 'string') {
            value1 = value1.toLowerCase();
            value2 = value2.toLowerCase();
        } else if (type1 === 'object') {
            if (isObject(value1))
                value1 = v1.index;
            if (isObject(value2))
                value2 = v2.index;
        }
        if (value1 !== value2) {
            result = value1 < value2 ? -1 : 1;
        }
    } else {
        result = type1 < type2 ? -1 : 1;
    }
    return result;
};
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
$parse = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return function (array, sortPredicate, reverseOrder, compareFn) {
    if (array == null)
        return array;
    if (!isArrayLike(array)) {
        throw minErr('orderBy')('notarray', 'Expected array but received: {0}', array);
    }
    if (!isArray(sortPredicate)) {
        sortPredicate = [sortPredicate];
    }
    if (sortPredicate.length === 0) {
        sortPredicate = ['+'];
    }
    var predicates = processPredicates(sortPredicate);
    var descending = reverseOrder ? -1 : 1;
    var compare = isFunction(compareFn) ? compareFn : defaultCompare;
    var compareValues = Array.prototype.map.call(array, getComparisonObject);
    compareValues.sort(doComparison);
    array = compareValues.map(function (item) {
        return item.value;
    });
    return array;
    function getComparisonObject(value, index) {
        return {
            value: value,
            tieBreaker: {
                value: index,
                type: 'number',
                index: index
            },
            predicateValues: predicates.map(function (predicate) {
                return getPredicateValue(predicate.get(value), index);
            })
        };
    }
    function doComparison(v1, v2) {
        for (var i = 0, ii = predicates.length; i < ii; i++) {
            var result = compare(v1.predicateValues[i], v2.predicateValues[i]);
            if (result) {
                return result * predicates[i].descending * descending;
            }
        }
        return compare(v1.tieBreaker, v2.tieBreaker) * descending;
    }
};});
    ngDirective = ($__.fs.ngDirective_235 = function ngDirective(directive) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
directive = arguments[0];
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    (isFunction, $__.fs.isFunction_29)(directive, 11, true, $__.uid);
    (directive, $__.os.oid38).restrict = (TAJS_restrictToType((directive, $__.os.oid38).restrict, 'undefined'), 'AC');
    return (valueFn, $__.fs.valueFn_20)(directive, 4, true, $__.uid);
case 1:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 1);
    (isFunction, $__.fs.isFunction_29)(directive, 13, true, $__.uid);
    (directive, $__.os.oid41).restrict = (TAJS_restrictToType((directive, $__.os.oid41).restrict, 'undefined'), 'AC');
    return (valueFn, $__.fs.valueFn_20)(directive, 5, true, $__.uid);
case 2:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 2);
    (isFunction, $__.fs.isFunction_29)(directive, 14, true, $__.uid);
    (directive, $__.os.oid46).restrict = (TAJS_restrictToType((directive, $__.os.oid46).restrict, 'undefined'), 'AC');
    return (valueFn, $__.fs.valueFn_20)(directive, 6, true, $__.uid);
case 3:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 3);
    (isFunction, $__.fs.isFunction_29)((directive, $__.fs.J$__v3645318688_2282_657), 15, true, $__.uid);
    directive = $__.os.oid47 = {
        'link': directive
    };
    (directive, $__.os.oid47).restrict = (TAJS_restrictToType((directive, $__.os.oid47).restrict, 'undefined'), 'AC');
    return (valueFn, $__.fs.valueFn_20)(directive, 7, true, $__.uid);
case 4:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 4);
    (isFunction, $__.fs.isFunction_29)(directive, 16, true, $__.uid);
    (directive, $__.os.oid48).restrict = (TAJS_restrictToType((directive, $__.os.oid48).restrict, 'undefined'), 'AC');
    return (valueFn, $__.fs.valueFn_20)(directive, 8, true, $__.uid);
case 5:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 5);
    (isFunction, $__.fs.isFunction_29)(directive, 17, true, $__.uid);
    (directive, $__.os.oid49).restrict = (TAJS_restrictToType((directive, $__.os.oid49).restrict, 'undefined'), 'AC');
    return (valueFn, $__.fs.valueFn_20)(directive, 9, true, $__.uid);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (isFunction(directive)) {
    directive = {
        link: directive
    };
}
directive.restrict = directive.restrict || 'AC';
return valueFn(directive);});
    nullFormRenameControl = ($__.fs.nullFormRenameControl_236 = function nullFormRenameControl(control, name) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
control = arguments[0], name = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
control.$name = name;});
    FormController = ($__.fs.FormController_237 = function FormController($element, $attrs, $scope, $animate, $interpolate) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
$element = arguments[0], $attrs = arguments[1], $scope = arguments[2], $animate = arguments[3], $interpolate = arguments[4];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.$$controls = [];
this.$error = {};
this.$$success = {};
this.$pending = undefined;
this.$name = $interpolate($attrs.name || $attrs.ngForm || '')($scope);
this.$dirty = false;
this.$pristine = true;
this.$valid = true;
this.$invalid = false;
this.$submitted = false;
this.$$parentForm = nullFormCtrl;
this.$$element = $element;
this.$$animate = $animate;
setupValidity(this);});
    setupValidity = ($__.fs.setupValidity_238 = function setupValidity(instance) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
instance = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
instance.$$classCache = {};
instance.$$classCache[INVALID_CLASS] = !(instance.$$classCache[VALID_CLASS] = instance.$$element.hasClass(VALID_CLASS));});
    addSetValidityMethod = ($__.fs.addSetValidityMethod_239 = function addSetValidityMethod(context) {
var vvv_return, vvv_switch, clazz, set, unset, createAndSet, unsetAndCleanup, cachedToggleClass, toggleValidationCss;
createAndSet = function createAndSet(ctrl, name, value, controller) {
    if (!ctrl[name]) {
        ctrl[name] = {};
    }
    set(ctrl[name], value, controller);
};
unsetAndCleanup = function unsetAndCleanup(ctrl, name, value, controller) {
    if (ctrl[name]) {
        unset(ctrl[name], value, controller);
    }
    if (isObjectEmpty(ctrl[name])) {
        ctrl[name] = undefined;
    }
};
cachedToggleClass = function cachedToggleClass(ctrl, className, switchValue) {
    if (switchValue && !ctrl.$$classCache[className]) {
        ctrl.$$animate.addClass(ctrl.$$element, className);
        ctrl.$$classCache[className] = true;
    } else if (!switchValue && ctrl.$$classCache[className]) {
        ctrl.$$animate.removeClass(ctrl.$$element, className);
        ctrl.$$classCache[className] = false;
    }
};
toggleValidationCss = function toggleValidationCss(ctrl, validationErrorKey, isValid) {
    validationErrorKey = validationErrorKey ? '-' + snake_case(validationErrorKey, '-') : '';
    cachedToggleClass(ctrl, VALID_CLASS + validationErrorKey, isValid === true);
    cachedToggleClass(ctrl, INVALID_CLASS + validationErrorKey, isValid === false);
};
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
context = arguments[0];
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    createAndSet = ($__.fs.createAndSet_554 = function createAndSet(ctrl, name, value, controller) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
ctrl = arguments[0], name = arguments[1], value = arguments[2], controller = arguments[3];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (!ctrl[name]) {
    ctrl[name] = {};
}
set(ctrl[name], value, controller);});
    unsetAndCleanup = ($__.fs.unsetAndCleanup_555 = function unsetAndCleanup(ctrl, name, value, controller) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
ctrl = arguments[0], name = arguments[1], value = arguments[2], controller = arguments[3];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (ctrl[name]) {
    unset(ctrl[name], value, controller);
}
if (isObjectEmpty(ctrl[name])) {
    ctrl[name] = undefined;
}});
    cachedToggleClass = ($__.fs.cachedToggleClass_556 = function cachedToggleClass(ctrl, className, switchValue) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
ctrl = arguments[0], className = arguments[1], switchValue = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (switchValue && !ctrl.$$classCache[className]) {
    ctrl.$$animate.addClass(ctrl.$$element, className);
    ctrl.$$classCache[className] = true;
} else if (!switchValue && ctrl.$$classCache[className]) {
    ctrl.$$animate.removeClass(ctrl.$$element, className);
    ctrl.$$classCache[className] = false;
}});
    toggleValidationCss = ($__.fs.toggleValidationCss_557 = function toggleValidationCss(ctrl, validationErrorKey, isValid) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
ctrl = arguments[0], validationErrorKey = arguments[1], isValid = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
validationErrorKey = validationErrorKey ? '-' + snake_case(validationErrorKey, '-') : '';
cachedToggleClass(ctrl, VALID_CLASS + validationErrorKey, isValid === true);
cachedToggleClass(ctrl, INVALID_CLASS + validationErrorKey, isValid === false);});
    clazz = TAJS_restrictToType((context, $__.os.oid35).clazz, 'function');
    set = TAJS_restrictToType((context, $__.os.oid35).set, 'function');
    unset = TAJS_restrictToType((context, $__.os.oid35).unset, 'function');
    ((clazz.prototype, $__.os.oid34), $__.os.oid34).$setValidity = ($__.fs.J$__v3645318688_1845_558 = function J$__v3645318688_1845(validationErrorKey, state, controller) {
var vvv_return, vvv_switch, combinedState;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
validationErrorKey = arguments[0], state = arguments[1], controller = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (isUndefined(state)) {
    createAndSet(this, '$pending', validationErrorKey, controller);
} else {
    unsetAndCleanup(this, '$pending', validationErrorKey, controller);
}
if (!isBoolean(state)) {
    unset(this.$error, validationErrorKey, controller);
    unset(this.$$success, validationErrorKey, controller);
} else {
    if (state) {
        unset(this.$error, validationErrorKey, controller);
        set(this.$$success, validationErrorKey, controller);
    } else {
        set(this.$error, validationErrorKey, controller);
        unset(this.$$success, validationErrorKey, controller);
    }
}
if (this.$pending) {
    cachedToggleClass(this, PENDING_CLASS, true);
    this.$valid = this.$invalid = undefined;
    toggleValidationCss(this, '', null);
} else {
    cachedToggleClass(this, PENDING_CLASS, false);
    this.$valid = isObjectEmpty(this.$error);
    this.$invalid = !this.$valid;
    toggleValidationCss(this, '', this.$valid);
}
if (this.$pending && this.$pending[validationErrorKey]) {
    combinedState = undefined;
} else if (this.$error[validationErrorKey]) {
    combinedState = false;
} else if (this.$$success[validationErrorKey]) {
    combinedState = true;
} else {
    combinedState = null;
}
toggleValidationCss(this, validationErrorKey, combinedState);
this.$$parentForm.$setValidity(validationErrorKey, combinedState, this);});
    return;
case 1:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 1);
    createAndSet = ($__.fs.createAndSet_641 = function createAndSet(ctrl, name, value, controller) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
ctrl = arguments[0], name = arguments[1], value = arguments[2], controller = arguments[3];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (!ctrl[name]) {
    ctrl[name] = {};
}
set(ctrl[name], value, controller);});
    unsetAndCleanup = ($__.fs.unsetAndCleanup_642 = function unsetAndCleanup(ctrl, name, value, controller) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
ctrl = arguments[0], name = arguments[1], value = arguments[2], controller = arguments[3];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (ctrl[name]) {
    unset(ctrl[name], value, controller);
}
if (isObjectEmpty(ctrl[name])) {
    ctrl[name] = undefined;
}});
    cachedToggleClass = ($__.fs.cachedToggleClass_643 = function cachedToggleClass(ctrl, className, switchValue) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
ctrl = arguments[0], className = arguments[1], switchValue = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (switchValue && !ctrl.$$classCache[className]) {
    ctrl.$$animate.addClass(ctrl.$$element, className);
    ctrl.$$classCache[className] = true;
} else if (!switchValue && ctrl.$$classCache[className]) {
    ctrl.$$animate.removeClass(ctrl.$$element, className);
    ctrl.$$classCache[className] = false;
}});
    toggleValidationCss = ($__.fs.toggleValidationCss_644 = function toggleValidationCss(ctrl, validationErrorKey, isValid) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
ctrl = arguments[0], validationErrorKey = arguments[1], isValid = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
validationErrorKey = validationErrorKey ? '-' + snake_case(validationErrorKey, '-') : '';
cachedToggleClass(ctrl, VALID_CLASS + validationErrorKey, isValid === true);
cachedToggleClass(ctrl, INVALID_CLASS + validationErrorKey, isValid === false);});
    clazz = TAJS_restrictToType((context, $__.os.oid43).clazz, 'function');
    set = TAJS_restrictToType((context, $__.os.oid43).set, 'function');
    unset = TAJS_restrictToType((context, $__.os.oid43).unset, 'function');
    ((clazz.prototype, $__.os.oid42), $__.os.oid42).$setValidity = ($__.fs.J$__v3645318688_1845_645 = function J$__v3645318688_1845(validationErrorKey, state, controller) {
var vvv_return, vvv_switch, combinedState;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
validationErrorKey = arguments[0], state = arguments[1], controller = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (isUndefined(state)) {
    createAndSet(this, '$pending', validationErrorKey, controller);
} else {
    unsetAndCleanup(this, '$pending', validationErrorKey, controller);
}
if (!isBoolean(state)) {
    unset(this.$error, validationErrorKey, controller);
    unset(this.$$success, validationErrorKey, controller);
} else {
    if (state) {
        unset(this.$error, validationErrorKey, controller);
        set(this.$$success, validationErrorKey, controller);
    } else {
        set(this.$error, validationErrorKey, controller);
        unset(this.$$success, validationErrorKey, controller);
    }
}
if (this.$pending) {
    cachedToggleClass(this, PENDING_CLASS, true);
    this.$valid = this.$invalid = undefined;
    toggleValidationCss(this, '', null);
} else {
    cachedToggleClass(this, PENDING_CLASS, false);
    this.$valid = isObjectEmpty(this.$error);
    this.$invalid = !this.$valid;
    toggleValidationCss(this, '', this.$valid);
}
if (this.$pending && this.$pending[validationErrorKey]) {
    combinedState = undefined;
} else if (this.$error[validationErrorKey]) {
    combinedState = false;
} else if (this.$$success[validationErrorKey]) {
    combinedState = true;
} else {
    combinedState = null;
}
toggleValidationCss(this, validationErrorKey, combinedState);
this.$$parentForm.$setValidity(validationErrorKey, combinedState, this);});
    return;
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
clazz = context.clazz;
set = context.set;
unset = context.unset;
clazz.prototype.$setValidity = function (validationErrorKey, state, controller) {
    if (isUndefined(state)) {
        createAndSet(this, '$pending', validationErrorKey, controller);
    } else {
        unsetAndCleanup(this, '$pending', validationErrorKey, controller);
    }
    if (!isBoolean(state)) {
        unset(this.$error, validationErrorKey, controller);
        unset(this.$$success, validationErrorKey, controller);
    } else {
        if (state) {
            unset(this.$error, validationErrorKey, controller);
            set(this.$$success, validationErrorKey, controller);
        } else {
            set(this.$error, validationErrorKey, controller);
            unset(this.$$success, validationErrorKey, controller);
        }
    }
    if (this.$pending) {
        cachedToggleClass(this, PENDING_CLASS, true);
        this.$valid = this.$invalid = undefined;
        toggleValidationCss(this, '', null);
    } else {
        cachedToggleClass(this, PENDING_CLASS, false);
        this.$valid = isObjectEmpty(this.$error);
        this.$invalid = !this.$valid;
        toggleValidationCss(this, '', this.$valid);
    }
    var combinedState;
    if (this.$pending && this.$pending[validationErrorKey]) {
        combinedState = undefined;
    } else if (this.$error[validationErrorKey]) {
        combinedState = false;
    } else if (this.$$success[validationErrorKey]) {
        combinedState = true;
    } else {
        combinedState = null;
    }
    toggleValidationCss(this, validationErrorKey, combinedState);
    this.$$parentForm.$setValidity(validationErrorKey, combinedState, this);
};});
    isObjectEmpty = ($__.fs.isObjectEmpty_240 = function isObjectEmpty(obj) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
obj = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (obj) {
    for (var prop in obj) {
        if (obj.hasOwnProperty(prop)) {
            return false;
        }
    }
}
return true;});
    stringBasedInputType = ($__.fs.stringBasedInputType_241 = function stringBasedInputType(ctrl) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
ctrl = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
ctrl.$formatters.push(function (value) {
    return ctrl.$isEmpty(value) ? value : value.toString();
});});
    textInputType = ($__.fs.textInputType_242 = function textInputType(scope, element, attr, ctrl, $sniffer, $browser) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
scope = arguments[0], element = arguments[1], attr = arguments[2], ctrl = arguments[3], $sniffer = arguments[4], $browser = arguments[5];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
stringBasedInputType(ctrl);});
    baseInputType = ($__.fs.baseInputType_243 = function baseInputType(scope, element, attr, ctrl, $sniffer, $browser) {
var vvv_return, vvv_switch, type, composing, timeout, listener, deferListener;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
scope = arguments[0], element = arguments[1], attr = arguments[2], ctrl = arguments[3], $sniffer = arguments[4], $browser = arguments[5];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
type = lowercase(element[0].type);
if (!$sniffer.android) {
    composing = false;
    element.on('compositionstart', function () {
        composing = true;
    });
    element.on('compositionend', function () {
        composing = false;
        listener();
    });
}
listener = function (ev) {
    if (timeout) {
        $browser.defer.cancel(timeout);
        timeout = null;
    }
    if (composing)
        return;
    var value = element.val(), event = ev && ev.type;
    if (type !== 'password' && (!attr.ngTrim || attr.ngTrim !== 'false')) {
        value = trim(value);
    }
    if (ctrl.$viewValue !== value || value === '' && ctrl.$$hasNativeValidators) {
        ctrl.$setViewValue(value, event);
    }
};
if ($sniffer.hasEvent('input')) {
    element.on('input', listener);
} else {
    deferListener = function (ev, input, origValue) {
        if (!timeout) {
            timeout = $browser.defer(function () {
                timeout = null;
                if (!input || input.value !== origValue) {
                    listener(ev);
                }
            });
        }
    };
    element.on('keydown', function (event) {
        var key = event.keyCode;
        if (key === 91 || 15 < key && key < 19 || 37 <= key && key <= 40)
            return;
        deferListener(event, this, this.value);
    });
    if ($sniffer.hasEvent('paste')) {
        element.on('paste cut', deferListener);
    }
}
element.on('change', listener);
if (PARTIAL_VALIDATION_TYPES[type] && ctrl.$$hasNativeValidators && type === attr.type) {
    element.on(PARTIAL_VALIDATION_EVENTS, function (ev) {
        if (!timeout) {
            var validity = this[VALIDITY_STATE_PROPERTY];
            var origBadInput = validity.badInput;
            var origTypeMismatch = validity.typeMismatch;
            timeout = $browser.defer(function () {
                timeout = null;
                if (validity.badInput !== origBadInput || validity.typeMismatch !== origTypeMismatch) {
                    listener(ev);
                }
            });
        }
    });
}
ctrl.$render = function () {
    var value = ctrl.$isEmpty(ctrl.$viewValue) ? '' : ctrl.$viewValue;
    if (element.val() !== value) {
        element.val(value);
    }
};});
    weekParser = ($__.fs.weekParser_244 = function weekParser(isoWeek, existingDate) {
var vvv_return, vvv_switch, parts, year, week, hours, minutes, seconds, milliseconds, firstThurs, addDays;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
isoWeek = arguments[0], existingDate = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (isDate(isoWeek)) {
    return isoWeek;
}
if (isString(isoWeek)) {
    WEEK_REGEXP.lastIndex = 0;
    parts = WEEK_REGEXP.exec(isoWeek);
    if (parts) {
        year = +parts[1];
        week = +parts[2];
        hours = 0;
        minutes = 0;
        seconds = 0;
        milliseconds = 0;
        firstThurs = getFirstThursdayOfYear(year);
        addDays = (week - 1) * 7;
        if (existingDate) {
            hours = existingDate.getHours();
            minutes = existingDate.getMinutes();
            seconds = existingDate.getSeconds();
            milliseconds = existingDate.getMilliseconds();
        }
        return new Date(year, 0, firstThurs.getDate() + addDays, hours, minutes, seconds, milliseconds);
    }
}
return NaN;});
    createDateParser = ($__.fs.createDateParser_245 = function createDateParser(regexp, mapping) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
regexp = arguments[0], mapping = arguments[1];
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    return ($__.fs.J$__v3645318688_1881_563 = function J$__v3645318688_1881(iso, date) {
var vvv_return, vvv_switch, parts, map;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
iso = arguments[0], date = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (isDate(iso)) {
    return iso;
}
if (isString(iso)) {
    if (iso.charAt(0) === '"' && iso.charAt(iso.length - 1) === '"') {
        iso = iso.substring(1, iso.length - 1);
    }
    if (ISO_DATE_REGEXP.test(iso)) {
        return new Date(iso);
    }
    regexp.lastIndex = 0;
    parts = regexp.exec(iso);
    if (parts) {
        parts.shift();
        if (date) {
            map = {
                yyyy: date.getFullYear(),
                MM: date.getMonth() + 1,
                dd: date.getDate(),
                HH: date.getHours(),
                mm: date.getMinutes(),
                ss: date.getSeconds(),
                sss: date.getMilliseconds() / 1000
            };
        } else {
            map = {
                yyyy: 1970,
                MM: 1,
                dd: 1,
                HH: 0,
                mm: 0,
                ss: 0,
                sss: 0
            };
        }
        forEach(parts, function (part, index) {
            if (index < mapping.length) {
                map[mapping[index]] = +part;
            }
        });
        return new Date(map.yyyy, map.MM - 1, map.dd, map.HH, map.mm, map.ss || 0, map.sss * 1000 || 0);
    }
}
return NaN;});
case 1:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 1);
    return ($__.fs.J$__v3645318688_1881_565 = function J$__v3645318688_1881(iso, date) {
var vvv_return, vvv_switch, parts, map;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
iso = arguments[0], date = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (isDate(iso)) {
    return iso;
}
if (isString(iso)) {
    if (iso.charAt(0) === '"' && iso.charAt(iso.length - 1) === '"') {
        iso = iso.substring(1, iso.length - 1);
    }
    if (ISO_DATE_REGEXP.test(iso)) {
        return new Date(iso);
    }
    regexp.lastIndex = 0;
    parts = regexp.exec(iso);
    if (parts) {
        parts.shift();
        if (date) {
            map = {
                yyyy: date.getFullYear(),
                MM: date.getMonth() + 1,
                dd: date.getDate(),
                HH: date.getHours(),
                mm: date.getMinutes(),
                ss: date.getSeconds(),
                sss: date.getMilliseconds() / 1000
            };
        } else {
            map = {
                yyyy: 1970,
                MM: 1,
                dd: 1,
                HH: 0,
                mm: 0,
                ss: 0,
                sss: 0
            };
        }
        forEach(parts, function (part, index) {
            if (index < mapping.length) {
                map[mapping[index]] = +part;
            }
        });
        return new Date(map.yyyy, map.MM - 1, map.dd, map.HH, map.mm, map.ss || 0, map.sss * 1000 || 0);
    }
}
return NaN;});
case 2:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 2);
    return ($__.fs.J$__v3645318688_1881_567 = function J$__v3645318688_1881(iso, date) {
var vvv_return, vvv_switch, parts, map;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
iso = arguments[0], date = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (isDate(iso)) {
    return iso;
}
if (isString(iso)) {
    if (iso.charAt(0) === '"' && iso.charAt(iso.length - 1) === '"') {
        iso = iso.substring(1, iso.length - 1);
    }
    if (ISO_DATE_REGEXP.test(iso)) {
        return new Date(iso);
    }
    regexp.lastIndex = 0;
    parts = regexp.exec(iso);
    if (parts) {
        parts.shift();
        if (date) {
            map = {
                yyyy: date.getFullYear(),
                MM: date.getMonth() + 1,
                dd: date.getDate(),
                HH: date.getHours(),
                mm: date.getMinutes(),
                ss: date.getSeconds(),
                sss: date.getMilliseconds() / 1000
            };
        } else {
            map = {
                yyyy: 1970,
                MM: 1,
                dd: 1,
                HH: 0,
                mm: 0,
                ss: 0,
                sss: 0
            };
        }
        forEach(parts, function (part, index) {
            if (index < mapping.length) {
                map[mapping[index]] = +part;
            }
        });
        return new Date(map.yyyy, map.MM - 1, map.dd, map.HH, map.mm, map.ss || 0, map.sss * 1000 || 0);
    }
}
return NaN;});
case 3:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 3);
    return ($__.fs.J$__v3645318688_1881_570 = function J$__v3645318688_1881(iso, date) {
var vvv_return, vvv_switch, parts, map;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
iso = arguments[0], date = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (isDate(iso)) {
    return iso;
}
if (isString(iso)) {
    if (iso.charAt(0) === '"' && iso.charAt(iso.length - 1) === '"') {
        iso = iso.substring(1, iso.length - 1);
    }
    if (ISO_DATE_REGEXP.test(iso)) {
        return new Date(iso);
    }
    regexp.lastIndex = 0;
    parts = regexp.exec(iso);
    if (parts) {
        parts.shift();
        if (date) {
            map = {
                yyyy: date.getFullYear(),
                MM: date.getMonth() + 1,
                dd: date.getDate(),
                HH: date.getHours(),
                mm: date.getMinutes(),
                ss: date.getSeconds(),
                sss: date.getMilliseconds() / 1000
            };
        } else {
            map = {
                yyyy: 1970,
                MM: 1,
                dd: 1,
                HH: 0,
                mm: 0,
                ss: 0,
                sss: 0
            };
        }
        forEach(parts, function (part, index) {
            if (index < mapping.length) {
                map[mapping[index]] = +part;
            }
        });
        return new Date(map.yyyy, map.MM - 1, map.dd, map.HH, map.mm, map.ss || 0, map.sss * 1000 || 0);
    }
}
return NaN;});
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return function (iso, date) {
    var parts, map;
    if (isDate(iso)) {
        return iso;
    }
    if (isString(iso)) {
        if (iso.charAt(0) === '"' && iso.charAt(iso.length - 1) === '"') {
            iso = iso.substring(1, iso.length - 1);
        }
        if (ISO_DATE_REGEXP.test(iso)) {
            return new Date(iso);
        }
        regexp.lastIndex = 0;
        parts = regexp.exec(iso);
        if (parts) {
            parts.shift();
            if (date) {
                map = {
                    yyyy: date.getFullYear(),
                    MM: date.getMonth() + 1,
                    dd: date.getDate(),
                    HH: date.getHours(),
                    mm: date.getMinutes(),
                    ss: date.getSeconds(),
                    sss: date.getMilliseconds() / 1000
                };
            } else {
                map = {
                    yyyy: 1970,
                    MM: 1,
                    dd: 1,
                    HH: 0,
                    mm: 0,
                    ss: 0,
                    sss: 0
                };
            }
            forEach(parts, function (part, index) {
                if (index < mapping.length) {
                    map[mapping[index]] = +part;
                }
            });
            return new Date(map.yyyy, map.MM - 1, map.dd, map.HH, map.mm, map.ss || 0, map.sss * 1000 || 0);
        }
    }
    return NaN;
};});
    createDateInputType = ($__.fs.createDateInputType_246 = function createDateInputType(type, regexp, parseDate, format) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
type = arguments[0], regexp = arguments[1], parseDate = arguments[2], format = arguments[3];
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    return ($__.fs.dynamicDateInputType_564 = function dynamicDateInputType(scope, element, attr, ctrl, $sniffer, $browser, $filter) {
var vvv_return, vvv_switch, timezone, previousDate, minVal, maxVal, isValidDate, parseObservedDateValue;
isValidDate = function isValidDate(value) {
    return value && !(value.getTime && value.getTime() !== value.getTime());
};
parseObservedDateValue = function parseObservedDateValue(val) {
    return isDefined(val) && !isDate(val) ? parseDate(val) || undefined : val;
};
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
scope = arguments[0], element = arguments[1], attr = arguments[2], ctrl = arguments[3], $sniffer = arguments[4], $browser = arguments[5], $filter = arguments[6];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
badInputChecker(scope, element, attr, ctrl);
baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
timezone = ctrl && ctrl.$options.getOption('timezone');
ctrl.$$parserName = type;
ctrl.$parsers.push(function (value) {
    if (ctrl.$isEmpty(value))
        return null;
    if (regexp.test(value)) {
        var parsedDate = parseDate(value, previousDate);
        if (timezone) {
            parsedDate = convertTimezoneToLocal(parsedDate, timezone);
        }
        return parsedDate;
    }
    return undefined;
});
ctrl.$formatters.push(function (value) {
    if (value && !isDate(value)) {
        throw ngModelMinErr('datefmt', 'Expected `{0}` to be a date', value);
    }
    if (isValidDate(value)) {
        previousDate = value;
        if (previousDate && timezone) {
            previousDate = convertTimezoneToLocal(previousDate, timezone, true);
        }
        return $filter('date')(value, format, timezone);
    } else {
        previousDate = null;
        return '';
    }
});
if (isDefined(attr.min) || attr.ngMin) {
    ctrl.$validators.min = function (value) {
        return !isValidDate(value) || isUndefined(minVal) || parseDate(value) >= minVal;
    };
    attr.$observe('min', function (val) {
        minVal = parseObservedDateValue(val);
        ctrl.$validate();
    });
}
if (isDefined(attr.max) || attr.ngMax) {
    ctrl.$validators.max = function (value) {
        return !isValidDate(value) || isUndefined(maxVal) || parseDate(value) <= maxVal;
    };
    attr.$observe('max', function (val) {
        maxVal = parseObservedDateValue(val);
        ctrl.$validate();
    });
}});
case 1:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 1);
    return ($__.fs.dynamicDateInputType_566 = function dynamicDateInputType(scope, element, attr, ctrl, $sniffer, $browser, $filter) {
var vvv_return, vvv_switch, timezone, previousDate, minVal, maxVal, isValidDate, parseObservedDateValue;
isValidDate = function isValidDate(value) {
    return value && !(value.getTime && value.getTime() !== value.getTime());
};
parseObservedDateValue = function parseObservedDateValue(val) {
    return isDefined(val) && !isDate(val) ? parseDate(val) || undefined : val;
};
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
scope = arguments[0], element = arguments[1], attr = arguments[2], ctrl = arguments[3], $sniffer = arguments[4], $browser = arguments[5], $filter = arguments[6];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
badInputChecker(scope, element, attr, ctrl);
baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
timezone = ctrl && ctrl.$options.getOption('timezone');
ctrl.$$parserName = type;
ctrl.$parsers.push(function (value) {
    if (ctrl.$isEmpty(value))
        return null;
    if (regexp.test(value)) {
        var parsedDate = parseDate(value, previousDate);
        if (timezone) {
            parsedDate = convertTimezoneToLocal(parsedDate, timezone);
        }
        return parsedDate;
    }
    return undefined;
});
ctrl.$formatters.push(function (value) {
    if (value && !isDate(value)) {
        throw ngModelMinErr('datefmt', 'Expected `{0}` to be a date', value);
    }
    if (isValidDate(value)) {
        previousDate = value;
        if (previousDate && timezone) {
            previousDate = convertTimezoneToLocal(previousDate, timezone, true);
        }
        return $filter('date')(value, format, timezone);
    } else {
        previousDate = null;
        return '';
    }
});
if (isDefined(attr.min) || attr.ngMin) {
    ctrl.$validators.min = function (value) {
        return !isValidDate(value) || isUndefined(minVal) || parseDate(value) >= minVal;
    };
    attr.$observe('min', function (val) {
        minVal = parseObservedDateValue(val);
        ctrl.$validate();
    });
}
if (isDefined(attr.max) || attr.ngMax) {
    ctrl.$validators.max = function (value) {
        return !isValidDate(value) || isUndefined(maxVal) || parseDate(value) <= maxVal;
    };
    attr.$observe('max', function (val) {
        maxVal = parseObservedDateValue(val);
        ctrl.$validate();
    });
}});
case 2:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 2);
    return ($__.fs.dynamicDateInputType_568 = function dynamicDateInputType(scope, element, attr, ctrl, $sniffer, $browser, $filter) {
var vvv_return, vvv_switch, timezone, previousDate, minVal, maxVal, isValidDate, parseObservedDateValue;
isValidDate = function isValidDate(value) {
    return value && !(value.getTime && value.getTime() !== value.getTime());
};
parseObservedDateValue = function parseObservedDateValue(val) {
    return isDefined(val) && !isDate(val) ? parseDate(val) || undefined : val;
};
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
scope = arguments[0], element = arguments[1], attr = arguments[2], ctrl = arguments[3], $sniffer = arguments[4], $browser = arguments[5], $filter = arguments[6];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
badInputChecker(scope, element, attr, ctrl);
baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
timezone = ctrl && ctrl.$options.getOption('timezone');
ctrl.$$parserName = type;
ctrl.$parsers.push(function (value) {
    if (ctrl.$isEmpty(value))
        return null;
    if (regexp.test(value)) {
        var parsedDate = parseDate(value, previousDate);
        if (timezone) {
            parsedDate = convertTimezoneToLocal(parsedDate, timezone);
        }
        return parsedDate;
    }
    return undefined;
});
ctrl.$formatters.push(function (value) {
    if (value && !isDate(value)) {
        throw ngModelMinErr('datefmt', 'Expected `{0}` to be a date', value);
    }
    if (isValidDate(value)) {
        previousDate = value;
        if (previousDate && timezone) {
            previousDate = convertTimezoneToLocal(previousDate, timezone, true);
        }
        return $filter('date')(value, format, timezone);
    } else {
        previousDate = null;
        return '';
    }
});
if (isDefined(attr.min) || attr.ngMin) {
    ctrl.$validators.min = function (value) {
        return !isValidDate(value) || isUndefined(minVal) || parseDate(value) >= minVal;
    };
    attr.$observe('min', function (val) {
        minVal = parseObservedDateValue(val);
        ctrl.$validate();
    });
}
if (isDefined(attr.max) || attr.ngMax) {
    ctrl.$validators.max = function (value) {
        return !isValidDate(value) || isUndefined(maxVal) || parseDate(value) <= maxVal;
    };
    attr.$observe('max', function (val) {
        maxVal = parseObservedDateValue(val);
        ctrl.$validate();
    });
}});
case 3:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 3);
    return ($__.fs.dynamicDateInputType_569 = function dynamicDateInputType(scope, element, attr, ctrl, $sniffer, $browser, $filter) {
var vvv_return, vvv_switch, timezone, previousDate, minVal, maxVal, isValidDate, parseObservedDateValue;
isValidDate = function isValidDate(value) {
    return value && !(value.getTime && value.getTime() !== value.getTime());
};
parseObservedDateValue = function parseObservedDateValue(val) {
    return isDefined(val) && !isDate(val) ? parseDate(val) || undefined : val;
};
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
scope = arguments[0], element = arguments[1], attr = arguments[2], ctrl = arguments[3], $sniffer = arguments[4], $browser = arguments[5], $filter = arguments[6];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
badInputChecker(scope, element, attr, ctrl);
baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
timezone = ctrl && ctrl.$options.getOption('timezone');
ctrl.$$parserName = type;
ctrl.$parsers.push(function (value) {
    if (ctrl.$isEmpty(value))
        return null;
    if (regexp.test(value)) {
        var parsedDate = parseDate(value, previousDate);
        if (timezone) {
            parsedDate = convertTimezoneToLocal(parsedDate, timezone);
        }
        return parsedDate;
    }
    return undefined;
});
ctrl.$formatters.push(function (value) {
    if (value && !isDate(value)) {
        throw ngModelMinErr('datefmt', 'Expected `{0}` to be a date', value);
    }
    if (isValidDate(value)) {
        previousDate = value;
        if (previousDate && timezone) {
            previousDate = convertTimezoneToLocal(previousDate, timezone, true);
        }
        return $filter('date')(value, format, timezone);
    } else {
        previousDate = null;
        return '';
    }
});
if (isDefined(attr.min) || attr.ngMin) {
    ctrl.$validators.min = function (value) {
        return !isValidDate(value) || isUndefined(minVal) || parseDate(value) >= minVal;
    };
    attr.$observe('min', function (val) {
        minVal = parseObservedDateValue(val);
        ctrl.$validate();
    });
}
if (isDefined(attr.max) || attr.ngMax) {
    ctrl.$validators.max = function (value) {
        return !isValidDate(value) || isUndefined(maxVal) || parseDate(value) <= maxVal;
    };
    attr.$observe('max', function (val) {
        maxVal = parseObservedDateValue(val);
        ctrl.$validate();
    });
}});
case 4:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 4);
    return ($__.fs.dynamicDateInputType_571 = function dynamicDateInputType(scope, element, attr, ctrl, $sniffer, $browser, $filter) {
var vvv_return, vvv_switch, timezone, previousDate, minVal, maxVal, isValidDate, parseObservedDateValue;
isValidDate = function isValidDate(value) {
    return value && !(value.getTime && value.getTime() !== value.getTime());
};
parseObservedDateValue = function parseObservedDateValue(val) {
    return isDefined(val) && !isDate(val) ? parseDate(val) || undefined : val;
};
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
scope = arguments[0], element = arguments[1], attr = arguments[2], ctrl = arguments[3], $sniffer = arguments[4], $browser = arguments[5], $filter = arguments[6];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
badInputChecker(scope, element, attr, ctrl);
baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
timezone = ctrl && ctrl.$options.getOption('timezone');
ctrl.$$parserName = type;
ctrl.$parsers.push(function (value) {
    if (ctrl.$isEmpty(value))
        return null;
    if (regexp.test(value)) {
        var parsedDate = parseDate(value, previousDate);
        if (timezone) {
            parsedDate = convertTimezoneToLocal(parsedDate, timezone);
        }
        return parsedDate;
    }
    return undefined;
});
ctrl.$formatters.push(function (value) {
    if (value && !isDate(value)) {
        throw ngModelMinErr('datefmt', 'Expected `{0}` to be a date', value);
    }
    if (isValidDate(value)) {
        previousDate = value;
        if (previousDate && timezone) {
            previousDate = convertTimezoneToLocal(previousDate, timezone, true);
        }
        return $filter('date')(value, format, timezone);
    } else {
        previousDate = null;
        return '';
    }
});
if (isDefined(attr.min) || attr.ngMin) {
    ctrl.$validators.min = function (value) {
        return !isValidDate(value) || isUndefined(minVal) || parseDate(value) >= minVal;
    };
    attr.$observe('min', function (val) {
        minVal = parseObservedDateValue(val);
        ctrl.$validate();
    });
}
if (isDefined(attr.max) || attr.ngMax) {
    ctrl.$validators.max = function (value) {
        return !isValidDate(value) || isUndefined(maxVal) || parseDate(value) <= maxVal;
    };
    attr.$observe('max', function (val) {
        maxVal = parseObservedDateValue(val);
        ctrl.$validate();
    });
}});
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return function dynamicDateInputType(scope, element, attr, ctrl, $sniffer, $browser, $filter) {
    badInputChecker(scope, element, attr, ctrl);
    baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
    var timezone = ctrl && ctrl.$options.getOption('timezone');
    var previousDate;
    ctrl.$$parserName = type;
    ctrl.$parsers.push(function (value) {
        if (ctrl.$isEmpty(value))
            return null;
        if (regexp.test(value)) {
            var parsedDate = parseDate(value, previousDate);
            if (timezone) {
                parsedDate = convertTimezoneToLocal(parsedDate, timezone);
            }
            return parsedDate;
        }
        return undefined;
    });
    ctrl.$formatters.push(function (value) {
        if (value && !isDate(value)) {
            throw ngModelMinErr('datefmt', 'Expected `{0}` to be a date', value);
        }
        if (isValidDate(value)) {
            previousDate = value;
            if (previousDate && timezone) {
                previousDate = convertTimezoneToLocal(previousDate, timezone, true);
            }
            return $filter('date')(value, format, timezone);
        } else {
            previousDate = null;
            return '';
        }
    });
    if (isDefined(attr.min) || attr.ngMin) {
        var minVal;
        ctrl.$validators.min = function (value) {
            return !isValidDate(value) || isUndefined(minVal) || parseDate(value) >= minVal;
        };
        attr.$observe('min', function (val) {
            minVal = parseObservedDateValue(val);
            ctrl.$validate();
        });
    }
    if (isDefined(attr.max) || attr.ngMax) {
        var maxVal;
        ctrl.$validators.max = function (value) {
            return !isValidDate(value) || isUndefined(maxVal) || parseDate(value) <= maxVal;
        };
        attr.$observe('max', function (val) {
            maxVal = parseObservedDateValue(val);
            ctrl.$validate();
        });
    }
    function isValidDate(value) {
        return value && !(value.getTime && value.getTime() !== value.getTime());
    }
    function parseObservedDateValue(val) {
        return isDefined(val) && !isDate(val) ? parseDate(val) || undefined : val;
    }
};});
    badInputChecker = ($__.fs.badInputChecker_247 = function badInputChecker(scope, element, attr, ctrl) {
var vvv_return, vvv_switch, node, nativeValidation;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
scope = arguments[0], element = arguments[1], attr = arguments[2], ctrl = arguments[3];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
node = element[0];
nativeValidation = ctrl.$$hasNativeValidators = isObject(node.validity);
if (nativeValidation) {
    ctrl.$parsers.push(function (value) {
        var validity = element.prop(VALIDITY_STATE_PROPERTY) || {};
        return validity.badInput || validity.typeMismatch ? undefined : value;
    });
}});
    numberFormatterParser = ($__.fs.numberFormatterParser_248 = function numberFormatterParser(ctrl) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
ctrl = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
ctrl.$$parserName = 'number';
ctrl.$parsers.push(function (value) {
    if (ctrl.$isEmpty(value))
        return null;
    if (NUMBER_REGEXP.test(value))
        return parseFloat(value);
    return undefined;
});
ctrl.$formatters.push(function (value) {
    if (!ctrl.$isEmpty(value)) {
        if (!isNumber(value)) {
            throw ngModelMinErr('numfmt', 'Expected `{0}` to be a number', value);
        }
        value = value.toString();
    }
    return value;
});});
    parseNumberAttrVal = ($__.fs.parseNumberAttrVal_249 = function parseNumberAttrVal(val) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
val = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (isDefined(val) && !isNumber(val)) {
    val = parseFloat(val);
}
return !isNumberNaN(val) ? val : undefined;});
    isNumberInteger = ($__.fs.isNumberInteger_250 = function isNumberInteger(num) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
num = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return (num | 0) === num;});
    countDecimals = ($__.fs.countDecimals_251 = function countDecimals(num) {
var vvv_return, vvv_switch, numString, decimalSymbolIndex, match;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
num = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
numString = num.toString();
decimalSymbolIndex = numString.indexOf('.');
if (decimalSymbolIndex === -1) {
    if (-1 < num && num < 1) {
        match = /e-(\d+)$/.exec(numString);
        if (match) {
            return Number(match[1]);
        }
    }
    return 0;
}
return numString.length - decimalSymbolIndex - 1;});
    isValidForStep = ($__.fs.isValidForStep_252 = function isValidForStep(viewValue, stepBase, step) {
var vvv_return, vvv_switch, value, isNonIntegerValue, isNonIntegerStepBase, isNonIntegerStep, valueDecimals, stepBaseDecimals, stepDecimals, decimalCount, multiplier;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
viewValue = arguments[0], stepBase = arguments[1], step = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
value = Number(viewValue);
isNonIntegerValue = !isNumberInteger(value);
isNonIntegerStepBase = !isNumberInteger(stepBase);
isNonIntegerStep = !isNumberInteger(step);
if (isNonIntegerValue || isNonIntegerStepBase || isNonIntegerStep) {
    valueDecimals = isNonIntegerValue ? countDecimals(value) : 0;
    stepBaseDecimals = isNonIntegerStepBase ? countDecimals(stepBase) : 0;
    stepDecimals = isNonIntegerStep ? countDecimals(step) : 0;
    decimalCount = Math.max(valueDecimals, stepBaseDecimals, stepDecimals);
    multiplier = Math.pow(10, decimalCount);
    value = value * multiplier;
    stepBase = stepBase * multiplier;
    step = step * multiplier;
    if (isNonIntegerValue)
        value = Math.round(value);
    if (isNonIntegerStepBase)
        stepBase = Math.round(stepBase);
    if (isNonIntegerStep)
        step = Math.round(step);
}
return (value - stepBase) % step === 0;});
    numberInputType = ($__.fs.numberInputType_253 = function numberInputType(scope, element, attr, ctrl, $sniffer, $browser) {
var vvv_return, vvv_switch, minVal, maxVal, stepVal;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
scope = arguments[0], element = arguments[1], attr = arguments[2], ctrl = arguments[3], $sniffer = arguments[4], $browser = arguments[5];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
badInputChecker(scope, element, attr, ctrl);
numberFormatterParser(ctrl);
baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
if (isDefined(attr.min) || attr.ngMin) {
    ctrl.$validators.min = function (value) {
        return ctrl.$isEmpty(value) || isUndefined(minVal) || value >= minVal;
    };
    attr.$observe('min', function (val) {
        minVal = parseNumberAttrVal(val);
        ctrl.$validate();
    });
}
if (isDefined(attr.max) || attr.ngMax) {
    ctrl.$validators.max = function (value) {
        return ctrl.$isEmpty(value) || isUndefined(maxVal) || value <= maxVal;
    };
    attr.$observe('max', function (val) {
        maxVal = parseNumberAttrVal(val);
        ctrl.$validate();
    });
}
if (isDefined(attr.step) || attr.ngStep) {
    ctrl.$validators.step = function (modelValue, viewValue) {
        return ctrl.$isEmpty(viewValue) || isUndefined(stepVal) || isValidForStep(viewValue, minVal || 0, stepVal);
    };
    attr.$observe('step', function (val) {
        stepVal = parseNumberAttrVal(val);
        ctrl.$validate();
    });
}});
    rangeInputType = ($__.fs.rangeInputType_254 = function rangeInputType(scope, element, attr, ctrl, $sniffer, $browser) {
var vvv_return, vvv_switch, supportsRange, minVal, maxVal, stepVal, validity, hasMinAttr, hasMaxAttr, hasStepAttr, originalRender, setInitialValueAndObserver, minChange, maxChange, stepChange;
setInitialValueAndObserver = function setInitialValueAndObserver(htmlAttrName, changeFn) {
    element.attr(htmlAttrName, attr[htmlAttrName]);
    attr.$observe(htmlAttrName, changeFn);
};
minChange = function minChange(val) {
    minVal = parseNumberAttrVal(val);
    if (isNumberNaN(ctrl.$modelValue)) {
        return;
    }
    if (supportsRange) {
        var elVal = element.val();
        if (minVal > elVal) {
            elVal = minVal;
            element.val(elVal);
        }
        ctrl.$setViewValue(elVal);
    } else {
        ctrl.$validate();
    }
};
maxChange = function maxChange(val) {
    maxVal = parseNumberAttrVal(val);
    if (isNumberNaN(ctrl.$modelValue)) {
        return;
    }
    if (supportsRange) {
        var elVal = element.val();
        if (maxVal < elVal) {
            element.val(maxVal);
            elVal = maxVal < minVal ? minVal : maxVal;
        }
        ctrl.$setViewValue(elVal);
    } else {
        ctrl.$validate();
    }
};
stepChange = function stepChange(val) {
    stepVal = parseNumberAttrVal(val);
    if (isNumberNaN(ctrl.$modelValue)) {
        return;
    }
    if (supportsRange && ctrl.$viewValue !== element.val()) {
        ctrl.$setViewValue(element.val());
    } else {
        ctrl.$validate();
    }
};
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
scope = arguments[0], element = arguments[1], attr = arguments[2], ctrl = arguments[3], $sniffer = arguments[4], $browser = arguments[5];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
badInputChecker(scope, element, attr, ctrl);
numberFormatterParser(ctrl);
baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
supportsRange = ctrl.$$hasNativeValidators && element[0].type === 'range';
minVal = supportsRange ? 0 : undefined;
maxVal = supportsRange ? 100 : undefined;
stepVal = supportsRange ? 1 : undefined;
validity = element[0].validity;
hasMinAttr = isDefined(attr.min);
hasMaxAttr = isDefined(attr.max);
hasStepAttr = isDefined(attr.step);
originalRender = ctrl.$render;
ctrl.$render = supportsRange && isDefined(validity.rangeUnderflow) && isDefined(validity.rangeOverflow) ? function rangeRender() {
    originalRender();
    ctrl.$setViewValue(element.val());
} : originalRender;
if (hasMinAttr) {
    ctrl.$validators.min = supportsRange ? function noopMinValidator() {
        return true;
    } : function minValidator(modelValue, viewValue) {
        return ctrl.$isEmpty(viewValue) || isUndefined(minVal) || viewValue >= minVal;
    };
    setInitialValueAndObserver('min', minChange);
}
if (hasMaxAttr) {
    ctrl.$validators.max = supportsRange ? function noopMaxValidator() {
        return true;
    } : function maxValidator(modelValue, viewValue) {
        return ctrl.$isEmpty(viewValue) || isUndefined(maxVal) || viewValue <= maxVal;
    };
    setInitialValueAndObserver('max', maxChange);
}
if (hasStepAttr) {
    ctrl.$validators.step = supportsRange ? function nativeStepValidator() {
        return !validity.stepMismatch;
    } : function stepValidator(modelValue, viewValue) {
        return ctrl.$isEmpty(viewValue) || isUndefined(stepVal) || isValidForStep(viewValue, minVal || 0, stepVal);
    };
    setInitialValueAndObserver('step', stepChange);
}});
    urlInputType = ($__.fs.urlInputType_255 = function urlInputType(scope, element, attr, ctrl, $sniffer, $browser) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
scope = arguments[0], element = arguments[1], attr = arguments[2], ctrl = arguments[3], $sniffer = arguments[4], $browser = arguments[5];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
stringBasedInputType(ctrl);
ctrl.$$parserName = 'url';
ctrl.$validators.url = function (modelValue, viewValue) {
    var value = modelValue || viewValue;
    return ctrl.$isEmpty(value) || URL_REGEXP.test(value);
};});
    emailInputType = ($__.fs.emailInputType_256 = function emailInputType(scope, element, attr, ctrl, $sniffer, $browser) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
scope = arguments[0], element = arguments[1], attr = arguments[2], ctrl = arguments[3], $sniffer = arguments[4], $browser = arguments[5];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
stringBasedInputType(ctrl);
ctrl.$$parserName = 'email';
ctrl.$validators.email = function (modelValue, viewValue) {
    var value = modelValue || viewValue;
    return ctrl.$isEmpty(value) || EMAIL_REGEXP.test(value);
};});
    radioInputType = ($__.fs.radioInputType_257 = function radioInputType(scope, element, attr, ctrl) {
var vvv_return, vvv_switch, doTrim, listener;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
scope = arguments[0], element = arguments[1], attr = arguments[2], ctrl = arguments[3];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
doTrim = !attr.ngTrim || trim(attr.ngTrim) !== 'false';
if (isUndefined(attr.name)) {
    element.attr('name', nextUid());
}
listener = function (ev) {
    var value;
    if (element[0].checked) {
        value = attr.value;
        if (doTrim) {
            value = trim(value);
        }
        ctrl.$setViewValue(value, ev && ev.type);
    }
};
element.on('click', listener);
ctrl.$render = function () {
    var value = attr.value;
    if (doTrim) {
        value = trim(value);
    }
    element[0].checked = value === ctrl.$viewValue;
};
attr.$observe('value', ctrl.$render);});
    parseConstantExpr = ($__.fs.parseConstantExpr_258 = function parseConstantExpr($parse, context, name, expression, fallback) {
var vvv_return, vvv_switch, parseFn;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
$parse = arguments[0], context = arguments[1], name = arguments[2], expression = arguments[3], fallback = arguments[4];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (isDefined(expression)) {
    parseFn = $parse(expression);
    if (!parseFn.constant) {
        throw ngModelMinErr('constexpr', 'Expected constant expression for `{0}`, but saw ' + '`{1}`.', name, expression);
    }
    return parseFn(context);
}
return fallback;});
    checkboxInputType = ($__.fs.checkboxInputType_259 = function checkboxInputType(scope, element, attr, ctrl, $sniffer, $browser, $filter, $parse) {
var vvv_return, vvv_switch, trueValue, falseValue, listener;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
scope = arguments[0], element = arguments[1], attr = arguments[2], ctrl = arguments[3], $sniffer = arguments[4], $browser = arguments[5], $filter = arguments[6], $parse = arguments[7];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
trueValue = parseConstantExpr($parse, scope, 'ngTrueValue', attr.ngTrueValue, true);
falseValue = parseConstantExpr($parse, scope, 'ngFalseValue', attr.ngFalseValue, false);
listener = function (ev) {
    ctrl.$setViewValue(element[0].checked, ev && ev.type);
};
element.on('click', listener);
ctrl.$render = function () {
    element[0].checked = ctrl.$viewValue;
};
ctrl.$isEmpty = function (value) {
    return value === false;
};
ctrl.$formatters.push(function (value) {
    return equals(value, trueValue);
});
ctrl.$parsers.push(function (value) {
    return value ? trueValue : falseValue;
});});
    classDirective = ($__.fs.classDirective_260 = function classDirective(name, selector) {
var vvv_return, vvv_switch, indexWatchExpression, arrayDifference, split, toClassString, toFlatValue;
arrayDifference = function arrayDifference(tokens1, tokens2) {
    if (!tokens1 || !tokens1.length)
        return [];
    if (!tokens2 || !tokens2.length)
        return tokens1;
    var values = [];
    outer:
        for (var i = 0; i < tokens1.length; i++) {
            var token = tokens1[i];
            for (var j = 0; j < tokens2.length; j++) {
                if (token === tokens2[j])
                    continue outer;
            }
            values.push(token);
        }
    return values;
};
split = function split(classString) {
    return classString && classString.split(' ');
};
toClassString = function toClassString(classValue) {
    var classString = classValue;
    if (isArray(classValue)) {
        classString = classValue.map(toClassString).join(' ');
    } else if (isObject(classValue)) {
        classString = Object.keys(classValue).filter(function (key) {
            return classValue[key];
        }).join(' ');
    }
    return classString;
};
toFlatValue = function toFlatValue(classValue) {
    var flatValue = classValue;
    if (isArray(classValue)) {
        flatValue = classValue.map(toFlatValue);
    } else if (isObject(classValue)) {
        var hasUndefined = false;
        flatValue = Object.keys(classValue).filter(function (key) {
            var value = classValue[key];
            if (!hasUndefined && isUndefined(value)) {
                hasUndefined = true;
            }
            return value;
        });
        if (hasUndefined) {
            flatValue.push(undefined);
        }
    }
    return flatValue;
};
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
name = arguments[0], selector = arguments[1];
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    arrayDifference = ($__.fs.arrayDifference_579 = function arrayDifference(tokens1, tokens2) {
var vvv_return, vvv_switch, values, token;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
tokens1 = arguments[0], tokens2 = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (!tokens1 || !tokens1.length)
    return [];
if (!tokens2 || !tokens2.length)
    return tokens1;
values = [];
outer:
    for (var i = 0; i < tokens1.length; i++) {
        token = tokens1[i];
        for (var j = 0; j < tokens2.length; j++) {
            if (token === tokens2[j])
                continue outer;
        }
        values.push(token);
    }
return values;});
    split = ($__.fs.split_580 = function split(classString) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
classString = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return classString && classString.split(' ');});
    toClassString = ($__.fs.toClassString_581 = function toClassString(classValue) {
var vvv_return, vvv_switch, classString;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
classValue = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
classString = classValue;
if (isArray(classValue)) {
    classString = classValue.map(toClassString).join(' ');
} else if (isObject(classValue)) {
    classString = Object.keys(classValue).filter(function (key) {
        return classValue[key];
    }).join(' ');
}
return classString;});
    toFlatValue = ($__.fs.toFlatValue_582 = function toFlatValue(classValue) {
var vvv_return, vvv_switch, flatValue, hasUndefined;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
classValue = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
flatValue = classValue;
if (isArray(classValue)) {
    flatValue = classValue.map(toFlatValue);
} else if (isObject(classValue)) {
    hasUndefined = false;
    flatValue = Object.keys(classValue).filter(function (key) {
        var value = classValue[key];
        if (!hasUndefined && isUndefined(value)) {
            hasUndefined = true;
        }
        return value;
    });
    if (hasUndefined) {
        flatValue.push(undefined);
    }
}
return flatValue;});
    name = 'ngClass' + name;
    return [
        '$parse',
        ($__.fs.J$__v3645318688_2005_583 = function J$__v3645318688_2005($parse) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
$parse = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return {
    restrict: 'AC',
    link: function (scope, element, attr) {
        var expression = attr[name].trim();
        var isOneTime = expression.charAt(0) === ':' && expression.charAt(1) === ':';
        var watchInterceptor = isOneTime ? toFlatValue : toClassString;
        var watchExpression = $parse(expression, watchInterceptor);
        var watchAction = isOneTime ? ngClassOneTimeWatchAction : ngClassWatchAction;
        var classCounts = element.data('$classCounts');
        var oldModulo = true;
        var oldClassString;
        if (!classCounts) {
            classCounts = createMap();
            element.data('$classCounts', classCounts);
        }
        if (name !== 'ngClass') {
            if (!indexWatchExpression) {
                indexWatchExpression = $parse('$index', function moduloTwo($index) {
                    return $index & 1;
                });
            }
            scope.$watch(indexWatchExpression, ngClassIndexWatchAction);
        }
        scope.$watch(watchExpression, watchAction, isOneTime);
        function addClasses(classString) {
            classString = digestClassCounts(split(classString), 1);
            attr.$addClass(classString);
        }
        function removeClasses(classString) {
            classString = digestClassCounts(split(classString), -1);
            attr.$removeClass(classString);
        }
        function updateClasses(oldClassString, newClassString) {
            var oldClassArray = split(oldClassString);
            var newClassArray = split(newClassString);
            var toRemoveArray = arrayDifference(oldClassArray, newClassArray);
            var toAddArray = arrayDifference(newClassArray, oldClassArray);
            var toRemoveString = digestClassCounts(toRemoveArray, -1);
            var toAddString = digestClassCounts(toAddArray, 1);
            attr.$addClass(toAddString);
            attr.$removeClass(toRemoveString);
        }
        function digestClassCounts(classArray, count) {
            var classesToUpdate = [];
            forEach(classArray, function (className) {
                if (count > 0 || classCounts[className]) {
                    classCounts[className] = (classCounts[className] || 0) + count;
                    if (classCounts[className] === +(count > 0)) {
                        classesToUpdate.push(className);
                    }
                }
            });
            return classesToUpdate.join(' ');
        }
        function ngClassIndexWatchAction(newModulo) {
            if (newModulo === selector) {
                addClasses(oldClassString);
            } else {
                removeClasses(oldClassString);
            }
            oldModulo = newModulo;
        }
        function ngClassOneTimeWatchAction(newClassValue) {
            var newClassString = toClassString(newClassValue);
            if (newClassString !== oldClassString) {
                ngClassWatchAction(newClassString);
            }
        }
        function ngClassWatchAction(newClassString) {
            if (oldModulo === selector) {
                updateClasses(oldClassString, newClassString);
            }
            oldClassString = newClassString;
        }
    }
};})
    ];
case 1:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 1);
    arrayDifference = ($__.fs.arrayDifference_584 = function arrayDifference(tokens1, tokens2) {
var vvv_return, vvv_switch, values, token;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
tokens1 = arguments[0], tokens2 = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (!tokens1 || !tokens1.length)
    return [];
if (!tokens2 || !tokens2.length)
    return tokens1;
values = [];
outer:
    for (var i = 0; i < tokens1.length; i++) {
        token = tokens1[i];
        for (var j = 0; j < tokens2.length; j++) {
            if (token === tokens2[j])
                continue outer;
        }
        values.push(token);
    }
return values;});
    split = ($__.fs.split_585 = function split(classString) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
classString = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return classString && classString.split(' ');});
    toClassString = ($__.fs.toClassString_586 = function toClassString(classValue) {
var vvv_return, vvv_switch, classString;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
classValue = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
classString = classValue;
if (isArray(classValue)) {
    classString = classValue.map(toClassString).join(' ');
} else if (isObject(classValue)) {
    classString = Object.keys(classValue).filter(function (key) {
        return classValue[key];
    }).join(' ');
}
return classString;});
    toFlatValue = ($__.fs.toFlatValue_587 = function toFlatValue(classValue) {
var vvv_return, vvv_switch, flatValue, hasUndefined;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
classValue = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
flatValue = classValue;
if (isArray(classValue)) {
    flatValue = classValue.map(toFlatValue);
} else if (isObject(classValue)) {
    hasUndefined = false;
    flatValue = Object.keys(classValue).filter(function (key) {
        var value = classValue[key];
        if (!hasUndefined && isUndefined(value)) {
            hasUndefined = true;
        }
        return value;
    });
    if (hasUndefined) {
        flatValue.push(undefined);
    }
}
return flatValue;});
    name = 'ngClass' + name;
    return [
        '$parse',
        ($__.fs.J$__v3645318688_2005_588 = function J$__v3645318688_2005($parse) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
$parse = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return {
    restrict: 'AC',
    link: function (scope, element, attr) {
        var expression = attr[name].trim();
        var isOneTime = expression.charAt(0) === ':' && expression.charAt(1) === ':';
        var watchInterceptor = isOneTime ? toFlatValue : toClassString;
        var watchExpression = $parse(expression, watchInterceptor);
        var watchAction = isOneTime ? ngClassOneTimeWatchAction : ngClassWatchAction;
        var classCounts = element.data('$classCounts');
        var oldModulo = true;
        var oldClassString;
        if (!classCounts) {
            classCounts = createMap();
            element.data('$classCounts', classCounts);
        }
        if (name !== 'ngClass') {
            if (!indexWatchExpression) {
                indexWatchExpression = $parse('$index', function moduloTwo($index) {
                    return $index & 1;
                });
            }
            scope.$watch(indexWatchExpression, ngClassIndexWatchAction);
        }
        scope.$watch(watchExpression, watchAction, isOneTime);
        function addClasses(classString) {
            classString = digestClassCounts(split(classString), 1);
            attr.$addClass(classString);
        }
        function removeClasses(classString) {
            classString = digestClassCounts(split(classString), -1);
            attr.$removeClass(classString);
        }
        function updateClasses(oldClassString, newClassString) {
            var oldClassArray = split(oldClassString);
            var newClassArray = split(newClassString);
            var toRemoveArray = arrayDifference(oldClassArray, newClassArray);
            var toAddArray = arrayDifference(newClassArray, oldClassArray);
            var toRemoveString = digestClassCounts(toRemoveArray, -1);
            var toAddString = digestClassCounts(toAddArray, 1);
            attr.$addClass(toAddString);
            attr.$removeClass(toRemoveString);
        }
        function digestClassCounts(classArray, count) {
            var classesToUpdate = [];
            forEach(classArray, function (className) {
                if (count > 0 || classCounts[className]) {
                    classCounts[className] = (classCounts[className] || 0) + count;
                    if (classCounts[className] === +(count > 0)) {
                        classesToUpdate.push(className);
                    }
                }
            });
            return classesToUpdate.join(' ');
        }
        function ngClassIndexWatchAction(newModulo) {
            if (newModulo === selector) {
                addClasses(oldClassString);
            } else {
                removeClasses(oldClassString);
            }
            oldModulo = newModulo;
        }
        function ngClassOneTimeWatchAction(newClassValue) {
            var newClassString = toClassString(newClassValue);
            if (newClassString !== oldClassString) {
                ngClassWatchAction(newClassString);
            }
        }
        function ngClassWatchAction(newClassString) {
            if (oldModulo === selector) {
                updateClasses(oldClassString, newClassString);
            }
            oldClassString = newClassString;
        }
    }
};})
    ];
case 2:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 2);
    arrayDifference = ($__.fs.arrayDifference_589 = function arrayDifference(tokens1, tokens2) {
var vvv_return, vvv_switch, values, token;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
tokens1 = arguments[0], tokens2 = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (!tokens1 || !tokens1.length)
    return [];
if (!tokens2 || !tokens2.length)
    return tokens1;
values = [];
outer:
    for (var i = 0; i < tokens1.length; i++) {
        token = tokens1[i];
        for (var j = 0; j < tokens2.length; j++) {
            if (token === tokens2[j])
                continue outer;
        }
        values.push(token);
    }
return values;});
    split = ($__.fs.split_590 = function split(classString) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
classString = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return classString && classString.split(' ');});
    toClassString = ($__.fs.toClassString_591 = function toClassString(classValue) {
var vvv_return, vvv_switch, classString;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
classValue = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
classString = classValue;
if (isArray(classValue)) {
    classString = classValue.map(toClassString).join(' ');
} else if (isObject(classValue)) {
    classString = Object.keys(classValue).filter(function (key) {
        return classValue[key];
    }).join(' ');
}
return classString;});
    toFlatValue = ($__.fs.toFlatValue_592 = function toFlatValue(classValue) {
var vvv_return, vvv_switch, flatValue, hasUndefined;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
classValue = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
flatValue = classValue;
if (isArray(classValue)) {
    flatValue = classValue.map(toFlatValue);
} else if (isObject(classValue)) {
    hasUndefined = false;
    flatValue = Object.keys(classValue).filter(function (key) {
        var value = classValue[key];
        if (!hasUndefined && isUndefined(value)) {
            hasUndefined = true;
        }
        return value;
    });
    if (hasUndefined) {
        flatValue.push(undefined);
    }
}
return flatValue;});
    name = 'ngClass' + name;
    return [
        '$parse',
        ($__.fs.J$__v3645318688_2005_593 = function J$__v3645318688_2005($parse) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
$parse = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return {
    restrict: 'AC',
    link: function (scope, element, attr) {
        var expression = attr[name].trim();
        var isOneTime = expression.charAt(0) === ':' && expression.charAt(1) === ':';
        var watchInterceptor = isOneTime ? toFlatValue : toClassString;
        var watchExpression = $parse(expression, watchInterceptor);
        var watchAction = isOneTime ? ngClassOneTimeWatchAction : ngClassWatchAction;
        var classCounts = element.data('$classCounts');
        var oldModulo = true;
        var oldClassString;
        if (!classCounts) {
            classCounts = createMap();
            element.data('$classCounts', classCounts);
        }
        if (name !== 'ngClass') {
            if (!indexWatchExpression) {
                indexWatchExpression = $parse('$index', function moduloTwo($index) {
                    return $index & 1;
                });
            }
            scope.$watch(indexWatchExpression, ngClassIndexWatchAction);
        }
        scope.$watch(watchExpression, watchAction, isOneTime);
        function addClasses(classString) {
            classString = digestClassCounts(split(classString), 1);
            attr.$addClass(classString);
        }
        function removeClasses(classString) {
            classString = digestClassCounts(split(classString), -1);
            attr.$removeClass(classString);
        }
        function updateClasses(oldClassString, newClassString) {
            var oldClassArray = split(oldClassString);
            var newClassArray = split(newClassString);
            var toRemoveArray = arrayDifference(oldClassArray, newClassArray);
            var toAddArray = arrayDifference(newClassArray, oldClassArray);
            var toRemoveString = digestClassCounts(toRemoveArray, -1);
            var toAddString = digestClassCounts(toAddArray, 1);
            attr.$addClass(toAddString);
            attr.$removeClass(toRemoveString);
        }
        function digestClassCounts(classArray, count) {
            var classesToUpdate = [];
            forEach(classArray, function (className) {
                if (count > 0 || classCounts[className]) {
                    classCounts[className] = (classCounts[className] || 0) + count;
                    if (classCounts[className] === +(count > 0)) {
                        classesToUpdate.push(className);
                    }
                }
            });
            return classesToUpdate.join(' ');
        }
        function ngClassIndexWatchAction(newModulo) {
            if (newModulo === selector) {
                addClasses(oldClassString);
            } else {
                removeClasses(oldClassString);
            }
            oldModulo = newModulo;
        }
        function ngClassOneTimeWatchAction(newClassValue) {
            var newClassString = toClassString(newClassValue);
            if (newClassString !== oldClassString) {
                ngClassWatchAction(newClassString);
            }
        }
        function ngClassWatchAction(newClassString) {
            if (oldModulo === selector) {
                updateClasses(oldClassString, newClassString);
            }
            oldClassString = newClassString;
        }
    }
};})
    ];
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
name = 'ngClass' + name;
return [
    '$parse',
    function ($parse) {
        return {
            restrict: 'AC',
            link: function (scope, element, attr) {
                var expression = attr[name].trim();
                var isOneTime = expression.charAt(0) === ':' && expression.charAt(1) === ':';
                var watchInterceptor = isOneTime ? toFlatValue : toClassString;
                var watchExpression = $parse(expression, watchInterceptor);
                var watchAction = isOneTime ? ngClassOneTimeWatchAction : ngClassWatchAction;
                var classCounts = element.data('$classCounts');
                var oldModulo = true;
                var oldClassString;
                if (!classCounts) {
                    classCounts = createMap();
                    element.data('$classCounts', classCounts);
                }
                if (name !== 'ngClass') {
                    if (!indexWatchExpression) {
                        indexWatchExpression = $parse('$index', function moduloTwo($index) {
                            return $index & 1;
                        });
                    }
                    scope.$watch(indexWatchExpression, ngClassIndexWatchAction);
                }
                scope.$watch(watchExpression, watchAction, isOneTime);
                function addClasses(classString) {
                    classString = digestClassCounts(split(classString), 1);
                    attr.$addClass(classString);
                }
                function removeClasses(classString) {
                    classString = digestClassCounts(split(classString), -1);
                    attr.$removeClass(classString);
                }
                function updateClasses(oldClassString, newClassString) {
                    var oldClassArray = split(oldClassString);
                    var newClassArray = split(newClassString);
                    var toRemoveArray = arrayDifference(oldClassArray, newClassArray);
                    var toAddArray = arrayDifference(newClassArray, oldClassArray);
                    var toRemoveString = digestClassCounts(toRemoveArray, -1);
                    var toAddString = digestClassCounts(toAddArray, 1);
                    attr.$addClass(toAddString);
                    attr.$removeClass(toRemoveString);
                }
                function digestClassCounts(classArray, count) {
                    var classesToUpdate = [];
                    forEach(classArray, function (className) {
                        if (count > 0 || classCounts[className]) {
                            classCounts[className] = (classCounts[className] || 0) + count;
                            if (classCounts[className] === +(count > 0)) {
                                classesToUpdate.push(className);
                            }
                        }
                    });
                    return classesToUpdate.join(' ');
                }
                function ngClassIndexWatchAction(newModulo) {
                    if (newModulo === selector) {
                        addClasses(oldClassString);
                    } else {
                        removeClasses(oldClassString);
                    }
                    oldModulo = newModulo;
                }
                function ngClassOneTimeWatchAction(newClassValue) {
                    var newClassString = toClassString(newClassValue);
                    if (newClassString !== oldClassString) {
                        ngClassWatchAction(newClassString);
                    }
                }
                function ngClassWatchAction(newClassString) {
                    if (oldModulo === selector) {
                        updateClasses(oldClassString, newClassString);
                    }
                    oldClassString = newClassString;
                }
            }
        };
    }
];});
    NgModelController = ($__.fs.NgModelController_261 = function NgModelController($scope, $exceptionHandler, $attr, $element, $parse, $animate, $timeout, $q, $interpolate) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
$scope = arguments[0], $exceptionHandler = arguments[1], $attr = arguments[2], $element = arguments[3], $parse = arguments[4], $animate = arguments[5], $timeout = arguments[6], $q = arguments[7], $interpolate = arguments[8];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.$viewValue = Number.NaN;
this.$modelValue = Number.NaN;
this.$$rawModelValue = undefined;
this.$validators = {};
this.$asyncValidators = {};
this.$parsers = [];
this.$formatters = [];
this.$viewChangeListeners = [];
this.$untouched = true;
this.$touched = false;
this.$pristine = true;
this.$dirty = false;
this.$valid = true;
this.$invalid = false;
this.$error = {};
this.$$success = {};
this.$pending = undefined;
this.$name = $interpolate($attr.name || '', false)($scope);
this.$$parentForm = nullFormCtrl;
this.$options = defaultModelOptions;
this.$$parsedNgModel = $parse($attr.ngModel);
this.$$parsedNgModelAssign = this.$$parsedNgModel.assign;
this.$$ngModelGet = this.$$parsedNgModel;
this.$$ngModelSet = this.$$parsedNgModelAssign;
this.$$pendingDebounce = null;
this.$$parserValid = undefined;
this.$$currentValidationRunId = 0;
this.$$scope = $scope;
this.$$attr = $attr;
this.$$element = $element;
this.$$animate = $animate;
this.$$timeout = $timeout;
this.$$parse = $parse;
this.$$q = $q;
this.$$exceptionHandler = $exceptionHandler;
setupValidity(this);
setupModelWatcher(this);});
    setupModelWatcher = ($__.fs.setupModelWatcher_262 = function setupModelWatcher(ctrl) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
ctrl = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
ctrl.$$scope.$watch(function ngModelWatch() {
    var modelValue = ctrl.$$ngModelGet(ctrl.$$scope);
    if (modelValue !== ctrl.$modelValue && (ctrl.$modelValue === ctrl.$modelValue || modelValue === modelValue)) {
        ctrl.$modelValue = ctrl.$$rawModelValue = modelValue;
        ctrl.$$parserValid = undefined;
        var formatters = ctrl.$formatters, idx = formatters.length;
        var viewValue = modelValue;
        while (idx--) {
            viewValue = formatters[idx](viewValue);
        }
        if (ctrl.$viewValue !== viewValue) {
            ctrl.$$updateEmptyClasses(viewValue);
            ctrl.$viewValue = ctrl.$$lastCommittedViewValue = viewValue;
            ctrl.$render();
            ctrl.$$runValidators(ctrl.$modelValue, ctrl.$viewValue, noop);
        }
    }
    return modelValue;
});});
    ModelOptions = ($__.fs.ModelOptions_263 = function ModelOptions(options) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
options = arguments[0];
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    this.$$options = options;
    return;
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.$$options = options;});
    defaults = ($__.fs.defaults_264 = function defaults(dst, src) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
dst = arguments[0], src = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
forEach(src, function (value, key) {
    if (!isDefined(dst[key])) {
        dst[key] = value;
    }
});});
    setOptionSelectedStatus = ($__.fs.setOptionSelectedStatus_265 = function setOptionSelectedStatus(optionEl, value) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
optionEl = arguments[0], value = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
optionEl.prop('selected', value);
optionEl.attr('selected', value);});
    REGEX_STRING_REGEXP = /^\/(.+)\/([a-z]*)$/;
    VALIDITY_STATE_PROPERTY = 'validity';
    hasOwnProperty = TAJS_restrictToType(TAJS_restrictToType(Object.prototype, 'object').hasOwnProperty, 'function');
    minErrConfig = $__.os.oid0 = {
        'objectMaxDepth': 5
    };
    lowercase = ($__.fs.J$__v3645318688_10_266 = function J$__v3645318688_10(string) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
string = arguments[0];
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    return (isString, $__.fs.isString_26)(string, 0, true, $__.uid), string['toLowerCase']();
case 1:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 1);
    return (isString, $__.fs.isString_26)(string, 1, true, $__.uid), string['toLowerCase']();
case 2:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 2);
    return (isString, $__.fs.isString_26)(string, 2, true, $__.uid), string['toLowerCase']();
case 3:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 3);
    return (isString, $__.fs.isString_26)(string, 3, true, $__.uid), string['toLowerCase']();
case 4:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 4);
    return (isString, $__.fs.isString_26)(string, 4, true, $__.uid), string['toLowerCase']();
case 5:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 5);
    return (isString, $__.fs.isString_26)(string, 5, true, $__.uid), string['toLowerCase']();
case 6:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 6);
    return (isString, $__.fs.isString_26)(string, 6, true, $__.uid), string['toLowerCase']();
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return isString(string) ? string.toLowerCase() : string;});
    uppercase = ($__.fs.J$__v3645318688_12_267 = function J$__v3645318688_12(string) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
string = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return isString(string) ? string.toUpperCase() : string;});
    manualLowercase = ($__.fs.J$__v3645318688_16_268 = function J$__v3645318688_16(s) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
s = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return isString(s) ? s.replace(/[A-Z]/g, function (ch) {
    return String.fromCharCode(ch.charCodeAt(0) | 32);
}) : s;});
    manualUppercase = ($__.fs.J$__v3645318688_20_269 = function J$__v3645318688_20(s) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
s = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return isString(s) ? s.replace(/[a-z]/g, function (ch) {
    return String.fromCharCode(ch.charCodeAt(0) & ~32);
}) : s;});
    'i' !== 'I'['toLowerCase']();
    slice = TAJS_restrictToType([].slice, 'function');
    splice = TAJS_restrictToType([].splice, 'function');
    push = TAJS_restrictToType([].push, 'function');
    toString = TAJS_restrictToType(TAJS_restrictToType(Object.prototype, 'object').toString, 'function');
    getPrototypeOf = TAJS_restrictToType(Object.getPrototypeOf, 'function');
    ngMinErr = (minErr, $__.fs.minErr_4)('ng', 0, true, $__.uid);
    angular = (TAJS_restrictToType(window.angular, 'undefined'), window.angular = $__.os.oid1 = {});
    uid = 0;
    msie = TAJS_restrictToType(TAJS_restrictToType(window.document, 'HTMLDocument').documentMode, 'undefined');
    isNumberNaN = TAJS_restrictToType(Number.isNaN, 'function');
    noop.$inject = [];
    identity.$inject = [];
    isArray = TAJS_restrictToType(Array.isArray, 'function');
    TYPED_ARRAY_REGEXP = /^\[object (?:Uint8|Uint8Clamped|Uint16|Uint32|Int8|Int16|Int32|Float32|Float64)Array]$/;
    trim = ($__.fs.J$__v3645318688_59_271 = function J$__v3645318688_59(value) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
value = arguments[0];
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    return (isString, $__.fs.isString_26)(value, 17, true, $__.uid), value['trim']();
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return isString(value) ? value.trim() : value;});
    escapeForRegexp = ($__.fs.J$__v3645318688_61_272 = function J$__v3645318688_61(s) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
s = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return s.replace(/([-()[\]{}+?*.$^|,:#<!\\])/g, '\\$1').replace(/\x08/g, '\\x08');});
    csp = ($__.fs.J$__v3645318688_76_273 = function J$__v3645318688_76() {
var vvv_return, vvv_switch, ngCspElement, ngCspAttribute, noUnsafeEval;
noUnsafeEval = function noUnsafeEval() {
    try {
        new Function('');
        return false;
    } catch (e) {
        return true;
    }
};
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    noUnsafeEval = ($__.fs.noUnsafeEval_719 = function noUnsafeEval() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    Function, '', ($__.fs.J$__v9047780371_1_721 = function J$__v9047780371_1() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;});
    return false;
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
try {
    new Function('');
    return false;
} catch (e) {
    return true;
}});
    !(isDefined, $__.fs.isDefined_23)(TAJS_restrictToType(csp.rules, 'undefined'), 2, true, $__.uid);
    ngCspElement = (TAJS_restrictToType(window.document, 'HTMLDocument')['querySelector']('[ng-csp]'), TAJS_restrictToType(window.document, 'HTMLDocument')['querySelector']('[data-ng-csp]'));
    ngCspElement;
    csp.rules = $__.os.oid59 = {
        'noUnsafeEval': (noUnsafeEval, $__.fs.noUnsafeEval_719)(0, true, $__.uid),
        'noInlineStyle': false
    };
    return csp.rules, $__.os.oid59;
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (!isDefined(csp.rules)) {
    ngCspElement = window.document.querySelector('[ng-csp]') || window.document.querySelector('[data-ng-csp]');
    if (ngCspElement) {
        ngCspAttribute = ngCspElement.getAttribute('ng-csp') || ngCspElement.getAttribute('data-ng-csp');
        csp.rules = {
            noUnsafeEval: !ngCspAttribute || ngCspAttribute.indexOf('no-unsafe-eval') !== -1,
            noInlineStyle: !ngCspAttribute || ngCspAttribute.indexOf('no-inline-style') !== -1
        };
    } else {
        csp.rules = {
            noUnsafeEval: noUnsafeEval(),
            noInlineStyle: false
        };
    }
}
return csp.rules;});
    jq = ($__.fs.J$__v3645318688_78_274 = function J$__v3645318688_78() {
var vvv_return, vvv_switch, el, i, ii, prefix, name;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    (isDefined, $__.fs.isDefined_23)(TAJS_restrictToType(jq.name_, 'undefined'), 0, true, $__.uid);
    ii = (ngAttrPrefixes.length, 4);
    i = 0;
    i < ii;
    prefix = TAJS_restrictToType(ngAttrPrefixes[i, 0], 'string');
    el = TAJS_restrictToType(window.document, 'HTMLDocument')['querySelector']('[' + prefix['replace'](':', '\\:') + 'jq]');
    el;
    i = +i + 1;
    i < ii;
    prefix = TAJS_restrictToType(ngAttrPrefixes[i, 1], 'string');
    el = TAJS_restrictToType(window.document, 'HTMLDocument')['querySelector']('[' + prefix['replace'](':', '\\:') + 'jq]');
    el;
    i = +i + 1;
    i < ii;
    prefix = TAJS_restrictToType(ngAttrPrefixes[i, 2], 'string');
    el = TAJS_restrictToType(window.document, 'HTMLDocument')['querySelector']('[' + prefix['replace'](':', '\\:') + 'jq]');
    el;
    i = +i + 1;
    i < ii;
    prefix = TAJS_restrictToType(ngAttrPrefixes[i, 3], 'string');
    el = TAJS_restrictToType(window.document, 'HTMLDocument')['querySelector']('[' + prefix['replace'](':', '\\:') + 'jq]');
    el;
    i = +i + 1;
    i < ii;
    return jq.name_ = name;
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (isDefined(jq.name_))
    return jq.name_;
ii = ngAttrPrefixes.length;
for (i = 0; i < ii; ++i) {
    prefix = ngAttrPrefixes[i];
    el = window.document.querySelector('[' + prefix.replace(':', '\\:') + 'jq]');
    if (el) {
        name = el.getAttribute(prefix + 'jq');
        break;
    }
}
return jq.name_ = name;});
    ALL_COLONS = /:/g;
    ngAttrPrefixes = [
        'ng-',
        'data-ng-',
        'ng:',
        'x-ng-'
    ];
    isAutoBootstrapAllowed = (allowAutoBootstrap, $__.fs.allowAutoBootstrap_63)(TAJS_restrictToType(window.document, 'HTMLDocument'), 0, true, $__.uid);
    SNAKE_CASE_REGEXP = /[A-Z]/g;
    bindJQueryFired = false;
    NODE_TYPE_ELEMENT = 1;
    NODE_TYPE_ATTRIBUTE = 2;
    NODE_TYPE_TEXT = 3;
    NODE_TYPE_COMMENT = 8;
    NODE_TYPE_DOCUMENT = 9;
    NODE_TYPE_DOCUMENT_FRAGMENT = 11;
    version = $__.os.oid2 = {
        'full': '1.6.3',
        'major': 1,
        'minor': 6,
        'dot': 3,
        'codeName': 'scriptalicious-bootstrapping'
    };
    JQLite.expando = 'ng339';
    jqCache = JQLite.cache = $__.os.oid3 = {};
    jqId = 1;
    JQLite._data = ($__.fs.J$__v3645318688_171_276 = function J$__v3645318688_171(node) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
node = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return this.cache[node[this.expando]] || {};});
    DASH_LOWERCASE_REGEXP = /-([a-z])/g;
    MS_HACK_REGEXP = /^-ms-/;
    MOUSE_EVENT_MAP = $__.os.oid4 = {
        'mouseleave': 'mouseout',
        'mouseenter': 'mouseover'
    };
    jqLiteMinErr = (minErr, $__.fs.minErr_4)('jqLite', 1, true, $__.uid);
    SINGLE_TAG_REGEXP = /^<([\w-]+)\s*\/?>(?:<\/\1>|)$/;
    HTML_REGEXP = /<|&#?\w+;/;
    TAG_NAME_REGEXP = /<([\w:-]+)/;
    XHTML_TAG_REGEXP = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:-]+)[^>]*)\/>/gi;
    wrapMap = $__.os.oid5 = {
        'option': [
            1,
            '<select multiple="multiple">',
            '</select>'
        ],
        'thead': [
            1,
            '<table>',
            '</table>'
        ],
        'col': [
            2,
            '<table><colgroup>',
            '</colgroup></table>'
        ],
        'tr': [
            2,
            '<table><tbody>',
            '</tbody></table>'
        ],
        'td': [
            3,
            '<table><tbody><tr>',
            '</tr></tbody></table>'
        ],
        '_default': [
            0,
            '',
            ''
        ]
    };
    (wrapMap, $__.os.oid5).optgroup = TAJS_restrictToType((wrapMap, $__.os.oid5).option, 'object');
    (wrapMap, $__.os.oid5).tbody = (wrapMap, $__.os.oid5).tfoot = (wrapMap, $__.os.oid5).colgroup = (wrapMap, $__.os.oid5).caption = TAJS_restrictToType((wrapMap, $__.os.oid5).thead, 'object');
    (wrapMap, $__.os.oid5).th = TAJS_restrictToType((wrapMap, $__.os.oid5).td, 'object');
    jqLiteContains = TAJS_restrictToType(TAJS_restrictToType(TAJS_restrictToType(window.Node, 'function').prototype, 'object').contains, 'function');
    JQLitePrototype = JQLite.prototype = $__.os.oid6 = {
        'ready': jqLiteReady,
        'toString': ($__.fs.J$__v3645318688_216_278 = function J$__v3645318688_216() {
var vvv_return, vvv_switch, value;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
value = [];
forEach(this, function (e) {
    value.push('' + e);
});
return '[' + value.join(', ') + ']';}),
        'eq': ($__.fs.J$__v3645318688_218_279 = function J$__v3645318688_218(index) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
index = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return index >= 0 ? jqLite(this[index]) : jqLite(this[this.length + index]);}),
        'length': 0,
        'push': push,
        'sort': TAJS_restrictToType([].sort, 'function'),
        'splice': TAJS_restrictToType([].splice, 'function')
    };
    BOOLEAN_ATTR = $__.os.oid7 = {};
    (forEach, $__.fs.forEach_8)(function $__lt0(res) {
        res.length = 7;
        if (res.length != 7)
            TAJS_dumpValue('Possible loss of precision');
        return res;
        ;
        TAJS_makeContextSensitive($__lt0, -2);
    }('multiple,selected,checked,disabled,readOnly,required,open'['split'](',')), ($__.fs.J$__v3645318688_220_280 = function J$__v3645318688_220(value) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
value = arguments[0];
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    (BOOLEAN_ATTR, $__.os.oid7)[(lowercase, $__.fs.J$__v3645318688_10_266)(value, 0, true, $__.uid), 'multiple'] = value;
    return;
case 1:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 1);
    (BOOLEAN_ATTR, $__.os.oid7)[(lowercase, $__.fs.J$__v3645318688_10_266)(value, 1, true, $__.uid), 'selected'] = value;
    return;
case 2:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 2);
    (BOOLEAN_ATTR, $__.os.oid7)[(lowercase, $__.fs.J$__v3645318688_10_266)(value, 2, true, $__.uid), 'checked'] = value;
    return;
case 3:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 3);
    (BOOLEAN_ATTR, $__.os.oid7)[(lowercase, $__.fs.J$__v3645318688_10_266)(value, 3, true, $__.uid), 'disabled'] = value;
    return;
case 4:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 4);
    (BOOLEAN_ATTR, $__.os.oid7)[(lowercase, $__.fs.J$__v3645318688_10_266)(value, 4, true, $__.uid), 'readonly'] = value;
    return;
case 5:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 5);
    (BOOLEAN_ATTR, $__.os.oid7)[(lowercase, $__.fs.J$__v3645318688_10_266)(value, 5, true, $__.uid), 'required'] = value;
    return;
case 6:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 6);
    (BOOLEAN_ATTR, $__.os.oid7)[(lowercase, $__.fs.J$__v3645318688_10_266)(value, 6, true, $__.uid), 'open'] = value;
    return;
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
BOOLEAN_ATTR[lowercase(value)] = value;}, $__.fs.J$__v3645318688_220_280), 0, true, $__.uid);
    BOOLEAN_ELEMENTS = $__.os.oid8 = {};
    (forEach, $__.fs.forEach_8)(function $__lt1(res) {
        res.length = 7;
        if (res.length != 7)
            TAJS_dumpValue('Possible loss of precision');
        return res;
        ;
        TAJS_makeContextSensitive($__lt1, -2);
    }('input,select,option,textarea,button,form,details'['split'](',')), ($__.fs.J$__v3645318688_222_281 = function J$__v3645318688_222(value) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
value = arguments[0];
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    (BOOLEAN_ELEMENTS, $__.os.oid8)[value, 'input'] = true;
    return;
case 1:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 1);
    (BOOLEAN_ELEMENTS, $__.os.oid8)[value, 'select'] = true;
    return;
case 2:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 2);
    (BOOLEAN_ELEMENTS, $__.os.oid8)[value, 'option'] = true;
    return;
case 3:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 3);
    (BOOLEAN_ELEMENTS, $__.os.oid8)[value, 'textarea'] = true;
    return;
case 4:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 4);
    (BOOLEAN_ELEMENTS, $__.os.oid8)[value, 'button'] = true;
    return;
case 5:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 5);
    (BOOLEAN_ELEMENTS, $__.os.oid8)[value, 'form'] = true;
    return;
case 6:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 6);
    (BOOLEAN_ELEMENTS, $__.os.oid8)[value, 'details'] = true;
    return;
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
BOOLEAN_ELEMENTS[value] = true;}, $__.fs.J$__v3645318688_222_281), 1, true, $__.uid);
    ALIASED_ATTR = $__.os.oid9 = {
        'ngMinlength': 'minlength',
        'ngMaxlength': 'maxlength',
        'ngMin': 'min',
        'ngMax': 'max',
        'ngPattern': 'pattern',
        'ngStep': 'step'
    };
    (forEach, $__.fs.forEach_8)($__.os.oid10 = {
        'data': jqLiteData,
        'removeData': jqLiteRemoveData,
        'hasData': jqLiteHasData,
        'cleanData': jqLiteCleanData
    }, ($__.fs.J$__v3645318688_226_282 = function J$__v3645318688_226(fn, name) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
fn = arguments[0], name = arguments[1];
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    JQLite[name, 'data'] = fn;
    return;
case 1:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 1);
    JQLite[name, 'removeData'] = fn;
    return;
case 2:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 2);
    JQLite[name, 'hasData'] = fn;
    return;
case 3:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 3);
    JQLite[name, 'cleanData'] = fn;
    return;
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
JQLite[name] = fn;}, $__.fs.J$__v3645318688_226_282), 2, true, $__.uid);
    (forEach, $__.fs.forEach_8)($__.os.oid11 = {
        'data': jqLiteData,
        'inheritedData': jqLiteInheritedData,
        'scope': ($__.fs.J$__v3645318688_228_283 = function J$__v3645318688_228(element) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
element = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return jqLite.data(element, '$scope') || jqLiteInheritedData(element.parentNode || element, [
    '$isolateScope',
    '$scope'
]);}, $__.fs.J$__v3645318688_228_283_28 = $__.fs.J$__v3645318688_228_283, $__.fs.J$__v3645318688_228_283),
        'isolateScope': ($__.fs.J$__v3645318688_230_284 = function J$__v3645318688_230(element) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
element = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return jqLite.data(element, '$isolateScope') || jqLite.data(element, '$isolateScopeNoTemplate');}, $__.fs.J$__v3645318688_230_284_30 = $__.fs.J$__v3645318688_230_284, $__.fs.J$__v3645318688_230_284),
        'controller': jqLiteController,
        'injector': ($__.fs.J$__v3645318688_232_285 = function J$__v3645318688_232(element) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
element = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return jqLiteInheritedData(element, '$injector');}, $__.fs.J$__v3645318688_232_285_34 = $__.fs.J$__v3645318688_232_285, $__.fs.J$__v3645318688_232_285),
        'removeAttr': ($__.fs.J$__v3645318688_234_286 = function J$__v3645318688_234(element, name) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
element = arguments[0], name = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
element.removeAttribute(name);}, $__.fs.J$__v3645318688_234_286_36 = $__.fs.J$__v3645318688_234_286, $__.fs.J$__v3645318688_234_286),
        'hasClass': jqLiteHasClass,
        'css': ($__.fs.J$__v3645318688_236_287 = function J$__v3645318688_236(element, name, value) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
element = arguments[0], name = arguments[1], value = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
name = cssKebabToCamel(name);
if (isDefined(value)) {
    element.style[name] = value;
} else {
    return element.style[name];
}}, $__.fs.J$__v3645318688_236_287_40 = $__.fs.J$__v3645318688_236_287, $__.fs.J$__v3645318688_236_287),
        'attr': ($__.fs.J$__v3645318688_238_288 = function J$__v3645318688_238(element, name, value) {
var vvv_return, vvv_switch, ret, nodeType, lowercasedName, isBooleanAttr;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
element = arguments[0], name = arguments[1], value = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
nodeType = element.nodeType;
if (nodeType === NODE_TYPE_TEXT || nodeType === NODE_TYPE_ATTRIBUTE || nodeType === NODE_TYPE_COMMENT || !element.getAttribute) {
    return;
}
lowercasedName = lowercase(name);
isBooleanAttr = BOOLEAN_ATTR[lowercasedName];
if (isDefined(value)) {
    if (value === null || value === false && isBooleanAttr) {
        element.removeAttribute(name);
    } else {
        element.setAttribute(name, isBooleanAttr ? lowercasedName : value);
    }
} else {
    ret = element.getAttribute(name);
    if (isBooleanAttr && ret !== null) {
        ret = lowercasedName;
    }
    return ret === null ? undefined : ret;
}}, $__.fs.J$__v3645318688_238_288_42 = $__.fs.J$__v3645318688_238_288, $__.fs.J$__v3645318688_238_288),
        'prop': ($__.fs.J$__v3645318688_240_289 = function J$__v3645318688_240(element, name, value) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
element = arguments[0], name = arguments[1], value = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (isDefined(value)) {
    element[name] = value;
} else {
    return element[name];
}}, $__.fs.J$__v3645318688_240_289_44 = $__.fs.J$__v3645318688_240_289, $__.fs.J$__v3645318688_240_289),
        'text': (($__.fs.J$__v3645318688_243_290 = function J$__v3645318688_243() {
var vvv_return, vvv_switch, getText;
getText = function getText(element, value) {
    if (isUndefined(value)) {
        var nodeType = element.nodeType;
        return nodeType === NODE_TYPE_ELEMENT || nodeType === NODE_TYPE_TEXT ? element.textContent : '';
    }
    element.textContent = value;
};
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    getText = ($__.fs.getText_291 = function getText(element, value) {
var vvv_return, vvv_switch, nodeType;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
element = arguments[0], value = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (isUndefined(value)) {
    nodeType = element.nodeType;
    return nodeType === NODE_TYPE_ELEMENT || nodeType === NODE_TYPE_TEXT ? element.textContent : '';
}
element.textContent = value;}, $__.fs.getText_291_46 = $__.fs.getText_291, $__.fs.getText_291);
    getText.$dv = '';
    return getText;
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
getText.$dv = '';
return getText;}), $__.fs.J$__v3645318688_243_290)(0, true, $__.uid),
        'val': ($__.fs.J$__v3645318688_247_292 = function J$__v3645318688_247(element, value) {
var vvv_return, vvv_switch, result;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
element = arguments[0], value = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (isUndefined(value)) {
    if (element.multiple && nodeName_(element) === 'select') {
        result = [];
        forEach(element.options, function (option) {
            if (option.selected) {
                result.push(option.value || option.text);
            }
        });
        return result;
    }
    return element.value;
}
element.value = value;}, $__.fs.J$__v3645318688_247_292_48 = $__.fs.J$__v3645318688_247_292, $__.fs.J$__v3645318688_247_292),
        'html': ($__.fs.J$__v3645318688_249_293 = function J$__v3645318688_249(element, value) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
element = arguments[0], value = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (isUndefined(value)) {
    return element.innerHTML;
}
jqLiteDealoc(element, true);
element.innerHTML = value;}, $__.fs.J$__v3645318688_249_293_50 = $__.fs.J$__v3645318688_249_293, $__.fs.J$__v3645318688_249_293),
        'empty': jqLiteEmpty
    }, ($__.fs.J$__v3645318688_253_294 = function J$__v3645318688_253(fn, name) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
fn = arguments[0], name = arguments[1];
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    ((JQLite.prototype, $__.os.oid6), $__.os.oid6)[name, 'data'] = ($__.fs.J$__v3645318688_251_295 = function J$__v3645318688_251(arg1, arg2) {
var vvv_return, vvv_switch, i, key, nodeCount, value, jj, nodeValue;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
arg1 = arguments[0], arg2 = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
nodeCount = this.length;
if (fn !== jqLiteEmpty && isUndefined(fn.length === 2 && (fn !== jqLiteHasClass && fn !== jqLiteController) ? arg1 : arg2)) {
    if (isObject(arg1)) {
        for (i = 0; i < nodeCount; i++) {
            if (fn === jqLiteData) {
                fn(this[i], arg1);
            } else {
                for (key in arg1) {
                    fn(this[i], key, arg1[key]);
                }
            }
        }
        return this;
    } else {
        value = fn.$dv;
        jj = isUndefined(value) ? Math.min(nodeCount, 1) : nodeCount;
        for (var j = 0; j < jj; j++) {
            nodeValue = fn(this[j], arg1, arg2);
            value = value ? value + nodeValue : nodeValue;
        }
        return value;
    }
} else {
    for (i = 0; i < nodeCount; i++) {
        fn(this[i], arg1, arg2);
    }
    return this;
}});
    return;
case 1:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 1);
    ((JQLite.prototype, $__.os.oid6), $__.os.oid6)[name, 'inheritedData'] = ($__.fs.J$__v3645318688_251_296 = function J$__v3645318688_251(arg1, arg2) {
var vvv_return, vvv_switch, i, key, nodeCount, value, jj, nodeValue;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
arg1 = arguments[0], arg2 = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
nodeCount = this.length;
if (fn !== jqLiteEmpty && isUndefined(fn.length === 2 && (fn !== jqLiteHasClass && fn !== jqLiteController) ? arg1 : arg2)) {
    if (isObject(arg1)) {
        for (i = 0; i < nodeCount; i++) {
            if (fn === jqLiteData) {
                fn(this[i], arg1);
            } else {
                for (key in arg1) {
                    fn(this[i], key, arg1[key]);
                }
            }
        }
        return this;
    } else {
        value = fn.$dv;
        jj = isUndefined(value) ? Math.min(nodeCount, 1) : nodeCount;
        for (var j = 0; j < jj; j++) {
            nodeValue = fn(this[j], arg1, arg2);
            value = value ? value + nodeValue : nodeValue;
        }
        return value;
    }
} else {
    for (i = 0; i < nodeCount; i++) {
        fn(this[i], arg1, arg2);
    }
    return this;
}});
    return;
case 2:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 2);
    ((JQLite.prototype, $__.os.oid6), $__.os.oid6)[name, 'scope'] = ($__.fs.J$__v3645318688_251_297 = function J$__v3645318688_251(arg1, arg2) {
var vvv_return, vvv_switch, i, key, nodeCount, value, jj, nodeValue;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
arg1 = arguments[0], arg2 = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
nodeCount = this.length;
if (fn !== jqLiteEmpty && isUndefined(fn.length === 2 && (fn !== jqLiteHasClass && fn !== jqLiteController) ? arg1 : arg2)) {
    if (isObject(arg1)) {
        for (i = 0; i < nodeCount; i++) {
            if (fn === jqLiteData) {
                fn(this[i], arg1);
            } else {
                for (key in arg1) {
                    fn(this[i], key, arg1[key]);
                }
            }
        }
        return this;
    } else {
        value = fn.$dv;
        jj = isUndefined(value) ? Math.min(nodeCount, 1) : nodeCount;
        for (var j = 0; j < jj; j++) {
            nodeValue = fn(this[j], arg1, arg2);
            value = value ? value + nodeValue : nodeValue;
        }
        return value;
    }
} else {
    for (i = 0; i < nodeCount; i++) {
        fn(this[i], arg1, arg2);
    }
    return this;
}});
    return;
case 3:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 3);
    ((JQLite.prototype, $__.os.oid6), $__.os.oid6)[name, 'isolateScope'] = ($__.fs.J$__v3645318688_251_298 = function J$__v3645318688_251(arg1, arg2) {
var vvv_return, vvv_switch, i, key, nodeCount, value, jj, nodeValue;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
arg1 = arguments[0], arg2 = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
nodeCount = this.length;
if (fn !== jqLiteEmpty && isUndefined(fn.length === 2 && (fn !== jqLiteHasClass && fn !== jqLiteController) ? arg1 : arg2)) {
    if (isObject(arg1)) {
        for (i = 0; i < nodeCount; i++) {
            if (fn === jqLiteData) {
                fn(this[i], arg1);
            } else {
                for (key in arg1) {
                    fn(this[i], key, arg1[key]);
                }
            }
        }
        return this;
    } else {
        value = fn.$dv;
        jj = isUndefined(value) ? Math.min(nodeCount, 1) : nodeCount;
        for (var j = 0; j < jj; j++) {
            nodeValue = fn(this[j], arg1, arg2);
            value = value ? value + nodeValue : nodeValue;
        }
        return value;
    }
} else {
    for (i = 0; i < nodeCount; i++) {
        fn(this[i], arg1, arg2);
    }
    return this;
}});
    return;
case 4:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 4);
    ((JQLite.prototype, $__.os.oid6), $__.os.oid6)[name, 'controller'] = ($__.fs.J$__v3645318688_251_299 = function J$__v3645318688_251(arg1, arg2) {
var vvv_return, vvv_switch, i, key, nodeCount, value, jj, nodeValue;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
arg1 = arguments[0], arg2 = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
nodeCount = this.length;
if (fn !== jqLiteEmpty && isUndefined(fn.length === 2 && (fn !== jqLiteHasClass && fn !== jqLiteController) ? arg1 : arg2)) {
    if (isObject(arg1)) {
        for (i = 0; i < nodeCount; i++) {
            if (fn === jqLiteData) {
                fn(this[i], arg1);
            } else {
                for (key in arg1) {
                    fn(this[i], key, arg1[key]);
                }
            }
        }
        return this;
    } else {
        value = fn.$dv;
        jj = isUndefined(value) ? Math.min(nodeCount, 1) : nodeCount;
        for (var j = 0; j < jj; j++) {
            nodeValue = fn(this[j], arg1, arg2);
            value = value ? value + nodeValue : nodeValue;
        }
        return value;
    }
} else {
    for (i = 0; i < nodeCount; i++) {
        fn(this[i], arg1, arg2);
    }
    return this;
}});
    return;
case 5:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 5);
    ((JQLite.prototype, $__.os.oid6), $__.os.oid6)[name, 'injector'] = ($__.fs.J$__v3645318688_251_300 = function J$__v3645318688_251(arg1, arg2) {
var vvv_return, vvv_switch, i, key, nodeCount, value, jj, nodeValue;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
arg1 = arguments[0], arg2 = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
nodeCount = this.length;
if (fn !== jqLiteEmpty && isUndefined(fn.length === 2 && (fn !== jqLiteHasClass && fn !== jqLiteController) ? arg1 : arg2)) {
    if (isObject(arg1)) {
        for (i = 0; i < nodeCount; i++) {
            if (fn === jqLiteData) {
                fn(this[i], arg1);
            } else {
                for (key in arg1) {
                    fn(this[i], key, arg1[key]);
                }
            }
        }
        return this;
    } else {
        value = fn.$dv;
        jj = isUndefined(value) ? Math.min(nodeCount, 1) : nodeCount;
        for (var j = 0; j < jj; j++) {
            nodeValue = fn(this[j], arg1, arg2);
            value = value ? value + nodeValue : nodeValue;
        }
        return value;
    }
} else {
    for (i = 0; i < nodeCount; i++) {
        fn(this[i], arg1, arg2);
    }
    return this;
}});
    return;
case 6:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 6);
    ((JQLite.prototype, $__.os.oid6), $__.os.oid6)[name, 'removeAttr'] = ($__.fs.J$__v3645318688_251_301 = function J$__v3645318688_251(arg1, arg2) {
var vvv_return, vvv_switch, i, key, nodeCount, value, jj, nodeValue;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
arg1 = arguments[0], arg2 = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
nodeCount = this.length;
if (fn !== jqLiteEmpty && isUndefined(fn.length === 2 && (fn !== jqLiteHasClass && fn !== jqLiteController) ? arg1 : arg2)) {
    if (isObject(arg1)) {
        for (i = 0; i < nodeCount; i++) {
            if (fn === jqLiteData) {
                fn(this[i], arg1);
            } else {
                for (key in arg1) {
                    fn(this[i], key, arg1[key]);
                }
            }
        }
        return this;
    } else {
        value = fn.$dv;
        jj = isUndefined(value) ? Math.min(nodeCount, 1) : nodeCount;
        for (var j = 0; j < jj; j++) {
            nodeValue = fn(this[j], arg1, arg2);
            value = value ? value + nodeValue : nodeValue;
        }
        return value;
    }
} else {
    for (i = 0; i < nodeCount; i++) {
        fn(this[i], arg1, arg2);
    }
    return this;
}});
    return;
case 7:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 7);
    ((JQLite.prototype, $__.os.oid6), $__.os.oid6)[name, 'hasClass'] = ($__.fs.J$__v3645318688_251_302 = function J$__v3645318688_251(arg1, arg2) {
var vvv_return, vvv_switch, i, key, nodeCount, value, jj, nodeValue;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
arg1 = arguments[0], arg2 = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
nodeCount = this.length;
if (fn !== jqLiteEmpty && isUndefined(fn.length === 2 && (fn !== jqLiteHasClass && fn !== jqLiteController) ? arg1 : arg2)) {
    if (isObject(arg1)) {
        for (i = 0; i < nodeCount; i++) {
            if (fn === jqLiteData) {
                fn(this[i], arg1);
            } else {
                for (key in arg1) {
                    fn(this[i], key, arg1[key]);
                }
            }
        }
        return this;
    } else {
        value = fn.$dv;
        jj = isUndefined(value) ? Math.min(nodeCount, 1) : nodeCount;
        for (var j = 0; j < jj; j++) {
            nodeValue = fn(this[j], arg1, arg2);
            value = value ? value + nodeValue : nodeValue;
        }
        return value;
    }
} else {
    for (i = 0; i < nodeCount; i++) {
        fn(this[i], arg1, arg2);
    }
    return this;
}});
    return;
case 8:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 8);
    ((JQLite.prototype, $__.os.oid6), $__.os.oid6)[name, 'css'] = ($__.fs.J$__v3645318688_251_303 = function J$__v3645318688_251(arg1, arg2) {
var vvv_return, vvv_switch, i, key, nodeCount, value, jj, nodeValue;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
arg1 = arguments[0], arg2 = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
nodeCount = this.length;
if (fn !== jqLiteEmpty && isUndefined(fn.length === 2 && (fn !== jqLiteHasClass && fn !== jqLiteController) ? arg1 : arg2)) {
    if (isObject(arg1)) {
        for (i = 0; i < nodeCount; i++) {
            if (fn === jqLiteData) {
                fn(this[i], arg1);
            } else {
                for (key in arg1) {
                    fn(this[i], key, arg1[key]);
                }
            }
        }
        return this;
    } else {
        value = fn.$dv;
        jj = isUndefined(value) ? Math.min(nodeCount, 1) : nodeCount;
        for (var j = 0; j < jj; j++) {
            nodeValue = fn(this[j], arg1, arg2);
            value = value ? value + nodeValue : nodeValue;
        }
        return value;
    }
} else {
    for (i = 0; i < nodeCount; i++) {
        fn(this[i], arg1, arg2);
    }
    return this;
}});
    return;
case 9:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 9);
    ((JQLite.prototype, $__.os.oid6), $__.os.oid6)[name, 'attr'] = ($__.fs.J$__v3645318688_251_304 = function J$__v3645318688_251(arg1, arg2) {
var vvv_return, vvv_switch, i, key, nodeCount, value, jj, nodeValue;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
arg1 = arguments[0], arg2 = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
nodeCount = this.length;
if (fn !== jqLiteEmpty && isUndefined(fn.length === 2 && (fn !== jqLiteHasClass && fn !== jqLiteController) ? arg1 : arg2)) {
    if (isObject(arg1)) {
        for (i = 0; i < nodeCount; i++) {
            if (fn === jqLiteData) {
                fn(this[i], arg1);
            } else {
                for (key in arg1) {
                    fn(this[i], key, arg1[key]);
                }
            }
        }
        return this;
    } else {
        value = fn.$dv;
        jj = isUndefined(value) ? Math.min(nodeCount, 1) : nodeCount;
        for (var j = 0; j < jj; j++) {
            nodeValue = fn(this[j], arg1, arg2);
            value = value ? value + nodeValue : nodeValue;
        }
        return value;
    }
} else {
    for (i = 0; i < nodeCount; i++) {
        fn(this[i], arg1, arg2);
    }
    return this;
}});
    return;
case 10:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 10);
    ((JQLite.prototype, $__.os.oid6), $__.os.oid6)[name, 'prop'] = ($__.fs.J$__v3645318688_251_305 = function J$__v3645318688_251(arg1, arg2) {
var vvv_return, vvv_switch, i, key, nodeCount, value, jj, nodeValue;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
arg1 = arguments[0], arg2 = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
nodeCount = this.length;
if (fn !== jqLiteEmpty && isUndefined(fn.length === 2 && (fn !== jqLiteHasClass && fn !== jqLiteController) ? arg1 : arg2)) {
    if (isObject(arg1)) {
        for (i = 0; i < nodeCount; i++) {
            if (fn === jqLiteData) {
                fn(this[i], arg1);
            } else {
                for (key in arg1) {
                    fn(this[i], key, arg1[key]);
                }
            }
        }
        return this;
    } else {
        value = fn.$dv;
        jj = isUndefined(value) ? Math.min(nodeCount, 1) : nodeCount;
        for (var j = 0; j < jj; j++) {
            nodeValue = fn(this[j], arg1, arg2);
            value = value ? value + nodeValue : nodeValue;
        }
        return value;
    }
} else {
    for (i = 0; i < nodeCount; i++) {
        fn(this[i], arg1, arg2);
    }
    return this;
}});
    return;
case 11:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 11);
    ((JQLite.prototype, $__.os.oid6), $__.os.oid6)[name, 'text'] = ($__.fs.J$__v3645318688_251_306 = function J$__v3645318688_251(arg1, arg2) {
var vvv_return, vvv_switch, i, key, nodeCount, value, jj, nodeValue;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
arg1 = arguments[0], arg2 = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
nodeCount = this.length;
if (fn !== jqLiteEmpty && isUndefined(fn.length === 2 && (fn !== jqLiteHasClass && fn !== jqLiteController) ? arg1 : arg2)) {
    if (isObject(arg1)) {
        for (i = 0; i < nodeCount; i++) {
            if (fn === jqLiteData) {
                fn(this[i], arg1);
            } else {
                for (key in arg1) {
                    fn(this[i], key, arg1[key]);
                }
            }
        }
        return this;
    } else {
        value = fn.$dv;
        jj = isUndefined(value) ? Math.min(nodeCount, 1) : nodeCount;
        for (var j = 0; j < jj; j++) {
            nodeValue = fn(this[j], arg1, arg2);
            value = value ? value + nodeValue : nodeValue;
        }
        return value;
    }
} else {
    for (i = 0; i < nodeCount; i++) {
        fn(this[i], arg1, arg2);
    }
    return this;
}});
    return;
case 12:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 12);
    ((JQLite.prototype, $__.os.oid6), $__.os.oid6)[name, 'val'] = ($__.fs.J$__v3645318688_251_307 = function J$__v3645318688_251(arg1, arg2) {
var vvv_return, vvv_switch, i, key, nodeCount, value, jj, nodeValue;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
arg1 = arguments[0], arg2 = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
nodeCount = this.length;
if (fn !== jqLiteEmpty && isUndefined(fn.length === 2 && (fn !== jqLiteHasClass && fn !== jqLiteController) ? arg1 : arg2)) {
    if (isObject(arg1)) {
        for (i = 0; i < nodeCount; i++) {
            if (fn === jqLiteData) {
                fn(this[i], arg1);
            } else {
                for (key in arg1) {
                    fn(this[i], key, arg1[key]);
                }
            }
        }
        return this;
    } else {
        value = fn.$dv;
        jj = isUndefined(value) ? Math.min(nodeCount, 1) : nodeCount;
        for (var j = 0; j < jj; j++) {
            nodeValue = fn(this[j], arg1, arg2);
            value = value ? value + nodeValue : nodeValue;
        }
        return value;
    }
} else {
    for (i = 0; i < nodeCount; i++) {
        fn(this[i], arg1, arg2);
    }
    return this;
}});
    return;
case 13:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 13);
    ((JQLite.prototype, $__.os.oid6), $__.os.oid6)[name, 'html'] = ($__.fs.J$__v3645318688_251_308 = function J$__v3645318688_251(arg1, arg2) {
var vvv_return, vvv_switch, i, key, nodeCount, value, jj, nodeValue;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
arg1 = arguments[0], arg2 = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
nodeCount = this.length;
if (fn !== jqLiteEmpty && isUndefined(fn.length === 2 && (fn !== jqLiteHasClass && fn !== jqLiteController) ? arg1 : arg2)) {
    if (isObject(arg1)) {
        for (i = 0; i < nodeCount; i++) {
            if (fn === jqLiteData) {
                fn(this[i], arg1);
            } else {
                for (key in arg1) {
                    fn(this[i], key, arg1[key]);
                }
            }
        }
        return this;
    } else {
        value = fn.$dv;
        jj = isUndefined(value) ? Math.min(nodeCount, 1) : nodeCount;
        for (var j = 0; j < jj; j++) {
            nodeValue = fn(this[j], arg1, arg2);
            value = value ? value + nodeValue : nodeValue;
        }
        return value;
    }
} else {
    for (i = 0; i < nodeCount; i++) {
        fn(this[i], arg1, arg2);
    }
    return this;
}});
    return;
case 14:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 14);
    ((JQLite.prototype, $__.os.oid6), $__.os.oid6)[name, 'empty'] = ($__.fs.J$__v3645318688_251_309 = function J$__v3645318688_251(arg1, arg2) {
var vvv_return, vvv_switch, i, key, nodeCount, value, jj, nodeValue;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
arg1 = arguments[0], arg2 = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
nodeCount = this.length;
if (fn !== jqLiteEmpty && isUndefined(fn.length === 2 && (fn !== jqLiteHasClass && fn !== jqLiteController) ? arg1 : arg2)) {
    if (isObject(arg1)) {
        for (i = 0; i < nodeCount; i++) {
            if (fn === jqLiteData) {
                fn(this[i], arg1);
            } else {
                for (key in arg1) {
                    fn(this[i], key, arg1[key]);
                }
            }
        }
        return this;
    } else {
        value = fn.$dv;
        jj = isUndefined(value) ? Math.min(nodeCount, 1) : nodeCount;
        for (var j = 0; j < jj; j++) {
            nodeValue = fn(this[j], arg1, arg2);
            value = value ? value + nodeValue : nodeValue;
        }
        return value;
    }
} else {
    for (i = 0; i < nodeCount; i++) {
        fn(this[i], arg1, arg2);
    }
    return this;
}});
    return;
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
JQLite.prototype[name] = function (arg1, arg2) {
    var i, key;
    var nodeCount = this.length;
    if (fn !== jqLiteEmpty && isUndefined(fn.length === 2 && (fn !== jqLiteHasClass && fn !== jqLiteController) ? arg1 : arg2)) {
        if (isObject(arg1)) {
            for (i = 0; i < nodeCount; i++) {
                if (fn === jqLiteData) {
                    fn(this[i], arg1);
                } else {
                    for (key in arg1) {
                        fn(this[i], key, arg1[key]);
                    }
                }
            }
            return this;
        } else {
            var value = fn.$dv;
            var jj = isUndefined(value) ? Math.min(nodeCount, 1) : nodeCount;
            for (var j = 0; j < jj; j++) {
                var nodeValue = fn(this[j], arg1, arg2);
                value = value ? value + nodeValue : nodeValue;
            }
            return value;
        }
    } else {
        for (i = 0; i < nodeCount; i++) {
            fn(this[i], arg1, arg2);
        }
        return this;
    }
};}, $__.fs.J$__v3645318688_253_294), 3, true, $__.uid);
    (forEach, $__.fs.forEach_8)($__.os.oid12 = {
        'removeData': jqLiteRemoveData,
        'on': ($__.fs.jqLiteOn_310 = function jqLiteOn(element, type, fn, unsupported) {
var vvv_return, vvv_switch, expandoStore, events, handle, types, i, addHandler;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
element = arguments[0], type = arguments[1], fn = arguments[2], unsupported = arguments[3];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (isDefined(unsupported))
    throw jqLiteMinErr('onargs', 'jqLite#on() does not support the `selector` or `eventData` parameters');
if (!jqLiteAcceptsData(element)) {
    return;
}
expandoStore = jqLiteExpandoStore(element, true);
events = expandoStore.events;
handle = expandoStore.handle;
if (!handle) {
    handle = expandoStore.handle = createEventHandler(element, events);
}
types = type.indexOf(' ') >= 0 ? type.split(' ') : [type];
i = types.length;
addHandler = function (type, specialHandlerWrapper, noEventListener) {
    var eventFns = events[type];
    if (!eventFns) {
        eventFns = events[type] = [];
        eventFns.specialHandlerWrapper = specialHandlerWrapper;
        if (type !== '$destroy' && !noEventListener) {
            element.addEventListener(type, handle);
        }
    }
    eventFns.push(fn);
};
while (i--) {
    type = types[i];
    if (MOUSE_EVENT_MAP[type]) {
        addHandler(MOUSE_EVENT_MAP[type], specialMouseHandlerWrapper);
        addHandler(type, undefined, true);
    } else {
        addHandler(type);
    }
}}, $__.fs.jqLiteOn_310_56 = $__.fs.jqLiteOn_310, $__.fs.jqLiteOn_310),
        'off': jqLiteOff,
        'one': ($__.fs.J$__v3645318688_270_311 = function J$__v3645318688_270(element, type, fn) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
element = arguments[0], type = arguments[1], fn = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
element = jqLite(element);
element.on(type, function onFn() {
    element.off(type, fn);
    element.off(type, onFn);
});
element.on(type, fn);}, $__.fs.J$__v3645318688_270_311_60 = $__.fs.J$__v3645318688_270_311, $__.fs.J$__v3645318688_270_311),
        'replaceWith': ($__.fs.J$__v3645318688_274_312 = function J$__v3645318688_274(element, replaceNode) {
var vvv_return, vvv_switch, index, parent;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
element = arguments[0], replaceNode = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
parent = element.parentNode;
jqLiteDealoc(element);
forEach(new JQLite(replaceNode), function (node) {
    if (index) {
        parent.insertBefore(node, index.nextSibling);
    } else {
        parent.replaceChild(node, element);
    }
    index = node;
});}, $__.fs.J$__v3645318688_274_312_62 = $__.fs.J$__v3645318688_274_312, $__.fs.J$__v3645318688_274_312),
        'children': ($__.fs.J$__v3645318688_278_313 = function J$__v3645318688_278(element) {
var vvv_return, vvv_switch, children;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
element = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
children = [];
forEach(element.childNodes, function (element) {
    if (element.nodeType === NODE_TYPE_ELEMENT) {
        children.push(element);
    }
});
return children;}, $__.fs.J$__v3645318688_278_313_64 = $__.fs.J$__v3645318688_278_313, $__.fs.J$__v3645318688_278_313),
        'contents': ($__.fs.J$__v3645318688_280_314 = function J$__v3645318688_280(element) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
element = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return element.contentDocument || element.childNodes || [];}, $__.fs.J$__v3645318688_280_314_66 = $__.fs.J$__v3645318688_280_314, $__.fs.J$__v3645318688_280_314),
        'append': ($__.fs.J$__v3645318688_282_315 = function J$__v3645318688_282(element, node) {
var vvv_return, vvv_switch, nodeType, child;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
element = arguments[0], node = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
nodeType = element.nodeType;
if (nodeType !== NODE_TYPE_ELEMENT && nodeType !== NODE_TYPE_DOCUMENT_FRAGMENT)
    return;
node = new JQLite(node);
for (var i = 0, ii = node.length; i < ii; i++) {
    child = node[i];
    element.appendChild(child);
}}, $__.fs.J$__v3645318688_282_315_68 = $__.fs.J$__v3645318688_282_315, $__.fs.J$__v3645318688_282_315),
        'prepend': ($__.fs.J$__v3645318688_286_316 = function J$__v3645318688_286(element, node) {
var vvv_return, vvv_switch, index;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
element = arguments[0], node = arguments[1];
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    (element.nodeType, 1) === NODE_TYPE_ELEMENT;
    index = TAJS_restrictToType(element.firstChild, 'HTMLMetaElement');
    (forEach, $__.fs.forEach_8)(new (JQLite, $__.fs.JQLite_93)(node, 4, true, $__.uid), ($__.fs.J$__v3645318688_284_723 = function J$__v3645318688_284(child) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
child = arguments[0];
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    element['insertBefore'](child, index);
    return;
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
element.insertBefore(child, index);}, $__.fs.J$__v3645318688_284_723), 13, true, $__.uid);
    return;
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (element.nodeType === NODE_TYPE_ELEMENT) {
    index = element.firstChild;
    forEach(new JQLite(node), function (child) {
        element.insertBefore(child, index);
    });
}}, $__.fs.J$__v3645318688_286_316_70 = ((function $_mk($_f, ids, isOneShotEscapingFunction) {
    TAJS_makeContextSensitive($_mk, 1);
    TAJS_makeContextSensitive($_mk, 2);
    var nxt = 0;
    function J$__v3645318688_286(element, node) {
        arguments[arguments.length] = ids[nxt];
        arguments[arguments.length + 1] = isOneShotEscapingFunction;
        arguments[arguments.length + 2] = $__.uid;
        arguments.length += 3;
        if (!isOneShotEscapingFunction) {
            ++nxt;
        }
        return $_f.apply(this, arguments);
    };
    TAJS_makeContextSensitive(J$__v3645318688_286, -2);
    return J$__v3645318688_286;
})($__.fs.J$__v3645318688_286_316, [0], false)), $__.fs.J$__v3645318688_286_316),
        'wrap': ($__.fs.J$__v3645318688_288_317 = function J$__v3645318688_288(element, wrapNode) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
element = arguments[0], wrapNode = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
jqLiteWrapNode(element, jqLite(wrapNode).eq(0).clone()[0]);}, $__.fs.J$__v3645318688_288_317_72 = $__.fs.J$__v3645318688_288_317, $__.fs.J$__v3645318688_288_317),
        'remove': jqLiteRemove,
        'detach': ($__.fs.J$__v3645318688_290_318 = function J$__v3645318688_290(element) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
element = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
jqLiteRemove(element, true);}, $__.fs.J$__v3645318688_290_318_76 = $__.fs.J$__v3645318688_290_318, $__.fs.J$__v3645318688_290_318),
        'after': ($__.fs.J$__v3645318688_292_319 = function J$__v3645318688_292(element, newElement) {
var vvv_return, vvv_switch, index, parent, node;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
element = arguments[0], newElement = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
index = element;
parent = element.parentNode;
if (parent) {
    newElement = new JQLite(newElement);
    for (var i = 0, ii = newElement.length; i < ii; i++) {
        node = newElement[i];
        parent.insertBefore(node, index.nextSibling);
        index = node;
    }
}}, $__.fs.J$__v3645318688_292_319_78 = $__.fs.J$__v3645318688_292_319, $__.fs.J$__v3645318688_292_319),
        'addClass': jqLiteAddClass,
        'removeClass': jqLiteRemoveClass,
        'toggleClass': ($__.fs.J$__v3645318688_296_320 = function J$__v3645318688_296(element, selector, condition) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
element = arguments[0], selector = arguments[1], condition = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (selector) {
    forEach(selector.split(' '), function (className) {
        var classCondition = condition;
        if (isUndefined(classCondition)) {
            classCondition = !jqLiteHasClass(element, className);
        }
        (classCondition ? jqLiteAddClass : jqLiteRemoveClass)(element, className);
    });
}}, $__.fs.J$__v3645318688_296_320_84 = $__.fs.J$__v3645318688_296_320, $__.fs.J$__v3645318688_296_320),
        'parent': ($__.fs.J$__v3645318688_298_321 = function J$__v3645318688_298(element) {
var vvv_return, vvv_switch, parent;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
element = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
parent = element.parentNode;
return parent && parent.nodeType !== NODE_TYPE_DOCUMENT_FRAGMENT ? parent : null;}, $__.fs.J$__v3645318688_298_321_86 = $__.fs.J$__v3645318688_298_321, $__.fs.J$__v3645318688_298_321),
        'next': ($__.fs.J$__v3645318688_300_322 = function J$__v3645318688_300(element) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
element = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return element.nextElementSibling;}, $__.fs.J$__v3645318688_300_322_88 = $__.fs.J$__v3645318688_300_322, $__.fs.J$__v3645318688_300_322),
        'find': ($__.fs.J$__v3645318688_302_323 = function J$__v3645318688_302(element, selector) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
element = arguments[0], selector = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (element.getElementsByTagName) {
    return element.getElementsByTagName(selector);
} else {
    return [];
}}, $__.fs.J$__v3645318688_302_323_90 = $__.fs.J$__v3645318688_302_323, $__.fs.J$__v3645318688_302_323),
        'clone': jqLiteClone,
        'triggerHandler': ($__.fs.J$__v3645318688_314_324 = function J$__v3645318688_314(element, event, extraParameters) {
var vvv_return, vvv_switch, dummyEvent, eventFnsCopy, handlerArgs, eventName, expandoStore, events, eventFns;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
element = arguments[0], event = arguments[1], extraParameters = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
eventName = event.type || event;
expandoStore = jqLiteExpandoStore(element);
events = expandoStore && expandoStore.events;
eventFns = events && events[eventName];
if (eventFns) {
    dummyEvent = {
        preventDefault: function () {
            this.defaultPrevented = true;
        },
        isDefaultPrevented: function () {
            return this.defaultPrevented === true;
        },
        stopImmediatePropagation: function () {
            this.immediatePropagationStopped = true;
        },
        isImmediatePropagationStopped: function () {
            return this.immediatePropagationStopped === true;
        },
        stopPropagation: noop,
        type: eventName,
        target: element
    };
    if (event.type) {
        dummyEvent = extend(dummyEvent, event);
    }
    eventFnsCopy = shallowCopy(eventFns);
    handlerArgs = extraParameters ? [dummyEvent].concat(extraParameters) : [dummyEvent];
    forEach(eventFnsCopy, function (fn) {
        if (!dummyEvent.isImmediatePropagationStopped()) {
            fn.apply(element, handlerArgs);
        }
    });
}}, $__.fs.J$__v3645318688_314_324_94 = $__.fs.J$__v3645318688_314_324, $__.fs.J$__v3645318688_314_324)
    }, ($__.fs.J$__v3645318688_318_325 = function J$__v3645318688_318(fn, name) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
fn = arguments[0], name = arguments[1];
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    ((JQLite.prototype, $__.os.oid6), $__.os.oid6)[name, 'removeData'] = ($__.fs.J$__v3645318688_316_326 = function J$__v3645318688_316(arg1, arg2, arg3) {
var vvv_return, vvv_switch, value;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
arg1 = arguments[0], arg2 = arguments[1], arg3 = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
for (var i = 0, ii = this.length; i < ii; i++) {
    if (isUndefined(value)) {
        value = fn(this[i], arg1, arg2, arg3);
        if (isDefined(value)) {
            value = jqLite(value);
        }
    } else {
        jqLiteAddNodes(value, fn(this[i], arg1, arg2, arg3));
    }
}
return isDefined(value) ? value : this;});
    return;
case 1:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 1);
    ((JQLite.prototype, $__.os.oid6), $__.os.oid6)[name, 'on'] = ($__.fs.J$__v3645318688_316_327 = function J$__v3645318688_316(arg1, arg2, arg3) {
var vvv_return, vvv_switch, value;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
arg1 = arguments[0], arg2 = arguments[1], arg3 = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
for (var i = 0, ii = this.length; i < ii; i++) {
    if (isUndefined(value)) {
        value = fn(this[i], arg1, arg2, arg3);
        if (isDefined(value)) {
            value = jqLite(value);
        }
    } else {
        jqLiteAddNodes(value, fn(this[i], arg1, arg2, arg3));
    }
}
return isDefined(value) ? value : this;});
    return;
case 2:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 2);
    ((JQLite.prototype, $__.os.oid6), $__.os.oid6)[name, 'off'] = ($__.fs.J$__v3645318688_316_328 = function J$__v3645318688_316(arg1, arg2, arg3) {
var vvv_return, vvv_switch, value;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
arg1 = arguments[0], arg2 = arguments[1], arg3 = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
for (var i = 0, ii = this.length; i < ii; i++) {
    if (isUndefined(value)) {
        value = fn(this[i], arg1, arg2, arg3);
        if (isDefined(value)) {
            value = jqLite(value);
        }
    } else {
        jqLiteAddNodes(value, fn(this[i], arg1, arg2, arg3));
    }
}
return isDefined(value) ? value : this;});
    return;
case 3:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 3);
    ((JQLite.prototype, $__.os.oid6), $__.os.oid6)[name, 'one'] = ($__.fs.J$__v3645318688_316_329 = function J$__v3645318688_316(arg1, arg2, arg3) {
var vvv_return, vvv_switch, value;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
arg1 = arguments[0], arg2 = arguments[1], arg3 = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
for (var i = 0, ii = this.length; i < ii; i++) {
    if (isUndefined(value)) {
        value = fn(this[i], arg1, arg2, arg3);
        if (isDefined(value)) {
            value = jqLite(value);
        }
    } else {
        jqLiteAddNodes(value, fn(this[i], arg1, arg2, arg3));
    }
}
return isDefined(value) ? value : this;});
    return;
case 4:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 4);
    ((JQLite.prototype, $__.os.oid6), $__.os.oid6)[name, 'replaceWith'] = ($__.fs.J$__v3645318688_316_330 = function J$__v3645318688_316(arg1, arg2, arg3) {
var vvv_return, vvv_switch, value;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
arg1 = arguments[0], arg2 = arguments[1], arg3 = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
for (var i = 0, ii = this.length; i < ii; i++) {
    if (isUndefined(value)) {
        value = fn(this[i], arg1, arg2, arg3);
        if (isDefined(value)) {
            value = jqLite(value);
        }
    } else {
        jqLiteAddNodes(value, fn(this[i], arg1, arg2, arg3));
    }
}
return isDefined(value) ? value : this;});
    return;
case 5:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 5);
    ((JQLite.prototype, $__.os.oid6), $__.os.oid6)[name, 'children'] = ($__.fs.J$__v3645318688_316_331 = function J$__v3645318688_316(arg1, arg2, arg3) {
var vvv_return, vvv_switch, value;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
arg1 = arguments[0], arg2 = arguments[1], arg3 = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
for (var i = 0, ii = this.length; i < ii; i++) {
    if (isUndefined(value)) {
        value = fn(this[i], arg1, arg2, arg3);
        if (isDefined(value)) {
            value = jqLite(value);
        }
    } else {
        jqLiteAddNodes(value, fn(this[i], arg1, arg2, arg3));
    }
}
return isDefined(value) ? value : this;});
    return;
case 6:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 6);
    ((JQLite.prototype, $__.os.oid6), $__.os.oid6)[name, 'contents'] = ($__.fs.J$__v3645318688_316_332 = function J$__v3645318688_316(arg1, arg2, arg3) {
var vvv_return, vvv_switch, value;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
arg1 = arguments[0], arg2 = arguments[1], arg3 = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
for (var i = 0, ii = this.length; i < ii; i++) {
    if (isUndefined(value)) {
        value = fn(this[i], arg1, arg2, arg3);
        if (isDefined(value)) {
            value = jqLite(value);
        }
    } else {
        jqLiteAddNodes(value, fn(this[i], arg1, arg2, arg3));
    }
}
return isDefined(value) ? value : this;});
    return;
case 7:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 7);
    ((JQLite.prototype, $__.os.oid6), $__.os.oid6)[name, 'append'] = ($__.fs.J$__v3645318688_316_333 = function J$__v3645318688_316(arg1, arg2, arg3) {
var vvv_return, vvv_switch, value;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
arg1 = arguments[0], arg2 = arguments[1], arg3 = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
for (var i = 0, ii = this.length; i < ii; i++) {
    if (isUndefined(value)) {
        value = fn(this[i], arg1, arg2, arg3);
        if (isDefined(value)) {
            value = jqLite(value);
        }
    } else {
        jqLiteAddNodes(value, fn(this[i], arg1, arg2, arg3));
    }
}
return isDefined(value) ? value : this;});
    return;
case 8:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 8);
    ((JQLite.prototype, $__.os.oid6), $__.os.oid6)[name, 'prepend'] = ($__.fs.J$__v3645318688_316_334 = function J$__v3645318688_316(arg1, arg2, arg3) {
var vvv_return, vvv_switch, value, i, ii;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
arg1 = arguments[0], arg2 = arguments[1], arg3 = arguments[2];
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    i = 0;
    ii = (this.length, 1);
    i < ii;
    (isUndefined, $__.fs.isUndefined_22)(value, 1, true, $__.uid);
    value = (fn, $__.fs.J$__v3645318688_286_316)(TAJS_restrictToType(this[i, 0], 'HTMLHeadElement'), arg1, arg2, arg3, 0, true, $__.uid);
    (isDefined, $__.fs.isDefined_23)(value, 3, true, $__.uid);
    (i = +i + 1) - 1;
    i < ii;
    return (isDefined, $__.fs.isDefined_23)(value, 4, true, $__.uid), this;
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
for (var i = 0, ii = this.length; i < ii; i++) {
    if (isUndefined(value)) {
        value = fn(this[i], arg1, arg2, arg3);
        if (isDefined(value)) {
            value = jqLite(value);
        }
    } else {
        jqLiteAddNodes(value, fn(this[i], arg1, arg2, arg3));
    }
}
return isDefined(value) ? value : this;});
    return;
case 9:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 9);
    ((JQLite.prototype, $__.os.oid6), $__.os.oid6)[name, 'wrap'] = ($__.fs.J$__v3645318688_316_335 = function J$__v3645318688_316(arg1, arg2, arg3) {
var vvv_return, vvv_switch, value;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
arg1 = arguments[0], arg2 = arguments[1], arg3 = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
for (var i = 0, ii = this.length; i < ii; i++) {
    if (isUndefined(value)) {
        value = fn(this[i], arg1, arg2, arg3);
        if (isDefined(value)) {
            value = jqLite(value);
        }
    } else {
        jqLiteAddNodes(value, fn(this[i], arg1, arg2, arg3));
    }
}
return isDefined(value) ? value : this;});
    return;
case 10:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 10);
    ((JQLite.prototype, $__.os.oid6), $__.os.oid6)[name, 'remove'] = ($__.fs.J$__v3645318688_316_336 = function J$__v3645318688_316(arg1, arg2, arg3) {
var vvv_return, vvv_switch, value;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
arg1 = arguments[0], arg2 = arguments[1], arg3 = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
for (var i = 0, ii = this.length; i < ii; i++) {
    if (isUndefined(value)) {
        value = fn(this[i], arg1, arg2, arg3);
        if (isDefined(value)) {
            value = jqLite(value);
        }
    } else {
        jqLiteAddNodes(value, fn(this[i], arg1, arg2, arg3));
    }
}
return isDefined(value) ? value : this;});
    return;
case 11:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 11);
    ((JQLite.prototype, $__.os.oid6), $__.os.oid6)[name, 'detach'] = ($__.fs.J$__v3645318688_316_337 = function J$__v3645318688_316(arg1, arg2, arg3) {
var vvv_return, vvv_switch, value;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
arg1 = arguments[0], arg2 = arguments[1], arg3 = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
for (var i = 0, ii = this.length; i < ii; i++) {
    if (isUndefined(value)) {
        value = fn(this[i], arg1, arg2, arg3);
        if (isDefined(value)) {
            value = jqLite(value);
        }
    } else {
        jqLiteAddNodes(value, fn(this[i], arg1, arg2, arg3));
    }
}
return isDefined(value) ? value : this;});
    return;
case 12:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 12);
    ((JQLite.prototype, $__.os.oid6), $__.os.oid6)[name, 'after'] = ($__.fs.J$__v3645318688_316_338 = function J$__v3645318688_316(arg1, arg2, arg3) {
var vvv_return, vvv_switch, value;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
arg1 = arguments[0], arg2 = arguments[1], arg3 = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
for (var i = 0, ii = this.length; i < ii; i++) {
    if (isUndefined(value)) {
        value = fn(this[i], arg1, arg2, arg3);
        if (isDefined(value)) {
            value = jqLite(value);
        }
    } else {
        jqLiteAddNodes(value, fn(this[i], arg1, arg2, arg3));
    }
}
return isDefined(value) ? value : this;});
    return;
case 13:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 13);
    ((JQLite.prototype, $__.os.oid6), $__.os.oid6)[name, 'addClass'] = ($__.fs.J$__v3645318688_316_339 = function J$__v3645318688_316(arg1, arg2, arg3) {
var vvv_return, vvv_switch, value;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
arg1 = arguments[0], arg2 = arguments[1], arg3 = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
for (var i = 0, ii = this.length; i < ii; i++) {
    if (isUndefined(value)) {
        value = fn(this[i], arg1, arg2, arg3);
        if (isDefined(value)) {
            value = jqLite(value);
        }
    } else {
        jqLiteAddNodes(value, fn(this[i], arg1, arg2, arg3));
    }
}
return isDefined(value) ? value : this;});
    return;
case 14:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 14);
    ((JQLite.prototype, $__.os.oid6), $__.os.oid6)[name, 'removeClass'] = ($__.fs.J$__v3645318688_316_340 = function J$__v3645318688_316(arg1, arg2, arg3) {
var vvv_return, vvv_switch, value;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
arg1 = arguments[0], arg2 = arguments[1], arg3 = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
for (var i = 0, ii = this.length; i < ii; i++) {
    if (isUndefined(value)) {
        value = fn(this[i], arg1, arg2, arg3);
        if (isDefined(value)) {
            value = jqLite(value);
        }
    } else {
        jqLiteAddNodes(value, fn(this[i], arg1, arg2, arg3));
    }
}
return isDefined(value) ? value : this;});
    return;
case 15:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 15);
    ((JQLite.prototype, $__.os.oid6), $__.os.oid6)[name, 'toggleClass'] = ($__.fs.J$__v3645318688_316_341 = function J$__v3645318688_316(arg1, arg2, arg3) {
var vvv_return, vvv_switch, value;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
arg1 = arguments[0], arg2 = arguments[1], arg3 = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
for (var i = 0, ii = this.length; i < ii; i++) {
    if (isUndefined(value)) {
        value = fn(this[i], arg1, arg2, arg3);
        if (isDefined(value)) {
            value = jqLite(value);
        }
    } else {
        jqLiteAddNodes(value, fn(this[i], arg1, arg2, arg3));
    }
}
return isDefined(value) ? value : this;});
    return;
case 16:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 16);
    ((JQLite.prototype, $__.os.oid6), $__.os.oid6)[name, 'parent'] = ($__.fs.J$__v3645318688_316_342 = function J$__v3645318688_316(arg1, arg2, arg3) {
var vvv_return, vvv_switch, value;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
arg1 = arguments[0], arg2 = arguments[1], arg3 = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
for (var i = 0, ii = this.length; i < ii; i++) {
    if (isUndefined(value)) {
        value = fn(this[i], arg1, arg2, arg3);
        if (isDefined(value)) {
            value = jqLite(value);
        }
    } else {
        jqLiteAddNodes(value, fn(this[i], arg1, arg2, arg3));
    }
}
return isDefined(value) ? value : this;});
    return;
case 17:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 17);
    ((JQLite.prototype, $__.os.oid6), $__.os.oid6)[name, 'next'] = ($__.fs.J$__v3645318688_316_343 = function J$__v3645318688_316(arg1, arg2, arg3) {
var vvv_return, vvv_switch, value;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
arg1 = arguments[0], arg2 = arguments[1], arg3 = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
for (var i = 0, ii = this.length; i < ii; i++) {
    if (isUndefined(value)) {
        value = fn(this[i], arg1, arg2, arg3);
        if (isDefined(value)) {
            value = jqLite(value);
        }
    } else {
        jqLiteAddNodes(value, fn(this[i], arg1, arg2, arg3));
    }
}
return isDefined(value) ? value : this;});
    return;
case 18:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 18);
    ((JQLite.prototype, $__.os.oid6), $__.os.oid6)[name, 'find'] = ($__.fs.J$__v3645318688_316_344 = function J$__v3645318688_316(arg1, arg2, arg3) {
var vvv_return, vvv_switch, value;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
arg1 = arguments[0], arg2 = arguments[1], arg3 = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
for (var i = 0, ii = this.length; i < ii; i++) {
    if (isUndefined(value)) {
        value = fn(this[i], arg1, arg2, arg3);
        if (isDefined(value)) {
            value = jqLite(value);
        }
    } else {
        jqLiteAddNodes(value, fn(this[i], arg1, arg2, arg3));
    }
}
return isDefined(value) ? value : this;});
    return;
case 19:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 19);
    ((JQLite.prototype, $__.os.oid6), $__.os.oid6)[name, 'clone'] = ($__.fs.J$__v3645318688_316_345 = function J$__v3645318688_316(arg1, arg2, arg3) {
var vvv_return, vvv_switch, value;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
arg1 = arguments[0], arg2 = arguments[1], arg3 = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
for (var i = 0, ii = this.length; i < ii; i++) {
    if (isUndefined(value)) {
        value = fn(this[i], arg1, arg2, arg3);
        if (isDefined(value)) {
            value = jqLite(value);
        }
    } else {
        jqLiteAddNodes(value, fn(this[i], arg1, arg2, arg3));
    }
}
return isDefined(value) ? value : this;});
    return;
case 20:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 20);
    ((JQLite.prototype, $__.os.oid6), $__.os.oid6)[name, 'triggerHandler'] = ($__.fs.J$__v3645318688_316_346 = function J$__v3645318688_316(arg1, arg2, arg3) {
var vvv_return, vvv_switch, value;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
arg1 = arguments[0], arg2 = arguments[1], arg3 = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
for (var i = 0, ii = this.length; i < ii; i++) {
    if (isUndefined(value)) {
        value = fn(this[i], arg1, arg2, arg3);
        if (isDefined(value)) {
            value = jqLite(value);
        }
    } else {
        jqLiteAddNodes(value, fn(this[i], arg1, arg2, arg3));
    }
}
return isDefined(value) ? value : this;});
    return;
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
JQLite.prototype[name] = function (arg1, arg2, arg3) {
    var value;
    for (var i = 0, ii = this.length; i < ii; i++) {
        if (isUndefined(value)) {
            value = fn(this[i], arg1, arg2, arg3);
            if (isDefined(value)) {
                value = jqLite(value);
            }
        } else {
            jqLiteAddNodes(value, fn(this[i], arg1, arg2, arg3));
        }
    }
    return isDefined(value) ? value : this;
};}, $__.fs.J$__v3645318688_318_325), 4, true, $__.uid);
    ((JQLite.prototype, $__.os.oid6), $__.os.oid6).bind = TAJS_restrictToType(((JQLite.prototype, $__.os.oid6), $__.os.oid6).on, 'function');
    ((JQLite.prototype, $__.os.oid6), $__.os.oid6).unbind = TAJS_restrictToType(((JQLite.prototype, $__.os.oid6), $__.os.oid6).off, 'function');
    nanKey = Object['create'](null);
    NgMapShim.prototype = $__.os.oid13 = {
        '_idx': ($__.fs.J$__v3645318688_330_347 = function J$__v3645318688_330(key) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
key = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (key === this._lastKey) {
    return this._lastIndex;
}
this._lastKey = key;
this._lastIndex = this._keys.indexOf(key);
return this._lastIndex;}),
        '_transformKey': ($__.fs.J$__v3645318688_332_348 = function J$__v3645318688_332(key) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
key = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return isNumberNaN(key) ? nanKey : key;}),
        'get': ($__.fs.J$__v3645318688_334_349 = function J$__v3645318688_334(key) {
var vvv_return, vvv_switch, idx;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
key = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
key = this._transformKey(key);
idx = this._idx(key);
if (idx !== -1) {
    return this._values[idx];
}}),
        'set': ($__.fs.J$__v3645318688_336_350 = function J$__v3645318688_336(key, value) {
var vvv_return, vvv_switch, idx;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
key = arguments[0], value = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
key = this._transformKey(key);
idx = this._idx(key);
if (idx === -1) {
    idx = this._lastIndex = this._keys.length;
}
this._keys[idx] = key;
this._values[idx] = value;}),
        'delete': ($__.fs.J$__v3645318688_338_351 = function J$__v3645318688_338(key) {
var vvv_return, vvv_switch, idx;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
key = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
key = this._transformKey(key);
idx = this._idx(key);
if (idx === -1) {
    return false;
}
this._keys.splice(idx, 1);
this._values.splice(idx, 1);
this._lastKey = NaN;
this._lastIndex = -1;
return true;})
    };
    NgMap = NgMapShim;
    $$MapProvider = [($__.fs.J$__v3645318688_342_352 = function J$__v3645318688_342() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.$get = [function () {
        return NgMap;
    }];})];
    ARROW_ARG = /^([^(]+?)=>/;
    FN_ARGS = /^[^(]*\(\s*([^)]*)\)/m;
    FN_ARG_SPLIT = /,/;
    FN_ARG = /^\s*(_?)(\S+?)\1\s*$/;
    STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/gm;
    $injectorMinErr = (minErr, $__.fs.minErr_4)('$injector', 2, true, $__.uid);
    createInjector.$$annotate = annotate;
    $animateMinErr = (minErr, $__.fs.minErr_4)('$animate', 3, true, $__.uid);
    ELEMENT_NODE = 1;
    NG_ANIMATE_CLASSNAME = 'ng-animate';
    $$CoreAnimateJsProvider = ($__.fs.J$__v3645318688_407_355 = function J$__v3645318688_407() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.$get = noop;});
    $$CoreAnimateQueueProvider = ($__.fs.J$__v3645318688_424_356 = function J$__v3645318688_424() {
var vvv_return, vvv_switch, postDigestQueue, postDigestElements;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
postDigestQueue = new NgMap();
postDigestElements = [];
this.$get = [
    '$$AnimateRunner',
    '$rootScope',
    function ($$AnimateRunner, $rootScope) {
        return {
            enabled: noop,
            on: noop,
            off: noop,
            pin: noop,
            push: function (element, event, options, domOperation) {
                if (domOperation) {
                    domOperation();
                }
                options = options || {};
                if (options.from) {
                    element.css(options.from);
                }
                if (options.to) {
                    element.css(options.to);
                }
                if (options.addClass || options.removeClass) {
                    addRemoveClassesPostDigest(element, options.addClass, options.removeClass);
                }
                var runner = new $$AnimateRunner();
                runner.complete();
                return runner;
            }
        };
        function updateData(data, classes, value) {
            var changed = false;
            if (classes) {
                classes = isString(classes) ? classes.split(' ') : isArray(classes) ? classes : [];
                forEach(classes, function (className) {
                    if (className) {
                        changed = true;
                        data[className] = value;
                    }
                });
            }
            return changed;
        }
        function handleCSSClassChanges() {
            forEach(postDigestElements, function (element) {
                var data = postDigestQueue.get(element);
                if (data) {
                    var existing = splitClasses(element.attr('class'));
                    var toAdd = '';
                    var toRemove = '';
                    forEach(data, function (status, className) {
                        var hasClass = !!existing[className];
                        if (status !== hasClass) {
                            if (status) {
                                toAdd += (toAdd.length ? ' ' : '') + className;
                            } else {
                                toRemove += (toRemove.length ? ' ' : '') + className;
                            }
                        }
                    });
                    forEach(element, function (elm) {
                        if (toAdd) {
                            jqLiteAddClass(elm, toAdd);
                        }
                        if (toRemove) {
                            jqLiteRemoveClass(elm, toRemove);
                        }
                    });
                    postDigestQueue.delete(element);
                }
            });
            postDigestElements.length = 0;
        }
        function addRemoveClassesPostDigest(element, add, remove) {
            var data = postDigestQueue.get(element) || {};
            var classesAdded = updateData(data, add, true);
            var classesRemoved = updateData(data, remove, false);
            if (classesAdded || classesRemoved) {
                postDigestQueue.set(element, data);
                postDigestElements.push(element);
                if (postDigestElements.length === 1) {
                    $rootScope.$$postDigest(handleCSSClassChanges);
                }
            }
        }
    }
];});
    $AnimateProvider = [
        '$provide',
        ($__.fs.J$__v3645318688_451_357 = function J$__v3645318688_451($provide) {
var vvv_return, vvv_switch, provider, classNameFilter;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
$provide = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
provider = this;
classNameFilter = null;
this.$$registeredAnimations = Object.create(null);
this.register = function (name, factory) {
    if (name && name.charAt(0) !== '.') {
        throw $animateMinErr('notcsel', 'Expecting class selector starting with \'.\' got \'{0}\'.', name);
    }
    var key = name + '-animation';
    provider.$$registeredAnimations[name.substr(1)] = key;
    $provide.factory(key, factory);
};
this.classNameFilter = function (expression) {
    if (arguments.length === 1) {
        classNameFilter = expression instanceof RegExp ? expression : null;
        if (classNameFilter) {
            var reservedRegex = new RegExp('[(\\s|\\/)]' + NG_ANIMATE_CLASSNAME + '[(\\s|\\/)]');
            if (reservedRegex.test(classNameFilter.toString())) {
                classNameFilter = null;
                throw $animateMinErr('nongcls', '$animateProvider.classNameFilter(regex) prohibits accepting a regex value which matches/contains the "{0}" CSS class.', NG_ANIMATE_CLASSNAME);
            }
        }
    }
    return classNameFilter;
};
this.$get = [
    '$$animateQueue',
    function ($$animateQueue) {
        function domInsert(element, parentElement, afterElement) {
            if (afterElement) {
                var afterNode = extractElementNode(afterElement);
                if (afterNode && !afterNode.parentNode && !afterNode.previousElementSibling) {
                    afterElement = null;
                }
            }
            if (afterElement) {
                afterElement.after(element);
            } else {
                parentElement.prepend(element);
            }
        }
        return {
            on: $$animateQueue.on,
            off: $$animateQueue.off,
            pin: $$animateQueue.pin,
            enabled: $$animateQueue.enabled,
            cancel: function (runner) {
                if (runner.end) {
                    runner.end();
                }
            },
            enter: function (element, parent, after, options) {
                parent = parent && jqLite(parent);
                after = after && jqLite(after);
                parent = parent || after.parent();
                domInsert(element, parent, after);
                return $$animateQueue.push(element, 'enter', prepareAnimateOptions(options));
            },
            move: function (element, parent, after, options) {
                parent = parent && jqLite(parent);
                after = after && jqLite(after);
                parent = parent || after.parent();
                domInsert(element, parent, after);
                return $$animateQueue.push(element, 'move', prepareAnimateOptions(options));
            },
            leave: function (element, options) {
                return $$animateQueue.push(element, 'leave', prepareAnimateOptions(options), function () {
                    element.remove();
                });
            },
            addClass: function (element, className, options) {
                options = prepareAnimateOptions(options);
                options.addClass = mergeClasses(options.addclass, className);
                return $$animateQueue.push(element, 'addClass', options);
            },
            removeClass: function (element, className, options) {
                options = prepareAnimateOptions(options);
                options.removeClass = mergeClasses(options.removeClass, className);
                return $$animateQueue.push(element, 'removeClass', options);
            },
            setClass: function (element, add, remove, options) {
                options = prepareAnimateOptions(options);
                options.addClass = mergeClasses(options.addClass, add);
                options.removeClass = mergeClasses(options.removeClass, remove);
                return $$animateQueue.push(element, 'setClass', options);
            },
            animate: function (element, from, to, className, options) {
                options = prepareAnimateOptions(options);
                options.from = options.from ? extend(options.from, from) : from;
                options.to = options.to ? extend(options.to, to) : to;
                className = className || 'ng-inline-animate';
                options.tempClasses = mergeClasses(options.tempClasses, className);
                return $$animateQueue.push(element, 'animate', options);
            }
        };
    }
];})
    ];
    $$AnimateAsyncRunFactoryProvider = ($__.fs.J$__v3645318688_464_358 = function J$__v3645318688_464() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.$get = [
    '$$rAF',
    function ($$rAF) {
        var waitQueue = [];
        function waitForTick(fn) {
            waitQueue.push(fn);
            if (waitQueue.length > 1)
                return;
            $$rAF(function () {
                for (var i = 0; i < waitQueue.length; i++) {
                    waitQueue[i]();
                }
                waitQueue = [];
            });
        }
        return function () {
            var passed = false;
            waitForTick(function () {
                passed = true;
            });
            return function (callback) {
                if (passed) {
                    callback();
                } else {
                    waitForTick(callback);
                }
            };
        };
    }
];});
    $$AnimateRunnerFactoryProvider = ($__.fs.J$__v3645318688_515_359 = function J$__v3645318688_515() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.$get = [
    '$q',
    '$sniffer',
    '$$animateAsyncRun',
    '$$isDocumentHidden',
    '$timeout',
    function ($q, $sniffer, $$animateAsyncRun, $$isDocumentHidden, $timeout) {
        var INITIAL_STATE = 0;
        var DONE_PENDING_STATE = 1;
        var DONE_COMPLETE_STATE = 2;
        AnimateRunner.chain = function (chain, callback) {
            var index = 0;
            next();
            function next() {
                if (index === chain.length) {
                    callback(true);
                    return;
                }
                chain[index](function (response) {
                    if (response === false) {
                        callback(false);
                        return;
                    }
                    index++;
                    next();
                });
            }
        };
        AnimateRunner.all = function (runners, callback) {
            var count = 0;
            var status = true;
            forEach(runners, function (runner) {
                runner.done(onProgress);
            });
            function onProgress(response) {
                status = status && response;
                if (++count === runners.length) {
                    callback(status);
                }
            }
        };
        function AnimateRunner(host) {
            this.setHost(host);
            var rafTick = $$animateAsyncRun();
            var timeoutTick = function (fn) {
                $timeout(fn, 0, false);
            };
            this._doneCallbacks = [];
            this._tick = function (fn) {
                if ($$isDocumentHidden()) {
                    timeoutTick(fn);
                } else {
                    rafTick(fn);
                }
            };
            this._state = 0;
        }
        AnimateRunner.prototype = {
            setHost: function (host) {
                this.host = host || {};
            },
            done: function (fn) {
                if (this._state === DONE_COMPLETE_STATE) {
                    fn();
                } else {
                    this._doneCallbacks.push(fn);
                }
            },
            progress: noop,
            getPromise: function () {
                if (!this.promise) {
                    var self = this;
                    this.promise = $q(function (resolve, reject) {
                        self.done(function (status) {
                            if (status === false) {
                                reject();
                            } else {
                                resolve();
                            }
                        });
                    });
                }
                return this.promise;
            },
            then: function (resolveHandler, rejectHandler) {
                return this.getPromise().then(resolveHandler, rejectHandler);
            },
            'catch': function (handler) {
                return this.getPromise()['catch'](handler);
            },
            'finally': function (handler) {
                return this.getPromise()['finally'](handler);
            },
            pause: function () {
                if (this.host.pause) {
                    this.host.pause();
                }
            },
            resume: function () {
                if (this.host.resume) {
                    this.host.resume();
                }
            },
            end: function () {
                if (this.host.end) {
                    this.host.end();
                }
                this._resolve(true);
            },
            cancel: function () {
                if (this.host.cancel) {
                    this.host.cancel();
                }
                this._resolve(false);
            },
            complete: function (response) {
                var self = this;
                if (self._state === INITIAL_STATE) {
                    self._state = DONE_PENDING_STATE;
                    self._tick(function () {
                        self._resolve(response);
                    });
                }
            },
            _resolve: function (response) {
                if (this._state !== DONE_COMPLETE_STATE) {
                    forEach(this._doneCallbacks, function (fn) {
                        fn(response);
                    });
                    this._doneCallbacks.length = 0;
                    this._state = DONE_COMPLETE_STATE;
                }
            }
        };
        return AnimateRunner;
    }
];});
    $CoreAnimateCssProvider = ($__.fs.J$__v3645318688_525_360 = function J$__v3645318688_525() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.$get = [
    '$$rAF',
    '$q',
    '$$AnimateRunner',
    function ($$rAF, $q, $$AnimateRunner) {
        return function (element, initialOptions) {
            var options = initialOptions || {};
            if (!options.$$prepared) {
                options = copy(options);
            }
            if (options.cleanupStyles) {
                options.from = options.to = null;
            }
            if (options.from) {
                element.css(options.from);
                options.from = null;
            }
            var closed, runner = new $$AnimateRunner();
            return {
                start: run,
                end: run
            };
            function run() {
                $$rAF(function () {
                    applyAnimationContents();
                    if (!closed) {
                        runner.complete();
                    }
                    closed = true;
                });
                return runner;
            }
            function applyAnimationContents() {
                if (options.addClass) {
                    element.addClass(options.addClass);
                    options.addClass = null;
                }
                if (options.removeClass) {
                    element.removeClass(options.removeClass);
                    options.removeClass = null;
                }
                if (options.to) {
                    element.css(options.to);
                    options.to = null;
                }
            }
        };
    }
];});
    $compileMinErr = (minErr, $__.fs.minErr_4)('$compile', 4, true, $__.uid);
    _UNINITIALIZED_VALUE = new (UNINITIALIZED_VALUE, $__.fs.UNINITIALIZED_VALUE_132)(0, true, $__.uid);
    $CompileProvider.$inject = [
        '$provide',
        '$$sanitizeUriProvider'
    ];
    TAJS_restrictToType(SimpleChange.prototype, 'object').isFirstChange = ($__.fs.J$__v3645318688_750_362 = function J$__v3645318688_750() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return this.previousValue === _UNINITIALIZED_VALUE;});
    PREFIX_REGEXP = /^((?:x|data)[:\-_])/i;
    SPECIAL_CHARS_REGEXP = /[:\-_]+(.)/g;
    $controllerMinErr = (minErr, $__.fs.minErr_4)('$controller', 5, true, $__.uid);
    CNTRL_REG = /^(\S+)(\s+as\s+([\w$]+))?$/;
    $$ForceReflowProvider = ($__.fs.J$__v3645318688_790_364 = function J$__v3645318688_790() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.$get = [
    '$document',
    function ($document) {
        return function (domNode) {
            if (domNode) {
                if (!domNode.nodeType && domNode instanceof jqLite) {
                    domNode = domNode[0];
                }
            } else {
                domNode = $document[0].body;
            }
            return domNode.offsetWidth + 1;
        };
    }
];});
    APPLICATION_JSON = 'application/json';
    CONTENT_TYPE_APPLICATION_JSON = $__.os.oid14 = {
        'Content-Type': APPLICATION_JSON + ';charset=utf-8'
    };
    JSON_START = /^\[|^\{(?!\{)/;
    JSON_ENDS = $__.os.oid15 = {
        '[': /]$/,
        '{': /}$/
    };
    JSON_PROTECTION_PREFIX = /^\)]\}',?\n/;
    $httpMinErr = (minErr, $__.fs.minErr_4)('$http', 6, true, $__.uid);
    $interpolateMinErr = (angular, $__.os.oid1).$interpolateMinErr = (minErr, $__.fs.minErr_4)('$interpolate', 7, true, $__.uid);
    $interpolateMinErr.throwNoconcat = ($__.fs.J$__v3645318688_897_367 = function J$__v3645318688_897(text) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
text = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
throw $interpolateMinErr('noconcat', 'Error while interpolating: {0}\nStrict Contextual Escaping disallows ' + 'interpolations that concatenate multiple expressions when a trusted value is ' + 'required.  See http://docs.angularjs.org/api/ng.$sce', text);});
    $interpolateMinErr.interr = ($__.fs.J$__v3645318688_899_368 = function J$__v3645318688_899(text, err) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
text = arguments[0], err = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return $interpolateMinErr('interr', 'Can\'t interpolate: {0}\n{1}', text, err.toString());});
    $jsonpCallbacksProvider = ($__.fs.J$__v3645318688_947_369 = function J$__v3645318688_947() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.$get = function () {
    var callbacks = angular.callbacks;
    var callbackMap = {};
    function createCallback(callbackId) {
        var callback = function (data) {
            callback.data = data;
            callback.called = true;
        };
        callback.id = callbackId;
        return callback;
    }
    return {
        createCallback: function (url) {
            var callbackId = '_' + (callbacks.$$counter++).toString(36);
            var callbackPath = 'angular.callbacks.' + callbackId;
            var callback = createCallback(callbackId);
            callbackMap[callbackPath] = callbacks[callbackId] = callback;
            return callbackPath;
        },
        wasCalled: function (callbackPath) {
            return callbackMap[callbackPath].called;
        },
        getResponse: function (callbackPath) {
            return callbackMap[callbackPath].data;
        },
        removeCallback: function (callbackPath) {
            var callback = callbackMap[callbackPath];
            delete callbacks[callback.id];
            delete callbackMap[callbackPath];
        }
    };
};});
    PATH_MATCH = /^([^?#]*)(\?([^#]*))?(#(.*))?$/;
    DEFAULT_PORTS = $__.os.oid16 = {
        'http': 80,
        'https': 443,
        'ftp': 21
    };
    $locationMinErr = (minErr, $__.fs.minErr_4)('$location', 8, true, $__.uid);
    DOUBLE_SLASH_REGEX = /^\s*[\\\/]{2,}/;
    locationPrototype = $__.os.oid17 = {
        '$$absUrl': '',
        '$$html5': false,
        '$$replace': false,
        'absUrl': (locationGetter, $__.fs.locationGetter_172)('$$absUrl', 0, true, $__.uid),
        'url': ($__.fs.J$__v3645318688_978_372 = function J$__v3645318688_978(url) {
var vvv_return, vvv_switch, match;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
url = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (isUndefined(url)) {
    return this.$$url;
}
match = PATH_MATCH.exec(url);
if (match[1] || url === '')
    this.path(decodeURIComponent(match[1]));
if (match[2] || match[1] || url === '')
    this.search(match[3] || '');
this.hash(match[5] || '');
return this;}),
        'protocol': (locationGetter, $__.fs.locationGetter_172)('$$protocol', 1, true, $__.uid),
        'host': (locationGetter, $__.fs.locationGetter_172)('$$host', 2, true, $__.uid),
        'port': (locationGetter, $__.fs.locationGetter_172)('$$port', 3, true, $__.uid),
        'path': (locationGetterSetter, $__.fs.locationGetterSetter_173)('$$path', ($__.fs.J$__v3645318688_980_376 = function J$__v3645318688_980(path) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
path = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
path = path !== null ? path.toString() : '';
return path.charAt(0) === '/' ? path : '/' + path;}), 0, true, $__.uid),
        'search': ($__.fs.J$__v3645318688_984_378 = function J$__v3645318688_984(search, paramValue) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
search = arguments[0], paramValue = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
switch (arguments.length) {
case 0:
    return this.$$search;
case 1:
    if (isString(search) || isNumber(search)) {
        search = search.toString();
        this.$$search = parseKeyValue(search);
    } else if (isObject(search)) {
        search = copy(search, {});
        forEach(search, function (value, key) {
            if (value == null)
                delete search[key];
        });
        this.$$search = search;
    } else {
        throw $locationMinErr('isrcharg', 'The first argument of the `$location#search()` call must be a string or an object.');
    }
    break;
default:
    if (isUndefined(paramValue) || paramValue === null) {
        delete this.$$search[search];
    } else {
        this.$$search[search] = paramValue;
    }
}
this.$$compose();
return this;}),
        'hash': (locationGetterSetter, $__.fs.locationGetterSetter_173)('$$hash', ($__.fs.J$__v3645318688_986_379 = function J$__v3645318688_986(hash) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
hash = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return hash !== null ? hash.toString() : '';}), 1, true, $__.uid),
        'replace': ($__.fs.J$__v3645318688_988_381 = function J$__v3645318688_988() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.$$replace = true;
return this;})
    };
    (forEach, $__.fs.forEach_8)([
        LocationHashbangInHtml5Url,
        LocationHashbangUrl,
        LocationHtml5Url
    ], ($__.fs.J$__v3645318688_992_382 = function J$__v3645318688_992(Location) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
Location = arguments[0];
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    Location.prototype = Object['create'](locationPrototype);
    TAJS_restrictToType(Location.prototype, 'object').state = ($__.fs.J$__v3645318688_990_383 = function J$__v3645318688_990(state) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
state = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (!arguments.length) {
    return this.$$state;
}
if (Location !== LocationHtml5Url || !this.$$html5) {
    throw $locationMinErr('nostate', 'History API state support is available only ' + 'in HTML5 mode and only in browsers supporting HTML5 History API');
}
this.$$state = isUndefined(state) ? null : state;
this.$$urlUpdatedByLocation = true;
return this;});
    return;
case 1:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 1);
    Location.prototype = Object['create'](locationPrototype);
    TAJS_restrictToType(Location.prototype, 'object').state = ($__.fs.J$__v3645318688_990_384 = function J$__v3645318688_990(state) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
state = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (!arguments.length) {
    return this.$$state;
}
if (Location !== LocationHtml5Url || !this.$$html5) {
    throw $locationMinErr('nostate', 'History API state support is available only ' + 'in HTML5 mode and only in browsers supporting HTML5 History API');
}
this.$$state = isUndefined(state) ? null : state;
this.$$urlUpdatedByLocation = true;
return this;});
    return;
case 2:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 2);
    Location.prototype = Object['create'](locationPrototype);
    TAJS_restrictToType(Location.prototype, 'object').state = ($__.fs.J$__v3645318688_990_385 = function J$__v3645318688_990(state) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
state = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (!arguments.length) {
    return this.$$state;
}
if (Location !== LocationHtml5Url || !this.$$html5) {
    throw $locationMinErr('nostate', 'History API state support is available only ' + 'in HTML5 mode and only in browsers supporting HTML5 History API');
}
this.$$state = isUndefined(state) ? null : state;
this.$$urlUpdatedByLocation = true;
return this;});
    return;
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
Location.prototype = Object.create(locationPrototype);
Location.prototype.state = function (state) {
    if (!arguments.length) {
        return this.$$state;
    }
    if (Location !== LocationHtml5Url || !this.$$html5) {
        throw $locationMinErr('nostate', 'History API state support is available only ' + 'in HTML5 mode and only in browsers supporting HTML5 History API');
    }
    this.$$state = isUndefined(state) ? null : state;
    this.$$urlUpdatedByLocation = true;
    return this;
};}, $__.fs.J$__v3645318688_992_382), 5, true, $__.uid);
    $parseMinErr = (minErr, $__.fs.minErr_4)('$parse', 9, true, $__.uid);
    objectValueOf = TAJS_restrictToType(TAJS_restrictToType(TAJS_restrictToType(($__.os.oid18 = {}, $__.os.oid18).constructor, 'function').prototype, 'object').valueOf, 'function');
    OPERATORS = (createMap, $__.fs.createMap_75)(0, true, $__.uid);
    (forEach, $__.fs.forEach_8)(function $__lt2(res) {
        res.length = 18;
        if (res.length != 18)
            TAJS_dumpValue('Possible loss of precision');
        return res;
        ;
        TAJS_makeContextSensitive($__lt2, -2);
    }('+ - * / % === !== == != < > <= >= && || ! = |'['split'](' ')), ($__.fs.J$__v3645318688_1036_387 = function J$__v3645318688_1036(operator) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
operator = arguments[0];
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    OPERATORS[operator, '+'] = true;
    return;
case 1:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 1);
    OPERATORS[operator, '-'] = true;
    return;
case 2:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 2);
    OPERATORS[operator, '*'] = true;
    return;
case 3:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 3);
    OPERATORS[operator, '/'] = true;
    return;
case 4:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 4);
    OPERATORS[operator, '%'] = true;
    return;
case 5:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 5);
    OPERATORS[operator, '==='] = true;
    return;
case 6:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 6);
    OPERATORS[operator, '!=='] = true;
    return;
case 7:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 7);
    OPERATORS[operator, '=='] = true;
    return;
case 8:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 8);
    OPERATORS[operator, '!='] = true;
    return;
case 9:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 9);
    OPERATORS[operator, '<'] = true;
    return;
case 10:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 10);
    OPERATORS[operator, '>'] = true;
    return;
case 11:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 11);
    OPERATORS[operator, '<='] = true;
    return;
case 12:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 12);
    OPERATORS[operator, '>='] = true;
    return;
case 13:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 13);
    OPERATORS[operator, '&&'] = true;
    return;
case 14:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 14);
    OPERATORS[operator, '||'] = true;
    return;
case 15:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 15);
    OPERATORS[operator, '!'] = true;
    return;
case 16:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 16);
    OPERATORS[operator, '='] = true;
    return;
case 17:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 17);
    OPERATORS[operator, '|'] = true;
    return;
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
OPERATORS[operator] = true;}, $__.fs.J$__v3645318688_1036_387), 6, true, $__.uid);
    ESCAPE = $__.os.oid19 = {
        'n': '\n',
        'f': '\f',
        'r': '\r',
        't': '\t',
        'v': '\x0B',
        '\'': '\'',
        '"': '"'
    };
    Lexer = ($__.fs.Lexer_388 = function Lexer(options) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
options = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.options = options;});
    Lexer.prototype = $__.os.oid20 = {
        'constructor': Lexer,
        'lex': ($__.fs.J$__v3645318688_1039_389 = function J$__v3645318688_1039(text) {
var vvv_return, vvv_switch, ch, ch2, ch3, op1, op2, op3, token;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
text = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.text = text;
this.index = 0;
this.tokens = [];
while (this.index < this.text.length) {
    ch = this.text.charAt(this.index);
    if (ch === '"' || ch === '\'') {
        this.readString(ch);
    } else if (this.isNumber(ch) || ch === '.' && this.isNumber(this.peek())) {
        this.readNumber();
    } else if (this.isIdentifierStart(this.peekMultichar())) {
        this.readIdent();
    } else if (this.is(ch, '(){}[].,;:?')) {
        this.tokens.push({
            index: this.index,
            text: ch
        });
        this.index++;
    } else if (this.isWhitespace(ch)) {
        this.index++;
    } else {
        ch2 = ch + this.peek();
        ch3 = ch2 + this.peek(2);
        op1 = OPERATORS[ch];
        op2 = OPERATORS[ch2];
        op3 = OPERATORS[ch3];
        if (op1 || op2 || op3) {
            token = op3 ? ch3 : op2 ? ch2 : ch;
            this.tokens.push({
                index: this.index,
                text: token,
                operator: true
            });
            this.index += token.length;
        } else {
            this.throwError('Unexpected next character ', this.index, this.index + 1);
        }
    }
}
return this.tokens;}),
        'is': ($__.fs.J$__v3645318688_1041_390 = function J$__v3645318688_1041(ch, chars) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
ch = arguments[0], chars = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return chars.indexOf(ch) !== -1;}),
        'peek': ($__.fs.J$__v3645318688_1043_391 = function J$__v3645318688_1043(i) {
var vvv_return, vvv_switch, num;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
i = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
num = i || 1;
return this.index + num < this.text.length ? this.text.charAt(this.index + num) : false;}),
        'isNumber': ($__.fs.J$__v3645318688_1045_392 = function J$__v3645318688_1045(ch) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
ch = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return '0' <= ch && ch <= '9' && typeof ch === 'string';}),
        'isWhitespace': ($__.fs.J$__v3645318688_1047_393 = function J$__v3645318688_1047(ch) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
ch = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return ch === ' ' || ch === '\r' || ch === '\t' || ch === '\n' || ch === '\x0B' || ch === '\xA0';}),
        'isIdentifierStart': ($__.fs.J$__v3645318688_1049_394 = function J$__v3645318688_1049(ch) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
ch = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return this.options.isIdentifierStart ? this.options.isIdentifierStart(ch, this.codePointAt(ch)) : this.isValidIdentifierStart(ch);}),
        'isValidIdentifierStart': ($__.fs.J$__v3645318688_1051_395 = function J$__v3645318688_1051(ch) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
ch = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return 'a' <= ch && ch <= 'z' || 'A' <= ch && ch <= 'Z' || '_' === ch || ch === '$';}),
        'isIdentifierContinue': ($__.fs.J$__v3645318688_1053_396 = function J$__v3645318688_1053(ch) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
ch = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return this.options.isIdentifierContinue ? this.options.isIdentifierContinue(ch, this.codePointAt(ch)) : this.isValidIdentifierContinue(ch);}),
        'isValidIdentifierContinue': ($__.fs.J$__v3645318688_1055_397 = function J$__v3645318688_1055(ch, cp) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
ch = arguments[0], cp = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return this.isValidIdentifierStart(ch, cp) || this.isNumber(ch);}),
        'codePointAt': ($__.fs.J$__v3645318688_1057_398 = function J$__v3645318688_1057(ch) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
ch = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (ch.length === 1)
    return ch.charCodeAt(0);
return (ch.charCodeAt(0) << 10) + ch.charCodeAt(1) - 56613888;}),
        'peekMultichar': ($__.fs.J$__v3645318688_1059_399 = function J$__v3645318688_1059() {
var vvv_return, vvv_switch, ch, peek, cp1, cp2;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
ch = this.text.charAt(this.index);
peek = this.peek();
if (!peek) {
    return ch;
}
cp1 = ch.charCodeAt(0);
cp2 = peek.charCodeAt(0);
if (cp1 >= 55296 && cp1 <= 56319 && cp2 >= 56320 && cp2 <= 57343) {
    return ch + peek;
}
return ch;}),
        'isExpOperator': ($__.fs.J$__v3645318688_1061_400 = function J$__v3645318688_1061(ch) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
ch = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return ch === '-' || ch === '+' || this.isNumber(ch);}),
        'throwError': ($__.fs.J$__v3645318688_1063_401 = function J$__v3645318688_1063(error, start, end) {
var vvv_return, vvv_switch, colStr;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
error = arguments[0], start = arguments[1], end = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
end = end || this.index;
colStr = isDefined(start) ? 's ' + start + '-' + this.index + ' [' + this.text.substring(start, end) + ']' : ' ' + end;
throw $parseMinErr('lexerr', 'Lexer Error: {0} at column{1} in expression [{2}].', error, colStr, this.text);}),
        'readNumber': ($__.fs.J$__v3645318688_1065_402 = function J$__v3645318688_1065() {
var vvv_return, vvv_switch, number, start, ch, peekCh;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
number = '';
start = this.index;
while (this.index < this.text.length) {
    ch = lowercase(this.text.charAt(this.index));
    if (ch === '.' || this.isNumber(ch)) {
        number += ch;
    } else {
        peekCh = this.peek();
        if (ch === 'e' && this.isExpOperator(peekCh)) {
            number += ch;
        } else if (this.isExpOperator(ch) && peekCh && this.isNumber(peekCh) && number.charAt(number.length - 1) === 'e') {
            number += ch;
        } else if (this.isExpOperator(ch) && (!peekCh || !this.isNumber(peekCh)) && number.charAt(number.length - 1) === 'e') {
            this.throwError('Invalid exponent');
        } else {
            break;
        }
    }
    this.index++;
}
this.tokens.push({
    index: start,
    text: number,
    constant: true,
    value: Number(number)
});}),
        'readIdent': ($__.fs.J$__v3645318688_1067_403 = function J$__v3645318688_1067() {
var vvv_return, vvv_switch, start, ch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
start = this.index;
this.index += this.peekMultichar().length;
while (this.index < this.text.length) {
    ch = this.peekMultichar();
    if (!this.isIdentifierContinue(ch)) {
        break;
    }
    this.index += ch.length;
}
this.tokens.push({
    index: start,
    text: this.text.slice(start, this.index),
    identifier: true
});}),
        'readString': ($__.fs.J$__v3645318688_1069_404 = function J$__v3645318688_1069(quote) {
var vvv_return, vvv_switch, start, string, rawString, escape, ch, hex, rep;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
quote = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
start = this.index;
this.index++;
string = '';
rawString = quote;
escape = false;
while (this.index < this.text.length) {
    ch = this.text.charAt(this.index);
    rawString += ch;
    if (escape) {
        if (ch === 'u') {
            hex = this.text.substring(this.index + 1, this.index + 5);
            if (!hex.match(/[\da-f]{4}/i)) {
                this.throwError('Invalid unicode escape [\\u' + hex + ']');
            }
            this.index += 4;
            string += String.fromCharCode(parseInt(hex, 16));
        } else {
            rep = ESCAPE[ch];
            string = string + (rep || ch);
        }
        escape = false;
    } else if (ch === '\\') {
        escape = true;
    } else if (ch === quote) {
        this.index++;
        this.tokens.push({
            index: start,
            text: rawString,
            constant: true,
            value: string
        });
        return;
    } else {
        string += ch;
    }
    this.index++;
}
this.throwError('Unterminated quote', start);})
    };
    AST = ($__.fs.AST_405 = function AST(lexer, options) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
lexer = arguments[0], options = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.lexer = lexer;
this.options = options;});
    AST.Program = 'Program';
    AST.ExpressionStatement = 'ExpressionStatement';
    AST.AssignmentExpression = 'AssignmentExpression';
    AST.ConditionalExpression = 'ConditionalExpression';
    AST.LogicalExpression = 'LogicalExpression';
    AST.BinaryExpression = 'BinaryExpression';
    AST.UnaryExpression = 'UnaryExpression';
    AST.CallExpression = 'CallExpression';
    AST.MemberExpression = 'MemberExpression';
    AST.Identifier = 'Identifier';
    AST.Literal = 'Literal';
    AST.ArrayExpression = 'ArrayExpression';
    AST.Property = 'Property';
    AST.ObjectExpression = 'ObjectExpression';
    AST.ThisExpression = 'ThisExpression';
    AST.LocalsExpression = 'LocalsExpression';
    AST.NGValueParameter = 'NGValueParameter';
    AST.prototype = $__.os.oid24 = {
        'ast': ($__.fs.J$__v3645318688_1072_406 = function J$__v3645318688_1072(text) {
var vvv_return, vvv_switch, value;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
text = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.text = text;
this.tokens = this.lexer.lex(text);
value = this.program();
if (this.tokens.length !== 0) {
    this.throwError('is an unexpected token', this.tokens[0]);
}
return value;}),
        'program': ($__.fs.J$__v3645318688_1074_407 = function J$__v3645318688_1074() {
var vvv_return, vvv_switch, body;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
body = [];
while (true) {
    if (this.tokens.length > 0 && !this.peek('}', ')', ';', ']'))
        body.push(this.expressionStatement());
    if (!this.expect(';')) {
        return {
            type: AST.Program,
            body: body
        };
    }
}}),
        'expressionStatement': ($__.fs.J$__v3645318688_1076_408 = function J$__v3645318688_1076() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return {
    type: AST.ExpressionStatement,
    expression: this.filterChain()
};}),
        'filterChain': ($__.fs.J$__v3645318688_1078_409 = function J$__v3645318688_1078() {
var vvv_return, vvv_switch, left;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
left = this.expression();
while (this.expect('|')) {
    left = this.filter(left);
}
return left;}),
        'expression': ($__.fs.J$__v3645318688_1080_410 = function J$__v3645318688_1080() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return this.assignment();}),
        'assignment': ($__.fs.J$__v3645318688_1082_411 = function J$__v3645318688_1082() {
var vvv_return, vvv_switch, result;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
result = this.ternary();
if (this.expect('=')) {
    if (!isAssignable(result)) {
        throw $parseMinErr('lval', 'Trying to assign a value to a non l-value');
    }
    result = {
        type: AST.AssignmentExpression,
        left: result,
        right: this.assignment(),
        operator: '='
    };
}
return result;}),
        'ternary': ($__.fs.J$__v3645318688_1084_412 = function J$__v3645318688_1084() {
var vvv_return, vvv_switch, test, alternate, consequent;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
test = this.logicalOR();
if (this.expect('?')) {
    alternate = this.expression();
    if (this.consume(':')) {
        consequent = this.expression();
        return {
            type: AST.ConditionalExpression,
            test: test,
            alternate: alternate,
            consequent: consequent
        };
    }
}
return test;}),
        'logicalOR': ($__.fs.J$__v3645318688_1086_413 = function J$__v3645318688_1086() {
var vvv_return, vvv_switch, left;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
left = this.logicalAND();
while (this.expect('||')) {
    left = {
        type: AST.LogicalExpression,
        operator: '||',
        left: left,
        right: this.logicalAND()
    };
}
return left;}),
        'logicalAND': ($__.fs.J$__v3645318688_1088_414 = function J$__v3645318688_1088() {
var vvv_return, vvv_switch, left;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
left = this.equality();
while (this.expect('&&')) {
    left = {
        type: AST.LogicalExpression,
        operator: '&&',
        left: left,
        right: this.equality()
    };
}
return left;}),
        'equality': ($__.fs.J$__v3645318688_1090_415 = function J$__v3645318688_1090() {
var vvv_return, vvv_switch, left, token;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
left = this.relational();
while (token = this.expect('==', '!=', '===', '!==')) {
    left = {
        type: AST.BinaryExpression,
        operator: token.text,
        left: left,
        right: this.relational()
    };
}
return left;}),
        'relational': ($__.fs.J$__v3645318688_1092_416 = function J$__v3645318688_1092() {
var vvv_return, vvv_switch, left, token;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
left = this.additive();
while (token = this.expect('<', '>', '<=', '>=')) {
    left = {
        type: AST.BinaryExpression,
        operator: token.text,
        left: left,
        right: this.additive()
    };
}
return left;}),
        'additive': ($__.fs.J$__v3645318688_1094_417 = function J$__v3645318688_1094() {
var vvv_return, vvv_switch, left, token;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
left = this.multiplicative();
while (token = this.expect('+', '-')) {
    left = {
        type: AST.BinaryExpression,
        operator: token.text,
        left: left,
        right: this.multiplicative()
    };
}
return left;}),
        'multiplicative': ($__.fs.J$__v3645318688_1096_418 = function J$__v3645318688_1096() {
var vvv_return, vvv_switch, left, token;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
left = this.unary();
while (token = this.expect('*', '/', '%')) {
    left = {
        type: AST.BinaryExpression,
        operator: token.text,
        left: left,
        right: this.unary()
    };
}
return left;}),
        'unary': ($__.fs.J$__v3645318688_1098_419 = function J$__v3645318688_1098() {
var vvv_return, vvv_switch, token;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (token = this.expect('+', '-', '!')) {
    return {
        type: AST.UnaryExpression,
        operator: token.text,
        prefix: true,
        argument: this.unary()
    };
} else {
    return this.primary();
}}),
        'primary': ($__.fs.J$__v3645318688_1100_420 = function J$__v3645318688_1100() {
var vvv_return, vvv_switch, primary, next;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (this.expect('(')) {
    primary = this.filterChain();
    this.consume(')');
} else if (this.expect('[')) {
    primary = this.arrayDeclaration();
} else if (this.expect('{')) {
    primary = this.object();
} else if (this.selfReferential.hasOwnProperty(this.peek().text)) {
    primary = copy(this.selfReferential[this.consume().text]);
} else if (this.options.literals.hasOwnProperty(this.peek().text)) {
    primary = {
        type: AST.Literal,
        value: this.options.literals[this.consume().text]
    };
} else if (this.peek().identifier) {
    primary = this.identifier();
} else if (this.peek().constant) {
    primary = this.constant();
} else {
    this.throwError('not a primary expression', this.peek());
}
while (next = this.expect('(', '[', '.')) {
    if (next.text === '(') {
        primary = {
            type: AST.CallExpression,
            callee: primary,
            arguments: this.parseArguments()
        };
        this.consume(')');
    } else if (next.text === '[') {
        primary = {
            type: AST.MemberExpression,
            object: primary,
            property: this.expression(),
            computed: true
        };
        this.consume(']');
    } else if (next.text === '.') {
        primary = {
            type: AST.MemberExpression,
            object: primary,
            property: this.identifier(),
            computed: false
        };
    } else {
        this.throwError('IMPOSSIBLE');
    }
}
return primary;}),
        'filter': ($__.fs.J$__v3645318688_1102_421 = function J$__v3645318688_1102(baseExpression) {
var vvv_return, vvv_switch, args, result;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
baseExpression = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
args = [baseExpression];
result = {
    type: AST.CallExpression,
    callee: this.identifier(),
    arguments: args,
    filter: true
};
while (this.expect(':')) {
    args.push(this.expression());
}
return result;}),
        'parseArguments': ($__.fs.J$__v3645318688_1104_422 = function J$__v3645318688_1104() {
var vvv_return, vvv_switch, args;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
args = [];
if (this.peekToken().text !== ')') {
    do {
        args.push(this.filterChain());
    } while (this.expect(','));
}
return args;}),
        'identifier': ($__.fs.J$__v3645318688_1106_423 = function J$__v3645318688_1106() {
var vvv_return, vvv_switch, token;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
token = this.consume();
if (!token.identifier) {
    this.throwError('is not a valid identifier', token);
}
return {
    type: AST.Identifier,
    name: token.text
};}),
        'constant': ($__.fs.J$__v3645318688_1108_424 = function J$__v3645318688_1108() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return {
    type: AST.Literal,
    value: this.consume().value
};}),
        'arrayDeclaration': ($__.fs.J$__v3645318688_1110_425 = function J$__v3645318688_1110() {
var vvv_return, vvv_switch, elements;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
elements = [];
if (this.peekToken().text !== ']') {
    do {
        if (this.peek(']')) {
            break;
        }
        elements.push(this.expression());
    } while (this.expect(','));
}
this.consume(']');
return {
    type: AST.ArrayExpression,
    elements: elements
};}),
        'object': ($__.fs.J$__v3645318688_1112_426 = function J$__v3645318688_1112() {
var vvv_return, vvv_switch, properties, property;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
properties = [];
if (this.peekToken().text !== '}') {
    do {
        if (this.peek('}')) {
            break;
        }
        property = {
            type: AST.Property,
            kind: 'init'
        };
        if (this.peek().constant) {
            property.key = this.constant();
            property.computed = false;
            this.consume(':');
            property.value = this.expression();
        } else if (this.peek().identifier) {
            property.key = this.identifier();
            property.computed = false;
            if (this.peek(':')) {
                this.consume(':');
                property.value = this.expression();
            } else {
                property.value = property.key;
            }
        } else if (this.peek('[')) {
            this.consume('[');
            property.key = this.expression();
            this.consume(']');
            property.computed = true;
            this.consume(':');
            property.value = this.expression();
        } else {
            this.throwError('invalid key', this.peek());
        }
        properties.push(property);
    } while (this.expect(','));
}
this.consume('}');
return {
    type: AST.ObjectExpression,
    properties: properties
};}),
        'throwError': ($__.fs.J$__v3645318688_1114_427 = function J$__v3645318688_1114(msg, token) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
msg = arguments[0], token = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
throw $parseMinErr('syntax', 'Syntax Error: Token \'{0}\' {1} at column {2} of the expression [{3}] starting at [{4}].', token.text, msg, token.index + 1, this.text, this.text.substring(token.index));}),
        'consume': ($__.fs.J$__v3645318688_1116_428 = function J$__v3645318688_1116(e1) {
var vvv_return, vvv_switch, token;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
e1 = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (this.tokens.length === 0) {
    throw $parseMinErr('ueoe', 'Unexpected end of expression: {0}', this.text);
}
token = this.expect(e1);
if (!token) {
    this.throwError('is unexpected, expecting [' + e1 + ']', this.peek());
}
return token;}),
        'peekToken': ($__.fs.J$__v3645318688_1118_429 = function J$__v3645318688_1118() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (this.tokens.length === 0) {
    throw $parseMinErr('ueoe', 'Unexpected end of expression: {0}', this.text);
}
return this.tokens[0];}),
        'peek': ($__.fs.J$__v3645318688_1120_430 = function J$__v3645318688_1120(e1, e2, e3, e4) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
e1 = arguments[0], e2 = arguments[1], e3 = arguments[2], e4 = arguments[3];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return this.peekAhead(0, e1, e2, e3, e4);}),
        'peekAhead': ($__.fs.J$__v3645318688_1122_431 = function J$__v3645318688_1122(i, e1, e2, e3, e4) {
var vvv_return, vvv_switch, token, t;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
i = arguments[0], e1 = arguments[1], e2 = arguments[2], e3 = arguments[3], e4 = arguments[4];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (this.tokens.length > i) {
    token = this.tokens[i];
    t = token.text;
    if (t === e1 || t === e2 || t === e3 || t === e4 || !e1 && !e2 && !e3 && !e4) {
        return token;
    }
}
return false;}),
        'expect': ($__.fs.J$__v3645318688_1124_432 = function J$__v3645318688_1124(e1, e2, e3, e4) {
var vvv_return, vvv_switch, token;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
e1 = arguments[0], e2 = arguments[1], e3 = arguments[2], e4 = arguments[3];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
token = this.peek(e1, e2, e3, e4);
if (token) {
    this.tokens.shift();
    return token;
}
return false;}),
        'selfReferential': $__.os.oid23 = {
            'this': $__.os.oid21 = {
                'type': TAJS_restrictToType(AST.ThisExpression, 'string')
            },
            '$locals': $__.os.oid22 = {
                'type': TAJS_restrictToType(AST.LocalsExpression, 'string')
            }
        }
    };
    ASTCompiler.prototype = $__.os.oid25 = {
        'compile': ($__.fs.J$__v3645318688_1146_433 = function J$__v3645318688_1146(expression) {
var vvv_return, vvv_switch, self, ast, extra, assignable, result, toWatch, fnString, fn;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
expression = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
self = this;
ast = this.astBuilder.ast(expression);
this.state = {
    nextId: 0,
    filters: {},
    fn: {
        vars: [],
        body: [],
        own: {}
    },
    assign: {
        vars: [],
        body: [],
        own: {}
    },
    inputs: []
};
findConstantAndWatchExpressions(ast, self.$filter);
extra = '';
this.stage = 'assign';
if (assignable = assignableAST(ast)) {
    this.state.computing = 'assign';
    result = this.nextId();
    this.recurse(assignable, result);
    this.return_(result);
    extra = 'fn.assign=' + this.generateFunction('assign', 's,v,l');
}
toWatch = getInputs(ast.body);
self.stage = 'inputs';
forEach(toWatch, function (watch, key) {
    var fnKey = 'fn' + key;
    self.state[fnKey] = {
        vars: [],
        body: [],
        own: {}
    };
    self.state.computing = fnKey;
    var intoId = self.nextId();
    self.recurse(watch, intoId);
    self.return_(intoId);
    self.state.inputs.push(fnKey);
    watch.watchId = key;
});
this.state.computing = 'fn';
this.stage = 'main';
this.recurse(ast);
fnString = '"' + this.USE + ' ' + this.STRICT + '";\n' + this.filterPrefix() + 'var fn=' + this.generateFunction('fn', 's,l,a,i') + extra + this.watchFns() + 'return fn;';
fn = new Function('$filter', 'getStringValue', 'ifDefined', 'plus', fnString)(this.$filter, getStringValue, ifDefined, plusFn);
this.state = this.stage = undefined;
fn.literal = isLiteral(ast);
fn.constant = isConstant(ast);
return fn;}),
        'USE': 'use',
        'STRICT': 'strict',
        'watchFns': ($__.fs.J$__v3645318688_1150_434 = function J$__v3645318688_1150() {
var vvv_return, vvv_switch, result, fns, self;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
result = [];
fns = this.state.inputs;
self = this;
forEach(fns, function (name) {
    result.push('var ' + name + '=' + self.generateFunction(name, 's'));
});
if (fns.length) {
    result.push('fn.inputs=[' + fns.join(',') + '];');
}
return result.join('');}),
        'generateFunction': ($__.fs.J$__v3645318688_1152_435 = function J$__v3645318688_1152(name, params) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
name = arguments[0], params = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return 'function(' + params + '){' + this.varsPrefix(name) + this.body(name) + '};';}),
        'filterPrefix': ($__.fs.J$__v3645318688_1156_436 = function J$__v3645318688_1156() {
var vvv_return, vvv_switch, parts, self;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
parts = [];
self = this;
forEach(this.state.filters, function (id, filter) {
    parts.push(id + '=$filter(' + self.escape(filter) + ')');
});
if (parts.length)
    return 'var ' + parts.join(',') + ';';
return '';}),
        'varsPrefix': ($__.fs.J$__v3645318688_1158_437 = function J$__v3645318688_1158(section) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
section = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return this.state[section].vars.length ? 'var ' + this.state[section].vars.join(',') + ';' : '';}),
        'body': ($__.fs.J$__v3645318688_1160_438 = function J$__v3645318688_1160(section) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
section = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return this.state[section].body.join('');}),
        'recurse': ($__.fs.J$__v3645318688_1210_439 = function J$__v3645318688_1210(ast, intoId, nameId, recursionFn, create, skipWatchIdCheck) {
var vvv_return, vvv_switch, left, right, self, args, expression, computed;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
ast = arguments[0], intoId = arguments[1], nameId = arguments[2], recursionFn = arguments[3], create = arguments[4], skipWatchIdCheck = arguments[5];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
self = this;
recursionFn = recursionFn || noop;
if (!skipWatchIdCheck && isDefined(ast.watchId)) {
    intoId = intoId || this.nextId();
    this.if_('i', this.lazyAssign(intoId, this.computedMember('i', ast.watchId)), this.lazyRecurse(ast, intoId, nameId, recursionFn, create, true));
    return;
}
switch (ast.type) {
case AST.Program:
    forEach(ast.body, function (expression, pos) {
        self.recurse(expression.expression, undefined, undefined, function (expr) {
            right = expr;
        });
        if (pos !== ast.body.length - 1) {
            self.current().body.push(right, ';');
        } else {
            self.return_(right);
        }
    });
    break;
case AST.Literal:
    expression = this.escape(ast.value);
    this.assign(intoId, expression);
    recursionFn(intoId || expression);
    break;
case AST.UnaryExpression:
    this.recurse(ast.argument, undefined, undefined, function (expr) {
        right = expr;
    });
    expression = ast.operator + '(' + this.ifDefined(right, 0) + ')';
    this.assign(intoId, expression);
    recursionFn(expression);
    break;
case AST.BinaryExpression:
    this.recurse(ast.left, undefined, undefined, function (expr) {
        left = expr;
    });
    this.recurse(ast.right, undefined, undefined, function (expr) {
        right = expr;
    });
    if (ast.operator === '+') {
        expression = this.plus(left, right);
    } else if (ast.operator === '-') {
        expression = this.ifDefined(left, 0) + ast.operator + this.ifDefined(right, 0);
    } else {
        expression = '(' + left + ')' + ast.operator + '(' + right + ')';
    }
    this.assign(intoId, expression);
    recursionFn(expression);
    break;
case AST.LogicalExpression:
    intoId = intoId || this.nextId();
    self.recurse(ast.left, intoId);
    self.if_(ast.operator === '&&' ? intoId : self.not(intoId), self.lazyRecurse(ast.right, intoId));
    recursionFn(intoId);
    break;
case AST.ConditionalExpression:
    intoId = intoId || this.nextId();
    self.recurse(ast.test, intoId);
    self.if_(intoId, self.lazyRecurse(ast.alternate, intoId), self.lazyRecurse(ast.consequent, intoId));
    recursionFn(intoId);
    break;
case AST.Identifier:
    intoId = intoId || this.nextId();
    if (nameId) {
        nameId.context = self.stage === 'inputs' ? 's' : this.assign(this.nextId(), this.getHasOwnProperty('l', ast.name) + '?l:s');
        nameId.computed = false;
        nameId.name = ast.name;
    }
    self.if_(self.stage === 'inputs' || self.not(self.getHasOwnProperty('l', ast.name)), function () {
        self.if_(self.stage === 'inputs' || 's', function () {
            if (create && create !== 1) {
                self.if_(self.isNull(self.nonComputedMember('s', ast.name)), self.lazyAssign(self.nonComputedMember('s', ast.name), '{}'));
            }
            self.assign(intoId, self.nonComputedMember('s', ast.name));
        });
    }, intoId && self.lazyAssign(intoId, self.nonComputedMember('l', ast.name)));
    recursionFn(intoId);
    break;
case AST.MemberExpression:
    left = nameId && (nameId.context = this.nextId()) || this.nextId();
    intoId = intoId || this.nextId();
    self.recurse(ast.object, left, undefined, function () {
        self.if_(self.notNull(left), function () {
            if (ast.computed) {
                right = self.nextId();
                self.recurse(ast.property, right);
                self.getStringValue(right);
                if (create && create !== 1) {
                    self.if_(self.not(self.computedMember(left, right)), self.lazyAssign(self.computedMember(left, right), '{}'));
                }
                expression = self.computedMember(left, right);
                self.assign(intoId, expression);
                if (nameId) {
                    nameId.computed = true;
                    nameId.name = right;
                }
            } else {
                if (create && create !== 1) {
                    self.if_(self.isNull(self.nonComputedMember(left, ast.property.name)), self.lazyAssign(self.nonComputedMember(left, ast.property.name), '{}'));
                }
                expression = self.nonComputedMember(left, ast.property.name);
                self.assign(intoId, expression);
                if (nameId) {
                    nameId.computed = false;
                    nameId.name = ast.property.name;
                }
            }
        }, function () {
            self.assign(intoId, 'undefined');
        });
        recursionFn(intoId);
    }, !!create);
    break;
case AST.CallExpression:
    intoId = intoId || this.nextId();
    if (ast.filter) {
        right = self.filter(ast.callee.name);
        args = [];
        forEach(ast.arguments, function (expr) {
            var argument = self.nextId();
            self.recurse(expr, argument);
            args.push(argument);
        });
        expression = right + '(' + args.join(',') + ')';
        self.assign(intoId, expression);
        recursionFn(intoId);
    } else {
        right = self.nextId();
        left = {};
        args = [];
        self.recurse(ast.callee, right, left, function () {
            self.if_(self.notNull(right), function () {
                forEach(ast.arguments, function (expr) {
                    self.recurse(expr, ast.constant ? undefined : self.nextId(), undefined, function (argument) {
                        args.push(argument);
                    });
                });
                if (left.name) {
                    expression = self.member(left.context, left.name, left.computed) + '(' + args.join(',') + ')';
                } else {
                    expression = right + '(' + args.join(',') + ')';
                }
                self.assign(intoId, expression);
            }, function () {
                self.assign(intoId, 'undefined');
            });
            recursionFn(intoId);
        });
    }
    break;
case AST.AssignmentExpression:
    right = this.nextId();
    left = {};
    this.recurse(ast.left, undefined, left, function () {
        self.if_(self.notNull(left.context), function () {
            self.recurse(ast.right, right);
            expression = self.member(left.context, left.name, left.computed) + ast.operator + right;
            self.assign(intoId, expression);
            recursionFn(intoId || expression);
        });
    }, 1);
    break;
case AST.ArrayExpression:
    args = [];
    forEach(ast.elements, function (expr) {
        self.recurse(expr, ast.constant ? undefined : self.nextId(), undefined, function (argument) {
            args.push(argument);
        });
    });
    expression = '[' + args.join(',') + ']';
    this.assign(intoId, expression);
    recursionFn(intoId || expression);
    break;
case AST.ObjectExpression:
    args = [];
    computed = false;
    forEach(ast.properties, function (property) {
        if (property.computed) {
            computed = true;
        }
    });
    if (computed) {
        intoId = intoId || this.nextId();
        this.assign(intoId, '{}');
        forEach(ast.properties, function (property) {
            if (property.computed) {
                left = self.nextId();
                self.recurse(property.key, left);
            } else {
                left = property.key.type === AST.Identifier ? property.key.name : '' + property.key.value;
            }
            right = self.nextId();
            self.recurse(property.value, right);
            self.assign(self.member(intoId, left, property.computed), right);
        });
    } else {
        forEach(ast.properties, function (property) {
            self.recurse(property.value, ast.constant ? undefined : self.nextId(), undefined, function (expr) {
                args.push(self.escape(property.key.type === AST.Identifier ? property.key.name : '' + property.key.value) + ':' + expr);
            });
        });
        expression = '{' + args.join(',') + '}';
        this.assign(intoId, expression);
    }
    recursionFn(intoId || expression);
    break;
case AST.ThisExpression:
    this.assign(intoId, 's');
    recursionFn(intoId || 's');
    break;
case AST.LocalsExpression:
    this.assign(intoId, 'l');
    recursionFn(intoId || 'l');
    break;
case AST.NGValueParameter:
    this.assign(intoId, 'v');
    recursionFn(intoId || 'v');
    break;
}}),
        'getHasOwnProperty': ($__.fs.J$__v3645318688_1212_440 = function J$__v3645318688_1212(element, property) {
var vvv_return, vvv_switch, key, own;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
element = arguments[0], property = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
key = element + '.' + property;
own = this.current().own;
if (!own.hasOwnProperty(key)) {
    own[key] = this.nextId(false, element + '&&(' + this.escape(property) + ' in ' + element + ')');
}
return own[key];}),
        'assign': ($__.fs.J$__v3645318688_1214_441 = function J$__v3645318688_1214(id, value) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
id = arguments[0], value = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (!id)
    return;
this.current().body.push(id, '=', value, ';');
return id;}),
        'filter': ($__.fs.J$__v3645318688_1216_442 = function J$__v3645318688_1216(filterName) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
filterName = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (!this.state.filters.hasOwnProperty(filterName)) {
    this.state.filters[filterName] = this.nextId(true);
}
return this.state.filters[filterName];}),
        'ifDefined': ($__.fs.J$__v3645318688_1218_443 = function J$__v3645318688_1218(id, defaultValue) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
id = arguments[0], defaultValue = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return 'ifDefined(' + id + ',' + this.escape(defaultValue) + ')';}),
        'plus': ($__.fs.J$__v3645318688_1220_444 = function J$__v3645318688_1220(left, right) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
left = arguments[0], right = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return 'plus(' + left + ',' + right + ')';}),
        'return_': ($__.fs.J$__v3645318688_1222_445 = function J$__v3645318688_1222(id) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
id = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.current().body.push('return ', id, ';');}),
        'if_': ($__.fs.J$__v3645318688_1224_446 = function J$__v3645318688_1224(test, alternate, consequent) {
var vvv_return, vvv_switch, body;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
test = arguments[0], alternate = arguments[1], consequent = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (test === true) {
    alternate();
} else {
    body = this.current().body;
    body.push('if(', test, '){');
    alternate();
    body.push('}');
    if (consequent) {
        body.push('else{');
        consequent();
        body.push('}');
    }
}}),
        'not': ($__.fs.J$__v3645318688_1226_447 = function J$__v3645318688_1226(expression) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
expression = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return '!(' + expression + ')';}),
        'isNull': ($__.fs.J$__v3645318688_1228_448 = function J$__v3645318688_1228(expression) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
expression = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return expression + '==null';}),
        'notNull': ($__.fs.J$__v3645318688_1230_449 = function J$__v3645318688_1230(expression) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
expression = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return expression + '!=null';}),
        'nonComputedMember': ($__.fs.J$__v3645318688_1232_450 = function J$__v3645318688_1232(left, right) {
var vvv_return, vvv_switch, SAFE_IDENTIFIER, UNSAFE_CHARACTERS;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
left = arguments[0], right = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
SAFE_IDENTIFIER = /^[$_a-zA-Z][$_a-zA-Z0-9]*$/;
UNSAFE_CHARACTERS = /[^$_a-zA-Z0-9]/g;
if (SAFE_IDENTIFIER.test(right)) {
    return left + '.' + right;
} else {
    return left + '["' + right.replace(UNSAFE_CHARACTERS, this.stringEscapeFn) + '"]';
}}),
        'computedMember': ($__.fs.J$__v3645318688_1234_451 = function J$__v3645318688_1234(left, right) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
left = arguments[0], right = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return left + '[' + right + ']';}),
        'member': ($__.fs.J$__v3645318688_1236_452 = function J$__v3645318688_1236(left, right, computed) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
left = arguments[0], right = arguments[1], computed = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (computed)
    return this.computedMember(left, right);
return this.nonComputedMember(left, right);}),
        'getStringValue': ($__.fs.J$__v3645318688_1238_453 = function J$__v3645318688_1238(item) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
item = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.assign(item, 'getStringValue(' + item + ')');}),
        'lazyRecurse': ($__.fs.J$__v3645318688_1242_454 = function J$__v3645318688_1242(ast, intoId, nameId, recursionFn, create, skipWatchIdCheck) {
var vvv_return, vvv_switch, self;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
ast = arguments[0], intoId = arguments[1], nameId = arguments[2], recursionFn = arguments[3], create = arguments[4], skipWatchIdCheck = arguments[5];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
self = this;
return function () {
    self.recurse(ast, intoId, nameId, recursionFn, create, skipWatchIdCheck);
};}),
        'lazyAssign': ($__.fs.J$__v3645318688_1246_455 = function J$__v3645318688_1246(id, value) {
var vvv_return, vvv_switch, self;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
id = arguments[0], value = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
self = this;
return function () {
    self.assign(id, value);
};}),
        'stringEscapeRegex': /[^ a-zA-Z0-9]/g,
        'stringEscapeFn': ($__.fs.J$__v3645318688_1248_456 = function J$__v3645318688_1248(c) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
c = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return '\\u' + ('0000' + c.charCodeAt(0).toString(16)).slice(-4);}),
        'escape': ($__.fs.J$__v3645318688_1250_457 = function J$__v3645318688_1250(value) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
value = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (isString(value))
    return '\'' + value.replace(this.stringEscapeRegex, this.stringEscapeFn) + '\'';
if (isNumber(value))
    return value.toString();
if (value === true)
    return 'true';
if (value === false)
    return 'false';
if (value === null)
    return 'null';
if (typeof value === 'undefined')
    return 'undefined';
throw $parseMinErr('esc', 'IMPOSSIBLE');}),
        'nextId': ($__.fs.J$__v3645318688_1252_458 = function J$__v3645318688_1252(skip, init) {
var vvv_return, vvv_switch, id;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
skip = arguments[0], init = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
id = 'v' + this.state.nextId++;
if (!skip) {
    this.current().vars.push(id + (init ? '=' + init : ''));
}
return id;}),
        'current': ($__.fs.J$__v3645318688_1254_459 = function J$__v3645318688_1254() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return this.state[this.state.computing];})
    };
    ASTInterpreter.prototype = $__.os.oid26 = {
        'compile': ($__.fs.J$__v3645318688_1267_460 = function J$__v3645318688_1267(expression) {
var vvv_return, vvv_switch, self, ast, assignable, assign, toWatch, inputs, expressions, fn;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
expression = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
self = this;
ast = this.astBuilder.ast(expression);
findConstantAndWatchExpressions(ast, self.$filter);
if (assignable = assignableAST(ast)) {
    assign = this.recurse(assignable);
}
toWatch = getInputs(ast.body);
if (toWatch) {
    inputs = [];
    forEach(toWatch, function (watch, key) {
        var input = self.recurse(watch);
        watch.input = input;
        inputs.push(input);
        watch.watchId = key;
    });
}
expressions = [];
forEach(ast.body, function (expression) {
    expressions.push(self.recurse(expression.expression));
});
fn = ast.body.length === 0 ? noop : ast.body.length === 1 ? expressions[0] : function (scope, locals) {
    var lastValue;
    forEach(expressions, function (exp) {
        lastValue = exp(scope, locals);
    });
    return lastValue;
};
if (assign) {
    fn.assign = function (scope, value, locals) {
        return assign(scope, locals, value);
    };
}
if (inputs) {
    fn.inputs = inputs;
}
fn.literal = isLiteral(ast);
fn.constant = isConstant(ast);
return fn;}),
        'recurse': ($__.fs.J$__v3645318688_1291_461 = function J$__v3645318688_1291(ast, context, create) {
var vvv_return, vvv_switch, left, right, self, args;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
ast = arguments[0], context = arguments[1], create = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
self = this;
if (ast.input) {
    return this.inputs(ast.input, ast.watchId);
}
switch (ast.type) {
case AST.Literal:
    return this.value(ast.value, context);
case AST.UnaryExpression:
    right = this.recurse(ast.argument);
    return this['unary' + ast.operator](right, context);
case AST.BinaryExpression:
    left = this.recurse(ast.left);
    right = this.recurse(ast.right);
    return this['binary' + ast.operator](left, right, context);
case AST.LogicalExpression:
    left = this.recurse(ast.left);
    right = this.recurse(ast.right);
    return this['binary' + ast.operator](left, right, context);
case AST.ConditionalExpression:
    return this['ternary?:'](this.recurse(ast.test), this.recurse(ast.alternate), this.recurse(ast.consequent), context);
case AST.Identifier:
    return self.identifier(ast.name, context, create);
case AST.MemberExpression:
    left = this.recurse(ast.object, false, !!create);
    if (!ast.computed) {
        right = ast.property.name;
    }
    if (ast.computed)
        right = this.recurse(ast.property);
    return ast.computed ? this.computedMember(left, right, context, create) : this.nonComputedMember(left, right, context, create);
case AST.CallExpression:
    args = [];
    forEach(ast.arguments, function (expr) {
        args.push(self.recurse(expr));
    });
    if (ast.filter)
        right = this.$filter(ast.callee.name);
    if (!ast.filter)
        right = this.recurse(ast.callee, true);
    return ast.filter ? function (scope, locals, assign, inputs) {
        var values = [];
        for (var i = 0; i < args.length; ++i) {
            values.push(args[i](scope, locals, assign, inputs));
        }
        var value = right.apply(undefined, values, inputs);
        return context ? {
            context: undefined,
            name: undefined,
            value: value
        } : value;
    } : function (scope, locals, assign, inputs) {
        var rhs = right(scope, locals, assign, inputs);
        var value;
        if (rhs.value != null) {
            var values = [];
            for (var i = 0; i < args.length; ++i) {
                values.push(args[i](scope, locals, assign, inputs));
            }
            value = rhs.value.apply(rhs.context, values);
        }
        return context ? {
            value: value
        } : value;
    };
case AST.AssignmentExpression:
    left = this.recurse(ast.left, true, 1);
    right = this.recurse(ast.right);
    return function (scope, locals, assign, inputs) {
        var lhs = left(scope, locals, assign, inputs);
        var rhs = right(scope, locals, assign, inputs);
        lhs.context[lhs.name] = rhs;
        return context ? {
            value: rhs
        } : rhs;
    };
case AST.ArrayExpression:
    args = [];
    forEach(ast.elements, function (expr) {
        args.push(self.recurse(expr));
    });
    return function (scope, locals, assign, inputs) {
        var value = [];
        for (var i = 0; i < args.length; ++i) {
            value.push(args[i](scope, locals, assign, inputs));
        }
        return context ? {
            value: value
        } : value;
    };
case AST.ObjectExpression:
    args = [];
    forEach(ast.properties, function (property) {
        if (property.computed) {
            args.push({
                key: self.recurse(property.key),
                computed: true,
                value: self.recurse(property.value)
            });
        } else {
            args.push({
                key: property.key.type === AST.Identifier ? property.key.name : '' + property.key.value,
                computed: false,
                value: self.recurse(property.value)
            });
        }
    });
    return function (scope, locals, assign, inputs) {
        var value = {};
        for (var i = 0; i < args.length; ++i) {
            if (args[i].computed) {
                value[args[i].key(scope, locals, assign, inputs)] = args[i].value(scope, locals, assign, inputs);
            } else {
                value[args[i].key] = args[i].value(scope, locals, assign, inputs);
            }
        }
        return context ? {
            value: value
        } : value;
    };
case AST.ThisExpression:
    return function (scope) {
        return context ? {
            value: scope
        } : scope;
    };
case AST.LocalsExpression:
    return function (scope, locals) {
        return context ? {
            value: locals
        } : locals;
    };
case AST.NGValueParameter:
    return function (scope, locals, assign) {
        return context ? {
            value: assign
        } : assign;
    };
}}),
        'unary+': ($__.fs.J$__v3645318688_1295_462 = function J$__v3645318688_1295(argument, context) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
argument = arguments[0], context = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return function (scope, locals, assign, inputs) {
    var arg = argument(scope, locals, assign, inputs);
    if (isDefined(arg)) {
        arg = +arg;
    } else {
        arg = 0;
    }
    return context ? {
        value: arg
    } : arg;
};}),
        'unary-': ($__.fs.J$__v3645318688_1299_463 = function J$__v3645318688_1299(argument, context) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
argument = arguments[0], context = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return function (scope, locals, assign, inputs) {
    var arg = argument(scope, locals, assign, inputs);
    if (isDefined(arg)) {
        arg = -arg;
    } else {
        arg = -0;
    }
    return context ? {
        value: arg
    } : arg;
};}),
        'unary!': ($__.fs.J$__v3645318688_1303_464 = function J$__v3645318688_1303(argument, context) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
argument = arguments[0], context = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return function (scope, locals, assign, inputs) {
    var arg = !argument(scope, locals, assign, inputs);
    return context ? {
        value: arg
    } : arg;
};}),
        'binary+': ($__.fs.J$__v3645318688_1307_465 = function J$__v3645318688_1307(left, right, context) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
left = arguments[0], right = arguments[1], context = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return function (scope, locals, assign, inputs) {
    var lhs = left(scope, locals, assign, inputs);
    var rhs = right(scope, locals, assign, inputs);
    var arg = plusFn(lhs, rhs);
    return context ? {
        value: arg
    } : arg;
};}),
        'binary-': ($__.fs.J$__v3645318688_1311_466 = function J$__v3645318688_1311(left, right, context) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
left = arguments[0], right = arguments[1], context = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return function (scope, locals, assign, inputs) {
    var lhs = left(scope, locals, assign, inputs);
    var rhs = right(scope, locals, assign, inputs);
    var arg = (isDefined(lhs) ? lhs : 0) - (isDefined(rhs) ? rhs : 0);
    return context ? {
        value: arg
    } : arg;
};}),
        'binary*': ($__.fs.J$__v3645318688_1315_467 = function J$__v3645318688_1315(left, right, context) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
left = arguments[0], right = arguments[1], context = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return function (scope, locals, assign, inputs) {
    var arg = left(scope, locals, assign, inputs) * right(scope, locals, assign, inputs);
    return context ? {
        value: arg
    } : arg;
};}),
        'binary/': ($__.fs.J$__v3645318688_1319_468 = function J$__v3645318688_1319(left, right, context) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
left = arguments[0], right = arguments[1], context = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return function (scope, locals, assign, inputs) {
    var arg = left(scope, locals, assign, inputs) / right(scope, locals, assign, inputs);
    return context ? {
        value: arg
    } : arg;
};}),
        'binary%': ($__.fs.J$__v3645318688_1323_469 = function J$__v3645318688_1323(left, right, context) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
left = arguments[0], right = arguments[1], context = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return function (scope, locals, assign, inputs) {
    var arg = left(scope, locals, assign, inputs) % right(scope, locals, assign, inputs);
    return context ? {
        value: arg
    } : arg;
};}),
        'binary===': ($__.fs.J$__v3645318688_1327_470 = function J$__v3645318688_1327(left, right, context) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
left = arguments[0], right = arguments[1], context = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return function (scope, locals, assign, inputs) {
    var arg = left(scope, locals, assign, inputs) === right(scope, locals, assign, inputs);
    return context ? {
        value: arg
    } : arg;
};}),
        'binary!==': ($__.fs.J$__v3645318688_1331_471 = function J$__v3645318688_1331(left, right, context) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
left = arguments[0], right = arguments[1], context = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return function (scope, locals, assign, inputs) {
    var arg = left(scope, locals, assign, inputs) !== right(scope, locals, assign, inputs);
    return context ? {
        value: arg
    } : arg;
};}),
        'binary==': ($__.fs.J$__v3645318688_1335_472 = function J$__v3645318688_1335(left, right, context) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
left = arguments[0], right = arguments[1], context = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return function (scope, locals, assign, inputs) {
    var arg = left(scope, locals, assign, inputs) == right(scope, locals, assign, inputs);
    return context ? {
        value: arg
    } : arg;
};}),
        'binary!=': ($__.fs.J$__v3645318688_1339_473 = function J$__v3645318688_1339(left, right, context) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
left = arguments[0], right = arguments[1], context = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return function (scope, locals, assign, inputs) {
    var arg = left(scope, locals, assign, inputs) != right(scope, locals, assign, inputs);
    return context ? {
        value: arg
    } : arg;
};}),
        'binary<': ($__.fs.J$__v3645318688_1343_474 = function J$__v3645318688_1343(left, right, context) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
left = arguments[0], right = arguments[1], context = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return function (scope, locals, assign, inputs) {
    var arg = left(scope, locals, assign, inputs) < right(scope, locals, assign, inputs);
    return context ? {
        value: arg
    } : arg;
};}),
        'binary>': ($__.fs.J$__v3645318688_1347_475 = function J$__v3645318688_1347(left, right, context) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
left = arguments[0], right = arguments[1], context = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return function (scope, locals, assign, inputs) {
    var arg = left(scope, locals, assign, inputs) > right(scope, locals, assign, inputs);
    return context ? {
        value: arg
    } : arg;
};}),
        'binary<=': ($__.fs.J$__v3645318688_1351_476 = function J$__v3645318688_1351(left, right, context) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
left = arguments[0], right = arguments[1], context = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return function (scope, locals, assign, inputs) {
    var arg = left(scope, locals, assign, inputs) <= right(scope, locals, assign, inputs);
    return context ? {
        value: arg
    } : arg;
};}),
        'binary>=': ($__.fs.J$__v3645318688_1355_477 = function J$__v3645318688_1355(left, right, context) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
left = arguments[0], right = arguments[1], context = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return function (scope, locals, assign, inputs) {
    var arg = left(scope, locals, assign, inputs) >= right(scope, locals, assign, inputs);
    return context ? {
        value: arg
    } : arg;
};}),
        'binary&&': ($__.fs.J$__v3645318688_1359_478 = function J$__v3645318688_1359(left, right, context) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
left = arguments[0], right = arguments[1], context = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return function (scope, locals, assign, inputs) {
    var arg = left(scope, locals, assign, inputs) && right(scope, locals, assign, inputs);
    return context ? {
        value: arg
    } : arg;
};}),
        'binary||': ($__.fs.J$__v3645318688_1363_479 = function J$__v3645318688_1363(left, right, context) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
left = arguments[0], right = arguments[1], context = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return function (scope, locals, assign, inputs) {
    var arg = left(scope, locals, assign, inputs) || right(scope, locals, assign, inputs);
    return context ? {
        value: arg
    } : arg;
};}),
        'ternary?:': ($__.fs.J$__v3645318688_1367_480 = function J$__v3645318688_1367(test, alternate, consequent, context) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
test = arguments[0], alternate = arguments[1], consequent = arguments[2], context = arguments[3];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return function (scope, locals, assign, inputs) {
    var arg = test(scope, locals, assign, inputs) ? alternate(scope, locals, assign, inputs) : consequent(scope, locals, assign, inputs);
    return context ? {
        value: arg
    } : arg;
};}),
        'value': ($__.fs.J$__v3645318688_1371_481 = function J$__v3645318688_1371(value, context) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
value = arguments[0], context = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return function () {
    return context ? {
        context: undefined,
        name: undefined,
        value: value
    } : value;
};}),
        'identifier': ($__.fs.J$__v3645318688_1375_482 = function J$__v3645318688_1375(name, context, create) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
name = arguments[0], context = arguments[1], create = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return function (scope, locals, assign, inputs) {
    var base = locals && name in locals ? locals : scope;
    if (create && create !== 1 && base && base[name] == null) {
        base[name] = {};
    }
    var value = base ? base[name] : undefined;
    if (context) {
        return {
            context: base,
            name: name,
            value: value
        };
    } else {
        return value;
    }
};}),
        'computedMember': ($__.fs.J$__v3645318688_1379_483 = function J$__v3645318688_1379(left, right, context, create) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
left = arguments[0], right = arguments[1], context = arguments[2], create = arguments[3];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return function (scope, locals, assign, inputs) {
    var lhs = left(scope, locals, assign, inputs);
    var rhs;
    var value;
    if (lhs != null) {
        rhs = right(scope, locals, assign, inputs);
        rhs = getStringValue(rhs);
        if (create && create !== 1) {
            if (lhs && !lhs[rhs]) {
                lhs[rhs] = {};
            }
        }
        value = lhs[rhs];
    }
    if (context) {
        return {
            context: lhs,
            name: rhs,
            value: value
        };
    } else {
        return value;
    }
};}),
        'nonComputedMember': ($__.fs.J$__v3645318688_1383_484 = function J$__v3645318688_1383(left, right, context, create) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
left = arguments[0], right = arguments[1], context = arguments[2], create = arguments[3];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return function (scope, locals, assign, inputs) {
    var lhs = left(scope, locals, assign, inputs);
    if (create && create !== 1) {
        if (lhs && lhs[right] == null) {
            lhs[right] = {};
        }
    }
    var value = lhs != null ? lhs[right] : undefined;
    if (context) {
        return {
            context: lhs,
            name: right,
            value: value
        };
    } else {
        return value;
    }
};}),
        'inputs': ($__.fs.J$__v3645318688_1387_485 = function J$__v3645318688_1387(input, watchId) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
input = arguments[0], watchId = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return function (scope, value, locals, inputs) {
    if (inputs)
        return inputs[watchId];
    return input(scope, value, locals);
};})
    };
    Parser = ($__.fs.Parser_486 = function Parser(lexer, $filter, options) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
lexer = arguments[0], $filter = arguments[1], options = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.lexer = lexer;
this.$filter = $filter;
this.options = options;
this.ast = new AST(lexer, options);
this.astCompiler = options.csp ? new ASTInterpreter(this.ast, $filter) : new ASTCompiler(this.ast, $filter);});
    Parser.prototype = $__.os.oid27 = {
        'constructor': Parser,
        'parse': ($__.fs.J$__v3645318688_1390_487 = function J$__v3645318688_1390(text) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
text = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return this.astCompiler.compile(text);})
    };
    $sceMinErr = (minErr, $__.fs.minErr_4)('$sce', 10, true, $__.uid);
    SCE_CONTEXTS = $__.os.oid28 = {
        'HTML': 'html',
        'CSS': 'css',
        'URL': 'url',
        'RESOURCE_URL': 'resourceUrl',
        'JS': 'js'
    };
    UNDERSCORE_LOWERCASE_REGEXP = /_([a-z])/g;
    $templateRequestMinErr = (minErr, $__.fs.minErr_4)('$compile', 11, true, $__.uid);
    urlParsingNode = TAJS_restrictToType(window.document, 'HTMLDocument')['createElement']('a');
    originUrl = (urlResolve, $__.fs.urlResolve_205)(TAJS_restrictToType(TAJS_restrictToType(window.location, 'object').href, 'string'), 0, true, $__.uid);
    $$CookieReader.$inject = ['$document'];
    $FilterProvider.$inject = ['$provide'];
    MAX_DIGITS = 22;
    DECIMAL_SEP = '.';
    ZERO_CHAR = '0';
    currencyFilter.$inject = ['$locale'];
    numberFilter.$inject = ['$locale'];
    DATE_FORMATS = $__.os.oid30 = {
        'yyyy': (dateGetter, $__.fs.dateGetter_221)('FullYear', 4, 0, false, true, 0, true, $__.uid),
        'yy': (dateGetter, $__.fs.dateGetter_221)('FullYear', 2, 0, true, true, 1, true, $__.uid),
        'y': (dateGetter, $__.fs.dateGetter_221)('FullYear', 1, 0, false, true, 2, true, $__.uid),
        'MMMM': (dateStrGetter, $__.fs.dateStrGetter_222)('Month', 0, true, $__.uid),
        'MMM': (dateStrGetter, $__.fs.dateStrGetter_222)('Month', true, 1, true, $__.uid),
        'MM': (dateGetter, $__.fs.dateGetter_221)('Month', 2, 1, 3, true, $__.uid),
        'M': (dateGetter, $__.fs.dateGetter_221)('Month', 1, 1, 4, true, $__.uid),
        'LLLL': (dateStrGetter, $__.fs.dateStrGetter_222)('Month', false, true, 2, true, $__.uid),
        'dd': (dateGetter, $__.fs.dateGetter_221)('Date', 2, 5, true, $__.uid),
        'd': (dateGetter, $__.fs.dateGetter_221)('Date', 1, 6, true, $__.uid),
        'HH': (dateGetter, $__.fs.dateGetter_221)('Hours', 2, 7, true, $__.uid),
        'H': (dateGetter, $__.fs.dateGetter_221)('Hours', 1, 8, true, $__.uid),
        'hh': (dateGetter, $__.fs.dateGetter_221)('Hours', 2, -12, 9, true, $__.uid),
        'h': (dateGetter, $__.fs.dateGetter_221)('Hours', 1, -12, 10, true, $__.uid),
        'mm': (dateGetter, $__.fs.dateGetter_221)('Minutes', 2, 11, true, $__.uid),
        'm': (dateGetter, $__.fs.dateGetter_221)('Minutes', 1, 12, true, $__.uid),
        'ss': (dateGetter, $__.fs.dateGetter_221)('Seconds', 2, 13, true, $__.uid),
        's': (dateGetter, $__.fs.dateGetter_221)('Seconds', 1, 14, true, $__.uid),
        'sss': (dateGetter, $__.fs.dateGetter_221)('Milliseconds', 3, 15, true, $__.uid),
        'EEEE': (dateStrGetter, $__.fs.dateStrGetter_222)('Day', 3, true, $__.uid),
        'EEE': (dateStrGetter, $__.fs.dateStrGetter_222)('Day', true, 4, true, $__.uid),
        'a': ampmGetter,
        'Z': timeZoneGetter,
        'ww': (weekGetter, $__.fs.weekGetter_226)(2, 0, true, $__.uid),
        'w': (weekGetter, $__.fs.weekGetter_226)(1, 1, true, $__.uid),
        'G': eraGetter,
        'GG': eraGetter,
        'GGG': eraGetter,
        'GGGG': longEraGetter
    };
    DATE_FORMATS_SPLIT = /((?:[^yMLdHhmsaZEwG']+)|(?:'(?:[^']|'')*')|(?:E+|y+|M+|L+|d+|H+|h+|m+|s+|a|Z|G+|w+))(.*)/;
    NUMBER_STRING = /^-?\d+$/;
    dateFilter.$inject = ['$locale'];
    lowercaseFilter = (valueFn, $__.fs.valueFn_20)((lowercase, $__.fs.J$__v3645318688_10_266), 0, true, $__.uid);
    uppercaseFilter = (valueFn, $__.fs.valueFn_20)((uppercase, $__.fs.J$__v3645318688_12_267), 1, true, $__.uid);
    orderByFilter.$inject = ['$parse'];
    htmlAnchorDirective = (valueFn, $__.fs.valueFn_20)($__.os.oid31 = {
        'restrict': 'E',
        'compile': ($__.fs.J$__v3645318688_1762_515 = function J$__v3645318688_1762(element, attr) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
element = arguments[0], attr = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (!attr.href && !attr.xlinkHref) {
    return function (scope, element) {
        if (element[0].nodeName.toLowerCase() !== 'a')
            return;
        var href = toString.call(element.prop('href')) === '[object SVGAnimatedString]' ? 'xlink:href' : 'href';
        element.on('click', function (event) {
            if (!element.attr(href)) {
                event.preventDefault();
            }
        });
    };
}})
    }, 2, true, $__.uid);
    ngAttributeAliasDirectives = $__.os.oid32 = {};
    (forEach, $__.fs.forEach_8)(BOOLEAN_ATTR, ($__.fs.J$__v3645318688_1770_517 = function J$__v3645318688_1770(propName, attrName) {
var vvv_return, vvv_switch, defaultLinkFn, normalized, linkFn;
defaultLinkFn = function defaultLinkFn(scope, element, attr) {
    scope.$watch(attr[normalized], function ngBooleanAttrWatchAction(value) {
        attr.$set(attrName, !!value);
    });
};
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
propName = arguments[0], attrName = arguments[1];
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    defaultLinkFn = ($__.fs.defaultLinkFn_518 = function defaultLinkFn(scope, element, attr) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
scope = arguments[0], element = arguments[1], attr = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
scope.$watch(attr[normalized], function ngBooleanAttrWatchAction(value) {
    attr.$set(attrName, !!value);
});});
    propName === 'multiple';
    return;
case 1:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 1);
    defaultLinkFn = ($__.fs.defaultLinkFn_519 = function defaultLinkFn(scope, element, attr) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
scope = arguments[0], element = arguments[1], attr = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
scope.$watch(attr[normalized], function ngBooleanAttrWatchAction(value) {
    attr.$set(attrName, !!value);
});});
    propName === 'multiple';
    normalized = (directiveNormalize, $__.fs.directiveNormalize_135)('ng-' + attrName, 0, true, $__.uid);
    linkFn = defaultLinkFn;
    propName === 'checked';
    (ngAttributeAliasDirectives, $__.os.oid32)[normalized, 'ngSelected'] = ($__.fs.J$__v3645318688_1768_520 = function J$__v3645318688_1768() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return {
    restrict: 'A',
    priority: 100,
    link: linkFn
};});
    return;
case 2:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 2);
    defaultLinkFn = ($__.fs.defaultLinkFn_521 = function defaultLinkFn(scope, element, attr) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
scope = arguments[0], element = arguments[1], attr = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
scope.$watch(attr[normalized], function ngBooleanAttrWatchAction(value) {
    attr.$set(attrName, !!value);
});});
    propName === 'multiple';
    normalized = (directiveNormalize, $__.fs.directiveNormalize_135)('ng-' + attrName, 1, true, $__.uid);
    linkFn = defaultLinkFn;
    propName === 'checked';
    linkFn = ($__.fs.J$__v3645318688_1766_522 = function J$__v3645318688_1766(scope, element, attr) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
scope = arguments[0], element = arguments[1], attr = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (attr.ngModel !== attr[normalized]) {
    defaultLinkFn(scope, element, attr);
}});
    (ngAttributeAliasDirectives, $__.os.oid32)[normalized, 'ngChecked'] = ($__.fs.J$__v3645318688_1768_523 = function J$__v3645318688_1768() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return {
    restrict: 'A',
    priority: 100,
    link: linkFn
};});
    return;
case 3:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 3);
    defaultLinkFn = ($__.fs.defaultLinkFn_524 = function defaultLinkFn(scope, element, attr) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
scope = arguments[0], element = arguments[1], attr = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
scope.$watch(attr[normalized], function ngBooleanAttrWatchAction(value) {
    attr.$set(attrName, !!value);
});});
    propName === 'multiple';
    normalized = (directiveNormalize, $__.fs.directiveNormalize_135)('ng-' + attrName, 2, true, $__.uid);
    linkFn = defaultLinkFn;
    propName === 'checked';
    (ngAttributeAliasDirectives, $__.os.oid32)[normalized, 'ngDisabled'] = ($__.fs.J$__v3645318688_1768_525 = function J$__v3645318688_1768() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return {
    restrict: 'A',
    priority: 100,
    link: linkFn
};});
    return;
case 4:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 4);
    defaultLinkFn = ($__.fs.defaultLinkFn_526 = function defaultLinkFn(scope, element, attr) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
scope = arguments[0], element = arguments[1], attr = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
scope.$watch(attr[normalized], function ngBooleanAttrWatchAction(value) {
    attr.$set(attrName, !!value);
});});
    propName === 'multiple';
    normalized = (directiveNormalize, $__.fs.directiveNormalize_135)('ng-' + attrName, 3, true, $__.uid);
    linkFn = defaultLinkFn;
    propName === 'checked';
    (ngAttributeAliasDirectives, $__.os.oid32)[normalized, 'ngReadonly'] = ($__.fs.J$__v3645318688_1768_527 = function J$__v3645318688_1768() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return {
    restrict: 'A',
    priority: 100,
    link: linkFn
};});
    return;
case 5:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 5);
    defaultLinkFn = ($__.fs.defaultLinkFn_528 = function defaultLinkFn(scope, element, attr) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
scope = arguments[0], element = arguments[1], attr = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
scope.$watch(attr[normalized], function ngBooleanAttrWatchAction(value) {
    attr.$set(attrName, !!value);
});});
    propName === 'multiple';
    normalized = (directiveNormalize, $__.fs.directiveNormalize_135)('ng-' + attrName, 4, true, $__.uid);
    linkFn = defaultLinkFn;
    propName === 'checked';
    (ngAttributeAliasDirectives, $__.os.oid32)[normalized, 'ngRequired'] = ($__.fs.J$__v3645318688_1768_529 = function J$__v3645318688_1768() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return {
    restrict: 'A',
    priority: 100,
    link: linkFn
};});
    return;
case 6:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 6);
    defaultLinkFn = ($__.fs.defaultLinkFn_530 = function defaultLinkFn(scope, element, attr) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
scope = arguments[0], element = arguments[1], attr = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
scope.$watch(attr[normalized], function ngBooleanAttrWatchAction(value) {
    attr.$set(attrName, !!value);
});});
    propName === 'multiple';
    normalized = (directiveNormalize, $__.fs.directiveNormalize_135)('ng-' + attrName, 5, true, $__.uid);
    linkFn = defaultLinkFn;
    propName === 'checked';
    (ngAttributeAliasDirectives, $__.os.oid32)[normalized, 'ngOpen'] = ($__.fs.J$__v3645318688_1768_531 = function J$__v3645318688_1768() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return {
    restrict: 'A',
    priority: 100,
    link: linkFn
};});
    return;
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (propName === 'multiple')
    return;
normalized = directiveNormalize('ng-' + attrName);
linkFn = defaultLinkFn;
if (propName === 'checked') {
    linkFn = function (scope, element, attr) {
        if (attr.ngModel !== attr[normalized]) {
            defaultLinkFn(scope, element, attr);
        }
    };
}
ngAttributeAliasDirectives[normalized] = function () {
    return {
        restrict: 'A',
        priority: 100,
        link: linkFn
    };
};}, $__.fs.J$__v3645318688_1770_517), 7, true, $__.uid);
    (forEach, $__.fs.forEach_8)(ALIASED_ATTR, ($__.fs.J$__v3645318688_1777_532 = function J$__v3645318688_1777(htmlAttr, ngAttr) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
htmlAttr = arguments[0], ngAttr = arguments[1];
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    (ngAttributeAliasDirectives, $__.os.oid32)[ngAttr, 'ngMinlength'] = ($__.fs.J$__v3645318688_1775_533 = function J$__v3645318688_1775() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return {
    priority: 100,
    link: function (scope, element, attr) {
        if (ngAttr === 'ngPattern' && attr.ngPattern.charAt(0) === '/') {
            var match = attr.ngPattern.match(REGEX_STRING_REGEXP);
            if (match) {
                attr.$set('ngPattern', new RegExp(match[1], match[2]));
                return;
            }
        }
        scope.$watch(attr[ngAttr], function ngAttrAliasWatchAction(value) {
            attr.$set(ngAttr, value);
        });
    }
};});
    return;
case 1:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 1);
    (ngAttributeAliasDirectives, $__.os.oid32)[ngAttr, 'ngMaxlength'] = ($__.fs.J$__v3645318688_1775_534 = function J$__v3645318688_1775() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return {
    priority: 100,
    link: function (scope, element, attr) {
        if (ngAttr === 'ngPattern' && attr.ngPattern.charAt(0) === '/') {
            var match = attr.ngPattern.match(REGEX_STRING_REGEXP);
            if (match) {
                attr.$set('ngPattern', new RegExp(match[1], match[2]));
                return;
            }
        }
        scope.$watch(attr[ngAttr], function ngAttrAliasWatchAction(value) {
            attr.$set(ngAttr, value);
        });
    }
};});
    return;
case 2:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 2);
    (ngAttributeAliasDirectives, $__.os.oid32)[ngAttr, 'ngMin'] = ($__.fs.J$__v3645318688_1775_535 = function J$__v3645318688_1775() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return {
    priority: 100,
    link: function (scope, element, attr) {
        if (ngAttr === 'ngPattern' && attr.ngPattern.charAt(0) === '/') {
            var match = attr.ngPattern.match(REGEX_STRING_REGEXP);
            if (match) {
                attr.$set('ngPattern', new RegExp(match[1], match[2]));
                return;
            }
        }
        scope.$watch(attr[ngAttr], function ngAttrAliasWatchAction(value) {
            attr.$set(ngAttr, value);
        });
    }
};});
    return;
case 3:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 3);
    (ngAttributeAliasDirectives, $__.os.oid32)[ngAttr, 'ngMax'] = ($__.fs.J$__v3645318688_1775_536 = function J$__v3645318688_1775() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return {
    priority: 100,
    link: function (scope, element, attr) {
        if (ngAttr === 'ngPattern' && attr.ngPattern.charAt(0) === '/') {
            var match = attr.ngPattern.match(REGEX_STRING_REGEXP);
            if (match) {
                attr.$set('ngPattern', new RegExp(match[1], match[2]));
                return;
            }
        }
        scope.$watch(attr[ngAttr], function ngAttrAliasWatchAction(value) {
            attr.$set(ngAttr, value);
        });
    }
};});
    return;
case 4:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 4);
    (ngAttributeAliasDirectives, $__.os.oid32)[ngAttr, 'ngPattern'] = ($__.fs.J$__v3645318688_1775_537 = function J$__v3645318688_1775() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return {
    priority: 100,
    link: function (scope, element, attr) {
        if (ngAttr === 'ngPattern' && attr.ngPattern.charAt(0) === '/') {
            var match = attr.ngPattern.match(REGEX_STRING_REGEXP);
            if (match) {
                attr.$set('ngPattern', new RegExp(match[1], match[2]));
                return;
            }
        }
        scope.$watch(attr[ngAttr], function ngAttrAliasWatchAction(value) {
            attr.$set(ngAttr, value);
        });
    }
};});
    return;
case 5:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 5);
    (ngAttributeAliasDirectives, $__.os.oid32)[ngAttr, 'ngStep'] = ($__.fs.J$__v3645318688_1775_538 = function J$__v3645318688_1775() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return {
    priority: 100,
    link: function (scope, element, attr) {
        if (ngAttr === 'ngPattern' && attr.ngPattern.charAt(0) === '/') {
            var match = attr.ngPattern.match(REGEX_STRING_REGEXP);
            if (match) {
                attr.$set('ngPattern', new RegExp(match[1], match[2]));
                return;
            }
        }
        scope.$watch(attr[ngAttr], function ngAttrAliasWatchAction(value) {
            attr.$set(ngAttr, value);
        });
    }
};});
    return;
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
ngAttributeAliasDirectives[ngAttr] = function () {
    return {
        priority: 100,
        link: function (scope, element, attr) {
            if (ngAttr === 'ngPattern' && attr.ngPattern.charAt(0) === '/') {
                var match = attr.ngPattern.match(REGEX_STRING_REGEXP);
                if (match) {
                    attr.$set('ngPattern', new RegExp(match[1], match[2]));
                    return;
                }
            }
            scope.$watch(attr[ngAttr], function ngAttrAliasWatchAction(value) {
                attr.$set(ngAttr, value);
            });
        }
    };
};}, $__.fs.J$__v3645318688_1777_532), 8, true, $__.uid);
    (forEach, $__.fs.forEach_8)([
        'src',
        'srcset',
        'href'
    ], ($__.fs.J$__v3645318688_1785_539 = function J$__v3645318688_1785(attrName) {
var vvv_return, vvv_switch, normalized;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
attrName = arguments[0];
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    normalized = (directiveNormalize, $__.fs.directiveNormalize_135)('ng-' + attrName, 6, true, $__.uid);
    (ngAttributeAliasDirectives, $__.os.oid32)[normalized, 'ngSrc'] = ($__.fs.J$__v3645318688_1783_540 = function J$__v3645318688_1783() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return {
    priority: 99,
    link: function (scope, element, attr) {
        var propName = attrName, name = attrName;
        if (attrName === 'href' && toString.call(element.prop('href')) === '[object SVGAnimatedString]') {
            name = 'xlinkHref';
            attr.$attr[name] = 'xlink:href';
            propName = null;
        }
        attr.$observe(normalized, function (value) {
            if (!value) {
                if (attrName === 'href') {
                    attr.$set(name, null);
                }
                return;
            }
            attr.$set(name, value);
            if (msie && propName)
                element.prop(propName, attr[name]);
        });
    }
};});
    return;
case 1:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 1);
    normalized = (directiveNormalize, $__.fs.directiveNormalize_135)('ng-' + attrName, 7, true, $__.uid);
    (ngAttributeAliasDirectives, $__.os.oid32)[normalized, 'ngSrcset'] = ($__.fs.J$__v3645318688_1783_541 = function J$__v3645318688_1783() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return {
    priority: 99,
    link: function (scope, element, attr) {
        var propName = attrName, name = attrName;
        if (attrName === 'href' && toString.call(element.prop('href')) === '[object SVGAnimatedString]') {
            name = 'xlinkHref';
            attr.$attr[name] = 'xlink:href';
            propName = null;
        }
        attr.$observe(normalized, function (value) {
            if (!value) {
                if (attrName === 'href') {
                    attr.$set(name, null);
                }
                return;
            }
            attr.$set(name, value);
            if (msie && propName)
                element.prop(propName, attr[name]);
        });
    }
};});
    return;
case 2:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 2);
    normalized = (directiveNormalize, $__.fs.directiveNormalize_135)('ng-' + attrName, 8, true, $__.uid);
    (ngAttributeAliasDirectives, $__.os.oid32)[normalized, 'ngHref'] = ($__.fs.J$__v3645318688_1783_542 = function J$__v3645318688_1783() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return {
    priority: 99,
    link: function (scope, element, attr) {
        var propName = attrName, name = attrName;
        if (attrName === 'href' && toString.call(element.prop('href')) === '[object SVGAnimatedString]') {
            name = 'xlinkHref';
            attr.$attr[name] = 'xlink:href';
            propName = null;
        }
        attr.$observe(normalized, function (value) {
            if (!value) {
                if (attrName === 'href') {
                    attr.$set(name, null);
                }
                return;
            }
            attr.$set(name, value);
            if (msie && propName)
                element.prop(propName, attr[name]);
        });
    }
};});
    return;
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
normalized = directiveNormalize('ng-' + attrName);
ngAttributeAliasDirectives[normalized] = function () {
    return {
        priority: 99,
        link: function (scope, element, attr) {
            var propName = attrName, name = attrName;
            if (attrName === 'href' && toString.call(element.prop('href')) === '[object SVGAnimatedString]') {
                name = 'xlinkHref';
                attr.$attr[name] = 'xlink:href';
                propName = null;
            }
            attr.$observe(normalized, function (value) {
                if (!value) {
                    if (attrName === 'href') {
                        attr.$set(name, null);
                    }
                    return;
                }
                attr.$set(name, value);
                if (msie && propName)
                    element.prop(propName, attr[name]);
            });
        }
    };
};}, $__.fs.J$__v3645318688_1785_539), 9, true, $__.uid);
    nullFormCtrl = $__.os.oid33 = {
        '$addControl': noop,
        '$$renameControl': nullFormRenameControl,
        '$removeControl': noop,
        '$setValidity': noop,
        '$setDirty': noop,
        '$setPristine': noop,
        '$setSubmitted': noop
    };
    PENDING_CLASS = 'ng-pending';
    SUBMITTED_CLASS = 'ng-submitted';
    FormController.$inject = [
        '$element',
        '$attrs',
        '$scope',
        '$animate',
        '$interpolate'
    ];
    FormController.prototype = $__.os.oid34 = {
        '$rollbackViewValue': ($__.fs.J$__v3645318688_1791_543 = function J$__v3645318688_1791() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
forEach(this.$$controls, function (control) {
    control.$rollbackViewValue();
});}),
        '$commitViewValue': ($__.fs.J$__v3645318688_1795_544 = function J$__v3645318688_1795() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
forEach(this.$$controls, function (control) {
    control.$commitViewValue();
});}),
        '$addControl': ($__.fs.J$__v3645318688_1797_545 = function J$__v3645318688_1797(control) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
control = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
assertNotHasOwnProperty(control.$name, 'input');
this.$$controls.push(control);
if (control.$name) {
    this[control.$name] = control;
}
control.$$parentForm = this;}),
        '$$renameControl': ($__.fs.J$__v3645318688_1799_546 = function J$__v3645318688_1799(control, newName) {
var vvv_return, vvv_switch, oldName;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
control = arguments[0], newName = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
oldName = control.$name;
if (this[oldName] === control) {
    delete this[oldName];
}
this[newName] = control;
control.$name = newName;}),
        '$removeControl': ($__.fs.J$__v3645318688_1807_547 = function J$__v3645318688_1807(control) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
control = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (control.$name && this[control.$name] === control) {
    delete this[control.$name];
}
forEach(this.$pending, function (value, name) {
    this.$setValidity(name, null, control);
}, this);
forEach(this.$error, function (value, name) {
    this.$setValidity(name, null, control);
}, this);
forEach(this.$$success, function (value, name) {
    this.$setValidity(name, null, control);
}, this);
arrayRemove(this.$$controls, control);
control.$$parentForm = nullFormCtrl;}),
        '$setDirty': ($__.fs.J$__v3645318688_1809_548 = function J$__v3645318688_1809() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.$$animate.removeClass(this.$$element, PRISTINE_CLASS);
this.$$animate.addClass(this.$$element, DIRTY_CLASS);
this.$dirty = true;
this.$pristine = false;
this.$$parentForm.$setDirty();}),
        '$setPristine': ($__.fs.J$__v3645318688_1813_549 = function J$__v3645318688_1813() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.$$animate.setClass(this.$$element, PRISTINE_CLASS, DIRTY_CLASS + ' ' + SUBMITTED_CLASS);
this.$dirty = false;
this.$pristine = true;
this.$submitted = false;
forEach(this.$$controls, function (control) {
    control.$setPristine();
});}),
        '$setUntouched': ($__.fs.J$__v3645318688_1817_550 = function J$__v3645318688_1817() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
forEach(this.$$controls, function (control) {
    control.$setUntouched();
});}),
        '$setSubmitted': ($__.fs.J$__v3645318688_1819_551 = function J$__v3645318688_1819() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.$$animate.addClass(this.$$element, SUBMITTED_CLASS);
this.$submitted = true;
this.$$parentForm.$setSubmitted();})
    };
    (addSetValidityMethod, $__.fs.addSetValidityMethod_239)($__.os.oid35 = {
        'clazz': FormController,
        'set': ($__.fs.J$__v3645318688_1821_552 = function J$__v3645318688_1821(object, property, controller) {
var vvv_return, vvv_switch, list, index;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
object = arguments[0], property = arguments[1], controller = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
list = object[property];
if (!list) {
    object[property] = [controller];
} else {
    index = list.indexOf(controller);
    if (index === -1) {
        list.push(controller);
    }
}}),
        'unset': ($__.fs.J$__v3645318688_1823_553 = function J$__v3645318688_1823(object, property, controller) {
var vvv_return, vvv_switch, list;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
object = arguments[0], property = arguments[1], controller = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
list = object[property];
if (!list) {
    return;
}
arrayRemove(list, controller);
if (list.length === 0) {
    delete object[property];
}})
    }, 0, true, $__.uid);
    formDirectiveFactory = ($__.fs.J$__v3645318688_1842_559 = function J$__v3645318688_1842(isNgForm) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
isNgForm = arguments[0];
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    return [
        '$timeout',
        '$parse',
        ($__.fs.J$__v3645318688_1840_560 = function J$__v3645318688_1840($timeout, $parse) {
var vvv_return, vvv_switch, formDirective, getSetter;
getSetter = function getSetter(expression) {
    if (expression === '') {
        return $parse('this[""]').assign;
    }
    return $parse(expression).assign || noop;
};
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
$timeout = arguments[0], $parse = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
formDirective = {
    name: 'form',
    restrict: isNgForm ? 'EAC' : 'E',
    require: [
        'form',
        '^^?form'
    ],
    controller: FormController,
    compile: function ngFormCompile(formElement, attr) {
        formElement.addClass(PRISTINE_CLASS).addClass(VALID_CLASS);
        var nameAttr = attr.name ? 'name' : isNgForm && attr.ngForm ? 'ngForm' : false;
        return {
            pre: function ngFormPreLink(scope, formElement, attr, ctrls) {
                var controller = ctrls[0];
                if (!('action' in attr)) {
                    var handleFormSubmission = function (event) {
                        scope.$apply(function () {
                            controller.$commitViewValue();
                            controller.$setSubmitted();
                        });
                        event.preventDefault();
                    };
                    formElement[0].addEventListener('submit', handleFormSubmission);
                    formElement.on('$destroy', function () {
                        $timeout(function () {
                            formElement[0].removeEventListener('submit', handleFormSubmission);
                        }, 0, false);
                    });
                }
                var parentFormCtrl = ctrls[1] || controller.$$parentForm;
                parentFormCtrl.$addControl(controller);
                var setter = nameAttr ? getSetter(controller.$name) : noop;
                if (nameAttr) {
                    setter(scope, controller);
                    attr.$observe(nameAttr, function (newValue) {
                        if (controller.$name === newValue)
                            return;
                        setter(scope, undefined);
                        controller.$$parentForm.$$renameControl(controller, newValue);
                        setter = getSetter(controller.$name);
                        setter(scope, controller);
                    });
                }
                formElement.on('$destroy', function () {
                    controller.$$parentForm.$removeControl(controller);
                    setter(scope, undefined);
                    extend(controller, nullFormCtrl);
                });
            }
        };
    }
};
return formDirective;})
    ];
case 1:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 1);
    return [
        '$timeout',
        '$parse',
        ($__.fs.J$__v3645318688_1840_561 = function J$__v3645318688_1840($timeout, $parse) {
var vvv_return, vvv_switch, formDirective, getSetter;
getSetter = function getSetter(expression) {
    if (expression === '') {
        return $parse('this[""]').assign;
    }
    return $parse(expression).assign || noop;
};
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
$timeout = arguments[0], $parse = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
formDirective = {
    name: 'form',
    restrict: isNgForm ? 'EAC' : 'E',
    require: [
        'form',
        '^^?form'
    ],
    controller: FormController,
    compile: function ngFormCompile(formElement, attr) {
        formElement.addClass(PRISTINE_CLASS).addClass(VALID_CLASS);
        var nameAttr = attr.name ? 'name' : isNgForm && attr.ngForm ? 'ngForm' : false;
        return {
            pre: function ngFormPreLink(scope, formElement, attr, ctrls) {
                var controller = ctrls[0];
                if (!('action' in attr)) {
                    var handleFormSubmission = function (event) {
                        scope.$apply(function () {
                            controller.$commitViewValue();
                            controller.$setSubmitted();
                        });
                        event.preventDefault();
                    };
                    formElement[0].addEventListener('submit', handleFormSubmission);
                    formElement.on('$destroy', function () {
                        $timeout(function () {
                            formElement[0].removeEventListener('submit', handleFormSubmission);
                        }, 0, false);
                    });
                }
                var parentFormCtrl = ctrls[1] || controller.$$parentForm;
                parentFormCtrl.$addControl(controller);
                var setter = nameAttr ? getSetter(controller.$name) : noop;
                if (nameAttr) {
                    setter(scope, controller);
                    attr.$observe(nameAttr, function (newValue) {
                        if (controller.$name === newValue)
                            return;
                        setter(scope, undefined);
                        controller.$$parentForm.$$renameControl(controller, newValue);
                        setter = getSetter(controller.$name);
                        setter(scope, controller);
                    });
                }
                formElement.on('$destroy', function () {
                    controller.$$parentForm.$removeControl(controller);
                    setter(scope, undefined);
                    extend(controller, nullFormCtrl);
                });
            }
        };
    }
};
return formDirective;})
    ];
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return [
    '$timeout',
    '$parse',
    function ($timeout, $parse) {
        var formDirective = {
            name: 'form',
            restrict: isNgForm ? 'EAC' : 'E',
            require: [
                'form',
                '^^?form'
            ],
            controller: FormController,
            compile: function ngFormCompile(formElement, attr) {
                formElement.addClass(PRISTINE_CLASS).addClass(VALID_CLASS);
                var nameAttr = attr.name ? 'name' : isNgForm && attr.ngForm ? 'ngForm' : false;
                return {
                    pre: function ngFormPreLink(scope, formElement, attr, ctrls) {
                        var controller = ctrls[0];
                        if (!('action' in attr)) {
                            var handleFormSubmission = function (event) {
                                scope.$apply(function () {
                                    controller.$commitViewValue();
                                    controller.$setSubmitted();
                                });
                                event.preventDefault();
                            };
                            formElement[0].addEventListener('submit', handleFormSubmission);
                            formElement.on('$destroy', function () {
                                $timeout(function () {
                                    formElement[0].removeEventListener('submit', handleFormSubmission);
                                }, 0, false);
                            });
                        }
                        var parentFormCtrl = ctrls[1] || controller.$$parentForm;
                        parentFormCtrl.$addControl(controller);
                        var setter = nameAttr ? getSetter(controller.$name) : noop;
                        if (nameAttr) {
                            setter(scope, controller);
                            attr.$observe(nameAttr, function (newValue) {
                                if (controller.$name === newValue)
                                    return;
                                setter(scope, undefined);
                                controller.$$parentForm.$$renameControl(controller, newValue);
                                setter = getSetter(controller.$name);
                                setter(scope, controller);
                            });
                        }
                        formElement.on('$destroy', function () {
                            controller.$$parentForm.$removeControl(controller);
                            setter(scope, undefined);
                            extend(controller, nullFormCtrl);
                        });
                    }
                };
            }
        };
        return formDirective;
        function getSetter(expression) {
            if (expression === '') {
                return $parse('this[""]').assign;
            }
            return $parse(expression).assign || noop;
        }
    }
];});
    formDirective = (formDirectiveFactory, $__.fs.J$__v3645318688_1842_559)(0, true, $__.uid);
    ngFormDirective = (formDirectiveFactory, $__.fs.J$__v3645318688_1842_559)(true, 1, true, $__.uid);
    ISO_DATE_REGEXP = /^\d{4,}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+(?:[+-][0-2]\d:[0-5]\d|Z)$/;
    URL_REGEXP = /^[a-z][a-z\d.+-]*:\/*(?:[^:@]+(?::[^@]+)?@)?(?:[^\s:\/?#]+|\[[a-f\d:]+])(?::\d+)?(?:\/[^?#]*)?(?:\?[^#]*)?(?:#.*)?$/i;
    EMAIL_REGEXP = /^(?=.{1,254}$)(?=.{1,64}@)[-!#$%&'*+\/0-9=?A-Z^_`a-z{|}~]+(\.[-!#$%&'*+\/0-9=?A-Z^_`a-z{|}~]+)*@[A-Za-z0-9]([A-Za-z0-9-]{0,61}[A-Za-z0-9])?(\.[A-Za-z0-9]([A-Za-z0-9-]{0,61}[A-Za-z0-9])?)*$/;
    NUMBER_REGEXP = /^\s*(-|\+)?(\d+|(\d*(\.\d*)))([eE][+-]?\d+)?\s*$/;
    DATE_REGEXP = /^(\d{4,})-(\d{2})-(\d{2})$/;
    DATETIMELOCAL_REGEXP = /^(\d{4,})-(\d\d)-(\d\d)T(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/;
    WEEK_REGEXP = /^(\d{4,})-W(\d\d)$/;
    MONTH_REGEXP = /^(\d{4,})-(\d\d)$/;
    TIME_REGEXP = /^(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/;
    PARTIAL_VALIDATION_EVENTS = 'keydown wheel mousedown';
    PARTIAL_VALIDATION_TYPES = (createMap, $__.fs.createMap_75)(1, true, $__.uid);
    (forEach, $__.fs.forEach_8)(function $__lt3(res) {
        res.length = 5;
        if (res.length != 5)
            TAJS_dumpValue('Possible loss of precision');
        return res;
        ;
        TAJS_makeContextSensitive($__lt3, -2);
    }('date,datetime-local,month,time,week'['split'](',')), ($__.fs.J$__v3645318688_1853_562 = function J$__v3645318688_1853(type) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
type = arguments[0];
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    PARTIAL_VALIDATION_TYPES[type, 'date'] = true;
    return;
case 1:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 1);
    PARTIAL_VALIDATION_TYPES[type, 'datetime-local'] = true;
    return;
case 2:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 2);
    PARTIAL_VALIDATION_TYPES[type, 'month'] = true;
    return;
case 3:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 3);
    PARTIAL_VALIDATION_TYPES[type, 'time'] = true;
    return;
case 4:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 4);
    PARTIAL_VALIDATION_TYPES[type, 'week'] = true;
    return;
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
PARTIAL_VALIDATION_TYPES[type] = true;}, $__.fs.J$__v3645318688_1853_562), 10, true, $__.uid);
    inputType = $__.os.oid36 = {
        'text': textInputType,
        'date': (createDateInputType, $__.fs.createDateInputType_246)('date', DATE_REGEXP, ((createDateParser, $__.fs.createDateParser_245)(DATE_REGEXP, [
            'yyyy',
            'MM',
            'dd'
        ], 0, true, $__.uid), $__.fs.J$__v3645318688_1881_563), 'yyyy-MM-dd', 0, true, $__.uid),
        'datetime-local': (createDateInputType, $__.fs.createDateInputType_246)('datetimelocal', DATETIMELOCAL_REGEXP, ((createDateParser, $__.fs.createDateParser_245)(DATETIMELOCAL_REGEXP, [
            'yyyy',
            'MM',
            'dd',
            'HH',
            'mm',
            'ss',
            'sss'
        ], 1, true, $__.uid), $__.fs.J$__v3645318688_1881_565), 'yyyy-MM-ddTHH:mm:ss.sss', 1, true, $__.uid),
        'time': (createDateInputType, $__.fs.createDateInputType_246)('time', TIME_REGEXP, ((createDateParser, $__.fs.createDateParser_245)(TIME_REGEXP, [
            'HH',
            'mm',
            'ss',
            'sss'
        ], 2, true, $__.uid), $__.fs.J$__v3645318688_1881_567), 'HH:mm:ss.sss', 2, true, $__.uid),
        'week': (createDateInputType, $__.fs.createDateInputType_246)('week', WEEK_REGEXP, (weekParser, $__.fs.weekParser_244), 'yyyy-Www', 3, true, $__.uid),
        'month': (createDateInputType, $__.fs.createDateInputType_246)('month', MONTH_REGEXP, ((createDateParser, $__.fs.createDateParser_245)(MONTH_REGEXP, [
            'yyyy',
            'MM'
        ], 3, true, $__.uid), $__.fs.J$__v3645318688_1881_570), 'yyyy-MM', 4, true, $__.uid),
        'number': numberInputType,
        'url': urlInputType,
        'email': emailInputType,
        'radio': radioInputType,
        'range': rangeInputType,
        'checkbox': checkboxInputType,
        'hidden': noop,
        'button': noop,
        'submit': noop,
        'reset': noop,
        'file': noop
    };
    inputDirective = [
        '$browser',
        '$sniffer',
        '$filter',
        '$parse',
        ($__.fs.J$__v3645318688_1962_572 = function J$__v3645318688_1962($browser, $sniffer, $filter, $parse) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
$browser = arguments[0], $sniffer = arguments[1], $filter = arguments[2], $parse = arguments[3];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return {
    restrict: 'E',
    require: ['?ngModel'],
    link: {
        pre: function (scope, element, attr, ctrls) {
            if (ctrls[0]) {
                (inputType[lowercase(attr.type)] || inputType.text)(scope, element, attr, ctrls[0], $sniffer, $browser, $filter, $parse);
            }
        }
    }
};})
    ];
    CONSTANT_VALUE_REGEXP = /^(true|false|\d+)$/;
    ngValueDirective = ($__.fs.J$__v3645318688_1970_573 = function J$__v3645318688_1970() {
var vvv_return, vvv_switch, updateElementValue;
updateElementValue = function updateElementValue(element, attr, value) {
    var propValue = isDefined(value) ? value : msie === 9 ? '' : null;
    element.prop('value', propValue);
    attr.$set('value', value);
};
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return {
    restrict: 'A',
    priority: 100,
    compile: function (tpl, tplAttr) {
        if (CONSTANT_VALUE_REGEXP.test(tplAttr.ngValue)) {
            return function ngValueConstantLink(scope, elm, attr) {
                var value = scope.$eval(attr.ngValue);
                updateElementValue(elm, attr, value);
            };
        } else {
            return function ngValueLink(scope, elm, attr) {
                scope.$watch(attr.ngValue, function valueWatchAction(value) {
                    updateElementValue(elm, attr, value);
                });
            };
        }
    }
};});
    ngBindDirective = [
        '$compile',
        ($__.fs.J$__v3645318688_1975_574 = function J$__v3645318688_1975($compile) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
$compile = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return {
    restrict: 'AC',
    compile: function ngBindCompile(templateElement) {
        $compile.$$addBindingClass(templateElement);
        return function ngBindLink(scope, element, attr) {
            $compile.$$addBindingInfo(element, attr.ngBind);
            element = element[0];
            scope.$watch(attr.ngBind, function ngBindWatchAction(value) {
                element.textContent = stringify(value);
            });
        };
    }
};})
    ];
    ngBindTemplateDirective = [
        '$interpolate',
        '$compile',
        ($__.fs.J$__v3645318688_1981_575 = function J$__v3645318688_1981($interpolate, $compile) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
$interpolate = arguments[0], $compile = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return {
    compile: function ngBindTemplateCompile(templateElement) {
        $compile.$$addBindingClass(templateElement);
        return function ngBindTemplateLink(scope, element, attr) {
            var interpolateFn = $interpolate(element.attr(attr.$attr.ngBindTemplate));
            $compile.$$addBindingInfo(element, interpolateFn.expressions);
            element = element[0];
            attr.$observe('ngBindTemplate', function (value) {
                element.textContent = isUndefined(value) ? '' : value;
            });
        };
    }
};})
    ];
    ngBindHtmlDirective = [
        '$sce',
        '$parse',
        '$compile',
        ($__.fs.J$__v3645318688_1987_576 = function J$__v3645318688_1987($sce, $parse, $compile) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
$sce = arguments[0], $parse = arguments[1], $compile = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return {
    restrict: 'A',
    compile: function ngBindHtmlCompile(tElement, tAttrs) {
        var ngBindHtmlGetter = $parse(tAttrs.ngBindHtml);
        var ngBindHtmlWatch = $parse(tAttrs.ngBindHtml, function sceValueOf(val) {
            return $sce.valueOf(val);
        });
        $compile.$$addBindingClass(tElement);
        return function ngBindHtmlLink(scope, element, attr) {
            $compile.$$addBindingInfo(element, attr.ngBindHtml);
            scope.$watch(ngBindHtmlWatch, function ngBindHtmlWatchAction() {
                var value = ngBindHtmlGetter(scope);
                element.html($sce.getTrustedHtml(value) || '');
            });
        };
    }
};})
    ];
    ngChangeDirective = (valueFn, $__.fs.valueFn_20)($__.os.oid37 = {
        'restrict': 'A',
        'require': 'ngModel',
        'link': ($__.fs.J$__v3645318688_1991_577 = function J$__v3645318688_1991(scope, element, attr, ctrl) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
scope = arguments[0], element = arguments[1], attr = arguments[2], ctrl = arguments[3];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
ctrl.$viewChangeListeners.push(function () {
    scope.$eval(attr.ngChange);
});})
    }, 3, true, $__.uid);
    ngClassDirective = (classDirective, $__.fs.classDirective_260)('', true, 0, true, $__.uid);
    ngClassOddDirective = (classDirective, $__.fs.classDirective_260)('Odd', 0, 1, true, $__.uid);
    ngClassEvenDirective = (classDirective, $__.fs.classDirective_260)('Even', 1, 2, true, $__.uid);
    ngCloakDirective = (ngDirective, $__.fs.ngDirective_235)($__.os.oid38 = {
        'compile': ($__.fs.J$__v3645318688_2016_594 = function J$__v3645318688_2016(element, attr) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
element = arguments[0], attr = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
attr.$set('ngCloak', undefined);
element.removeClass('ng-cloak');})
    }, 0, true, $__.uid);
    ngControllerDirective = [($__.fs.J$__v3645318688_2018_596 = function J$__v3645318688_2018() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return {
    restrict: 'A',
    scope: true,
    controller: '@',
    priority: 500
};})];
    ngEventDirectives = $__.os.oid39 = {};
    forceAsyncEvents = $__.os.oid40 = {
        'blur': true,
        'focus': true
    };
    (forEach, $__.fs.forEach_8)(function $__lt4(res) {
        res.length = 18;
        if (res.length != 18)
            TAJS_dumpValue('Possible loss of precision');
        return res;
        ;
        TAJS_makeContextSensitive($__lt4, -2);
    }('click dblclick mousedown mouseup mouseover mouseout mousemove mouseenter mouseleave keydown keyup keypress submit focus blur copy cut paste'['split'](' ')), ($__.fs.J$__v3645318688_2029_597 = function J$__v3645318688_2029(eventName) {
var vvv_return, vvv_switch, directiveName;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
eventName = arguments[0];
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    directiveName = (directiveNormalize, $__.fs.directiveNormalize_135)('ng-' + eventName, 9, true, $__.uid);
    (ngEventDirectives, $__.os.oid39)[directiveName, 'ngClick'] = [
        '$parse',
        '$rootScope',
        ($__.fs.J$__v3645318688_2027_598 = function J$__v3645318688_2027($parse, $rootScope) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
$parse = arguments[0], $rootScope = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return {
    restrict: 'A',
    compile: function ($element, attr) {
        var fn = $parse(attr[directiveName]);
        return function ngEventHandler(scope, element) {
            element.on(eventName, function (event) {
                var callback = function () {
                    fn(scope, {
                        $event: event
                    });
                };
                if (forceAsyncEvents[eventName] && $rootScope.$$phase) {
                    scope.$evalAsync(callback);
                } else {
                    scope.$apply(callback);
                }
            });
        };
    }
};})
    ];
    return;
case 1:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 1);
    directiveName = (directiveNormalize, $__.fs.directiveNormalize_135)('ng-' + eventName, 10, true, $__.uid);
    (ngEventDirectives, $__.os.oid39)[directiveName, 'ngDblclick'] = [
        '$parse',
        '$rootScope',
        ($__.fs.J$__v3645318688_2027_599 = function J$__v3645318688_2027($parse, $rootScope) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
$parse = arguments[0], $rootScope = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return {
    restrict: 'A',
    compile: function ($element, attr) {
        var fn = $parse(attr[directiveName]);
        return function ngEventHandler(scope, element) {
            element.on(eventName, function (event) {
                var callback = function () {
                    fn(scope, {
                        $event: event
                    });
                };
                if (forceAsyncEvents[eventName] && $rootScope.$$phase) {
                    scope.$evalAsync(callback);
                } else {
                    scope.$apply(callback);
                }
            });
        };
    }
};})
    ];
    return;
case 2:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 2);
    directiveName = (directiveNormalize, $__.fs.directiveNormalize_135)('ng-' + eventName, 11, true, $__.uid);
    (ngEventDirectives, $__.os.oid39)[directiveName, 'ngMousedown'] = [
        '$parse',
        '$rootScope',
        ($__.fs.J$__v3645318688_2027_600 = function J$__v3645318688_2027($parse, $rootScope) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
$parse = arguments[0], $rootScope = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return {
    restrict: 'A',
    compile: function ($element, attr) {
        var fn = $parse(attr[directiveName]);
        return function ngEventHandler(scope, element) {
            element.on(eventName, function (event) {
                var callback = function () {
                    fn(scope, {
                        $event: event
                    });
                };
                if (forceAsyncEvents[eventName] && $rootScope.$$phase) {
                    scope.$evalAsync(callback);
                } else {
                    scope.$apply(callback);
                }
            });
        };
    }
};})
    ];
    return;
case 3:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 3);
    directiveName = (directiveNormalize, $__.fs.directiveNormalize_135)('ng-' + eventName, 12, true, $__.uid);
    (ngEventDirectives, $__.os.oid39)[directiveName, 'ngMouseup'] = [
        '$parse',
        '$rootScope',
        ($__.fs.J$__v3645318688_2027_601 = function J$__v3645318688_2027($parse, $rootScope) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
$parse = arguments[0], $rootScope = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return {
    restrict: 'A',
    compile: function ($element, attr) {
        var fn = $parse(attr[directiveName]);
        return function ngEventHandler(scope, element) {
            element.on(eventName, function (event) {
                var callback = function () {
                    fn(scope, {
                        $event: event
                    });
                };
                if (forceAsyncEvents[eventName] && $rootScope.$$phase) {
                    scope.$evalAsync(callback);
                } else {
                    scope.$apply(callback);
                }
            });
        };
    }
};})
    ];
    return;
case 4:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 4);
    directiveName = (directiveNormalize, $__.fs.directiveNormalize_135)('ng-' + eventName, 13, true, $__.uid);
    (ngEventDirectives, $__.os.oid39)[directiveName, 'ngMouseover'] = [
        '$parse',
        '$rootScope',
        ($__.fs.J$__v3645318688_2027_602 = function J$__v3645318688_2027($parse, $rootScope) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
$parse = arguments[0], $rootScope = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return {
    restrict: 'A',
    compile: function ($element, attr) {
        var fn = $parse(attr[directiveName]);
        return function ngEventHandler(scope, element) {
            element.on(eventName, function (event) {
                var callback = function () {
                    fn(scope, {
                        $event: event
                    });
                };
                if (forceAsyncEvents[eventName] && $rootScope.$$phase) {
                    scope.$evalAsync(callback);
                } else {
                    scope.$apply(callback);
                }
            });
        };
    }
};})
    ];
    return;
case 5:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 5);
    directiveName = (directiveNormalize, $__.fs.directiveNormalize_135)('ng-' + eventName, 14, true, $__.uid);
    (ngEventDirectives, $__.os.oid39)[directiveName, 'ngMouseout'] = [
        '$parse',
        '$rootScope',
        ($__.fs.J$__v3645318688_2027_603 = function J$__v3645318688_2027($parse, $rootScope) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
$parse = arguments[0], $rootScope = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return {
    restrict: 'A',
    compile: function ($element, attr) {
        var fn = $parse(attr[directiveName]);
        return function ngEventHandler(scope, element) {
            element.on(eventName, function (event) {
                var callback = function () {
                    fn(scope, {
                        $event: event
                    });
                };
                if (forceAsyncEvents[eventName] && $rootScope.$$phase) {
                    scope.$evalAsync(callback);
                } else {
                    scope.$apply(callback);
                }
            });
        };
    }
};})
    ];
    return;
case 6:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 6);
    directiveName = (directiveNormalize, $__.fs.directiveNormalize_135)('ng-' + eventName, 15, true, $__.uid);
    (ngEventDirectives, $__.os.oid39)[directiveName, 'ngMousemove'] = [
        '$parse',
        '$rootScope',
        ($__.fs.J$__v3645318688_2027_604 = function J$__v3645318688_2027($parse, $rootScope) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
$parse = arguments[0], $rootScope = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return {
    restrict: 'A',
    compile: function ($element, attr) {
        var fn = $parse(attr[directiveName]);
        return function ngEventHandler(scope, element) {
            element.on(eventName, function (event) {
                var callback = function () {
                    fn(scope, {
                        $event: event
                    });
                };
                if (forceAsyncEvents[eventName] && $rootScope.$$phase) {
                    scope.$evalAsync(callback);
                } else {
                    scope.$apply(callback);
                }
            });
        };
    }
};})
    ];
    return;
case 7:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 7);
    directiveName = (directiveNormalize, $__.fs.directiveNormalize_135)('ng-' + eventName, 16, true, $__.uid);
    (ngEventDirectives, $__.os.oid39)[directiveName, 'ngMouseenter'] = [
        '$parse',
        '$rootScope',
        ($__.fs.J$__v3645318688_2027_605 = function J$__v3645318688_2027($parse, $rootScope) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
$parse = arguments[0], $rootScope = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return {
    restrict: 'A',
    compile: function ($element, attr) {
        var fn = $parse(attr[directiveName]);
        return function ngEventHandler(scope, element) {
            element.on(eventName, function (event) {
                var callback = function () {
                    fn(scope, {
                        $event: event
                    });
                };
                if (forceAsyncEvents[eventName] && $rootScope.$$phase) {
                    scope.$evalAsync(callback);
                } else {
                    scope.$apply(callback);
                }
            });
        };
    }
};})
    ];
    return;
case 8:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 8);
    directiveName = (directiveNormalize, $__.fs.directiveNormalize_135)('ng-' + eventName, 17, true, $__.uid);
    (ngEventDirectives, $__.os.oid39)[directiveName, 'ngMouseleave'] = [
        '$parse',
        '$rootScope',
        ($__.fs.J$__v3645318688_2027_606 = function J$__v3645318688_2027($parse, $rootScope) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
$parse = arguments[0], $rootScope = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return {
    restrict: 'A',
    compile: function ($element, attr) {
        var fn = $parse(attr[directiveName]);
        return function ngEventHandler(scope, element) {
            element.on(eventName, function (event) {
                var callback = function () {
                    fn(scope, {
                        $event: event
                    });
                };
                if (forceAsyncEvents[eventName] && $rootScope.$$phase) {
                    scope.$evalAsync(callback);
                } else {
                    scope.$apply(callback);
                }
            });
        };
    }
};})
    ];
    return;
case 9:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 9);
    directiveName = (directiveNormalize, $__.fs.directiveNormalize_135)('ng-' + eventName, 18, true, $__.uid);
    (ngEventDirectives, $__.os.oid39)[directiveName, 'ngKeydown'] = [
        '$parse',
        '$rootScope',
        ($__.fs.J$__v3645318688_2027_607 = function J$__v3645318688_2027($parse, $rootScope) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
$parse = arguments[0], $rootScope = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return {
    restrict: 'A',
    compile: function ($element, attr) {
        var fn = $parse(attr[directiveName]);
        return function ngEventHandler(scope, element) {
            element.on(eventName, function (event) {
                var callback = function () {
                    fn(scope, {
                        $event: event
                    });
                };
                if (forceAsyncEvents[eventName] && $rootScope.$$phase) {
                    scope.$evalAsync(callback);
                } else {
                    scope.$apply(callback);
                }
            });
        };
    }
};})
    ];
    return;
case 10:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 10);
    directiveName = (directiveNormalize, $__.fs.directiveNormalize_135)('ng-' + eventName, 19, true, $__.uid);
    (ngEventDirectives, $__.os.oid39)[directiveName, 'ngKeyup'] = [
        '$parse',
        '$rootScope',
        ($__.fs.J$__v3645318688_2027_608 = function J$__v3645318688_2027($parse, $rootScope) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
$parse = arguments[0], $rootScope = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return {
    restrict: 'A',
    compile: function ($element, attr) {
        var fn = $parse(attr[directiveName]);
        return function ngEventHandler(scope, element) {
            element.on(eventName, function (event) {
                var callback = function () {
                    fn(scope, {
                        $event: event
                    });
                };
                if (forceAsyncEvents[eventName] && $rootScope.$$phase) {
                    scope.$evalAsync(callback);
                } else {
                    scope.$apply(callback);
                }
            });
        };
    }
};})
    ];
    return;
case 11:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 11);
    directiveName = (directiveNormalize, $__.fs.directiveNormalize_135)('ng-' + eventName, 20, true, $__.uid);
    (ngEventDirectives, $__.os.oid39)[directiveName, 'ngKeypress'] = [
        '$parse',
        '$rootScope',
        ($__.fs.J$__v3645318688_2027_609 = function J$__v3645318688_2027($parse, $rootScope) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
$parse = arguments[0], $rootScope = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return {
    restrict: 'A',
    compile: function ($element, attr) {
        var fn = $parse(attr[directiveName]);
        return function ngEventHandler(scope, element) {
            element.on(eventName, function (event) {
                var callback = function () {
                    fn(scope, {
                        $event: event
                    });
                };
                if (forceAsyncEvents[eventName] && $rootScope.$$phase) {
                    scope.$evalAsync(callback);
                } else {
                    scope.$apply(callback);
                }
            });
        };
    }
};})
    ];
    return;
case 12:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 12);
    directiveName = (directiveNormalize, $__.fs.directiveNormalize_135)('ng-' + eventName, 21, true, $__.uid);
    (ngEventDirectives, $__.os.oid39)[directiveName, 'ngSubmit'] = [
        '$parse',
        '$rootScope',
        ($__.fs.J$__v3645318688_2027_610 = function J$__v3645318688_2027($parse, $rootScope) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
$parse = arguments[0], $rootScope = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return {
    restrict: 'A',
    compile: function ($element, attr) {
        var fn = $parse(attr[directiveName]);
        return function ngEventHandler(scope, element) {
            element.on(eventName, function (event) {
                var callback = function () {
                    fn(scope, {
                        $event: event
                    });
                };
                if (forceAsyncEvents[eventName] && $rootScope.$$phase) {
                    scope.$evalAsync(callback);
                } else {
                    scope.$apply(callback);
                }
            });
        };
    }
};})
    ];
    return;
case 13:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 13);
    directiveName = (directiveNormalize, $__.fs.directiveNormalize_135)('ng-' + eventName, 22, true, $__.uid);
    (ngEventDirectives, $__.os.oid39)[directiveName, 'ngFocus'] = [
        '$parse',
        '$rootScope',
        ($__.fs.J$__v3645318688_2027_611 = function J$__v3645318688_2027($parse, $rootScope) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
$parse = arguments[0], $rootScope = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return {
    restrict: 'A',
    compile: function ($element, attr) {
        var fn = $parse(attr[directiveName]);
        return function ngEventHandler(scope, element) {
            element.on(eventName, function (event) {
                var callback = function () {
                    fn(scope, {
                        $event: event
                    });
                };
                if (forceAsyncEvents[eventName] && $rootScope.$$phase) {
                    scope.$evalAsync(callback);
                } else {
                    scope.$apply(callback);
                }
            });
        };
    }
};})
    ];
    return;
case 14:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 14);
    directiveName = (directiveNormalize, $__.fs.directiveNormalize_135)('ng-' + eventName, 23, true, $__.uid);
    (ngEventDirectives, $__.os.oid39)[directiveName, 'ngBlur'] = [
        '$parse',
        '$rootScope',
        ($__.fs.J$__v3645318688_2027_612 = function J$__v3645318688_2027($parse, $rootScope) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
$parse = arguments[0], $rootScope = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return {
    restrict: 'A',
    compile: function ($element, attr) {
        var fn = $parse(attr[directiveName]);
        return function ngEventHandler(scope, element) {
            element.on(eventName, function (event) {
                var callback = function () {
                    fn(scope, {
                        $event: event
                    });
                };
                if (forceAsyncEvents[eventName] && $rootScope.$$phase) {
                    scope.$evalAsync(callback);
                } else {
                    scope.$apply(callback);
                }
            });
        };
    }
};})
    ];
    return;
case 15:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 15);
    directiveName = (directiveNormalize, $__.fs.directiveNormalize_135)('ng-' + eventName, 24, true, $__.uid);
    (ngEventDirectives, $__.os.oid39)[directiveName, 'ngCopy'] = [
        '$parse',
        '$rootScope',
        ($__.fs.J$__v3645318688_2027_613 = function J$__v3645318688_2027($parse, $rootScope) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
$parse = arguments[0], $rootScope = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return {
    restrict: 'A',
    compile: function ($element, attr) {
        var fn = $parse(attr[directiveName]);
        return function ngEventHandler(scope, element) {
            element.on(eventName, function (event) {
                var callback = function () {
                    fn(scope, {
                        $event: event
                    });
                };
                if (forceAsyncEvents[eventName] && $rootScope.$$phase) {
                    scope.$evalAsync(callback);
                } else {
                    scope.$apply(callback);
                }
            });
        };
    }
};})
    ];
    return;
case 16:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 16);
    directiveName = (directiveNormalize, $__.fs.directiveNormalize_135)('ng-' + eventName, 25, true, $__.uid);
    (ngEventDirectives, $__.os.oid39)[directiveName, 'ngCut'] = [
        '$parse',
        '$rootScope',
        ($__.fs.J$__v3645318688_2027_614 = function J$__v3645318688_2027($parse, $rootScope) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
$parse = arguments[0], $rootScope = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return {
    restrict: 'A',
    compile: function ($element, attr) {
        var fn = $parse(attr[directiveName]);
        return function ngEventHandler(scope, element) {
            element.on(eventName, function (event) {
                var callback = function () {
                    fn(scope, {
                        $event: event
                    });
                };
                if (forceAsyncEvents[eventName] && $rootScope.$$phase) {
                    scope.$evalAsync(callback);
                } else {
                    scope.$apply(callback);
                }
            });
        };
    }
};})
    ];
    return;
case 17:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 17);
    directiveName = (directiveNormalize, $__.fs.directiveNormalize_135)('ng-' + eventName, 26, true, $__.uid);
    (ngEventDirectives, $__.os.oid39)[directiveName, 'ngPaste'] = [
        '$parse',
        '$rootScope',
        ($__.fs.J$__v3645318688_2027_615 = function J$__v3645318688_2027($parse, $rootScope) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
$parse = arguments[0], $rootScope = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return {
    restrict: 'A',
    compile: function ($element, attr) {
        var fn = $parse(attr[directiveName]);
        return function ngEventHandler(scope, element) {
            element.on(eventName, function (event) {
                var callback = function () {
                    fn(scope, {
                        $event: event
                    });
                };
                if (forceAsyncEvents[eventName] && $rootScope.$$phase) {
                    scope.$evalAsync(callback);
                } else {
                    scope.$apply(callback);
                }
            });
        };
    }
};})
    ];
    return;
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
directiveName = directiveNormalize('ng-' + eventName);
ngEventDirectives[directiveName] = [
    '$parse',
    '$rootScope',
    function ($parse, $rootScope) {
        return {
            restrict: 'A',
            compile: function ($element, attr) {
                var fn = $parse(attr[directiveName]);
                return function ngEventHandler(scope, element) {
                    element.on(eventName, function (event) {
                        var callback = function () {
                            fn(scope, {
                                $event: event
                            });
                        };
                        if (forceAsyncEvents[eventName] && $rootScope.$$phase) {
                            scope.$evalAsync(callback);
                        } else {
                            scope.$apply(callback);
                        }
                    });
                };
            }
        };
    }
];}, $__.fs.J$__v3645318688_2029_597), 11, true, $__.uid);
    ngIfDirective = [
        '$animate',
        '$compile',
        ($__.fs.J$__v3645318688_2038_616 = function J$__v3645318688_2038($animate, $compile) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
$animate = arguments[0], $compile = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return {
    multiElement: true,
    transclude: 'element',
    priority: 600,
    terminal: true,
    restrict: 'A',
    $$tlb: true,
    link: function ($scope, $element, $attr, ctrl, $transclude) {
        var block, childScope, previousElements;
        $scope.$watch($attr.ngIf, function ngIfWatchAction(value) {
            if (value) {
                if (!childScope) {
                    $transclude(function (clone, newScope) {
                        childScope = newScope;
                        clone[clone.length++] = $compile.$$createComment('end ngIf', $attr.ngIf);
                        block = {
                            clone: clone
                        };
                        $animate.enter(clone, $element.parent(), $element);
                    });
                }
            } else {
                if (previousElements) {
                    previousElements.remove();
                    previousElements = null;
                }
                if (childScope) {
                    childScope.$destroy();
                    childScope = null;
                }
                if (block) {
                    previousElements = getBlockNodes(block.clone);
                    $animate.leave(previousElements).done(function (response) {
                        if (response !== false)
                            previousElements = null;
                    });
                    block = null;
                }
            }
        });
    }
};})
    ];
    ngIncludeDirective = [
        '$templateRequest',
        '$anchorScroll',
        '$animate',
        ($__.fs.J$__v3645318688_2057_617 = function J$__v3645318688_2057($templateRequest, $anchorScroll, $animate) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
$templateRequest = arguments[0], $anchorScroll = arguments[1], $animate = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return {
    restrict: 'ECA',
    priority: 400,
    terminal: true,
    transclude: 'element',
    controller: angular.noop,
    compile: function (element, attr) {
        var srcExp = attr.ngInclude || attr.src, onloadExp = attr.onload || '', autoScrollExp = attr.autoscroll;
        return function (scope, $element, $attr, ctrl, $transclude) {
            var changeCounter = 0, currentScope, previousElement, currentElement;
            var cleanupLastIncludeContent = function () {
                if (previousElement) {
                    previousElement.remove();
                    previousElement = null;
                }
                if (currentScope) {
                    currentScope.$destroy();
                    currentScope = null;
                }
                if (currentElement) {
                    $animate.leave(currentElement).done(function (response) {
                        if (response !== false)
                            previousElement = null;
                    });
                    previousElement = currentElement;
                    currentElement = null;
                }
            };
            scope.$watch(srcExp, function ngIncludeWatchAction(src) {
                var afterAnimation = function (response) {
                    if (response !== false && isDefined(autoScrollExp) && (!autoScrollExp || scope.$eval(autoScrollExp))) {
                        $anchorScroll();
                    }
                };
                var thisChangeId = ++changeCounter;
                if (src) {
                    $templateRequest(src, true).then(function (response) {
                        if (scope.$$destroyed)
                            return;
                        if (thisChangeId !== changeCounter)
                            return;
                        var newScope = scope.$new();
                        ctrl.template = response;
                        var clone = $transclude(newScope, function (clone) {
                            cleanupLastIncludeContent();
                            $animate.enter(clone, null, $element).done(afterAnimation);
                        });
                        currentScope = newScope;
                        currentElement = clone;
                        currentScope.$emit('$includeContentLoaded', src);
                        scope.$eval(onloadExp);
                    }, function () {
                        if (scope.$$destroyed)
                            return;
                        if (thisChangeId === changeCounter) {
                            cleanupLastIncludeContent();
                            scope.$emit('$includeContentError', src);
                        }
                    });
                    scope.$emit('$includeContentRequested', src);
                } else {
                    cleanupLastIncludeContent();
                    ctrl.template = null;
                }
            });
        };
    }
};})
    ];
    ngIncludeFillContentDirective = [
        '$compile',
        ($__.fs.J$__v3645318688_2062_618 = function J$__v3645318688_2062($compile) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
$compile = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return {
    restrict: 'ECA',
    priority: -400,
    require: 'ngInclude',
    link: function (scope, $element, $attr, ctrl) {
        if (toString.call($element[0]).match(/SVG/)) {
            $element.empty();
            $compile(jqLiteBuildFragment(ctrl.template, window.document).childNodes)(scope, function namespaceAdaptedClone(clone) {
                $element.append(clone);
            }, {
                futureParentElement: $element
            });
            return;
        }
        $element.html(ctrl.template);
        $compile($element.contents())(scope);
    }
};})
    ];
    ngInitDirective = (ngDirective, $__.fs.ngDirective_235)($__.os.oid41 = {
        'priority': 450,
        'compile': ($__.fs.J$__v3645318688_2066_619 = function J$__v3645318688_2066() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return {
    pre: function (scope, element, attrs) {
        scope.$eval(attrs.ngInit);
    }
};})
    }, 1, true, $__.uid);
    ngListDirective = ($__.fs.J$__v3645318688_2078_621 = function J$__v3645318688_2078() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return {
    restrict: 'A',
    priority: 100,
    require: 'ngModel',
    link: function (scope, element, attr, ctrl) {
        var ngList = attr.ngList || ', ';
        var trimValues = attr.ngTrim !== 'false';
        var separator = trimValues ? trim(ngList) : ngList;
        var parse = function (viewValue) {
            if (isUndefined(viewValue))
                return;
            var list = [];
            if (viewValue) {
                forEach(viewValue.split(separator), function (value) {
                    if (value)
                        list.push(trimValues ? trim(value) : value);
                });
            }
            return list;
        };
        ctrl.$parsers.push(parse);
        ctrl.$formatters.push(function (value) {
            if (isArray(value)) {
                return value.join(ngList);
            }
            return undefined;
        });
        ctrl.$isEmpty = function (value) {
            return !value || !value.length;
        };
    }
};});
    VALID_CLASS = 'ng-valid';
    INVALID_CLASS = 'ng-invalid';
    PRISTINE_CLASS = 'ng-pristine';
    DIRTY_CLASS = 'ng-dirty';
    UNTOUCHED_CLASS = 'ng-untouched';
    TOUCHED_CLASS = 'ng-touched';
    EMPTY_CLASS = 'ng-empty';
    NOT_EMPTY_CLASS = 'ng-not-empty';
    ngModelMinErr = (minErr, $__.fs.minErr_4)('ngModel', 12, true, $__.uid);
    NgModelController.$inject = [
        '$scope',
        '$exceptionHandler',
        '$attrs',
        '$element',
        '$parse',
        '$animate',
        '$timeout',
        '$q',
        '$interpolate'
    ];
    NgModelController.prototype = $__.os.oid42 = {
        '$$initGetterSetters': ($__.fs.J$__v3645318688_2085_623 = function J$__v3645318688_2085() {
var vvv_return, vvv_switch, invokeModelGetter, invokeModelSetter;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (this.$options.getOption('getterSetter')) {
    invokeModelGetter = this.$$parse(this.$$attr.ngModel + '()');
    invokeModelSetter = this.$$parse(this.$$attr.ngModel + '($$$p)');
    this.$$ngModelGet = function ($scope) {
        var modelValue = this.$$parsedNgModel($scope);
        if (isFunction(modelValue)) {
            modelValue = invokeModelGetter($scope);
        }
        return modelValue;
    };
    this.$$ngModelSet = function ($scope, newValue) {
        if (isFunction(this.$$parsedNgModel($scope))) {
            invokeModelSetter($scope, {
                $$$p: newValue
            });
        } else {
            this.$$parsedNgModelAssign($scope, newValue);
        }
    };
} else if (!this.$$parsedNgModel.assign) {
    throw ngModelMinErr('nonassign', 'Expression \'{0}\' is non-assignable. Element: {1}', this.$$attr.ngModel, startingTag(this.$$element));
}}),
        '$render': noop,
        '$isEmpty': ($__.fs.J$__v3645318688_2087_624 = function J$__v3645318688_2087(value) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
value = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return isUndefined(value) || value === '' || value === null || value !== value;}),
        '$$updateEmptyClasses': ($__.fs.J$__v3645318688_2089_625 = function J$__v3645318688_2089(value) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
value = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (this.$isEmpty(value)) {
    this.$$animate.removeClass(this.$$element, NOT_EMPTY_CLASS);
    this.$$animate.addClass(this.$$element, EMPTY_CLASS);
} else {
    this.$$animate.removeClass(this.$$element, EMPTY_CLASS);
    this.$$animate.addClass(this.$$element, NOT_EMPTY_CLASS);
}}),
        '$setPristine': ($__.fs.J$__v3645318688_2091_626 = function J$__v3645318688_2091() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.$dirty = false;
this.$pristine = true;
this.$$animate.removeClass(this.$$element, DIRTY_CLASS);
this.$$animate.addClass(this.$$element, PRISTINE_CLASS);}),
        '$setDirty': ($__.fs.J$__v3645318688_2093_627 = function J$__v3645318688_2093() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.$dirty = true;
this.$pristine = false;
this.$$animate.removeClass(this.$$element, PRISTINE_CLASS);
this.$$animate.addClass(this.$$element, DIRTY_CLASS);
this.$$parentForm.$setDirty();}),
        '$setUntouched': ($__.fs.J$__v3645318688_2095_628 = function J$__v3645318688_2095() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.$touched = false;
this.$untouched = true;
this.$$animate.setClass(this.$$element, UNTOUCHED_CLASS, TOUCHED_CLASS);}),
        '$setTouched': ($__.fs.J$__v3645318688_2097_629 = function J$__v3645318688_2097() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.$touched = true;
this.$untouched = false;
this.$$animate.setClass(this.$$element, TOUCHED_CLASS, UNTOUCHED_CLASS);}),
        '$rollbackViewValue': ($__.fs.J$__v3645318688_2099_630 = function J$__v3645318688_2099() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.$$timeout.cancel(this.$$pendingDebounce);
this.$viewValue = this.$$lastCommittedViewValue;
this.$render();}),
        '$validate': ($__.fs.J$__v3645318688_2103_631 = function J$__v3645318688_2103() {
var vvv_return, vvv_switch, viewValue, modelValue, prevValid, prevModelValue, allowInvalid, that;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (isNumberNaN(this.$modelValue)) {
    return;
}
viewValue = this.$$lastCommittedViewValue;
modelValue = this.$$rawModelValue;
prevValid = this.$valid;
prevModelValue = this.$modelValue;
allowInvalid = this.$options.getOption('allowInvalid');
that = this;
this.$$runValidators(modelValue, viewValue, function (allValid) {
    if (!allowInvalid && prevValid !== allValid) {
        that.$modelValue = allValid ? modelValue : undefined;
        if (that.$modelValue !== prevModelValue) {
            that.$$writeModelToScope();
        }
    }
});}),
        '$$runValidators': ($__.fs.J$__v3645318688_2126_632 = function J$__v3645318688_2126(modelValue, viewValue, doneCallback) {
var vvv_return, vvv_switch, localValidationRunId, that, processParseErrors, processSyncValidators, processAsyncValidators, setValidity, validationDone;
processParseErrors = function processParseErrors() {
    var errorKey = that.$$parserName || 'parse';
    if (isUndefined(that.$$parserValid)) {
        setValidity(errorKey, null);
    } else {
        if (!that.$$parserValid) {
            forEach(that.$validators, function (v, name) {
                setValidity(name, null);
            });
            forEach(that.$asyncValidators, function (v, name) {
                setValidity(name, null);
            });
        }
        setValidity(errorKey, that.$$parserValid);
        return that.$$parserValid;
    }
    return true;
};
processSyncValidators = function processSyncValidators() {
    var syncValidatorsValid = true;
    forEach(that.$validators, function (validator, name) {
        var result = Boolean(validator(modelValue, viewValue));
        syncValidatorsValid = syncValidatorsValid && result;
        setValidity(name, result);
    });
    if (!syncValidatorsValid) {
        forEach(that.$asyncValidators, function (v, name) {
            setValidity(name, null);
        });
        return false;
    }
    return true;
};
processAsyncValidators = function processAsyncValidators() {
    var validatorPromises = [];
    var allValid = true;
    forEach(that.$asyncValidators, function (validator, name) {
        var promise = validator(modelValue, viewValue);
        if (!isPromiseLike(promise)) {
            throw ngModelMinErr('nopromise', 'Expected asynchronous validator to return a promise but got \'{0}\' instead.', promise);
        }
        setValidity(name, undefined);
        validatorPromises.push(promise.then(function () {
            setValidity(name, true);
        }, function () {
            allValid = false;
            setValidity(name, false);
        }));
    });
    if (!validatorPromises.length) {
        validationDone(true);
    } else {
        that.$$q.all(validatorPromises).then(function () {
            validationDone(allValid);
        }, noop);
    }
};
setValidity = function setValidity(name, isValid) {
    if (localValidationRunId === that.$$currentValidationRunId) {
        that.$setValidity(name, isValid);
    }
};
validationDone = function validationDone(allValid) {
    if (localValidationRunId === that.$$currentValidationRunId) {
        doneCallback(allValid);
    }
};
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
modelValue = arguments[0], viewValue = arguments[1], doneCallback = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.$$currentValidationRunId++;
localValidationRunId = this.$$currentValidationRunId;
that = this;
if (!processParseErrors()) {
    validationDone(false);
    return;
}
if (!processSyncValidators()) {
    validationDone(false);
    return;
}
processAsyncValidators();}),
        '$commitViewValue': ($__.fs.J$__v3645318688_2128_633 = function J$__v3645318688_2128() {
var vvv_return, vvv_switch, viewValue;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
viewValue = this.$viewValue;
this.$$timeout.cancel(this.$$pendingDebounce);
if (this.$$lastCommittedViewValue === viewValue && (viewValue !== '' || !this.$$hasNativeValidators)) {
    return;
}
this.$$updateEmptyClasses(viewValue);
this.$$lastCommittedViewValue = viewValue;
if (this.$pristine) {
    this.$setDirty();
}
this.$$parseAndValidate();}),
        '$$parseAndValidate': ($__.fs.J$__v3645318688_2133_634 = function J$__v3645318688_2133() {
var vvv_return, vvv_switch, viewValue, modelValue, that, prevModelValue, allowInvalid, writeToModelIfNeeded;
writeToModelIfNeeded = function writeToModelIfNeeded() {
    if (that.$modelValue !== prevModelValue) {
        that.$$writeModelToScope();
    }
};
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
viewValue = this.$$lastCommittedViewValue;
modelValue = viewValue;
that = this;
this.$$parserValid = isUndefined(modelValue) ? undefined : true;
if (this.$$parserValid) {
    for (var i = 0; i < this.$parsers.length; i++) {
        modelValue = this.$parsers[i](modelValue);
        if (isUndefined(modelValue)) {
            this.$$parserValid = false;
            break;
        }
    }
}
if (isNumberNaN(this.$modelValue)) {
    this.$modelValue = this.$$ngModelGet(this.$$scope);
}
prevModelValue = this.$modelValue;
allowInvalid = this.$options.getOption('allowInvalid');
this.$$rawModelValue = modelValue;
if (allowInvalid) {
    this.$modelValue = modelValue;
    writeToModelIfNeeded();
}
this.$$runValidators(modelValue, this.$$lastCommittedViewValue, function (allValid) {
    if (!allowInvalid) {
        that.$modelValue = allValid ? modelValue : undefined;
        writeToModelIfNeeded();
    }
});}),
        '$$writeModelToScope': ($__.fs.J$__v3645318688_2137_635 = function J$__v3645318688_2137() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.$$ngModelSet(this.$$scope, this.$modelValue);
forEach(this.$viewChangeListeners, function (listener) {
    try {
        listener();
    } catch (e) {
        this.$$exceptionHandler(e);
    }
}, this);}),
        '$setViewValue': ($__.fs.J$__v3645318688_2139_636 = function J$__v3645318688_2139(value, trigger) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
value = arguments[0], trigger = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.$viewValue = value;
if (this.$options.getOption('updateOnDefault')) {
    this.$$debounceViewValueCommit(trigger);
}}),
        '$$debounceViewValueCommit': ($__.fs.J$__v3645318688_2145_637 = function J$__v3645318688_2145(trigger) {
var vvv_return, vvv_switch, debounceDelay, that;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
trigger = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
debounceDelay = this.$options.getOption('debounce');
if (isNumber(debounceDelay[trigger])) {
    debounceDelay = debounceDelay[trigger];
} else if (isNumber(debounceDelay['default'])) {
    debounceDelay = debounceDelay['default'];
}
this.$$timeout.cancel(this.$$pendingDebounce);
that = this;
if (debounceDelay > 0) {
    this.$$pendingDebounce = this.$$timeout(function () {
        that.$commitViewValue();
    }, debounceDelay);
} else if (this.$$scope.$root.$$phase) {
    this.$commitViewValue();
} else {
    this.$$scope.$apply(function () {
        that.$commitViewValue();
    });
}}),
        '$overrideModelOptions': ($__.fs.J$__v3645318688_2147_638 = function J$__v3645318688_2147(options) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
options = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.$options = this.$options.createChild(options);})
    };
    (addSetValidityMethod, $__.fs.addSetValidityMethod_239)($__.os.oid43 = {
        'clazz': NgModelController,
        'set': ($__.fs.J$__v3645318688_2151_639 = function J$__v3645318688_2151(object, property) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
object = arguments[0], property = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
object[property] = true;}),
        'unset': ($__.fs.J$__v3645318688_2153_640 = function J$__v3645318688_2153(object, property) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
object = arguments[0], property = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
delete object[property];})
    }, 1, true, $__.uid);
    ngModelDirective = [
        '$rootScope',
        ($__.fs.J$__v3645318688_2167_646 = function J$__v3645318688_2167($rootScope) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
$rootScope = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return {
    restrict: 'A',
    require: [
        'ngModel',
        '^?form',
        '^?ngModelOptions'
    ],
    controller: NgModelController,
    priority: 1,
    compile: function ngModelCompile(element) {
        element.addClass(PRISTINE_CLASS).addClass(UNTOUCHED_CLASS).addClass(VALID_CLASS);
        return {
            pre: function ngModelPreLink(scope, element, attr, ctrls) {
                var modelCtrl = ctrls[0], formCtrl = ctrls[1] || modelCtrl.$$parentForm, optionsCtrl = ctrls[2];
                if (optionsCtrl) {
                    modelCtrl.$options = optionsCtrl.$options;
                }
                modelCtrl.$$initGetterSetters();
                formCtrl.$addControl(modelCtrl);
                attr.$observe('name', function (newValue) {
                    if (modelCtrl.$name !== newValue) {
                        modelCtrl.$$parentForm.$$renameControl(modelCtrl, newValue);
                    }
                });
                scope.$on('$destroy', function () {
                    modelCtrl.$$parentForm.$removeControl(modelCtrl);
                });
            },
            post: function ngModelPostLink(scope, element, attr, ctrls) {
                var modelCtrl = ctrls[0];
                if (modelCtrl.$options.getOption('updateOn')) {
                    element.on(modelCtrl.$options.getOption('updateOn'), function (ev) {
                        modelCtrl.$$debounceViewValueCommit(ev && ev.type);
                    });
                }
                function setTouched() {
                    modelCtrl.$setTouched();
                }
                element.on('blur', function () {
                    if (modelCtrl.$touched)
                        return;
                    if ($rootScope.$$phase) {
                        scope.$evalAsync(setTouched);
                    } else {
                        scope.$apply(setTouched);
                    }
                });
            }
        };
    }
};})
    ];
    DEFAULT_REGEXP = /(\s+|^)default(\s+|$)/;
    ModelOptions.prototype = $__.os.oid44 = {
        'getOption': ($__.fs.J$__v3645318688_2170_647 = function J$__v3645318688_2170(name) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
name = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return this.$$options[name];}),
        'createChild': ($__.fs.J$__v3645318688_2176_648 = function J$__v3645318688_2176(options) {
var vvv_return, vvv_switch, inheritAll;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
options = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
inheritAll = false;
options = extend({}, options);
forEach(options, function (option, key) {
    if (option === '$inherit') {
        if (key === '*') {
            inheritAll = true;
        } else {
            options[key] = this.$$options[key];
            if (key === 'updateOn') {
                options.updateOnDefault = this.$$options.updateOnDefault;
            }
        }
    } else {
        if (key === 'updateOn') {
            options.updateOnDefault = false;
            options[key] = trim(option.replace(DEFAULT_REGEXP, function () {
                options.updateOnDefault = true;
                return ' ';
            }));
        }
    }
}, this);
if (inheritAll) {
    delete options['*'];
    defaults(options, this.$$options);
}
defaults(options, defaultModelOptions.$$options);
return new ModelOptions(options);})
    };
    defaultModelOptions = new (ModelOptions, $__.fs.ModelOptions_263)($__.os.oid45 = {
        'updateOn': '',
        'updateOnDefault': true,
        'debounce': 0,
        'getterSetter': false,
        'allowInvalid': false,
        'timezone': null
    }, 0, true, $__.uid);
    ngModelOptionsDirective = ($__.fs.J$__v3645318688_2181_649 = function J$__v3645318688_2181() {
var vvv_return, vvv_switch, NgModelOptionsController;
NgModelOptionsController = function NgModelOptionsController($attrs, $scope) {
    this.$$attrs = $attrs;
    this.$$scope = $scope;
};
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
NgModelOptionsController.$inject = [
    '$attrs',
    '$scope'
];
NgModelOptionsController.prototype = {
    $onInit: function () {
        var parentOptions = this.parentCtrl ? this.parentCtrl.$options : defaultModelOptions;
        var modelOptionsDefinition = this.$$scope.$eval(this.$$attrs.ngModelOptions);
        this.$options = parentOptions.createChild(modelOptionsDefinition);
    }
};
return {
    restrict: 'A',
    priority: 10,
    require: {
        parentCtrl: '?^^ngModelOptions'
    },
    bindToController: true,
    controller: NgModelOptionsController
};});
    ngNonBindableDirective = (ngDirective, $__.fs.ngDirective_235)($__.os.oid46 = {
        'terminal': true,
        'priority': 1000
    }, 2, true, $__.uid);
    ngOptionsMinErr = (minErr, $__.fs.minErr_4)('ngOptions', 13, true, $__.uid);
    NG_OPTIONS_REGEXP = /^\s*([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+group\s+by\s+([\s\S]+?))?(?:\s+disable\s+when\s+([\s\S]+?))?\s+for\s+(?:([$\w][$\w]*)|(?:\(\s*([$\w][$\w]*)\s*,\s*([$\w][$\w]*)\s*\)))\s+in\s+([\s\S]+?)(?:\s+track\s+by\s+([\s\S]+?))?$/;
    ngOptionsDirective = [
        '$compile',
        '$document',
        '$parse',
        ($__.fs.J$__v3645318688_2237_652 = function J$__v3645318688_2237($compile, $document, $parse) {
var vvv_return, vvv_switch, parseOptionsExpression, optionTemplate, optGroupTemplate, ngOptionsPostLink;
parseOptionsExpression = function parseOptionsExpression(optionsExp, selectElement, scope) {
    var match = optionsExp.match(NG_OPTIONS_REGEXP);
    if (!match) {
        throw ngOptionsMinErr('iexp', 'Expected expression in form of ' + '\'_select_ (as _label_)? for (_key_,)?_value_ in _collection_\'' + ' but got \'{0}\'. Element: {1}', optionsExp, startingTag(selectElement));
    }
    var valueName = match[5] || match[7];
    var keyName = match[6];
    var selectAs = / as /.test(match[0]) && match[1];
    var trackBy = match[9];
    var valueFn = $parse(match[2] ? match[1] : valueName);
    var selectAsFn = selectAs && $parse(selectAs);
    var viewValueFn = selectAsFn || valueFn;
    var trackByFn = trackBy && $parse(trackBy);
    var getTrackByValueFn = trackBy ? function (value, locals) {
        return trackByFn(scope, locals);
    } : function getHashOfValue(value) {
        return hashKey(value);
    };
    var getTrackByValue = function (value, key) {
        return getTrackByValueFn(value, getLocals(value, key));
    };
    var displayFn = $parse(match[2] || match[1]);
    var groupByFn = $parse(match[3] || '');
    var disableWhenFn = $parse(match[4] || '');
    var valuesFn = $parse(match[8]);
    var locals = {};
    var getLocals = keyName ? function (value, key) {
        locals[keyName] = key;
        locals[valueName] = value;
        return locals;
    } : function (value) {
        locals[valueName] = value;
        return locals;
    };
    function Option(selectValue, viewValue, label, group, disabled) {
        this.selectValue = selectValue;
        this.viewValue = viewValue;
        this.label = label;
        this.group = group;
        this.disabled = disabled;
    }
    function getOptionValuesKeys(optionValues) {
        var optionValuesKeys;
        if (!keyName && isArrayLike(optionValues)) {
            optionValuesKeys = optionValues;
        } else {
            optionValuesKeys = [];
            for (var itemKey in optionValues) {
                if (optionValues.hasOwnProperty(itemKey) && itemKey.charAt(0) !== '$') {
                    optionValuesKeys.push(itemKey);
                }
            }
        }
        return optionValuesKeys;
    }
    return {
        trackBy: trackBy,
        getTrackByValue: getTrackByValue,
        getWatchables: $parse(valuesFn, function (optionValues) {
            var watchedArray = [];
            optionValues = optionValues || [];
            var optionValuesKeys = getOptionValuesKeys(optionValues);
            var optionValuesLength = optionValuesKeys.length;
            for (var index = 0; index < optionValuesLength; index++) {
                var key = optionValues === optionValuesKeys ? index : optionValuesKeys[index];
                var value = optionValues[key];
                var locals = getLocals(value, key);
                var selectValue = getTrackByValueFn(value, locals);
                watchedArray.push(selectValue);
                if (match[2] || match[1]) {
                    var label = displayFn(scope, locals);
                    watchedArray.push(label);
                }
                if (match[4]) {
                    var disableWhen = disableWhenFn(scope, locals);
                    watchedArray.push(disableWhen);
                }
            }
            return watchedArray;
        }),
        getOptions: function () {
            var optionItems = [];
            var selectValueMap = {};
            var optionValues = valuesFn(scope) || [];
            var optionValuesKeys = getOptionValuesKeys(optionValues);
            var optionValuesLength = optionValuesKeys.length;
            for (var index = 0; index < optionValuesLength; index++) {
                var key = optionValues === optionValuesKeys ? index : optionValuesKeys[index];
                var value = optionValues[key];
                var locals = getLocals(value, key);
                var viewValue = viewValueFn(scope, locals);
                var selectValue = getTrackByValueFn(viewValue, locals);
                var label = displayFn(scope, locals);
                var group = groupByFn(scope, locals);
                var disabled = disableWhenFn(scope, locals);
                var optionItem = new Option(selectValue, viewValue, label, group, disabled);
                optionItems.push(optionItem);
                selectValueMap[selectValue] = optionItem;
            }
            return {
                items: optionItems,
                selectValueMap: selectValueMap,
                getOptionFromViewValue: function (value) {
                    return selectValueMap[getTrackByValue(value)];
                },
                getViewValueFromOption: function (option) {
                    return trackBy ? copy(option.viewValue) : option.viewValue;
                }
            };
        }
    };
};
ngOptionsPostLink = function ngOptionsPostLink(scope, selectElement, attr, ctrls) {
    var selectCtrl = ctrls[0];
    var ngModelCtrl = ctrls[1];
    var multiple = attr.multiple;
    for (var i = 0, children = selectElement.children(), ii = children.length; i < ii; i++) {
        if (children[i].value === '') {
            selectCtrl.hasEmptyOption = true;
            selectCtrl.emptyOption = children.eq(i);
            break;
        }
    }
    var providedEmptyOption = !!selectCtrl.emptyOption;
    var unknownOption = jqLite(optionTemplate.cloneNode(false));
    unknownOption.val('?');
    var options;
    var ngOptions = parseOptionsExpression(attr.ngOptions, selectElement, scope);
    var listFragment = $document[0].createDocumentFragment();
    selectCtrl.generateUnknownOptionValue = function (val) {
        return '?';
    };
    if (!multiple) {
        selectCtrl.writeValue = function writeNgOptionsValue(value) {
            var selectedOption = options.selectValueMap[selectElement.val()];
            var option = options.getOptionFromViewValue(value);
            if (selectedOption)
                selectedOption.element.removeAttribute('selected');
            if (option) {
                if (selectElement[0].value !== option.selectValue) {
                    selectCtrl.removeUnknownOption();
                    selectCtrl.unselectEmptyOption();
                    selectElement[0].value = option.selectValue;
                    option.element.selected = true;
                }
                option.element.setAttribute('selected', 'selected');
            } else {
                if (providedEmptyOption) {
                    selectCtrl.selectEmptyOption();
                } else if (selectCtrl.unknownOption.parent().length) {
                    selectCtrl.updateUnknownOption(value);
                } else {
                    selectCtrl.renderUnknownOption(value);
                }
            }
        };
        selectCtrl.readValue = function readNgOptionsValue() {
            var selectedOption = options.selectValueMap[selectElement.val()];
            if (selectedOption && !selectedOption.disabled) {
                selectCtrl.unselectEmptyOption();
                selectCtrl.removeUnknownOption();
                return options.getViewValueFromOption(selectedOption);
            }
            return null;
        };
        if (ngOptions.trackBy) {
            scope.$watch(function () {
                return ngOptions.getTrackByValue(ngModelCtrl.$viewValue);
            }, function () {
                ngModelCtrl.$render();
            });
        }
    } else {
        selectCtrl.writeValue = function writeNgOptionsMultiple(values) {
            var selectedOptions = values && values.map(getAndUpdateSelectedOption) || [];
            options.items.forEach(function (option) {
                if (option.element.selected && !includes(selectedOptions, option)) {
                    option.element.selected = false;
                }
            });
        };
        selectCtrl.readValue = function readNgOptionsMultiple() {
            var selectedValues = selectElement.val() || [], selections = [];
            forEach(selectedValues, function (value) {
                var option = options.selectValueMap[value];
                if (option && !option.disabled)
                    selections.push(options.getViewValueFromOption(option));
            });
            return selections;
        };
        if (ngOptions.trackBy) {
            scope.$watchCollection(function () {
                if (isArray(ngModelCtrl.$viewValue)) {
                    return ngModelCtrl.$viewValue.map(function (value) {
                        return ngOptions.getTrackByValue(value);
                    });
                }
            }, function () {
                ngModelCtrl.$render();
            });
        }
    }
    if (providedEmptyOption) {
        selectCtrl.emptyOption.remove();
        $compile(selectCtrl.emptyOption)(scope);
        if (selectCtrl.emptyOption[0].nodeType === NODE_TYPE_COMMENT) {
            selectCtrl.hasEmptyOption = false;
            selectCtrl.registerOption = function (optionScope, optionEl) {
                if (optionEl.val() === '') {
                    selectCtrl.hasEmptyOption = true;
                    selectCtrl.emptyOption = optionEl;
                    selectCtrl.emptyOption.removeClass('ng-scope');
                    ngModelCtrl.$render();
                    optionEl.on('$destroy', function () {
                        selectCtrl.hasEmptyOption = false;
                        selectCtrl.emptyOption = undefined;
                    });
                }
            };
        } else {
            selectCtrl.emptyOption.removeClass('ng-scope');
        }
    }
    selectElement.empty();
    updateOptions();
    scope.$watchCollection(ngOptions.getWatchables, updateOptions);
    function addOptionElement(option, parent) {
        var optionElement = optionTemplate.cloneNode(false);
        parent.appendChild(optionElement);
        updateOptionElement(option, optionElement);
    }
    function getAndUpdateSelectedOption(viewValue) {
        var option = options.getOptionFromViewValue(viewValue);
        var element = option && option.element;
        if (element && !element.selected)
            element.selected = true;
        return option;
    }
    function updateOptionElement(option, element) {
        option.element = element;
        element.disabled = option.disabled;
        if (option.label !== element.label) {
            element.label = option.label;
            element.textContent = option.label;
        }
        element.value = option.selectValue;
    }
    function updateOptions() {
        var previousValue = options && selectCtrl.readValue();
        if (options) {
            for (var i = options.items.length - 1; i >= 0; i--) {
                var option = options.items[i];
                if (isDefined(option.group)) {
                    jqLiteRemove(option.element.parentNode);
                } else {
                    jqLiteRemove(option.element);
                }
            }
        }
        options = ngOptions.getOptions();
        var groupElementMap = {};
        if (providedEmptyOption) {
            selectElement.prepend(selectCtrl.emptyOption);
        }
        options.items.forEach(function addOption(option) {
            var groupElement;
            if (isDefined(option.group)) {
                groupElement = groupElementMap[option.group];
                if (!groupElement) {
                    groupElement = optGroupTemplate.cloneNode(false);
                    listFragment.appendChild(groupElement);
                    groupElement.label = option.group === null ? 'null' : option.group;
                    groupElementMap[option.group] = groupElement;
                }
                addOptionElement(option, groupElement);
            } else {
                addOptionElement(option, listFragment);
            }
        });
        selectElement[0].appendChild(listFragment);
        ngModelCtrl.$render();
        if (!ngModelCtrl.$isEmpty(previousValue)) {
            var nextValue = selectCtrl.readValue();
            var isNotPrimitive = ngOptions.trackBy || multiple;
            if (isNotPrimitive ? !equals(previousValue, nextValue) : previousValue !== nextValue) {
                ngModelCtrl.$setViewValue(nextValue);
                ngModelCtrl.$render();
            }
        }
    }
};
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
$compile = arguments[0], $document = arguments[1], $parse = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
optionTemplate = window.document.createElement('option');
optGroupTemplate = window.document.createElement('optgroup');
return {
    restrict: 'A',
    terminal: true,
    require: [
        'select',
        'ngModel'
    ],
    link: {
        pre: function ngOptionsPreLink(scope, selectElement, attr, ctrls) {
            ctrls[0].registerOption = noop;
        },
        post: ngOptionsPostLink
    }
};})
    ];
    ngPluralizeDirective = [
        '$locale',
        '$interpolate',
        '$log',
        ($__.fs.J$__v3645318688_2247_653 = function J$__v3645318688_2247($locale, $interpolate, $log) {
var vvv_return, vvv_switch, BRACE, IS_WHEN;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
$locale = arguments[0], $interpolate = arguments[1], $log = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
BRACE = /{}/g;
IS_WHEN = /^when(Minus)?(.+)$/;
return {
    link: function (scope, element, attr) {
        var numberExp = attr.count, whenExp = attr.$attr.when && element.attr(attr.$attr.when), offset = attr.offset || 0, whens = scope.$eval(whenExp) || {}, whensExpFns = {}, startSymbol = $interpolate.startSymbol(), endSymbol = $interpolate.endSymbol(), braceReplacement = startSymbol + numberExp + '-' + offset + endSymbol, watchRemover = angular.noop, lastCount;
        forEach(attr, function (expression, attributeName) {
            var tmpMatch = IS_WHEN.exec(attributeName);
            if (tmpMatch) {
                var whenKey = (tmpMatch[1] ? '-' : '') + lowercase(tmpMatch[2]);
                whens[whenKey] = element.attr(attr.$attr[attributeName]);
            }
        });
        forEach(whens, function (expression, key) {
            whensExpFns[key] = $interpolate(expression.replace(BRACE, braceReplacement));
        });
        scope.$watch(numberExp, function ngPluralizeWatchAction(newVal) {
            var count = parseFloat(newVal);
            var countIsNaN = isNumberNaN(count);
            if (!countIsNaN && !(count in whens)) {
                count = $locale.pluralCat(count - offset);
            }
            if (count !== lastCount && !(countIsNaN && isNumberNaN(lastCount))) {
                watchRemover();
                var whenExpFn = whensExpFns[count];
                if (isUndefined(whenExpFn)) {
                    if (newVal != null) {
                        $log.debug('ngPluralize: no rule defined for \'' + count + '\' in ' + whenExp);
                    }
                    watchRemover = noop;
                    updateElementText();
                } else {
                    watchRemover = scope.$watch(whenExpFn, updateElementText);
                }
                lastCount = count;
            }
        });
        function updateElementText(newText) {
            element.text(newText || '');
        }
    }
};})
    ];
    ngRepeatDirective = [
        '$parse',
        '$animate',
        '$compile',
        ($__.fs.J$__v3645318688_2267_654 = function J$__v3645318688_2267($parse, $animate, $compile) {
var vvv_return, vvv_switch, NG_REMOVED, ngRepeatMinErr, updateScope, getBlockStart, getBlockEnd;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
$parse = arguments[0], $animate = arguments[1], $compile = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
NG_REMOVED = '$$NG_REMOVED';
ngRepeatMinErr = minErr('ngRepeat');
updateScope = function (scope, index, valueIdentifier, value, keyIdentifier, key, arrayLength) {
    scope[valueIdentifier] = value;
    if (keyIdentifier)
        scope[keyIdentifier] = key;
    scope.$index = index;
    scope.$first = index === 0;
    scope.$last = index === arrayLength - 1;
    scope.$middle = !(scope.$first || scope.$last);
    scope.$odd = !(scope.$even = (index & 1) === 0);
};
getBlockStart = function (block) {
    return block.clone[0];
};
getBlockEnd = function (block) {
    return block.clone[block.clone.length - 1];
};
return {
    restrict: 'A',
    multiElement: true,
    transclude: 'element',
    priority: 1000,
    terminal: true,
    $$tlb: true,
    compile: function ngRepeatCompile($element, $attr) {
        var expression = $attr.ngRepeat;
        var ngRepeatEndComment = $compile.$$createComment('end ngRepeat', expression);
        var match = expression.match(/^\s*([\s\S]+?)\s+in\s+([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+track\s+by\s+([\s\S]+?))?\s*$/);
        if (!match) {
            throw ngRepeatMinErr('iexp', 'Expected expression in form of \'_item_ in _collection_[ track by _id_]\' but got \'{0}\'.', expression);
        }
        var lhs = match[1];
        var rhs = match[2];
        var aliasAs = match[3];
        var trackByExp = match[4];
        match = lhs.match(/^(?:(\s*[$\w]+)|\(\s*([$\w]+)\s*,\s*([$\w]+)\s*\))$/);
        if (!match) {
            throw ngRepeatMinErr('iidexp', '\'_item_\' in \'_item_ in _collection_\' should be an identifier or \'(_key_, _value_)\' expression, but got \'{0}\'.', lhs);
        }
        var valueIdentifier = match[3] || match[1];
        var keyIdentifier = match[2];
        if (aliasAs && (!/^[$a-zA-Z_][$a-zA-Z0-9_]*$/.test(aliasAs) || /^(null|undefined|this|\$index|\$first|\$middle|\$last|\$even|\$odd|\$parent|\$root|\$id)$/.test(aliasAs))) {
            throw ngRepeatMinErr('badident', 'alias \'{0}\' is invalid --- must be a valid JS identifier which is not a reserved name.', aliasAs);
        }
        var trackByExpGetter, trackByIdExpFn, trackByIdArrayFn, trackByIdObjFn;
        var hashFnLocals = {
            $id: hashKey
        };
        if (trackByExp) {
            trackByExpGetter = $parse(trackByExp);
        } else {
            trackByIdArrayFn = function (key, value) {
                return hashKey(value);
            };
            trackByIdObjFn = function (key) {
                return key;
            };
        }
        return function ngRepeatLink($scope, $element, $attr, ctrl, $transclude) {
            if (trackByExpGetter) {
                trackByIdExpFn = function (key, value, index) {
                    if (keyIdentifier)
                        hashFnLocals[keyIdentifier] = key;
                    hashFnLocals[valueIdentifier] = value;
                    hashFnLocals.$index = index;
                    return trackByExpGetter($scope, hashFnLocals);
                };
            }
            var lastBlockMap = createMap();
            $scope.$watchCollection(rhs, function ngRepeatAction(collection) {
                var index, length, previousNode = $element[0], nextNode, nextBlockMap = createMap(), collectionLength, key, value, trackById, trackByIdFn, collectionKeys, block, nextBlockOrder, elementsToRemove;
                if (aliasAs) {
                    $scope[aliasAs] = collection;
                }
                if (isArrayLike(collection)) {
                    collectionKeys = collection;
                    trackByIdFn = trackByIdExpFn || trackByIdArrayFn;
                } else {
                    trackByIdFn = trackByIdExpFn || trackByIdObjFn;
                    collectionKeys = [];
                    for (var itemKey in collection) {
                        if (hasOwnProperty.call(collection, itemKey) && itemKey.charAt(0) !== '$') {
                            collectionKeys.push(itemKey);
                        }
                    }
                }
                collectionLength = collectionKeys.length;
                nextBlockOrder = new Array(collectionLength);
                for (index = 0; index < collectionLength; index++) {
                    key = collection === collectionKeys ? index : collectionKeys[index];
                    value = collection[key];
                    trackById = trackByIdFn(key, value, index);
                    if (lastBlockMap[trackById]) {
                        block = lastBlockMap[trackById];
                        delete lastBlockMap[trackById];
                        nextBlockMap[trackById] = block;
                        nextBlockOrder[index] = block;
                    } else if (nextBlockMap[trackById]) {
                        forEach(nextBlockOrder, function (block) {
                            if (block && block.scope)
                                lastBlockMap[block.id] = block;
                        });
                        throw ngRepeatMinErr('dupes', 'Duplicates in a repeater are not allowed. Use \'track by\' expression to specify unique keys. Repeater: {0}, Duplicate key: {1}, Duplicate value: {2}', expression, trackById, value);
                    } else {
                        nextBlockOrder[index] = {
                            id: trackById,
                            scope: undefined,
                            clone: undefined
                        };
                        nextBlockMap[trackById] = true;
                    }
                }
                for (var blockKey in lastBlockMap) {
                    block = lastBlockMap[blockKey];
                    elementsToRemove = getBlockNodes(block.clone);
                    $animate.leave(elementsToRemove);
                    if (elementsToRemove[0].parentNode) {
                        for (index = 0, length = elementsToRemove.length; index < length; index++) {
                            elementsToRemove[index][NG_REMOVED] = true;
                        }
                    }
                    block.scope.$destroy();
                }
                for (index = 0; index < collectionLength; index++) {
                    key = collection === collectionKeys ? index : collectionKeys[index];
                    value = collection[key];
                    block = nextBlockOrder[index];
                    if (block.scope) {
                        nextNode = previousNode;
                        do {
                            nextNode = nextNode.nextSibling;
                        } while (nextNode && nextNode[NG_REMOVED]);
                        if (getBlockStart(block) !== nextNode) {
                            $animate.move(getBlockNodes(block.clone), null, previousNode);
                        }
                        previousNode = getBlockEnd(block);
                        updateScope(block.scope, index, valueIdentifier, value, keyIdentifier, key, collectionLength);
                    } else {
                        $transclude(function ngRepeatTransclude(clone, scope) {
                            block.scope = scope;
                            var endNode = ngRepeatEndComment.cloneNode(false);
                            clone[clone.length++] = endNode;
                            $animate.enter(clone, null, previousNode);
                            previousNode = endNode;
                            block.clone = clone;
                            nextBlockMap[block.id] = block;
                            updateScope(block.scope, index, valueIdentifier, value, keyIdentifier, key, collectionLength);
                        });
                    }
                }
                lastBlockMap = nextBlockMap;
            });
        };
    }
};})
    ];
    NG_HIDE_CLASS = 'ng-hide';
    NG_HIDE_IN_PROGRESS_CLASS = 'ng-hide-animate';
    ngShowDirective = [
        '$animate',
        ($__.fs.J$__v3645318688_2272_655 = function J$__v3645318688_2272($animate) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
$animate = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return {
    restrict: 'A',
    multiElement: true,
    link: function (scope, element, attr) {
        scope.$watch(attr.ngShow, function ngShowWatchAction(value) {
            $animate[value ? 'removeClass' : 'addClass'](element, NG_HIDE_CLASS, {
                tempClasses: NG_HIDE_IN_PROGRESS_CLASS
            });
        });
    }
};})
    ];
    ngHideDirective = [
        '$animate',
        ($__.fs.J$__v3645318688_2277_656 = function J$__v3645318688_2277($animate) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
$animate = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return {
    restrict: 'A',
    multiElement: true,
    link: function (scope, element, attr) {
        scope.$watch(attr.ngHide, function ngHideWatchAction(value) {
            $animate[value ? 'addClass' : 'removeClass'](element, NG_HIDE_CLASS, {
                tempClasses: NG_HIDE_IN_PROGRESS_CLASS
            });
        });
    }
};})
    ];
    ngStyleDirective = (ngDirective, $__.fs.ngDirective_235)(($__.fs.J$__v3645318688_2282_657 = function J$__v3645318688_2282(scope, element, attr) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
scope = arguments[0], element = arguments[1], attr = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
scope.$watch(attr.ngStyle, function ngStyleWatchAction(newStyles, oldStyles) {
    if (oldStyles && newStyles !== oldStyles) {
        forEach(oldStyles, function (val, style) {
            element.css(style, '');
        });
    }
    if (newStyles)
        element.css(newStyles);
}, true);}), 3, true, $__.uid);
    ngSwitchDirective = [
        '$animate',
        '$compile',
        ($__.fs.J$__v3645318688_2296_659 = function J$__v3645318688_2296($animate, $compile) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
$animate = arguments[0], $compile = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return {
    require: 'ngSwitch',
    controller: [
        '$scope',
        function NgSwitchController() {
            this.cases = {};
        }
    ],
    link: function (scope, element, attr, ngSwitchController) {
        var watchExpr = attr.ngSwitch || attr.on, selectedTranscludes = [], selectedElements = [], previousLeaveAnimations = [], selectedScopes = [];
        var spliceFactory = function (array, index) {
            return function (response) {
                if (response !== false)
                    array.splice(index, 1);
            };
        };
        scope.$watch(watchExpr, function ngSwitchWatchAction(value) {
            var i, ii;
            while (previousLeaveAnimations.length) {
                $animate.cancel(previousLeaveAnimations.pop());
            }
            for (i = 0, ii = selectedScopes.length; i < ii; ++i) {
                var selected = getBlockNodes(selectedElements[i].clone);
                selectedScopes[i].$destroy();
                var runner = previousLeaveAnimations[i] = $animate.leave(selected);
                runner.done(spliceFactory(previousLeaveAnimations, i));
            }
            selectedElements.length = 0;
            selectedScopes.length = 0;
            if (selectedTranscludes = ngSwitchController.cases['!' + value] || ngSwitchController.cases['?']) {
                forEach(selectedTranscludes, function (selectedTransclude) {
                    selectedTransclude.transclude(function (caseElement, selectedScope) {
                        selectedScopes.push(selectedScope);
                        var anchor = selectedTransclude.element;
                        caseElement[caseElement.length++] = $compile.$$createComment('end ngSwitchWhen');
                        var block = {
                            clone: caseElement
                        };
                        selectedElements.push(block);
                        $animate.enter(caseElement, anchor.parent(), anchor);
                    });
                });
            }
        });
    }
};})
    ];
    ngSwitchWhenDirective = (ngDirective, $__.fs.ngDirective_235)($__.os.oid48 = {
        'transclude': 'element',
        'priority': 1200,
        'require': '^ngSwitch',
        'multiElement': true,
        'link': ($__.fs.J$__v3645318688_2302_660 = function J$__v3645318688_2302(scope, element, attrs, ctrl, $transclude) {
var vvv_return, vvv_switch, cases;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
scope = arguments[0], element = arguments[1], attrs = arguments[2], ctrl = arguments[3], $transclude = arguments[4];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
cases = attrs.ngSwitchWhen.split(attrs.ngSwitchWhenSeparator).sort().filter(function (element, index, array) {
    return array[index - 1] !== element;
});
forEach(cases, function (whenCase) {
    ctrl.cases['!' + whenCase] = ctrl.cases['!' + whenCase] || [];
    ctrl.cases['!' + whenCase].push({
        transclude: $transclude,
        element: element
    });
});})
    }, 4, true, $__.uid);
    ngSwitchDefaultDirective = (ngDirective, $__.fs.ngDirective_235)($__.os.oid49 = {
        'transclude': 'element',
        'priority': 1200,
        'require': '^ngSwitch',
        'multiElement': true,
        'link': ($__.fs.J$__v3645318688_2304_662 = function J$__v3645318688_2304(scope, element, attr, ctrl, $transclude) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
scope = arguments[0], element = arguments[1], attr = arguments[2], ctrl = arguments[3], $transclude = arguments[4];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
ctrl.cases['?'] = ctrl.cases['?'] || [];
ctrl.cases['?'].push({
    transclude: $transclude,
    element: element
});})
    }, 5, true, $__.uid);
    ngTranscludeMinErr = (minErr, $__.fs.minErr_4)('ngTransclude', 14, true, $__.uid);
    ngTranscludeDirective = [
        '$compile',
        ($__.fs.J$__v3645318688_2313_665 = function J$__v3645318688_2313($compile) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
$compile = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return {
    restrict: 'EAC',
    terminal: true,
    compile: function ngTranscludeCompile(tElement) {
        var fallbackLinkFn = $compile(tElement.contents());
        tElement.empty();
        return function ngTranscludePostLink($scope, $element, $attrs, controller, $transclude) {
            if (!$transclude) {
                throw ngTranscludeMinErr('orphan', 'Illegal use of ngTransclude directive in the template! ' + 'No parent directive that requires a transclusion found. ' + 'Element: {0}', startingTag($element));
            }
            if ($attrs.ngTransclude === $attrs.$attr.ngTransclude) {
                $attrs.ngTransclude = '';
            }
            var slotName = $attrs.ngTransclude || $attrs.ngTranscludeSlot;
            $transclude(ngTranscludeCloneAttachFn, null, slotName);
            if (slotName && !$transclude.isSlotFilled(slotName)) {
                useFallbackContent();
            }
            function ngTranscludeCloneAttachFn(clone, transcludedScope) {
                if (clone.length && notWhitespace(clone)) {
                    $element.append(clone);
                } else {
                    useFallbackContent();
                    transcludedScope.$destroy();
                }
            }
            function useFallbackContent() {
                fallbackLinkFn($scope, function (clone) {
                    $element.append(clone);
                });
            }
            function notWhitespace(nodes) {
                for (var i = 0, ii = nodes.length; i < ii; i++) {
                    var node = nodes[i];
                    if (node.nodeType !== NODE_TYPE_TEXT || node.nodeValue.trim()) {
                        return true;
                    }
                }
            }
        };
    }
};})
    ];
    scriptDirective = [
        '$templateCache',
        ($__.fs.J$__v3645318688_2317_666 = function J$__v3645318688_2317($templateCache) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
$templateCache = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return {
    restrict: 'E',
    terminal: true,
    compile: function (element, attr) {
        if (attr.type === 'text/ng-template') {
            var templateUrl = attr.id, text = element[0].text;
            $templateCache.put(templateUrl, text);
        }
    }
};})
    ];
    noopNgModelController = $__.os.oid50 = {
        '$setViewValue': noop,
        '$render': noop
    };
    SelectController = [
        '$element',
        '$scope',
        ($__.fs.J$__v3645318688_2357_667 = function J$__v3645318688_2357($element, $scope) {
var vvv_return, vvv_switch, self, optionsMap, renderScheduled, scheduleRender, updateScheduled, scheduleViewValueUpdate;
scheduleRender = function scheduleRender() {
    if (renderScheduled)
        return;
    renderScheduled = true;
    $scope.$$postDigest(function () {
        renderScheduled = false;
        self.ngModelCtrl.$render();
    });
};
scheduleViewValueUpdate = function scheduleViewValueUpdate(renderAfter) {
    if (updateScheduled)
        return;
    updateScheduled = true;
    $scope.$$postDigest(function () {
        if ($scope.$$destroyed)
            return;
        updateScheduled = false;
        self.ngModelCtrl.$setViewValue(self.readValue());
        if (renderAfter)
            self.ngModelCtrl.$render();
    });
};
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
$element = arguments[0], $scope = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
self = this;
optionsMap = new NgMap();
self.selectValueMap = {};
self.ngModelCtrl = noopNgModelController;
self.multiple = false;
self.unknownOption = jqLite(window.document.createElement('option'));
self.hasEmptyOption = false;
self.emptyOption = undefined;
self.renderUnknownOption = function (val) {
    var unknownVal = self.generateUnknownOptionValue(val);
    self.unknownOption.val(unknownVal);
    $element.prepend(self.unknownOption);
    setOptionSelectedStatus(self.unknownOption, true);
    $element.val(unknownVal);
};
self.updateUnknownOption = function (val) {
    var unknownVal = self.generateUnknownOptionValue(val);
    self.unknownOption.val(unknownVal);
    setOptionSelectedStatus(self.unknownOption, true);
    $element.val(unknownVal);
};
self.generateUnknownOptionValue = function (val) {
    return '? ' + hashKey(val) + ' ?';
};
self.removeUnknownOption = function () {
    if (self.unknownOption.parent())
        self.unknownOption.remove();
};
self.selectEmptyOption = function () {
    if (self.emptyOption) {
        $element.val('');
        setOptionSelectedStatus(self.emptyOption, true);
    }
};
self.unselectEmptyOption = function () {
    if (self.hasEmptyOption) {
        self.emptyOption.removeAttr('selected');
    }
};
$scope.$on('$destroy', function () {
    self.renderUnknownOption = noop;
});
self.readValue = function readSingleValue() {
    var val = $element.val();
    var realVal = val in self.selectValueMap ? self.selectValueMap[val] : val;
    if (self.hasOption(realVal)) {
        return realVal;
    }
    return null;
};
self.writeValue = function writeSingleValue(value) {
    var currentlySelectedOption = $element[0].options[$element[0].selectedIndex];
    if (currentlySelectedOption)
        setOptionSelectedStatus(jqLite(currentlySelectedOption), false);
    if (self.hasOption(value)) {
        self.removeUnknownOption();
        var hashedVal = hashKey(value);
        $element.val(hashedVal in self.selectValueMap ? hashedVal : value);
        var selectedOption = $element[0].options[$element[0].selectedIndex];
        setOptionSelectedStatus(jqLite(selectedOption), true);
    } else {
        if (value == null && self.emptyOption) {
            self.removeUnknownOption();
            self.selectEmptyOption();
        } else if (self.unknownOption.parent().length) {
            self.updateUnknownOption(value);
        } else {
            self.renderUnknownOption(value);
        }
    }
};
self.addOption = function (value, element) {
    if (element[0].nodeType === NODE_TYPE_COMMENT)
        return;
    assertNotHasOwnProperty(value, '"option value"');
    if (value === '') {
        self.hasEmptyOption = true;
        self.emptyOption = element;
    }
    var count = optionsMap.get(value) || 0;
    optionsMap.set(value, count + 1);
    scheduleRender();
};
self.removeOption = function (value) {
    var count = optionsMap.get(value);
    if (count) {
        if (count === 1) {
            optionsMap.delete(value);
            if (value === '') {
                self.hasEmptyOption = false;
                self.emptyOption = undefined;
            }
        } else {
            optionsMap.set(value, count - 1);
        }
    }
};
self.hasOption = function (value) {
    return !!optionsMap.get(value);
};
renderScheduled = false;
updateScheduled = false;
self.registerOption = function (optionScope, optionElement, optionAttrs, interpolateValueFn, interpolateTextFn) {
    if (optionAttrs.$attr.ngValue) {
        var oldVal, hashedVal = NaN;
        optionAttrs.$observe('value', function valueAttributeObserveAction(newVal) {
            var removal;
            var previouslySelected = optionElement.prop('selected');
            if (isDefined(hashedVal)) {
                self.removeOption(oldVal);
                delete self.selectValueMap[hashedVal];
                removal = true;
            }
            hashedVal = hashKey(newVal);
            oldVal = newVal;
            self.selectValueMap[hashedVal] = newVal;
            self.addOption(newVal, optionElement);
            optionElement.attr('value', hashedVal);
            if (removal && previouslySelected) {
                scheduleViewValueUpdate();
            }
        });
    } else if (interpolateValueFn) {
        optionAttrs.$observe('value', function valueAttributeObserveAction(newVal) {
            self.readValue();
            var removal;
            var previouslySelected = optionElement.prop('selected');
            if (isDefined(oldVal)) {
                self.removeOption(oldVal);
                removal = true;
            }
            oldVal = newVal;
            self.addOption(newVal, optionElement);
            if (removal && previouslySelected) {
                scheduleViewValueUpdate();
            }
        });
    } else if (interpolateTextFn) {
        optionScope.$watch(interpolateTextFn, function interpolateWatchAction(newVal, oldVal) {
            optionAttrs.$set('value', newVal);
            var previouslySelected = optionElement.prop('selected');
            if (oldVal !== newVal) {
                self.removeOption(oldVal);
            }
            self.addOption(newVal, optionElement);
            if (oldVal && previouslySelected) {
                scheduleViewValueUpdate();
            }
        });
    } else {
        self.addOption(optionAttrs.value, optionElement);
    }
    optionAttrs.$observe('disabled', function (newVal) {
        if (newVal === 'true' || newVal && optionElement.prop('selected')) {
            if (self.multiple) {
                scheduleViewValueUpdate(true);
            } else {
                self.ngModelCtrl.$setViewValue(null);
                self.ngModelCtrl.$render();
            }
        }
    });
    optionElement.on('$destroy', function () {
        var currentValue = self.readValue();
        var removeValue = optionAttrs.value;
        self.removeOption(removeValue);
        scheduleRender();
        if (self.multiple && currentValue && currentValue.indexOf(removeValue) !== -1 || currentValue === removeValue) {
            scheduleViewValueUpdate(true);
        }
    });
};})
    ];
    selectDirective = ($__.fs.J$__v3645318688_2376_668 = function J$__v3645318688_2376() {
var vvv_return, vvv_switch, selectPreLink, selectPostLink;
selectPreLink = function selectPreLink(scope, element, attr, ctrls) {
    var selectCtrl = ctrls[0];
    var ngModelCtrl = ctrls[1];
    if (!ngModelCtrl) {
        selectCtrl.registerOption = noop;
        return;
    }
    selectCtrl.ngModelCtrl = ngModelCtrl;
    element.on('change', function () {
        selectCtrl.removeUnknownOption();
        scope.$apply(function () {
            ngModelCtrl.$setViewValue(selectCtrl.readValue());
        });
    });
    if (attr.multiple) {
        selectCtrl.multiple = true;
        selectCtrl.readValue = function readMultipleValue() {
            var array = [];
            forEach(element.find('option'), function (option) {
                if (option.selected && !option.disabled) {
                    var val = option.value;
                    array.push(val in selectCtrl.selectValueMap ? selectCtrl.selectValueMap[val] : val);
                }
            });
            return array;
        };
        selectCtrl.writeValue = function writeMultipleValue(value) {
            forEach(element.find('option'), function (option) {
                var shouldBeSelected = !!value && (includes(value, option.value) || includes(value, selectCtrl.selectValueMap[option.value]));
                var currentlySelected = option.selected;
                if (shouldBeSelected !== currentlySelected) {
                    setOptionSelectedStatus(jqLite(option), shouldBeSelected);
                }
            });
        };
        var lastView, lastViewRef = NaN;
        scope.$watch(function selectMultipleWatch() {
            if (lastViewRef === ngModelCtrl.$viewValue && !equals(lastView, ngModelCtrl.$viewValue)) {
                lastView = shallowCopy(ngModelCtrl.$viewValue);
                ngModelCtrl.$render();
            }
            lastViewRef = ngModelCtrl.$viewValue;
        });
        ngModelCtrl.$isEmpty = function (value) {
            return !value || value.length === 0;
        };
    }
};
selectPostLink = function selectPostLink(scope, element, attrs, ctrls) {
    var ngModelCtrl = ctrls[1];
    if (!ngModelCtrl)
        return;
    var selectCtrl = ctrls[0];
    ngModelCtrl.$render = function () {
        selectCtrl.writeValue(ngModelCtrl.$viewValue);
    };
};
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return {
    restrict: 'E',
    require: [
        'select',
        '?ngModel'
    ],
    controller: SelectController,
    priority: 1,
    link: {
        pre: selectPreLink,
        post: selectPostLink
    }
};});
    optionDirective = [
        '$interpolate',
        ($__.fs.J$__v3645318688_2382_669 = function J$__v3645318688_2382($interpolate) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
$interpolate = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return {
    restrict: 'E',
    priority: 100,
    compile: function (element, attr) {
        var interpolateValueFn, interpolateTextFn;
        if (isDefined(attr.ngValue)) {
        } else if (isDefined(attr.value)) {
            interpolateValueFn = $interpolate(attr.value, true);
        } else {
            interpolateTextFn = $interpolate(element.text(), true);
            if (!interpolateTextFn) {
                attr.$set('value', element.text());
            }
        }
        return function (scope, element, attr) {
            var selectCtrlName = '$selectController', parent = element.parent(), selectCtrl = parent.data(selectCtrlName) || parent.parent().data(selectCtrlName);
            if (selectCtrl) {
                selectCtrl.registerOption(scope, element, attr, interpolateValueFn, interpolateTextFn);
            }
        };
    }
};})
    ];
    requiredDirective = ($__.fs.J$__v3645318688_2390_670 = function J$__v3645318688_2390() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return {
    restrict: 'A',
    require: '?ngModel',
    link: function (scope, elm, attr, ctrl) {
        if (!ctrl)
            return;
        attr.required = true;
        ctrl.$validators.required = function (modelValue, viewValue) {
            return !attr.required || !ctrl.$isEmpty(viewValue);
        };
        attr.$observe('required', function () {
            ctrl.$validate();
        });
    }
};});
    patternDirective = ($__.fs.J$__v3645318688_2398_671 = function J$__v3645318688_2398() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return {
    restrict: 'A',
    require: '?ngModel',
    link: function (scope, elm, attr, ctrl) {
        if (!ctrl)
            return;
        var regexp, patternExp = attr.ngPattern || attr.pattern;
        attr.$observe('pattern', function (regex) {
            if (isString(regex) && regex.length > 0) {
                regex = new RegExp('^' + regex + '$');
            }
            if (regex && !regex.test) {
                throw minErr('ngPattern')('noregexp', 'Expected {0} to be a RegExp but was {1}. Element: {2}', patternExp, regex, startingTag(elm));
            }
            regexp = regex || undefined;
            ctrl.$validate();
        });
        ctrl.$validators.pattern = function (modelValue, viewValue) {
            return ctrl.$isEmpty(viewValue) || isUndefined(regexp) || regexp.test(viewValue);
        };
    }
};});
    maxlengthDirective = ($__.fs.J$__v3645318688_2406_672 = function J$__v3645318688_2406() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return {
    restrict: 'A',
    require: '?ngModel',
    link: function (scope, elm, attr, ctrl) {
        if (!ctrl)
            return;
        var maxlength = -1;
        attr.$observe('maxlength', function (value) {
            var intVal = toInt(value);
            maxlength = isNumberNaN(intVal) ? -1 : intVal;
            ctrl.$validate();
        });
        ctrl.$validators.maxlength = function (modelValue, viewValue) {
            return maxlength < 0 || ctrl.$isEmpty(viewValue) || viewValue.length <= maxlength;
        };
    }
};});
    minlengthDirective = ($__.fs.J$__v3645318688_2414_673 = function J$__v3645318688_2414() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return {
    restrict: 'A',
    require: '?ngModel',
    link: function (scope, elm, attr, ctrl) {
        if (!ctrl)
            return;
        var minlength = 0;
        attr.$observe('minlength', function (value) {
            minlength = toInt(value) || 0;
            ctrl.$validate();
        });
        ctrl.$validators.minlength = function (modelValue, viewValue) {
            return ctrl.$isEmpty(viewValue) || viewValue.length >= minlength;
        };
    }
};});
    TAJS_restrictToType(((window.angular, $__.os.oid1), $__.os.oid1).bootstrap, 'undefined');
    (bindJQuery, $__.fs.bindJQuery_69)(0, true, $__.uid);
    (publishExternalAPI, $__.fs.publishExternalAPI_81)(angular, 0, true, $__.uid);
    vvv_tmp0 = angular, 'module', $__.fs.module_678.call(vvv_tmp0, 'ngLocale', [], [
        '$provide',
        ($__.fs.J$__v3645318688_2420_698 = function J$__v3645318688_2420($provide) {
var vvv_return, vvv_switch, PLURAL_CATEGORY, getDecimals, getVF;
getDecimals = function getDecimals(n) {
    n = n + '';
    var i = n.indexOf('.');
    return i == -1 ? 0 : n.length - i - 1;
};
getVF = function getVF(n, opt_precision) {
    var v = opt_precision;
    if (undefined === v) {
        v = Math.min(getDecimals(n), 3);
    }
    var base = Math.pow(10, v);
    var f = (n * base | 0) % base;
    return {
        v: v,
        f: f
    };
};
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
$provide = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
PLURAL_CATEGORY = {
    ZERO: 'zero',
    ONE: 'one',
    TWO: 'two',
    FEW: 'few',
    MANY: 'many',
    OTHER: 'other'
};
$provide.value('$locale', {
    'DATETIME_FORMATS': {
        'AMPMS': [
            'AM',
            'PM'
        ],
        'DAY': [
            'Sunday',
            'Monday',
            'Tuesday',
            'Wednesday',
            'Thursday',
            'Friday',
            'Saturday'
        ],
        'ERANAMES': [
            'Before Christ',
            'Anno Domini'
        ],
        'ERAS': [
            'BC',
            'AD'
        ],
        'FIRSTDAYOFWEEK': 6,
        'MONTH': [
            'January',
            'February',
            'March',
            'April',
            'May',
            'June',
            'July',
            'August',
            'September',
            'October',
            'November',
            'December'
        ],
        'SHORTDAY': [
            'Sun',
            'Mon',
            'Tue',
            'Wed',
            'Thu',
            'Fri',
            'Sat'
        ],
        'SHORTMONTH': [
            'Jan',
            'Feb',
            'Mar',
            'Apr',
            'May',
            'Jun',
            'Jul',
            'Aug',
            'Sep',
            'Oct',
            'Nov',
            'Dec'
        ],
        'STANDALONEMONTH': [
            'January',
            'February',
            'March',
            'April',
            'May',
            'June',
            'July',
            'August',
            'September',
            'October',
            'November',
            'December'
        ],
        'WEEKENDRANGE': [
            5,
            6
        ],
        'fullDate': 'EEEE, MMMM d, y',
        'longDate': 'MMMM d, y',
        'medium': 'MMM d, y h:mm:ss a',
        'mediumDate': 'MMM d, y',
        'mediumTime': 'h:mm:ss a',
        'short': 'M/d/yy h:mm a',
        'shortDate': 'M/d/yy',
        'shortTime': 'h:mm a'
    },
    'NUMBER_FORMATS': {
        'CURRENCY_SYM': '$',
        'DECIMAL_SEP': '.',
        'GROUP_SEP': ',',
        'PATTERNS': [
            {
                'gSize': 3,
                'lgSize': 3,
                'maxFrac': 3,
                'minFrac': 0,
                'minInt': 1,
                'negPre': '-',
                'negSuf': '',
                'posPre': '',
                'posSuf': ''
            },
            {
                'gSize': 3,
                'lgSize': 3,
                'maxFrac': 2,
                'minFrac': 2,
                'minInt': 1,
                'negPre': '-\xA4',
                'negSuf': '',
                'posPre': '\xA4',
                'posSuf': ''
            }
        ]
    },
    'id': 'en-us',
    'localeID': 'en_US',
    'pluralCat': function (n, opt_precision) {
        var i = n | 0;
        var vf = getVF(n, opt_precision);
        if (i == 1 && vf.v == 0) {
            return PLURAL_CATEGORY.ONE;
        }
        return PLURAL_CATEGORY.OTHER;
    }
});})
    ], 1, true, $__.uid);
    (jqLite, $__.fs.JQLite_93)(($__.fs.J$__v3645318688_2422_717 = function J$__v3645318688_2422() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    (angularInit, $__.fs.angularInit_64)(TAJS_restrictToType(window.document, 'HTMLDocument'), (bootstrap, $__.fs.bootstrap_65), 0, true, $__.uid);
    return;
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
angularInit(window.document, bootstrap);}), 1, true, $__.uid);
    return;
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
REGEX_STRING_REGEXP = /^\/(.+)\/([a-z]*)$/;
VALIDITY_STATE_PROPERTY = 'validity';
hasOwnProperty = Object.prototype.hasOwnProperty;
minErrConfig = {
    objectMaxDepth: 5
};
lowercase = function (string) {
    return isString(string) ? string.toLowerCase() : string;
};
uppercase = function (string) {
    return isString(string) ? string.toUpperCase() : string;
};
manualLowercase = function (s) {
    return isString(s) ? s.replace(/[A-Z]/g, function (ch) {
        return String.fromCharCode(ch.charCodeAt(0) | 32);
    }) : s;
};
manualUppercase = function (s) {
    return isString(s) ? s.replace(/[a-z]/g, function (ch) {
        return String.fromCharCode(ch.charCodeAt(0) & ~32);
    }) : s;
};
if ('i' !== 'I'.toLowerCase()) {
    lowercase = manualLowercase;
    uppercase = manualUppercase;
}
slice = [].slice;
splice = [].splice;
push = [].push;
toString = Object.prototype.toString;
getPrototypeOf = Object.getPrototypeOf;
ngMinErr = minErr('ng');
angular = window.angular || (window.angular = {});
uid = 0;
msie = window.document.documentMode;
isNumberNaN = Number.isNaN || function isNumberNaN(num) {
    return num !== num;
};
noop.$inject = [];
identity.$inject = [];
isArray = Array.isArray;
TYPED_ARRAY_REGEXP = /^\[object (?:Uint8|Uint8Clamped|Uint16|Uint32|Int8|Int16|Int32|Float32|Float64)Array]$/;
trim = function (value) {
    return isString(value) ? value.trim() : value;
};
escapeForRegexp = function (s) {
    return s.replace(/([-()[\]{}+?*.$^|,:#<!\\])/g, '\\$1').replace(/\x08/g, '\\x08');
};
csp = function () {
    if (!isDefined(csp.rules)) {
        var ngCspElement = window.document.querySelector('[ng-csp]') || window.document.querySelector('[data-ng-csp]');
        if (ngCspElement) {
            var ngCspAttribute = ngCspElement.getAttribute('ng-csp') || ngCspElement.getAttribute('data-ng-csp');
            csp.rules = {
                noUnsafeEval: !ngCspAttribute || ngCspAttribute.indexOf('no-unsafe-eval') !== -1,
                noInlineStyle: !ngCspAttribute || ngCspAttribute.indexOf('no-inline-style') !== -1
            };
        } else {
            csp.rules = {
                noUnsafeEval: noUnsafeEval(),
                noInlineStyle: false
            };
        }
    }
    return csp.rules;
    function noUnsafeEval() {
        try {
            new Function('');
            return false;
        } catch (e) {
            return true;
        }
    }
};
jq = function () {
    if (isDefined(jq.name_))
        return jq.name_;
    var el;
    var i, ii = ngAttrPrefixes.length, prefix, name;
    for (i = 0; i < ii; ++i) {
        prefix = ngAttrPrefixes[i];
        el = window.document.querySelector('[' + prefix.replace(':', '\\:') + 'jq]');
        if (el) {
            name = el.getAttribute(prefix + 'jq');
            break;
        }
    }
    return jq.name_ = name;
};
ALL_COLONS = /:/g;
ngAttrPrefixes = [
    'ng-',
    'data-ng-',
    'ng:',
    'x-ng-'
];
isAutoBootstrapAllowed = allowAutoBootstrap(window.document);
SNAKE_CASE_REGEXP = /[A-Z]/g;
bindJQueryFired = false;
NODE_TYPE_ELEMENT = 1;
NODE_TYPE_ATTRIBUTE = 2;
NODE_TYPE_TEXT = 3;
NODE_TYPE_COMMENT = 8;
NODE_TYPE_DOCUMENT = 9;
NODE_TYPE_DOCUMENT_FRAGMENT = 11;
version = {
    full: '1.6.3',
    major: 1,
    minor: 6,
    dot: 3,
    codeName: 'scriptalicious-bootstrapping'
};
JQLite.expando = 'ng339';
jqCache = JQLite.cache = {};
jqId = 1;
JQLite._data = function (node) {
    return this.cache[node[this.expando]] || {};
};
DASH_LOWERCASE_REGEXP = /-([a-z])/g;
MS_HACK_REGEXP = /^-ms-/;
MOUSE_EVENT_MAP = {
    mouseleave: 'mouseout',
    mouseenter: 'mouseover'
};
jqLiteMinErr = minErr('jqLite');
SINGLE_TAG_REGEXP = /^<([\w-]+)\s*\/?>(?:<\/\1>|)$/;
HTML_REGEXP = /<|&#?\w+;/;
TAG_NAME_REGEXP = /<([\w:-]+)/;
XHTML_TAG_REGEXP = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:-]+)[^>]*)\/>/gi;
wrapMap = {
    'option': [
        1,
        '<select multiple="multiple">',
        '</select>'
    ],
    'thead': [
        1,
        '<table>',
        '</table>'
    ],
    'col': [
        2,
        '<table><colgroup>',
        '</colgroup></table>'
    ],
    'tr': [
        2,
        '<table><tbody>',
        '</tbody></table>'
    ],
    'td': [
        3,
        '<table><tbody><tr>',
        '</tr></tbody></table>'
    ],
    '_default': [
        0,
        '',
        ''
    ]
};
wrapMap.optgroup = wrapMap.option;
wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;
jqLiteContains = window.Node.prototype.contains || function (arg) {
    return !!(this.compareDocumentPosition(arg) & 16);
};
JQLitePrototype = JQLite.prototype = {
    ready: jqLiteReady,
    toString: function () {
        var value = [];
        forEach(this, function (e) {
            value.push('' + e);
        });
        return '[' + value.join(', ') + ']';
    },
    eq: function (index) {
        return index >= 0 ? jqLite(this[index]) : jqLite(this[this.length + index]);
    },
    length: 0,
    push: push,
    sort: [].sort,
    splice: [].splice
};
BOOLEAN_ATTR = {};
forEach('multiple,selected,checked,disabled,readOnly,required,open'.split(','), function (value) {
    BOOLEAN_ATTR[lowercase(value)] = value;
});
BOOLEAN_ELEMENTS = {};
forEach('input,select,option,textarea,button,form,details'.split(','), function (value) {
    BOOLEAN_ELEMENTS[value] = true;
});
ALIASED_ATTR = {
    'ngMinlength': 'minlength',
    'ngMaxlength': 'maxlength',
    'ngMin': 'min',
    'ngMax': 'max',
    'ngPattern': 'pattern',
    'ngStep': 'step'
};
forEach({
    data: jqLiteData,
    removeData: jqLiteRemoveData,
    hasData: jqLiteHasData,
    cleanData: jqLiteCleanData
}, function (fn, name) {
    JQLite[name] = fn;
});
forEach({
    data: jqLiteData,
    inheritedData: jqLiteInheritedData,
    scope: function (element) {
        return jqLite.data(element, '$scope') || jqLiteInheritedData(element.parentNode || element, [
            '$isolateScope',
            '$scope'
        ]);
    },
    isolateScope: function (element) {
        return jqLite.data(element, '$isolateScope') || jqLite.data(element, '$isolateScopeNoTemplate');
    },
    controller: jqLiteController,
    injector: function (element) {
        return jqLiteInheritedData(element, '$injector');
    },
    removeAttr: function (element, name) {
        element.removeAttribute(name);
    },
    hasClass: jqLiteHasClass,
    css: function (element, name, value) {
        name = cssKebabToCamel(name);
        if (isDefined(value)) {
            element.style[name] = value;
        } else {
            return element.style[name];
        }
    },
    attr: function (element, name, value) {
        var ret;
        var nodeType = element.nodeType;
        if (nodeType === NODE_TYPE_TEXT || nodeType === NODE_TYPE_ATTRIBUTE || nodeType === NODE_TYPE_COMMENT || !element.getAttribute) {
            return;
        }
        var lowercasedName = lowercase(name);
        var isBooleanAttr = BOOLEAN_ATTR[lowercasedName];
        if (isDefined(value)) {
            if (value === null || value === false && isBooleanAttr) {
                element.removeAttribute(name);
            } else {
                element.setAttribute(name, isBooleanAttr ? lowercasedName : value);
            }
        } else {
            ret = element.getAttribute(name);
            if (isBooleanAttr && ret !== null) {
                ret = lowercasedName;
            }
            return ret === null ? undefined : ret;
        }
    },
    prop: function (element, name, value) {
        if (isDefined(value)) {
            element[name] = value;
        } else {
            return element[name];
        }
    },
    text: function () {
        getText.$dv = '';
        return getText;
        function getText(element, value) {
            if (isUndefined(value)) {
                var nodeType = element.nodeType;
                return nodeType === NODE_TYPE_ELEMENT || nodeType === NODE_TYPE_TEXT ? element.textContent : '';
            }
            element.textContent = value;
        }
    }(),
    val: function (element, value) {
        if (isUndefined(value)) {
            if (element.multiple && nodeName_(element) === 'select') {
                var result = [];
                forEach(element.options, function (option) {
                    if (option.selected) {
                        result.push(option.value || option.text);
                    }
                });
                return result;
            }
            return element.value;
        }
        element.value = value;
    },
    html: function (element, value) {
        if (isUndefined(value)) {
            return element.innerHTML;
        }
        jqLiteDealoc(element, true);
        element.innerHTML = value;
    },
    empty: jqLiteEmpty
}, function (fn, name) {
    JQLite.prototype[name] = function (arg1, arg2) {
        var i, key;
        var nodeCount = this.length;
        if (fn !== jqLiteEmpty && isUndefined(fn.length === 2 && (fn !== jqLiteHasClass && fn !== jqLiteController) ? arg1 : arg2)) {
            if (isObject(arg1)) {
                for (i = 0; i < nodeCount; i++) {
                    if (fn === jqLiteData) {
                        fn(this[i], arg1);
                    } else {
                        for (key in arg1) {
                            fn(this[i], key, arg1[key]);
                        }
                    }
                }
                return this;
            } else {
                var value = fn.$dv;
                var jj = isUndefined(value) ? Math.min(nodeCount, 1) : nodeCount;
                for (var j = 0; j < jj; j++) {
                    var nodeValue = fn(this[j], arg1, arg2);
                    value = value ? value + nodeValue : nodeValue;
                }
                return value;
            }
        } else {
            for (i = 0; i < nodeCount; i++) {
                fn(this[i], arg1, arg2);
            }
            return this;
        }
    };
});
forEach({
    removeData: jqLiteRemoveData,
    on: function jqLiteOn(element, type, fn, unsupported) {
        if (isDefined(unsupported))
            throw jqLiteMinErr('onargs', 'jqLite#on() does not support the `selector` or `eventData` parameters');
        if (!jqLiteAcceptsData(element)) {
            return;
        }
        var expandoStore = jqLiteExpandoStore(element, true);
        var events = expandoStore.events;
        var handle = expandoStore.handle;
        if (!handle) {
            handle = expandoStore.handle = createEventHandler(element, events);
        }
        var types = type.indexOf(' ') >= 0 ? type.split(' ') : [type];
        var i = types.length;
        var addHandler = function (type, specialHandlerWrapper, noEventListener) {
            var eventFns = events[type];
            if (!eventFns) {
                eventFns = events[type] = [];
                eventFns.specialHandlerWrapper = specialHandlerWrapper;
                if (type !== '$destroy' && !noEventListener) {
                    element.addEventListener(type, handle);
                }
            }
            eventFns.push(fn);
        };
        while (i--) {
            type = types[i];
            if (MOUSE_EVENT_MAP[type]) {
                addHandler(MOUSE_EVENT_MAP[type], specialMouseHandlerWrapper);
                addHandler(type, undefined, true);
            } else {
                addHandler(type);
            }
        }
    },
    off: jqLiteOff,
    one: function (element, type, fn) {
        element = jqLite(element);
        element.on(type, function onFn() {
            element.off(type, fn);
            element.off(type, onFn);
        });
        element.on(type, fn);
    },
    replaceWith: function (element, replaceNode) {
        var index, parent = element.parentNode;
        jqLiteDealoc(element);
        forEach(new JQLite(replaceNode), function (node) {
            if (index) {
                parent.insertBefore(node, index.nextSibling);
            } else {
                parent.replaceChild(node, element);
            }
            index = node;
        });
    },
    children: function (element) {
        var children = [];
        forEach(element.childNodes, function (element) {
            if (element.nodeType === NODE_TYPE_ELEMENT) {
                children.push(element);
            }
        });
        return children;
    },
    contents: function (element) {
        return element.contentDocument || element.childNodes || [];
    },
    append: function (element, node) {
        var nodeType = element.nodeType;
        if (nodeType !== NODE_TYPE_ELEMENT && nodeType !== NODE_TYPE_DOCUMENT_FRAGMENT)
            return;
        node = new JQLite(node);
        for (var i = 0, ii = node.length; i < ii; i++) {
            var child = node[i];
            element.appendChild(child);
        }
    },
    prepend: function (element, node) {
        if (element.nodeType === NODE_TYPE_ELEMENT) {
            var index = element.firstChild;
            forEach(new JQLite(node), function (child) {
                element.insertBefore(child, index);
            });
        }
    },
    wrap: function (element, wrapNode) {
        jqLiteWrapNode(element, jqLite(wrapNode).eq(0).clone()[0]);
    },
    remove: jqLiteRemove,
    detach: function (element) {
        jqLiteRemove(element, true);
    },
    after: function (element, newElement) {
        var index = element, parent = element.parentNode;
        if (parent) {
            newElement = new JQLite(newElement);
            for (var i = 0, ii = newElement.length; i < ii; i++) {
                var node = newElement[i];
                parent.insertBefore(node, index.nextSibling);
                index = node;
            }
        }
    },
    addClass: jqLiteAddClass,
    removeClass: jqLiteRemoveClass,
    toggleClass: function (element, selector, condition) {
        if (selector) {
            forEach(selector.split(' '), function (className) {
                var classCondition = condition;
                if (isUndefined(classCondition)) {
                    classCondition = !jqLiteHasClass(element, className);
                }
                (classCondition ? jqLiteAddClass : jqLiteRemoveClass)(element, className);
            });
        }
    },
    parent: function (element) {
        var parent = element.parentNode;
        return parent && parent.nodeType !== NODE_TYPE_DOCUMENT_FRAGMENT ? parent : null;
    },
    next: function (element) {
        return element.nextElementSibling;
    },
    find: function (element, selector) {
        if (element.getElementsByTagName) {
            return element.getElementsByTagName(selector);
        } else {
            return [];
        }
    },
    clone: jqLiteClone,
    triggerHandler: function (element, event, extraParameters) {
        var dummyEvent, eventFnsCopy, handlerArgs;
        var eventName = event.type || event;
        var expandoStore = jqLiteExpandoStore(element);
        var events = expandoStore && expandoStore.events;
        var eventFns = events && events[eventName];
        if (eventFns) {
            dummyEvent = {
                preventDefault: function () {
                    this.defaultPrevented = true;
                },
                isDefaultPrevented: function () {
                    return this.defaultPrevented === true;
                },
                stopImmediatePropagation: function () {
                    this.immediatePropagationStopped = true;
                },
                isImmediatePropagationStopped: function () {
                    return this.immediatePropagationStopped === true;
                },
                stopPropagation: noop,
                type: eventName,
                target: element
            };
            if (event.type) {
                dummyEvent = extend(dummyEvent, event);
            }
            eventFnsCopy = shallowCopy(eventFns);
            handlerArgs = extraParameters ? [dummyEvent].concat(extraParameters) : [dummyEvent];
            forEach(eventFnsCopy, function (fn) {
                if (!dummyEvent.isImmediatePropagationStopped()) {
                    fn.apply(element, handlerArgs);
                }
            });
        }
    }
}, function (fn, name) {
    JQLite.prototype[name] = function (arg1, arg2, arg3) {
        var value;
        for (var i = 0, ii = this.length; i < ii; i++) {
            if (isUndefined(value)) {
                value = fn(this[i], arg1, arg2, arg3);
                if (isDefined(value)) {
                    value = jqLite(value);
                }
            } else {
                jqLiteAddNodes(value, fn(this[i], arg1, arg2, arg3));
            }
        }
        return isDefined(value) ? value : this;
    };
});
JQLite.prototype.bind = JQLite.prototype.on;
JQLite.prototype.unbind = JQLite.prototype.off;
nanKey = Object.create(null);
NgMapShim.prototype = {
    _idx: function (key) {
        if (key === this._lastKey) {
            return this._lastIndex;
        }
        this._lastKey = key;
        this._lastIndex = this._keys.indexOf(key);
        return this._lastIndex;
    },
    _transformKey: function (key) {
        return isNumberNaN(key) ? nanKey : key;
    },
    get: function (key) {
        key = this._transformKey(key);
        var idx = this._idx(key);
        if (idx !== -1) {
            return this._values[idx];
        }
    },
    set: function (key, value) {
        key = this._transformKey(key);
        var idx = this._idx(key);
        if (idx === -1) {
            idx = this._lastIndex = this._keys.length;
        }
        this._keys[idx] = key;
        this._values[idx] = value;
    },
    delete: function (key) {
        key = this._transformKey(key);
        var idx = this._idx(key);
        if (idx === -1) {
            return false;
        }
        this._keys.splice(idx, 1);
        this._values.splice(idx, 1);
        this._lastKey = NaN;
        this._lastIndex = -1;
        return true;
    }
};
NgMap = NgMapShim;
$$MapProvider = [function () {
        this.$get = [function () {
                return NgMap;
            }];
    }];
ARROW_ARG = /^([^(]+?)=>/;
FN_ARGS = /^[^(]*\(\s*([^)]*)\)/m;
FN_ARG_SPLIT = /,/;
FN_ARG = /^\s*(_?)(\S+?)\1\s*$/;
STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/gm;
$injectorMinErr = minErr('$injector');
createInjector.$$annotate = annotate;
$animateMinErr = minErr('$animate');
ELEMENT_NODE = 1;
NG_ANIMATE_CLASSNAME = 'ng-animate';
$$CoreAnimateJsProvider = function () {
    this.$get = noop;
};
$$CoreAnimateQueueProvider = function () {
    var postDigestQueue = new NgMap();
    var postDigestElements = [];
    this.$get = [
        '$$AnimateRunner',
        '$rootScope',
        function ($$AnimateRunner, $rootScope) {
            return {
                enabled: noop,
                on: noop,
                off: noop,
                pin: noop,
                push: function (element, event, options, domOperation) {
                    if (domOperation) {
                        domOperation();
                    }
                    options = options || {};
                    if (options.from) {
                        element.css(options.from);
                    }
                    if (options.to) {
                        element.css(options.to);
                    }
                    if (options.addClass || options.removeClass) {
                        addRemoveClassesPostDigest(element, options.addClass, options.removeClass);
                    }
                    var runner = new $$AnimateRunner();
                    runner.complete();
                    return runner;
                }
            };
            function updateData(data, classes, value) {
                var changed = false;
                if (classes) {
                    classes = isString(classes) ? classes.split(' ') : isArray(classes) ? classes : [];
                    forEach(classes, function (className) {
                        if (className) {
                            changed = true;
                            data[className] = value;
                        }
                    });
                }
                return changed;
            }
            function handleCSSClassChanges() {
                forEach(postDigestElements, function (element) {
                    var data = postDigestQueue.get(element);
                    if (data) {
                        var existing = splitClasses(element.attr('class'));
                        var toAdd = '';
                        var toRemove = '';
                        forEach(data, function (status, className) {
                            var hasClass = !!existing[className];
                            if (status !== hasClass) {
                                if (status) {
                                    toAdd += (toAdd.length ? ' ' : '') + className;
                                } else {
                                    toRemove += (toRemove.length ? ' ' : '') + className;
                                }
                            }
                        });
                        forEach(element, function (elm) {
                            if (toAdd) {
                                jqLiteAddClass(elm, toAdd);
                            }
                            if (toRemove) {
                                jqLiteRemoveClass(elm, toRemove);
                            }
                        });
                        postDigestQueue.delete(element);
                    }
                });
                postDigestElements.length = 0;
            }
            function addRemoveClassesPostDigest(element, add, remove) {
                var data = postDigestQueue.get(element) || {};
                var classesAdded = updateData(data, add, true);
                var classesRemoved = updateData(data, remove, false);
                if (classesAdded || classesRemoved) {
                    postDigestQueue.set(element, data);
                    postDigestElements.push(element);
                    if (postDigestElements.length === 1) {
                        $rootScope.$$postDigest(handleCSSClassChanges);
                    }
                }
            }
        }
    ];
};
$AnimateProvider = [
    '$provide',
    function ($provide) {
        var provider = this;
        var classNameFilter = null;
        this.$$registeredAnimations = Object.create(null);
        this.register = function (name, factory) {
            if (name && name.charAt(0) !== '.') {
                throw $animateMinErr('notcsel', 'Expecting class selector starting with \'.\' got \'{0}\'.', name);
            }
            var key = name + '-animation';
            provider.$$registeredAnimations[name.substr(1)] = key;
            $provide.factory(key, factory);
        };
        this.classNameFilter = function (expression) {
            if (arguments.length === 1) {
                classNameFilter = expression instanceof RegExp ? expression : null;
                if (classNameFilter) {
                    var reservedRegex = new RegExp('[(\\s|\\/)]' + NG_ANIMATE_CLASSNAME + '[(\\s|\\/)]');
                    if (reservedRegex.test(classNameFilter.toString())) {
                        classNameFilter = null;
                        throw $animateMinErr('nongcls', '$animateProvider.classNameFilter(regex) prohibits accepting a regex value which matches/contains the "{0}" CSS class.', NG_ANIMATE_CLASSNAME);
                    }
                }
            }
            return classNameFilter;
        };
        this.$get = [
            '$$animateQueue',
            function ($$animateQueue) {
                function domInsert(element, parentElement, afterElement) {
                    if (afterElement) {
                        var afterNode = extractElementNode(afterElement);
                        if (afterNode && !afterNode.parentNode && !afterNode.previousElementSibling) {
                            afterElement = null;
                        }
                    }
                    if (afterElement) {
                        afterElement.after(element);
                    } else {
                        parentElement.prepend(element);
                    }
                }
                return {
                    on: $$animateQueue.on,
                    off: $$animateQueue.off,
                    pin: $$animateQueue.pin,
                    enabled: $$animateQueue.enabled,
                    cancel: function (runner) {
                        if (runner.end) {
                            runner.end();
                        }
                    },
                    enter: function (element, parent, after, options) {
                        parent = parent && jqLite(parent);
                        after = after && jqLite(after);
                        parent = parent || after.parent();
                        domInsert(element, parent, after);
                        return $$animateQueue.push(element, 'enter', prepareAnimateOptions(options));
                    },
                    move: function (element, parent, after, options) {
                        parent = parent && jqLite(parent);
                        after = after && jqLite(after);
                        parent = parent || after.parent();
                        domInsert(element, parent, after);
                        return $$animateQueue.push(element, 'move', prepareAnimateOptions(options));
                    },
                    leave: function (element, options) {
                        return $$animateQueue.push(element, 'leave', prepareAnimateOptions(options), function () {
                            element.remove();
                        });
                    },
                    addClass: function (element, className, options) {
                        options = prepareAnimateOptions(options);
                        options.addClass = mergeClasses(options.addclass, className);
                        return $$animateQueue.push(element, 'addClass', options);
                    },
                    removeClass: function (element, className, options) {
                        options = prepareAnimateOptions(options);
                        options.removeClass = mergeClasses(options.removeClass, className);
                        return $$animateQueue.push(element, 'removeClass', options);
                    },
                    setClass: function (element, add, remove, options) {
                        options = prepareAnimateOptions(options);
                        options.addClass = mergeClasses(options.addClass, add);
                        options.removeClass = mergeClasses(options.removeClass, remove);
                        return $$animateQueue.push(element, 'setClass', options);
                    },
                    animate: function (element, from, to, className, options) {
                        options = prepareAnimateOptions(options);
                        options.from = options.from ? extend(options.from, from) : from;
                        options.to = options.to ? extend(options.to, to) : to;
                        className = className || 'ng-inline-animate';
                        options.tempClasses = mergeClasses(options.tempClasses, className);
                        return $$animateQueue.push(element, 'animate', options);
                    }
                };
            }
        ];
    }
];
$$AnimateAsyncRunFactoryProvider = function () {
    this.$get = [
        '$$rAF',
        function ($$rAF) {
            var waitQueue = [];
            function waitForTick(fn) {
                waitQueue.push(fn);
                if (waitQueue.length > 1)
                    return;
                $$rAF(function () {
                    for (var i = 0; i < waitQueue.length; i++) {
                        waitQueue[i]();
                    }
                    waitQueue = [];
                });
            }
            return function () {
                var passed = false;
                waitForTick(function () {
                    passed = true;
                });
                return function (callback) {
                    if (passed) {
                        callback();
                    } else {
                        waitForTick(callback);
                    }
                };
            };
        }
    ];
};
$$AnimateRunnerFactoryProvider = function () {
    this.$get = [
        '$q',
        '$sniffer',
        '$$animateAsyncRun',
        '$$isDocumentHidden',
        '$timeout',
        function ($q, $sniffer, $$animateAsyncRun, $$isDocumentHidden, $timeout) {
            var INITIAL_STATE = 0;
            var DONE_PENDING_STATE = 1;
            var DONE_COMPLETE_STATE = 2;
            AnimateRunner.chain = function (chain, callback) {
                var index = 0;
                next();
                function next() {
                    if (index === chain.length) {
                        callback(true);
                        return;
                    }
                    chain[index](function (response) {
                        if (response === false) {
                            callback(false);
                            return;
                        }
                        index++;
                        next();
                    });
                }
            };
            AnimateRunner.all = function (runners, callback) {
                var count = 0;
                var status = true;
                forEach(runners, function (runner) {
                    runner.done(onProgress);
                });
                function onProgress(response) {
                    status = status && response;
                    if (++count === runners.length) {
                        callback(status);
                    }
                }
            };
            function AnimateRunner(host) {
                this.setHost(host);
                var rafTick = $$animateAsyncRun();
                var timeoutTick = function (fn) {
                    $timeout(fn, 0, false);
                };
                this._doneCallbacks = [];
                this._tick = function (fn) {
                    if ($$isDocumentHidden()) {
                        timeoutTick(fn);
                    } else {
                        rafTick(fn);
                    }
                };
                this._state = 0;
            }
            AnimateRunner.prototype = {
                setHost: function (host) {
                    this.host = host || {};
                },
                done: function (fn) {
                    if (this._state === DONE_COMPLETE_STATE) {
                        fn();
                    } else {
                        this._doneCallbacks.push(fn);
                    }
                },
                progress: noop,
                getPromise: function () {
                    if (!this.promise) {
                        var self = this;
                        this.promise = $q(function (resolve, reject) {
                            self.done(function (status) {
                                if (status === false) {
                                    reject();
                                } else {
                                    resolve();
                                }
                            });
                        });
                    }
                    return this.promise;
                },
                then: function (resolveHandler, rejectHandler) {
                    return this.getPromise().then(resolveHandler, rejectHandler);
                },
                'catch': function (handler) {
                    return this.getPromise()['catch'](handler);
                },
                'finally': function (handler) {
                    return this.getPromise()['finally'](handler);
                },
                pause: function () {
                    if (this.host.pause) {
                        this.host.pause();
                    }
                },
                resume: function () {
                    if (this.host.resume) {
                        this.host.resume();
                    }
                },
                end: function () {
                    if (this.host.end) {
                        this.host.end();
                    }
                    this._resolve(true);
                },
                cancel: function () {
                    if (this.host.cancel) {
                        this.host.cancel();
                    }
                    this._resolve(false);
                },
                complete: function (response) {
                    var self = this;
                    if (self._state === INITIAL_STATE) {
                        self._state = DONE_PENDING_STATE;
                        self._tick(function () {
                            self._resolve(response);
                        });
                    }
                },
                _resolve: function (response) {
                    if (this._state !== DONE_COMPLETE_STATE) {
                        forEach(this._doneCallbacks, function (fn) {
                            fn(response);
                        });
                        this._doneCallbacks.length = 0;
                        this._state = DONE_COMPLETE_STATE;
                    }
                }
            };
            return AnimateRunner;
        }
    ];
};
$CoreAnimateCssProvider = function () {
    this.$get = [
        '$$rAF',
        '$q',
        '$$AnimateRunner',
        function ($$rAF, $q, $$AnimateRunner) {
            return function (element, initialOptions) {
                var options = initialOptions || {};
                if (!options.$$prepared) {
                    options = copy(options);
                }
                if (options.cleanupStyles) {
                    options.from = options.to = null;
                }
                if (options.from) {
                    element.css(options.from);
                    options.from = null;
                }
                var closed, runner = new $$AnimateRunner();
                return {
                    start: run,
                    end: run
                };
                function run() {
                    $$rAF(function () {
                        applyAnimationContents();
                        if (!closed) {
                            runner.complete();
                        }
                        closed = true;
                    });
                    return runner;
                }
                function applyAnimationContents() {
                    if (options.addClass) {
                        element.addClass(options.addClass);
                        options.addClass = null;
                    }
                    if (options.removeClass) {
                        element.removeClass(options.removeClass);
                        options.removeClass = null;
                    }
                    if (options.to) {
                        element.css(options.to);
                        options.to = null;
                    }
                }
            };
        }
    ];
};
$compileMinErr = minErr('$compile');
_UNINITIALIZED_VALUE = new UNINITIALIZED_VALUE();
$CompileProvider.$inject = [
    '$provide',
    '$$sanitizeUriProvider'
];
SimpleChange.prototype.isFirstChange = function () {
    return this.previousValue === _UNINITIALIZED_VALUE;
};
PREFIX_REGEXP = /^((?:x|data)[:\-_])/i;
SPECIAL_CHARS_REGEXP = /[:\-_]+(.)/g;
$controllerMinErr = minErr('$controller');
CNTRL_REG = /^(\S+)(\s+as\s+([\w$]+))?$/;
$$ForceReflowProvider = function () {
    this.$get = [
        '$document',
        function ($document) {
            return function (domNode) {
                if (domNode) {
                    if (!domNode.nodeType && domNode instanceof jqLite) {
                        domNode = domNode[0];
                    }
                } else {
                    domNode = $document[0].body;
                }
                return domNode.offsetWidth + 1;
            };
        }
    ];
};
APPLICATION_JSON = 'application/json';
CONTENT_TYPE_APPLICATION_JSON = {
    'Content-Type': APPLICATION_JSON + ';charset=utf-8'
};
JSON_START = /^\[|^\{(?!\{)/;
JSON_ENDS = {
    '[': /]$/,
    '{': /}$/
};
JSON_PROTECTION_PREFIX = /^\)]\}',?\n/;
$httpMinErr = minErr('$http');
$interpolateMinErr = angular.$interpolateMinErr = minErr('$interpolate');
$interpolateMinErr.throwNoconcat = function (text) {
    throw $interpolateMinErr('noconcat', 'Error while interpolating: {0}\nStrict Contextual Escaping disallows ' + 'interpolations that concatenate multiple expressions when a trusted value is ' + 'required.  See http://docs.angularjs.org/api/ng.$sce', text);
};
$interpolateMinErr.interr = function (text, err) {
    return $interpolateMinErr('interr', 'Can\'t interpolate: {0}\n{1}', text, err.toString());
};
$jsonpCallbacksProvider = function () {
    this.$get = function () {
        var callbacks = angular.callbacks;
        var callbackMap = {};
        function createCallback(callbackId) {
            var callback = function (data) {
                callback.data = data;
                callback.called = true;
            };
            callback.id = callbackId;
            return callback;
        }
        return {
            createCallback: function (url) {
                var callbackId = '_' + (callbacks.$$counter++).toString(36);
                var callbackPath = 'angular.callbacks.' + callbackId;
                var callback = createCallback(callbackId);
                callbackMap[callbackPath] = callbacks[callbackId] = callback;
                return callbackPath;
            },
            wasCalled: function (callbackPath) {
                return callbackMap[callbackPath].called;
            },
            getResponse: function (callbackPath) {
                return callbackMap[callbackPath].data;
            },
            removeCallback: function (callbackPath) {
                var callback = callbackMap[callbackPath];
                delete callbacks[callback.id];
                delete callbackMap[callbackPath];
            }
        };
    };
};
PATH_MATCH = /^([^?#]*)(\?([^#]*))?(#(.*))?$/;
DEFAULT_PORTS = {
    'http': 80,
    'https': 443,
    'ftp': 21
};
$locationMinErr = minErr('$location');
DOUBLE_SLASH_REGEX = /^\s*[\\\/]{2,}/;
locationPrototype = {
    $$absUrl: '',
    $$html5: false,
    $$replace: false,
    absUrl: locationGetter('$$absUrl'),
    url: function (url) {
        if (isUndefined(url)) {
            return this.$$url;
        }
        var match = PATH_MATCH.exec(url);
        if (match[1] || url === '')
            this.path(decodeURIComponent(match[1]));
        if (match[2] || match[1] || url === '')
            this.search(match[3] || '');
        this.hash(match[5] || '');
        return this;
    },
    protocol: locationGetter('$$protocol'),
    host: locationGetter('$$host'),
    port: locationGetter('$$port'),
    path: locationGetterSetter('$$path', function (path) {
        path = path !== null ? path.toString() : '';
        return path.charAt(0) === '/' ? path : '/' + path;
    }),
    search: function (search, paramValue) {
        switch (arguments.length) {
        case 0:
            return this.$$search;
        case 1:
            if (isString(search) || isNumber(search)) {
                search = search.toString();
                this.$$search = parseKeyValue(search);
            } else if (isObject(search)) {
                search = copy(search, {});
                forEach(search, function (value, key) {
                    if (value == null)
                        delete search[key];
                });
                this.$$search = search;
            } else {
                throw $locationMinErr('isrcharg', 'The first argument of the `$location#search()` call must be a string or an object.');
            }
            break;
        default:
            if (isUndefined(paramValue) || paramValue === null) {
                delete this.$$search[search];
            } else {
                this.$$search[search] = paramValue;
            }
        }
        this.$$compose();
        return this;
    },
    hash: locationGetterSetter('$$hash', function (hash) {
        return hash !== null ? hash.toString() : '';
    }),
    replace: function () {
        this.$$replace = true;
        return this;
    }
};
forEach([
    LocationHashbangInHtml5Url,
    LocationHashbangUrl,
    LocationHtml5Url
], function (Location) {
    Location.prototype = Object.create(locationPrototype);
    Location.prototype.state = function (state) {
        if (!arguments.length) {
            return this.$$state;
        }
        if (Location !== LocationHtml5Url || !this.$$html5) {
            throw $locationMinErr('nostate', 'History API state support is available only ' + 'in HTML5 mode and only in browsers supporting HTML5 History API');
        }
        this.$$state = isUndefined(state) ? null : state;
        this.$$urlUpdatedByLocation = true;
        return this;
    };
});
$parseMinErr = minErr('$parse');
objectValueOf = {}.constructor.prototype.valueOf;
OPERATORS = createMap();
forEach('+ - * / % === !== == != < > <= >= && || ! = |'.split(' '), function (operator) {
    OPERATORS[operator] = true;
});
ESCAPE = {
    'n': '\n',
    'f': '\f',
    'r': '\r',
    't': '\t',
    'v': '\x0B',
    '\'': '\'',
    '"': '"'
};
Lexer = function Lexer(options) {
    this.options = options;
};
Lexer.prototype = {
    constructor: Lexer,
    lex: function (text) {
        this.text = text;
        this.index = 0;
        this.tokens = [];
        while (this.index < this.text.length) {
            var ch = this.text.charAt(this.index);
            if (ch === '"' || ch === '\'') {
                this.readString(ch);
            } else if (this.isNumber(ch) || ch === '.' && this.isNumber(this.peek())) {
                this.readNumber();
            } else if (this.isIdentifierStart(this.peekMultichar())) {
                this.readIdent();
            } else if (this.is(ch, '(){}[].,;:?')) {
                this.tokens.push({
                    index: this.index,
                    text: ch
                });
                this.index++;
            } else if (this.isWhitespace(ch)) {
                this.index++;
            } else {
                var ch2 = ch + this.peek();
                var ch3 = ch2 + this.peek(2);
                var op1 = OPERATORS[ch];
                var op2 = OPERATORS[ch2];
                var op3 = OPERATORS[ch3];
                if (op1 || op2 || op3) {
                    var token = op3 ? ch3 : op2 ? ch2 : ch;
                    this.tokens.push({
                        index: this.index,
                        text: token,
                        operator: true
                    });
                    this.index += token.length;
                } else {
                    this.throwError('Unexpected next character ', this.index, this.index + 1);
                }
            }
        }
        return this.tokens;
    },
    is: function (ch, chars) {
        return chars.indexOf(ch) !== -1;
    },
    peek: function (i) {
        var num = i || 1;
        return this.index + num < this.text.length ? this.text.charAt(this.index + num) : false;
    },
    isNumber: function (ch) {
        return '0' <= ch && ch <= '9' && typeof ch === 'string';
    },
    isWhitespace: function (ch) {
        return ch === ' ' || ch === '\r' || ch === '\t' || ch === '\n' || ch === '\x0B' || ch === '\xA0';
    },
    isIdentifierStart: function (ch) {
        return this.options.isIdentifierStart ? this.options.isIdentifierStart(ch, this.codePointAt(ch)) : this.isValidIdentifierStart(ch);
    },
    isValidIdentifierStart: function (ch) {
        return 'a' <= ch && ch <= 'z' || 'A' <= ch && ch <= 'Z' || '_' === ch || ch === '$';
    },
    isIdentifierContinue: function (ch) {
        return this.options.isIdentifierContinue ? this.options.isIdentifierContinue(ch, this.codePointAt(ch)) : this.isValidIdentifierContinue(ch);
    },
    isValidIdentifierContinue: function (ch, cp) {
        return this.isValidIdentifierStart(ch, cp) || this.isNumber(ch);
    },
    codePointAt: function (ch) {
        if (ch.length === 1)
            return ch.charCodeAt(0);
        return (ch.charCodeAt(0) << 10) + ch.charCodeAt(1) - 56613888;
    },
    peekMultichar: function () {
        var ch = this.text.charAt(this.index);
        var peek = this.peek();
        if (!peek) {
            return ch;
        }
        var cp1 = ch.charCodeAt(0);
        var cp2 = peek.charCodeAt(0);
        if (cp1 >= 55296 && cp1 <= 56319 && cp2 >= 56320 && cp2 <= 57343) {
            return ch + peek;
        }
        return ch;
    },
    isExpOperator: function (ch) {
        return ch === '-' || ch === '+' || this.isNumber(ch);
    },
    throwError: function (error, start, end) {
        end = end || this.index;
        var colStr = isDefined(start) ? 's ' + start + '-' + this.index + ' [' + this.text.substring(start, end) + ']' : ' ' + end;
        throw $parseMinErr('lexerr', 'Lexer Error: {0} at column{1} in expression [{2}].', error, colStr, this.text);
    },
    readNumber: function () {
        var number = '';
        var start = this.index;
        while (this.index < this.text.length) {
            var ch = lowercase(this.text.charAt(this.index));
            if (ch === '.' || this.isNumber(ch)) {
                number += ch;
            } else {
                var peekCh = this.peek();
                if (ch === 'e' && this.isExpOperator(peekCh)) {
                    number += ch;
                } else if (this.isExpOperator(ch) && peekCh && this.isNumber(peekCh) && number.charAt(number.length - 1) === 'e') {
                    number += ch;
                } else if (this.isExpOperator(ch) && (!peekCh || !this.isNumber(peekCh)) && number.charAt(number.length - 1) === 'e') {
                    this.throwError('Invalid exponent');
                } else {
                    break;
                }
            }
            this.index++;
        }
        this.tokens.push({
            index: start,
            text: number,
            constant: true,
            value: Number(number)
        });
    },
    readIdent: function () {
        var start = this.index;
        this.index += this.peekMultichar().length;
        while (this.index < this.text.length) {
            var ch = this.peekMultichar();
            if (!this.isIdentifierContinue(ch)) {
                break;
            }
            this.index += ch.length;
        }
        this.tokens.push({
            index: start,
            text: this.text.slice(start, this.index),
            identifier: true
        });
    },
    readString: function (quote) {
        var start = this.index;
        this.index++;
        var string = '';
        var rawString = quote;
        var escape = false;
        while (this.index < this.text.length) {
            var ch = this.text.charAt(this.index);
            rawString += ch;
            if (escape) {
                if (ch === 'u') {
                    var hex = this.text.substring(this.index + 1, this.index + 5);
                    if (!hex.match(/[\da-f]{4}/i)) {
                        this.throwError('Invalid unicode escape [\\u' + hex + ']');
                    }
                    this.index += 4;
                    string += String.fromCharCode(parseInt(hex, 16));
                } else {
                    var rep = ESCAPE[ch];
                    string = string + (rep || ch);
                }
                escape = false;
            } else if (ch === '\\') {
                escape = true;
            } else if (ch === quote) {
                this.index++;
                this.tokens.push({
                    index: start,
                    text: rawString,
                    constant: true,
                    value: string
                });
                return;
            } else {
                string += ch;
            }
            this.index++;
        }
        this.throwError('Unterminated quote', start);
    }
};
AST = function AST(lexer, options) {
    this.lexer = lexer;
    this.options = options;
};
AST.Program = 'Program';
AST.ExpressionStatement = 'ExpressionStatement';
AST.AssignmentExpression = 'AssignmentExpression';
AST.ConditionalExpression = 'ConditionalExpression';
AST.LogicalExpression = 'LogicalExpression';
AST.BinaryExpression = 'BinaryExpression';
AST.UnaryExpression = 'UnaryExpression';
AST.CallExpression = 'CallExpression';
AST.MemberExpression = 'MemberExpression';
AST.Identifier = 'Identifier';
AST.Literal = 'Literal';
AST.ArrayExpression = 'ArrayExpression';
AST.Property = 'Property';
AST.ObjectExpression = 'ObjectExpression';
AST.ThisExpression = 'ThisExpression';
AST.LocalsExpression = 'LocalsExpression';
AST.NGValueParameter = 'NGValueParameter';
AST.prototype = {
    ast: function (text) {
        this.text = text;
        this.tokens = this.lexer.lex(text);
        var value = this.program();
        if (this.tokens.length !== 0) {
            this.throwError('is an unexpected token', this.tokens[0]);
        }
        return value;
    },
    program: function () {
        var body = [];
        while (true) {
            if (this.tokens.length > 0 && !this.peek('}', ')', ';', ']'))
                body.push(this.expressionStatement());
            if (!this.expect(';')) {
                return {
                    type: AST.Program,
                    body: body
                };
            }
        }
    },
    expressionStatement: function () {
        return {
            type: AST.ExpressionStatement,
            expression: this.filterChain()
        };
    },
    filterChain: function () {
        var left = this.expression();
        while (this.expect('|')) {
            left = this.filter(left);
        }
        return left;
    },
    expression: function () {
        return this.assignment();
    },
    assignment: function () {
        var result = this.ternary();
        if (this.expect('=')) {
            if (!isAssignable(result)) {
                throw $parseMinErr('lval', 'Trying to assign a value to a non l-value');
            }
            result = {
                type: AST.AssignmentExpression,
                left: result,
                right: this.assignment(),
                operator: '='
            };
        }
        return result;
    },
    ternary: function () {
        var test = this.logicalOR();
        var alternate;
        var consequent;
        if (this.expect('?')) {
            alternate = this.expression();
            if (this.consume(':')) {
                consequent = this.expression();
                return {
                    type: AST.ConditionalExpression,
                    test: test,
                    alternate: alternate,
                    consequent: consequent
                };
            }
        }
        return test;
    },
    logicalOR: function () {
        var left = this.logicalAND();
        while (this.expect('||')) {
            left = {
                type: AST.LogicalExpression,
                operator: '||',
                left: left,
                right: this.logicalAND()
            };
        }
        return left;
    },
    logicalAND: function () {
        var left = this.equality();
        while (this.expect('&&')) {
            left = {
                type: AST.LogicalExpression,
                operator: '&&',
                left: left,
                right: this.equality()
            };
        }
        return left;
    },
    equality: function () {
        var left = this.relational();
        var token;
        while (token = this.expect('==', '!=', '===', '!==')) {
            left = {
                type: AST.BinaryExpression,
                operator: token.text,
                left: left,
                right: this.relational()
            };
        }
        return left;
    },
    relational: function () {
        var left = this.additive();
        var token;
        while (token = this.expect('<', '>', '<=', '>=')) {
            left = {
                type: AST.BinaryExpression,
                operator: token.text,
                left: left,
                right: this.additive()
            };
        }
        return left;
    },
    additive: function () {
        var left = this.multiplicative();
        var token;
        while (token = this.expect('+', '-')) {
            left = {
                type: AST.BinaryExpression,
                operator: token.text,
                left: left,
                right: this.multiplicative()
            };
        }
        return left;
    },
    multiplicative: function () {
        var left = this.unary();
        var token;
        while (token = this.expect('*', '/', '%')) {
            left = {
                type: AST.BinaryExpression,
                operator: token.text,
                left: left,
                right: this.unary()
            };
        }
        return left;
    },
    unary: function () {
        var token;
        if (token = this.expect('+', '-', '!')) {
            return {
                type: AST.UnaryExpression,
                operator: token.text,
                prefix: true,
                argument: this.unary()
            };
        } else {
            return this.primary();
        }
    },
    primary: function () {
        var primary;
        if (this.expect('(')) {
            primary = this.filterChain();
            this.consume(')');
        } else if (this.expect('[')) {
            primary = this.arrayDeclaration();
        } else if (this.expect('{')) {
            primary = this.object();
        } else if (this.selfReferential.hasOwnProperty(this.peek().text)) {
            primary = copy(this.selfReferential[this.consume().text]);
        } else if (this.options.literals.hasOwnProperty(this.peek().text)) {
            primary = {
                type: AST.Literal,
                value: this.options.literals[this.consume().text]
            };
        } else if (this.peek().identifier) {
            primary = this.identifier();
        } else if (this.peek().constant) {
            primary = this.constant();
        } else {
            this.throwError('not a primary expression', this.peek());
        }
        var next;
        while (next = this.expect('(', '[', '.')) {
            if (next.text === '(') {
                primary = {
                    type: AST.CallExpression,
                    callee: primary,
                    arguments: this.parseArguments()
                };
                this.consume(')');
            } else if (next.text === '[') {
                primary = {
                    type: AST.MemberExpression,
                    object: primary,
                    property: this.expression(),
                    computed: true
                };
                this.consume(']');
            } else if (next.text === '.') {
                primary = {
                    type: AST.MemberExpression,
                    object: primary,
                    property: this.identifier(),
                    computed: false
                };
            } else {
                this.throwError('IMPOSSIBLE');
            }
        }
        return primary;
    },
    filter: function (baseExpression) {
        var args = [baseExpression];
        var result = {
            type: AST.CallExpression,
            callee: this.identifier(),
            arguments: args,
            filter: true
        };
        while (this.expect(':')) {
            args.push(this.expression());
        }
        return result;
    },
    parseArguments: function () {
        var args = [];
        if (this.peekToken().text !== ')') {
            do {
                args.push(this.filterChain());
            } while (this.expect(','));
        }
        return args;
    },
    identifier: function () {
        var token = this.consume();
        if (!token.identifier) {
            this.throwError('is not a valid identifier', token);
        }
        return {
            type: AST.Identifier,
            name: token.text
        };
    },
    constant: function () {
        return {
            type: AST.Literal,
            value: this.consume().value
        };
    },
    arrayDeclaration: function () {
        var elements = [];
        if (this.peekToken().text !== ']') {
            do {
                if (this.peek(']')) {
                    break;
                }
                elements.push(this.expression());
            } while (this.expect(','));
        }
        this.consume(']');
        return {
            type: AST.ArrayExpression,
            elements: elements
        };
    },
    object: function () {
        var properties = [], property;
        if (this.peekToken().text !== '}') {
            do {
                if (this.peek('}')) {
                    break;
                }
                property = {
                    type: AST.Property,
                    kind: 'init'
                };
                if (this.peek().constant) {
                    property.key = this.constant();
                    property.computed = false;
                    this.consume(':');
                    property.value = this.expression();
                } else if (this.peek().identifier) {
                    property.key = this.identifier();
                    property.computed = false;
                    if (this.peek(':')) {
                        this.consume(':');
                        property.value = this.expression();
                    } else {
                        property.value = property.key;
                    }
                } else if (this.peek('[')) {
                    this.consume('[');
                    property.key = this.expression();
                    this.consume(']');
                    property.computed = true;
                    this.consume(':');
                    property.value = this.expression();
                } else {
                    this.throwError('invalid key', this.peek());
                }
                properties.push(property);
            } while (this.expect(','));
        }
        this.consume('}');
        return {
            type: AST.ObjectExpression,
            properties: properties
        };
    },
    throwError: function (msg, token) {
        throw $parseMinErr('syntax', 'Syntax Error: Token \'{0}\' {1} at column {2} of the expression [{3}] starting at [{4}].', token.text, msg, token.index + 1, this.text, this.text.substring(token.index));
    },
    consume: function (e1) {
        if (this.tokens.length === 0) {
            throw $parseMinErr('ueoe', 'Unexpected end of expression: {0}', this.text);
        }
        var token = this.expect(e1);
        if (!token) {
            this.throwError('is unexpected, expecting [' + e1 + ']', this.peek());
        }
        return token;
    },
    peekToken: function () {
        if (this.tokens.length === 0) {
            throw $parseMinErr('ueoe', 'Unexpected end of expression: {0}', this.text);
        }
        return this.tokens[0];
    },
    peek: function (e1, e2, e3, e4) {
        return this.peekAhead(0, e1, e2, e3, e4);
    },
    peekAhead: function (i, e1, e2, e3, e4) {
        if (this.tokens.length > i) {
            var token = this.tokens[i];
            var t = token.text;
            if (t === e1 || t === e2 || t === e3 || t === e4 || !e1 && !e2 && !e3 && !e4) {
                return token;
            }
        }
        return false;
    },
    expect: function (e1, e2, e3, e4) {
        var token = this.peek(e1, e2, e3, e4);
        if (token) {
            this.tokens.shift();
            return token;
        }
        return false;
    },
    selfReferential: {
        'this': {
            type: AST.ThisExpression
        },
        '$locals': {
            type: AST.LocalsExpression
        }
    }
};
ASTCompiler.prototype = {
    compile: function (expression) {
        var self = this;
        var ast = this.astBuilder.ast(expression);
        this.state = {
            nextId: 0,
            filters: {},
            fn: {
                vars: [],
                body: [],
                own: {}
            },
            assign: {
                vars: [],
                body: [],
                own: {}
            },
            inputs: []
        };
        findConstantAndWatchExpressions(ast, self.$filter);
        var extra = '';
        var assignable;
        this.stage = 'assign';
        if (assignable = assignableAST(ast)) {
            this.state.computing = 'assign';
            var result = this.nextId();
            this.recurse(assignable, result);
            this.return_(result);
            extra = 'fn.assign=' + this.generateFunction('assign', 's,v,l');
        }
        var toWatch = getInputs(ast.body);
        self.stage = 'inputs';
        forEach(toWatch, function (watch, key) {
            var fnKey = 'fn' + key;
            self.state[fnKey] = {
                vars: [],
                body: [],
                own: {}
            };
            self.state.computing = fnKey;
            var intoId = self.nextId();
            self.recurse(watch, intoId);
            self.return_(intoId);
            self.state.inputs.push(fnKey);
            watch.watchId = key;
        });
        this.state.computing = 'fn';
        this.stage = 'main';
        this.recurse(ast);
        var fnString = '"' + this.USE + ' ' + this.STRICT + '";\n' + this.filterPrefix() + 'var fn=' + this.generateFunction('fn', 's,l,a,i') + extra + this.watchFns() + 'return fn;';
        var fn = new Function('$filter', 'getStringValue', 'ifDefined', 'plus', fnString)(this.$filter, getStringValue, ifDefined, plusFn);
        this.state = this.stage = undefined;
        fn.literal = isLiteral(ast);
        fn.constant = isConstant(ast);
        return fn;
    },
    USE: 'use',
    STRICT: 'strict',
    watchFns: function () {
        var result = [];
        var fns = this.state.inputs;
        var self = this;
        forEach(fns, function (name) {
            result.push('var ' + name + '=' + self.generateFunction(name, 's'));
        });
        if (fns.length) {
            result.push('fn.inputs=[' + fns.join(',') + '];');
        }
        return result.join('');
    },
    generateFunction: function (name, params) {
        return 'function(' + params + '){' + this.varsPrefix(name) + this.body(name) + '};';
    },
    filterPrefix: function () {
        var parts = [];
        var self = this;
        forEach(this.state.filters, function (id, filter) {
            parts.push(id + '=$filter(' + self.escape(filter) + ')');
        });
        if (parts.length)
            return 'var ' + parts.join(',') + ';';
        return '';
    },
    varsPrefix: function (section) {
        return this.state[section].vars.length ? 'var ' + this.state[section].vars.join(',') + ';' : '';
    },
    body: function (section) {
        return this.state[section].body.join('');
    },
    recurse: function (ast, intoId, nameId, recursionFn, create, skipWatchIdCheck) {
        var left, right, self = this, args, expression, computed;
        recursionFn = recursionFn || noop;
        if (!skipWatchIdCheck && isDefined(ast.watchId)) {
            intoId = intoId || this.nextId();
            this.if_('i', this.lazyAssign(intoId, this.computedMember('i', ast.watchId)), this.lazyRecurse(ast, intoId, nameId, recursionFn, create, true));
            return;
        }
        switch (ast.type) {
        case AST.Program:
            forEach(ast.body, function (expression, pos) {
                self.recurse(expression.expression, undefined, undefined, function (expr) {
                    right = expr;
                });
                if (pos !== ast.body.length - 1) {
                    self.current().body.push(right, ';');
                } else {
                    self.return_(right);
                }
            });
            break;
        case AST.Literal:
            expression = this.escape(ast.value);
            this.assign(intoId, expression);
            recursionFn(intoId || expression);
            break;
        case AST.UnaryExpression:
            this.recurse(ast.argument, undefined, undefined, function (expr) {
                right = expr;
            });
            expression = ast.operator + '(' + this.ifDefined(right, 0) + ')';
            this.assign(intoId, expression);
            recursionFn(expression);
            break;
        case AST.BinaryExpression:
            this.recurse(ast.left, undefined, undefined, function (expr) {
                left = expr;
            });
            this.recurse(ast.right, undefined, undefined, function (expr) {
                right = expr;
            });
            if (ast.operator === '+') {
                expression = this.plus(left, right);
            } else if (ast.operator === '-') {
                expression = this.ifDefined(left, 0) + ast.operator + this.ifDefined(right, 0);
            } else {
                expression = '(' + left + ')' + ast.operator + '(' + right + ')';
            }
            this.assign(intoId, expression);
            recursionFn(expression);
            break;
        case AST.LogicalExpression:
            intoId = intoId || this.nextId();
            self.recurse(ast.left, intoId);
            self.if_(ast.operator === '&&' ? intoId : self.not(intoId), self.lazyRecurse(ast.right, intoId));
            recursionFn(intoId);
            break;
        case AST.ConditionalExpression:
            intoId = intoId || this.nextId();
            self.recurse(ast.test, intoId);
            self.if_(intoId, self.lazyRecurse(ast.alternate, intoId), self.lazyRecurse(ast.consequent, intoId));
            recursionFn(intoId);
            break;
        case AST.Identifier:
            intoId = intoId || this.nextId();
            if (nameId) {
                nameId.context = self.stage === 'inputs' ? 's' : this.assign(this.nextId(), this.getHasOwnProperty('l', ast.name) + '?l:s');
                nameId.computed = false;
                nameId.name = ast.name;
            }
            self.if_(self.stage === 'inputs' || self.not(self.getHasOwnProperty('l', ast.name)), function () {
                self.if_(self.stage === 'inputs' || 's', function () {
                    if (create && create !== 1) {
                        self.if_(self.isNull(self.nonComputedMember('s', ast.name)), self.lazyAssign(self.nonComputedMember('s', ast.name), '{}'));
                    }
                    self.assign(intoId, self.nonComputedMember('s', ast.name));
                });
            }, intoId && self.lazyAssign(intoId, self.nonComputedMember('l', ast.name)));
            recursionFn(intoId);
            break;
        case AST.MemberExpression:
            left = nameId && (nameId.context = this.nextId()) || this.nextId();
            intoId = intoId || this.nextId();
            self.recurse(ast.object, left, undefined, function () {
                self.if_(self.notNull(left), function () {
                    if (ast.computed) {
                        right = self.nextId();
                        self.recurse(ast.property, right);
                        self.getStringValue(right);
                        if (create && create !== 1) {
                            self.if_(self.not(self.computedMember(left, right)), self.lazyAssign(self.computedMember(left, right), '{}'));
                        }
                        expression = self.computedMember(left, right);
                        self.assign(intoId, expression);
                        if (nameId) {
                            nameId.computed = true;
                            nameId.name = right;
                        }
                    } else {
                        if (create && create !== 1) {
                            self.if_(self.isNull(self.nonComputedMember(left, ast.property.name)), self.lazyAssign(self.nonComputedMember(left, ast.property.name), '{}'));
                        }
                        expression = self.nonComputedMember(left, ast.property.name);
                        self.assign(intoId, expression);
                        if (nameId) {
                            nameId.computed = false;
                            nameId.name = ast.property.name;
                        }
                    }
                }, function () {
                    self.assign(intoId, 'undefined');
                });
                recursionFn(intoId);
            }, !!create);
            break;
        case AST.CallExpression:
            intoId = intoId || this.nextId();
            if (ast.filter) {
                right = self.filter(ast.callee.name);
                args = [];
                forEach(ast.arguments, function (expr) {
                    var argument = self.nextId();
                    self.recurse(expr, argument);
                    args.push(argument);
                });
                expression = right + '(' + args.join(',') + ')';
                self.assign(intoId, expression);
                recursionFn(intoId);
            } else {
                right = self.nextId();
                left = {};
                args = [];
                self.recurse(ast.callee, right, left, function () {
                    self.if_(self.notNull(right), function () {
                        forEach(ast.arguments, function (expr) {
                            self.recurse(expr, ast.constant ? undefined : self.nextId(), undefined, function (argument) {
                                args.push(argument);
                            });
                        });
                        if (left.name) {
                            expression = self.member(left.context, left.name, left.computed) + '(' + args.join(',') + ')';
                        } else {
                            expression = right + '(' + args.join(',') + ')';
                        }
                        self.assign(intoId, expression);
                    }, function () {
                        self.assign(intoId, 'undefined');
                    });
                    recursionFn(intoId);
                });
            }
            break;
        case AST.AssignmentExpression:
            right = this.nextId();
            left = {};
            this.recurse(ast.left, undefined, left, function () {
                self.if_(self.notNull(left.context), function () {
                    self.recurse(ast.right, right);
                    expression = self.member(left.context, left.name, left.computed) + ast.operator + right;
                    self.assign(intoId, expression);
                    recursionFn(intoId || expression);
                });
            }, 1);
            break;
        case AST.ArrayExpression:
            args = [];
            forEach(ast.elements, function (expr) {
                self.recurse(expr, ast.constant ? undefined : self.nextId(), undefined, function (argument) {
                    args.push(argument);
                });
            });
            expression = '[' + args.join(',') + ']';
            this.assign(intoId, expression);
            recursionFn(intoId || expression);
            break;
        case AST.ObjectExpression:
            args = [];
            computed = false;
            forEach(ast.properties, function (property) {
                if (property.computed) {
                    computed = true;
                }
            });
            if (computed) {
                intoId = intoId || this.nextId();
                this.assign(intoId, '{}');
                forEach(ast.properties, function (property) {
                    if (property.computed) {
                        left = self.nextId();
                        self.recurse(property.key, left);
                    } else {
                        left = property.key.type === AST.Identifier ? property.key.name : '' + property.key.value;
                    }
                    right = self.nextId();
                    self.recurse(property.value, right);
                    self.assign(self.member(intoId, left, property.computed), right);
                });
            } else {
                forEach(ast.properties, function (property) {
                    self.recurse(property.value, ast.constant ? undefined : self.nextId(), undefined, function (expr) {
                        args.push(self.escape(property.key.type === AST.Identifier ? property.key.name : '' + property.key.value) + ':' + expr);
                    });
                });
                expression = '{' + args.join(',') + '}';
                this.assign(intoId, expression);
            }
            recursionFn(intoId || expression);
            break;
        case AST.ThisExpression:
            this.assign(intoId, 's');
            recursionFn(intoId || 's');
            break;
        case AST.LocalsExpression:
            this.assign(intoId, 'l');
            recursionFn(intoId || 'l');
            break;
        case AST.NGValueParameter:
            this.assign(intoId, 'v');
            recursionFn(intoId || 'v');
            break;
        }
    },
    getHasOwnProperty: function (element, property) {
        var key = element + '.' + property;
        var own = this.current().own;
        if (!own.hasOwnProperty(key)) {
            own[key] = this.nextId(false, element + '&&(' + this.escape(property) + ' in ' + element + ')');
        }
        return own[key];
    },
    assign: function (id, value) {
        if (!id)
            return;
        this.current().body.push(id, '=', value, ';');
        return id;
    },
    filter: function (filterName) {
        if (!this.state.filters.hasOwnProperty(filterName)) {
            this.state.filters[filterName] = this.nextId(true);
        }
        return this.state.filters[filterName];
    },
    ifDefined: function (id, defaultValue) {
        return 'ifDefined(' + id + ',' + this.escape(defaultValue) + ')';
    },
    plus: function (left, right) {
        return 'plus(' + left + ',' + right + ')';
    },
    return_: function (id) {
        this.current().body.push('return ', id, ';');
    },
    if_: function (test, alternate, consequent) {
        if (test === true) {
            alternate();
        } else {
            var body = this.current().body;
            body.push('if(', test, '){');
            alternate();
            body.push('}');
            if (consequent) {
                body.push('else{');
                consequent();
                body.push('}');
            }
        }
    },
    not: function (expression) {
        return '!(' + expression + ')';
    },
    isNull: function (expression) {
        return expression + '==null';
    },
    notNull: function (expression) {
        return expression + '!=null';
    },
    nonComputedMember: function (left, right) {
        var SAFE_IDENTIFIER = /^[$_a-zA-Z][$_a-zA-Z0-9]*$/;
        var UNSAFE_CHARACTERS = /[^$_a-zA-Z0-9]/g;
        if (SAFE_IDENTIFIER.test(right)) {
            return left + '.' + right;
        } else {
            return left + '["' + right.replace(UNSAFE_CHARACTERS, this.stringEscapeFn) + '"]';
        }
    },
    computedMember: function (left, right) {
        return left + '[' + right + ']';
    },
    member: function (left, right, computed) {
        if (computed)
            return this.computedMember(left, right);
        return this.nonComputedMember(left, right);
    },
    getStringValue: function (item) {
        this.assign(item, 'getStringValue(' + item + ')');
    },
    lazyRecurse: function (ast, intoId, nameId, recursionFn, create, skipWatchIdCheck) {
        var self = this;
        return function () {
            self.recurse(ast, intoId, nameId, recursionFn, create, skipWatchIdCheck);
        };
    },
    lazyAssign: function (id, value) {
        var self = this;
        return function () {
            self.assign(id, value);
        };
    },
    stringEscapeRegex: /[^ a-zA-Z0-9]/g,
    stringEscapeFn: function (c) {
        return '\\u' + ('0000' + c.charCodeAt(0).toString(16)).slice(-4);
    },
    escape: function (value) {
        if (isString(value))
            return '\'' + value.replace(this.stringEscapeRegex, this.stringEscapeFn) + '\'';
        if (isNumber(value))
            return value.toString();
        if (value === true)
            return 'true';
        if (value === false)
            return 'false';
        if (value === null)
            return 'null';
        if (typeof value === 'undefined')
            return 'undefined';
        throw $parseMinErr('esc', 'IMPOSSIBLE');
    },
    nextId: function (skip, init) {
        var id = 'v' + this.state.nextId++;
        if (!skip) {
            this.current().vars.push(id + (init ? '=' + init : ''));
        }
        return id;
    },
    current: function () {
        return this.state[this.state.computing];
    }
};
ASTInterpreter.prototype = {
    compile: function (expression) {
        var self = this;
        var ast = this.astBuilder.ast(expression);
        findConstantAndWatchExpressions(ast, self.$filter);
        var assignable;
        var assign;
        if (assignable = assignableAST(ast)) {
            assign = this.recurse(assignable);
        }
        var toWatch = getInputs(ast.body);
        var inputs;
        if (toWatch) {
            inputs = [];
            forEach(toWatch, function (watch, key) {
                var input = self.recurse(watch);
                watch.input = input;
                inputs.push(input);
                watch.watchId = key;
            });
        }
        var expressions = [];
        forEach(ast.body, function (expression) {
            expressions.push(self.recurse(expression.expression));
        });
        var fn = ast.body.length === 0 ? noop : ast.body.length === 1 ? expressions[0] : function (scope, locals) {
            var lastValue;
            forEach(expressions, function (exp) {
                lastValue = exp(scope, locals);
            });
            return lastValue;
        };
        if (assign) {
            fn.assign = function (scope, value, locals) {
                return assign(scope, locals, value);
            };
        }
        if (inputs) {
            fn.inputs = inputs;
        }
        fn.literal = isLiteral(ast);
        fn.constant = isConstant(ast);
        return fn;
    },
    recurse: function (ast, context, create) {
        var left, right, self = this, args;
        if (ast.input) {
            return this.inputs(ast.input, ast.watchId);
        }
        switch (ast.type) {
        case AST.Literal:
            return this.value(ast.value, context);
        case AST.UnaryExpression:
            right = this.recurse(ast.argument);
            return this['unary' + ast.operator](right, context);
        case AST.BinaryExpression:
            left = this.recurse(ast.left);
            right = this.recurse(ast.right);
            return this['binary' + ast.operator](left, right, context);
        case AST.LogicalExpression:
            left = this.recurse(ast.left);
            right = this.recurse(ast.right);
            return this['binary' + ast.operator](left, right, context);
        case AST.ConditionalExpression:
            return this['ternary?:'](this.recurse(ast.test), this.recurse(ast.alternate), this.recurse(ast.consequent), context);
        case AST.Identifier:
            return self.identifier(ast.name, context, create);
        case AST.MemberExpression:
            left = this.recurse(ast.object, false, !!create);
            if (!ast.computed) {
                right = ast.property.name;
            }
            if (ast.computed)
                right = this.recurse(ast.property);
            return ast.computed ? this.computedMember(left, right, context, create) : this.nonComputedMember(left, right, context, create);
        case AST.CallExpression:
            args = [];
            forEach(ast.arguments, function (expr) {
                args.push(self.recurse(expr));
            });
            if (ast.filter)
                right = this.$filter(ast.callee.name);
            if (!ast.filter)
                right = this.recurse(ast.callee, true);
            return ast.filter ? function (scope, locals, assign, inputs) {
                var values = [];
                for (var i = 0; i < args.length; ++i) {
                    values.push(args[i](scope, locals, assign, inputs));
                }
                var value = right.apply(undefined, values, inputs);
                return context ? {
                    context: undefined,
                    name: undefined,
                    value: value
                } : value;
            } : function (scope, locals, assign, inputs) {
                var rhs = right(scope, locals, assign, inputs);
                var value;
                if (rhs.value != null) {
                    var values = [];
                    for (var i = 0; i < args.length; ++i) {
                        values.push(args[i](scope, locals, assign, inputs));
                    }
                    value = rhs.value.apply(rhs.context, values);
                }
                return context ? {
                    value: value
                } : value;
            };
        case AST.AssignmentExpression:
            left = this.recurse(ast.left, true, 1);
            right = this.recurse(ast.right);
            return function (scope, locals, assign, inputs) {
                var lhs = left(scope, locals, assign, inputs);
                var rhs = right(scope, locals, assign, inputs);
                lhs.context[lhs.name] = rhs;
                return context ? {
                    value: rhs
                } : rhs;
            };
        case AST.ArrayExpression:
            args = [];
            forEach(ast.elements, function (expr) {
                args.push(self.recurse(expr));
            });
            return function (scope, locals, assign, inputs) {
                var value = [];
                for (var i = 0; i < args.length; ++i) {
                    value.push(args[i](scope, locals, assign, inputs));
                }
                return context ? {
                    value: value
                } : value;
            };
        case AST.ObjectExpression:
            args = [];
            forEach(ast.properties, function (property) {
                if (property.computed) {
                    args.push({
                        key: self.recurse(property.key),
                        computed: true,
                        value: self.recurse(property.value)
                    });
                } else {
                    args.push({
                        key: property.key.type === AST.Identifier ? property.key.name : '' + property.key.value,
                        computed: false,
                        value: self.recurse(property.value)
                    });
                }
            });
            return function (scope, locals, assign, inputs) {
                var value = {};
                for (var i = 0; i < args.length; ++i) {
                    if (args[i].computed) {
                        value[args[i].key(scope, locals, assign, inputs)] = args[i].value(scope, locals, assign, inputs);
                    } else {
                        value[args[i].key] = args[i].value(scope, locals, assign, inputs);
                    }
                }
                return context ? {
                    value: value
                } : value;
            };
        case AST.ThisExpression:
            return function (scope) {
                return context ? {
                    value: scope
                } : scope;
            };
        case AST.LocalsExpression:
            return function (scope, locals) {
                return context ? {
                    value: locals
                } : locals;
            };
        case AST.NGValueParameter:
            return function (scope, locals, assign) {
                return context ? {
                    value: assign
                } : assign;
            };
        }
    },
    'unary+': function (argument, context) {
        return function (scope, locals, assign, inputs) {
            var arg = argument(scope, locals, assign, inputs);
            if (isDefined(arg)) {
                arg = +arg;
            } else {
                arg = 0;
            }
            return context ? {
                value: arg
            } : arg;
        };
    },
    'unary-': function (argument, context) {
        return function (scope, locals, assign, inputs) {
            var arg = argument(scope, locals, assign, inputs);
            if (isDefined(arg)) {
                arg = -arg;
            } else {
                arg = -0;
            }
            return context ? {
                value: arg
            } : arg;
        };
    },
    'unary!': function (argument, context) {
        return function (scope, locals, assign, inputs) {
            var arg = !argument(scope, locals, assign, inputs);
            return context ? {
                value: arg
            } : arg;
        };
    },
    'binary+': function (left, right, context) {
        return function (scope, locals, assign, inputs) {
            var lhs = left(scope, locals, assign, inputs);
            var rhs = right(scope, locals, assign, inputs);
            var arg = plusFn(lhs, rhs);
            return context ? {
                value: arg
            } : arg;
        };
    },
    'binary-': function (left, right, context) {
        return function (scope, locals, assign, inputs) {
            var lhs = left(scope, locals, assign, inputs);
            var rhs = right(scope, locals, assign, inputs);
            var arg = (isDefined(lhs) ? lhs : 0) - (isDefined(rhs) ? rhs : 0);
            return context ? {
                value: arg
            } : arg;
        };
    },
    'binary*': function (left, right, context) {
        return function (scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) * right(scope, locals, assign, inputs);
            return context ? {
                value: arg
            } : arg;
        };
    },
    'binary/': function (left, right, context) {
        return function (scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) / right(scope, locals, assign, inputs);
            return context ? {
                value: arg
            } : arg;
        };
    },
    'binary%': function (left, right, context) {
        return function (scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) % right(scope, locals, assign, inputs);
            return context ? {
                value: arg
            } : arg;
        };
    },
    'binary===': function (left, right, context) {
        return function (scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) === right(scope, locals, assign, inputs);
            return context ? {
                value: arg
            } : arg;
        };
    },
    'binary!==': function (left, right, context) {
        return function (scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) !== right(scope, locals, assign, inputs);
            return context ? {
                value: arg
            } : arg;
        };
    },
    'binary==': function (left, right, context) {
        return function (scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) == right(scope, locals, assign, inputs);
            return context ? {
                value: arg
            } : arg;
        };
    },
    'binary!=': function (left, right, context) {
        return function (scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) != right(scope, locals, assign, inputs);
            return context ? {
                value: arg
            } : arg;
        };
    },
    'binary<': function (left, right, context) {
        return function (scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) < right(scope, locals, assign, inputs);
            return context ? {
                value: arg
            } : arg;
        };
    },
    'binary>': function (left, right, context) {
        return function (scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) > right(scope, locals, assign, inputs);
            return context ? {
                value: arg
            } : arg;
        };
    },
    'binary<=': function (left, right, context) {
        return function (scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) <= right(scope, locals, assign, inputs);
            return context ? {
                value: arg
            } : arg;
        };
    },
    'binary>=': function (left, right, context) {
        return function (scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) >= right(scope, locals, assign, inputs);
            return context ? {
                value: arg
            } : arg;
        };
    },
    'binary&&': function (left, right, context) {
        return function (scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) && right(scope, locals, assign, inputs);
            return context ? {
                value: arg
            } : arg;
        };
    },
    'binary||': function (left, right, context) {
        return function (scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) || right(scope, locals, assign, inputs);
            return context ? {
                value: arg
            } : arg;
        };
    },
    'ternary?:': function (test, alternate, consequent, context) {
        return function (scope, locals, assign, inputs) {
            var arg = test(scope, locals, assign, inputs) ? alternate(scope, locals, assign, inputs) : consequent(scope, locals, assign, inputs);
            return context ? {
                value: arg
            } : arg;
        };
    },
    value: function (value, context) {
        return function () {
            return context ? {
                context: undefined,
                name: undefined,
                value: value
            } : value;
        };
    },
    identifier: function (name, context, create) {
        return function (scope, locals, assign, inputs) {
            var base = locals && name in locals ? locals : scope;
            if (create && create !== 1 && base && base[name] == null) {
                base[name] = {};
            }
            var value = base ? base[name] : undefined;
            if (context) {
                return {
                    context: base,
                    name: name,
                    value: value
                };
            } else {
                return value;
            }
        };
    },
    computedMember: function (left, right, context, create) {
        return function (scope, locals, assign, inputs) {
            var lhs = left(scope, locals, assign, inputs);
            var rhs;
            var value;
            if (lhs != null) {
                rhs = right(scope, locals, assign, inputs);
                rhs = getStringValue(rhs);
                if (create && create !== 1) {
                    if (lhs && !lhs[rhs]) {
                        lhs[rhs] = {};
                    }
                }
                value = lhs[rhs];
            }
            if (context) {
                return {
                    context: lhs,
                    name: rhs,
                    value: value
                };
            } else {
                return value;
            }
        };
    },
    nonComputedMember: function (left, right, context, create) {
        return function (scope, locals, assign, inputs) {
            var lhs = left(scope, locals, assign, inputs);
            if (create && create !== 1) {
                if (lhs && lhs[right] == null) {
                    lhs[right] = {};
                }
            }
            var value = lhs != null ? lhs[right] : undefined;
            if (context) {
                return {
                    context: lhs,
                    name: right,
                    value: value
                };
            } else {
                return value;
            }
        };
    },
    inputs: function (input, watchId) {
        return function (scope, value, locals, inputs) {
            if (inputs)
                return inputs[watchId];
            return input(scope, value, locals);
        };
    }
};
Parser = function Parser(lexer, $filter, options) {
    this.lexer = lexer;
    this.$filter = $filter;
    this.options = options;
    this.ast = new AST(lexer, options);
    this.astCompiler = options.csp ? new ASTInterpreter(this.ast, $filter) : new ASTCompiler(this.ast, $filter);
};
Parser.prototype = {
    constructor: Parser,
    parse: function (text) {
        return this.astCompiler.compile(text);
    }
};
$sceMinErr = minErr('$sce');
SCE_CONTEXTS = {
    HTML: 'html',
    CSS: 'css',
    URL: 'url',
    RESOURCE_URL: 'resourceUrl',
    JS: 'js'
};
UNDERSCORE_LOWERCASE_REGEXP = /_([a-z])/g;
$templateRequestMinErr = minErr('$compile');
urlParsingNode = window.document.createElement('a');
originUrl = urlResolve(window.location.href);
$$CookieReader.$inject = ['$document'];
$FilterProvider.$inject = ['$provide'];
MAX_DIGITS = 22;
DECIMAL_SEP = '.';
ZERO_CHAR = '0';
currencyFilter.$inject = ['$locale'];
numberFilter.$inject = ['$locale'];
DATE_FORMATS = {
    yyyy: dateGetter('FullYear', 4, 0, false, true),
    yy: dateGetter('FullYear', 2, 0, true, true),
    y: dateGetter('FullYear', 1, 0, false, true),
    MMMM: dateStrGetter('Month'),
    MMM: dateStrGetter('Month', true),
    MM: dateGetter('Month', 2, 1),
    M: dateGetter('Month', 1, 1),
    LLLL: dateStrGetter('Month', false, true),
    dd: dateGetter('Date', 2),
    d: dateGetter('Date', 1),
    HH: dateGetter('Hours', 2),
    H: dateGetter('Hours', 1),
    hh: dateGetter('Hours', 2, -12),
    h: dateGetter('Hours', 1, -12),
    mm: dateGetter('Minutes', 2),
    m: dateGetter('Minutes', 1),
    ss: dateGetter('Seconds', 2),
    s: dateGetter('Seconds', 1),
    sss: dateGetter('Milliseconds', 3),
    EEEE: dateStrGetter('Day'),
    EEE: dateStrGetter('Day', true),
    a: ampmGetter,
    Z: timeZoneGetter,
    ww: weekGetter(2),
    w: weekGetter(1),
    G: eraGetter,
    GG: eraGetter,
    GGG: eraGetter,
    GGGG: longEraGetter
};
DATE_FORMATS_SPLIT = /((?:[^yMLdHhmsaZEwG']+)|(?:'(?:[^']|'')*')|(?:E+|y+|M+|L+|d+|H+|h+|m+|s+|a|Z|G+|w+))(.*)/;
NUMBER_STRING = /^-?\d+$/;
dateFilter.$inject = ['$locale'];
lowercaseFilter = valueFn(lowercase);
uppercaseFilter = valueFn(uppercase);
orderByFilter.$inject = ['$parse'];
htmlAnchorDirective = valueFn({
    restrict: 'E',
    compile: function (element, attr) {
        if (!attr.href && !attr.xlinkHref) {
            return function (scope, element) {
                if (element[0].nodeName.toLowerCase() !== 'a')
                    return;
                var href = toString.call(element.prop('href')) === '[object SVGAnimatedString]' ? 'xlink:href' : 'href';
                element.on('click', function (event) {
                    if (!element.attr(href)) {
                        event.preventDefault();
                    }
                });
            };
        }
    }
});
ngAttributeAliasDirectives = {};
forEach(BOOLEAN_ATTR, function (propName, attrName) {
    if (propName === 'multiple')
        return;
    function defaultLinkFn(scope, element, attr) {
        scope.$watch(attr[normalized], function ngBooleanAttrWatchAction(value) {
            attr.$set(attrName, !!value);
        });
    }
    var normalized = directiveNormalize('ng-' + attrName);
    var linkFn = defaultLinkFn;
    if (propName === 'checked') {
        linkFn = function (scope, element, attr) {
            if (attr.ngModel !== attr[normalized]) {
                defaultLinkFn(scope, element, attr);
            }
        };
    }
    ngAttributeAliasDirectives[normalized] = function () {
        return {
            restrict: 'A',
            priority: 100,
            link: linkFn
        };
    };
});
forEach(ALIASED_ATTR, function (htmlAttr, ngAttr) {
    ngAttributeAliasDirectives[ngAttr] = function () {
        return {
            priority: 100,
            link: function (scope, element, attr) {
                if (ngAttr === 'ngPattern' && attr.ngPattern.charAt(0) === '/') {
                    var match = attr.ngPattern.match(REGEX_STRING_REGEXP);
                    if (match) {
                        attr.$set('ngPattern', new RegExp(match[1], match[2]));
                        return;
                    }
                }
                scope.$watch(attr[ngAttr], function ngAttrAliasWatchAction(value) {
                    attr.$set(ngAttr, value);
                });
            }
        };
    };
});
forEach([
    'src',
    'srcset',
    'href'
], function (attrName) {
    var normalized = directiveNormalize('ng-' + attrName);
    ngAttributeAliasDirectives[normalized] = function () {
        return {
            priority: 99,
            link: function (scope, element, attr) {
                var propName = attrName, name = attrName;
                if (attrName === 'href' && toString.call(element.prop('href')) === '[object SVGAnimatedString]') {
                    name = 'xlinkHref';
                    attr.$attr[name] = 'xlink:href';
                    propName = null;
                }
                attr.$observe(normalized, function (value) {
                    if (!value) {
                        if (attrName === 'href') {
                            attr.$set(name, null);
                        }
                        return;
                    }
                    attr.$set(name, value);
                    if (msie && propName)
                        element.prop(propName, attr[name]);
                });
            }
        };
    };
});
nullFormCtrl = {
    $addControl: noop,
    $$renameControl: nullFormRenameControl,
    $removeControl: noop,
    $setValidity: noop,
    $setDirty: noop,
    $setPristine: noop,
    $setSubmitted: noop
};
PENDING_CLASS = 'ng-pending';
SUBMITTED_CLASS = 'ng-submitted';
FormController.$inject = [
    '$element',
    '$attrs',
    '$scope',
    '$animate',
    '$interpolate'
];
FormController.prototype = {
    $rollbackViewValue: function () {
        forEach(this.$$controls, function (control) {
            control.$rollbackViewValue();
        });
    },
    $commitViewValue: function () {
        forEach(this.$$controls, function (control) {
            control.$commitViewValue();
        });
    },
    $addControl: function (control) {
        assertNotHasOwnProperty(control.$name, 'input');
        this.$$controls.push(control);
        if (control.$name) {
            this[control.$name] = control;
        }
        control.$$parentForm = this;
    },
    $$renameControl: function (control, newName) {
        var oldName = control.$name;
        if (this[oldName] === control) {
            delete this[oldName];
        }
        this[newName] = control;
        control.$name = newName;
    },
    $removeControl: function (control) {
        if (control.$name && this[control.$name] === control) {
            delete this[control.$name];
        }
        forEach(this.$pending, function (value, name) {
            this.$setValidity(name, null, control);
        }, this);
        forEach(this.$error, function (value, name) {
            this.$setValidity(name, null, control);
        }, this);
        forEach(this.$$success, function (value, name) {
            this.$setValidity(name, null, control);
        }, this);
        arrayRemove(this.$$controls, control);
        control.$$parentForm = nullFormCtrl;
    },
    $setDirty: function () {
        this.$$animate.removeClass(this.$$element, PRISTINE_CLASS);
        this.$$animate.addClass(this.$$element, DIRTY_CLASS);
        this.$dirty = true;
        this.$pristine = false;
        this.$$parentForm.$setDirty();
    },
    $setPristine: function () {
        this.$$animate.setClass(this.$$element, PRISTINE_CLASS, DIRTY_CLASS + ' ' + SUBMITTED_CLASS);
        this.$dirty = false;
        this.$pristine = true;
        this.$submitted = false;
        forEach(this.$$controls, function (control) {
            control.$setPristine();
        });
    },
    $setUntouched: function () {
        forEach(this.$$controls, function (control) {
            control.$setUntouched();
        });
    },
    $setSubmitted: function () {
        this.$$animate.addClass(this.$$element, SUBMITTED_CLASS);
        this.$submitted = true;
        this.$$parentForm.$setSubmitted();
    }
};
addSetValidityMethod({
    clazz: FormController,
    set: function (object, property, controller) {
        var list = object[property];
        if (!list) {
            object[property] = [controller];
        } else {
            var index = list.indexOf(controller);
            if (index === -1) {
                list.push(controller);
            }
        }
    },
    unset: function (object, property, controller) {
        var list = object[property];
        if (!list) {
            return;
        }
        arrayRemove(list, controller);
        if (list.length === 0) {
            delete object[property];
        }
    }
});
formDirectiveFactory = function (isNgForm) {
    return [
        '$timeout',
        '$parse',
        function ($timeout, $parse) {
            var formDirective = {
                name: 'form',
                restrict: isNgForm ? 'EAC' : 'E',
                require: [
                    'form',
                    '^^?form'
                ],
                controller: FormController,
                compile: function ngFormCompile(formElement, attr) {
                    formElement.addClass(PRISTINE_CLASS).addClass(VALID_CLASS);
                    var nameAttr = attr.name ? 'name' : isNgForm && attr.ngForm ? 'ngForm' : false;
                    return {
                        pre: function ngFormPreLink(scope, formElement, attr, ctrls) {
                            var controller = ctrls[0];
                            if (!('action' in attr)) {
                                var handleFormSubmission = function (event) {
                                    scope.$apply(function () {
                                        controller.$commitViewValue();
                                        controller.$setSubmitted();
                                    });
                                    event.preventDefault();
                                };
                                formElement[0].addEventListener('submit', handleFormSubmission);
                                formElement.on('$destroy', function () {
                                    $timeout(function () {
                                        formElement[0].removeEventListener('submit', handleFormSubmission);
                                    }, 0, false);
                                });
                            }
                            var parentFormCtrl = ctrls[1] || controller.$$parentForm;
                            parentFormCtrl.$addControl(controller);
                            var setter = nameAttr ? getSetter(controller.$name) : noop;
                            if (nameAttr) {
                                setter(scope, controller);
                                attr.$observe(nameAttr, function (newValue) {
                                    if (controller.$name === newValue)
                                        return;
                                    setter(scope, undefined);
                                    controller.$$parentForm.$$renameControl(controller, newValue);
                                    setter = getSetter(controller.$name);
                                    setter(scope, controller);
                                });
                            }
                            formElement.on('$destroy', function () {
                                controller.$$parentForm.$removeControl(controller);
                                setter(scope, undefined);
                                extend(controller, nullFormCtrl);
                            });
                        }
                    };
                }
            };
            return formDirective;
            function getSetter(expression) {
                if (expression === '') {
                    return $parse('this[""]').assign;
                }
                return $parse(expression).assign || noop;
            }
        }
    ];
};
formDirective = formDirectiveFactory();
ngFormDirective = formDirectiveFactory(true);
ISO_DATE_REGEXP = /^\d{4,}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+(?:[+-][0-2]\d:[0-5]\d|Z)$/;
URL_REGEXP = /^[a-z][a-z\d.+-]*:\/*(?:[^:@]+(?::[^@]+)?@)?(?:[^\s:\/?#]+|\[[a-f\d:]+])(?::\d+)?(?:\/[^?#]*)?(?:\?[^#]*)?(?:#.*)?$/i;
EMAIL_REGEXP = /^(?=.{1,254}$)(?=.{1,64}@)[-!#$%&'*+\/0-9=?A-Z^_`a-z{|}~]+(\.[-!#$%&'*+\/0-9=?A-Z^_`a-z{|}~]+)*@[A-Za-z0-9]([A-Za-z0-9-]{0,61}[A-Za-z0-9])?(\.[A-Za-z0-9]([A-Za-z0-9-]{0,61}[A-Za-z0-9])?)*$/;
NUMBER_REGEXP = /^\s*(-|\+)?(\d+|(\d*(\.\d*)))([eE][+-]?\d+)?\s*$/;
DATE_REGEXP = /^(\d{4,})-(\d{2})-(\d{2})$/;
DATETIMELOCAL_REGEXP = /^(\d{4,})-(\d\d)-(\d\d)T(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/;
WEEK_REGEXP = /^(\d{4,})-W(\d\d)$/;
MONTH_REGEXP = /^(\d{4,})-(\d\d)$/;
TIME_REGEXP = /^(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/;
PARTIAL_VALIDATION_EVENTS = 'keydown wheel mousedown';
PARTIAL_VALIDATION_TYPES = createMap();
forEach('date,datetime-local,month,time,week'.split(','), function (type) {
    PARTIAL_VALIDATION_TYPES[type] = true;
});
inputType = {
    'text': textInputType,
    'date': createDateInputType('date', DATE_REGEXP, createDateParser(DATE_REGEXP, [
        'yyyy',
        'MM',
        'dd'
    ]), 'yyyy-MM-dd'),
    'datetime-local': createDateInputType('datetimelocal', DATETIMELOCAL_REGEXP, createDateParser(DATETIMELOCAL_REGEXP, [
        'yyyy',
        'MM',
        'dd',
        'HH',
        'mm',
        'ss',
        'sss'
    ]), 'yyyy-MM-ddTHH:mm:ss.sss'),
    'time': createDateInputType('time', TIME_REGEXP, createDateParser(TIME_REGEXP, [
        'HH',
        'mm',
        'ss',
        'sss'
    ]), 'HH:mm:ss.sss'),
    'week': createDateInputType('week', WEEK_REGEXP, weekParser, 'yyyy-Www'),
    'month': createDateInputType('month', MONTH_REGEXP, createDateParser(MONTH_REGEXP, [
        'yyyy',
        'MM'
    ]), 'yyyy-MM'),
    'number': numberInputType,
    'url': urlInputType,
    'email': emailInputType,
    'radio': radioInputType,
    'range': rangeInputType,
    'checkbox': checkboxInputType,
    'hidden': noop,
    'button': noop,
    'submit': noop,
    'reset': noop,
    'file': noop
};
inputDirective = [
    '$browser',
    '$sniffer',
    '$filter',
    '$parse',
    function ($browser, $sniffer, $filter, $parse) {
        return {
            restrict: 'E',
            require: ['?ngModel'],
            link: {
                pre: function (scope, element, attr, ctrls) {
                    if (ctrls[0]) {
                        (inputType[lowercase(attr.type)] || inputType.text)(scope, element, attr, ctrls[0], $sniffer, $browser, $filter, $parse);
                    }
                }
            }
        };
    }
];
CONSTANT_VALUE_REGEXP = /^(true|false|\d+)$/;
ngValueDirective = function () {
    function updateElementValue(element, attr, value) {
        var propValue = isDefined(value) ? value : msie === 9 ? '' : null;
        element.prop('value', propValue);
        attr.$set('value', value);
    }
    return {
        restrict: 'A',
        priority: 100,
        compile: function (tpl, tplAttr) {
            if (CONSTANT_VALUE_REGEXP.test(tplAttr.ngValue)) {
                return function ngValueConstantLink(scope, elm, attr) {
                    var value = scope.$eval(attr.ngValue);
                    updateElementValue(elm, attr, value);
                };
            } else {
                return function ngValueLink(scope, elm, attr) {
                    scope.$watch(attr.ngValue, function valueWatchAction(value) {
                        updateElementValue(elm, attr, value);
                    });
                };
            }
        }
    };
};
ngBindDirective = [
    '$compile',
    function ($compile) {
        return {
            restrict: 'AC',
            compile: function ngBindCompile(templateElement) {
                $compile.$$addBindingClass(templateElement);
                return function ngBindLink(scope, element, attr) {
                    $compile.$$addBindingInfo(element, attr.ngBind);
                    element = element[0];
                    scope.$watch(attr.ngBind, function ngBindWatchAction(value) {
                        element.textContent = stringify(value);
                    });
                };
            }
        };
    }
];
ngBindTemplateDirective = [
    '$interpolate',
    '$compile',
    function ($interpolate, $compile) {
        return {
            compile: function ngBindTemplateCompile(templateElement) {
                $compile.$$addBindingClass(templateElement);
                return function ngBindTemplateLink(scope, element, attr) {
                    var interpolateFn = $interpolate(element.attr(attr.$attr.ngBindTemplate));
                    $compile.$$addBindingInfo(element, interpolateFn.expressions);
                    element = element[0];
                    attr.$observe('ngBindTemplate', function (value) {
                        element.textContent = isUndefined(value) ? '' : value;
                    });
                };
            }
        };
    }
];
ngBindHtmlDirective = [
    '$sce',
    '$parse',
    '$compile',
    function ($sce, $parse, $compile) {
        return {
            restrict: 'A',
            compile: function ngBindHtmlCompile(tElement, tAttrs) {
                var ngBindHtmlGetter = $parse(tAttrs.ngBindHtml);
                var ngBindHtmlWatch = $parse(tAttrs.ngBindHtml, function sceValueOf(val) {
                    return $sce.valueOf(val);
                });
                $compile.$$addBindingClass(tElement);
                return function ngBindHtmlLink(scope, element, attr) {
                    $compile.$$addBindingInfo(element, attr.ngBindHtml);
                    scope.$watch(ngBindHtmlWatch, function ngBindHtmlWatchAction() {
                        var value = ngBindHtmlGetter(scope);
                        element.html($sce.getTrustedHtml(value) || '');
                    });
                };
            }
        };
    }
];
ngChangeDirective = valueFn({
    restrict: 'A',
    require: 'ngModel',
    link: function (scope, element, attr, ctrl) {
        ctrl.$viewChangeListeners.push(function () {
            scope.$eval(attr.ngChange);
        });
    }
});
ngClassDirective = classDirective('', true);
ngClassOddDirective = classDirective('Odd', 0);
ngClassEvenDirective = classDirective('Even', 1);
ngCloakDirective = ngDirective({
    compile: function (element, attr) {
        attr.$set('ngCloak', undefined);
        element.removeClass('ng-cloak');
    }
});
ngControllerDirective = [function () {
        return {
            restrict: 'A',
            scope: true,
            controller: '@',
            priority: 500
        };
    }];
ngEventDirectives = {};
forceAsyncEvents = {
    'blur': true,
    'focus': true
};
forEach('click dblclick mousedown mouseup mouseover mouseout mousemove mouseenter mouseleave keydown keyup keypress submit focus blur copy cut paste'.split(' '), function (eventName) {
    var directiveName = directiveNormalize('ng-' + eventName);
    ngEventDirectives[directiveName] = [
        '$parse',
        '$rootScope',
        function ($parse, $rootScope) {
            return {
                restrict: 'A',
                compile: function ($element, attr) {
                    var fn = $parse(attr[directiveName]);
                    return function ngEventHandler(scope, element) {
                        element.on(eventName, function (event) {
                            var callback = function () {
                                fn(scope, {
                                    $event: event
                                });
                            };
                            if (forceAsyncEvents[eventName] && $rootScope.$$phase) {
                                scope.$evalAsync(callback);
                            } else {
                                scope.$apply(callback);
                            }
                        });
                    };
                }
            };
        }
    ];
});
ngIfDirective = [
    '$animate',
    '$compile',
    function ($animate, $compile) {
        return {
            multiElement: true,
            transclude: 'element',
            priority: 600,
            terminal: true,
            restrict: 'A',
            $$tlb: true,
            link: function ($scope, $element, $attr, ctrl, $transclude) {
                var block, childScope, previousElements;
                $scope.$watch($attr.ngIf, function ngIfWatchAction(value) {
                    if (value) {
                        if (!childScope) {
                            $transclude(function (clone, newScope) {
                                childScope = newScope;
                                clone[clone.length++] = $compile.$$createComment('end ngIf', $attr.ngIf);
                                block = {
                                    clone: clone
                                };
                                $animate.enter(clone, $element.parent(), $element);
                            });
                        }
                    } else {
                        if (previousElements) {
                            previousElements.remove();
                            previousElements = null;
                        }
                        if (childScope) {
                            childScope.$destroy();
                            childScope = null;
                        }
                        if (block) {
                            previousElements = getBlockNodes(block.clone);
                            $animate.leave(previousElements).done(function (response) {
                                if (response !== false)
                                    previousElements = null;
                            });
                            block = null;
                        }
                    }
                });
            }
        };
    }
];
ngIncludeDirective = [
    '$templateRequest',
    '$anchorScroll',
    '$animate',
    function ($templateRequest, $anchorScroll, $animate) {
        return {
            restrict: 'ECA',
            priority: 400,
            terminal: true,
            transclude: 'element',
            controller: angular.noop,
            compile: function (element, attr) {
                var srcExp = attr.ngInclude || attr.src, onloadExp = attr.onload || '', autoScrollExp = attr.autoscroll;
                return function (scope, $element, $attr, ctrl, $transclude) {
                    var changeCounter = 0, currentScope, previousElement, currentElement;
                    var cleanupLastIncludeContent = function () {
                        if (previousElement) {
                            previousElement.remove();
                            previousElement = null;
                        }
                        if (currentScope) {
                            currentScope.$destroy();
                            currentScope = null;
                        }
                        if (currentElement) {
                            $animate.leave(currentElement).done(function (response) {
                                if (response !== false)
                                    previousElement = null;
                            });
                            previousElement = currentElement;
                            currentElement = null;
                        }
                    };
                    scope.$watch(srcExp, function ngIncludeWatchAction(src) {
                        var afterAnimation = function (response) {
                            if (response !== false && isDefined(autoScrollExp) && (!autoScrollExp || scope.$eval(autoScrollExp))) {
                                $anchorScroll();
                            }
                        };
                        var thisChangeId = ++changeCounter;
                        if (src) {
                            $templateRequest(src, true).then(function (response) {
                                if (scope.$$destroyed)
                                    return;
                                if (thisChangeId !== changeCounter)
                                    return;
                                var newScope = scope.$new();
                                ctrl.template = response;
                                var clone = $transclude(newScope, function (clone) {
                                    cleanupLastIncludeContent();
                                    $animate.enter(clone, null, $element).done(afterAnimation);
                                });
                                currentScope = newScope;
                                currentElement = clone;
                                currentScope.$emit('$includeContentLoaded', src);
                                scope.$eval(onloadExp);
                            }, function () {
                                if (scope.$$destroyed)
                                    return;
                                if (thisChangeId === changeCounter) {
                                    cleanupLastIncludeContent();
                                    scope.$emit('$includeContentError', src);
                                }
                            });
                            scope.$emit('$includeContentRequested', src);
                        } else {
                            cleanupLastIncludeContent();
                            ctrl.template = null;
                        }
                    });
                };
            }
        };
    }
];
ngIncludeFillContentDirective = [
    '$compile',
    function ($compile) {
        return {
            restrict: 'ECA',
            priority: -400,
            require: 'ngInclude',
            link: function (scope, $element, $attr, ctrl) {
                if (toString.call($element[0]).match(/SVG/)) {
                    $element.empty();
                    $compile(jqLiteBuildFragment(ctrl.template, window.document).childNodes)(scope, function namespaceAdaptedClone(clone) {
                        $element.append(clone);
                    }, {
                        futureParentElement: $element
                    });
                    return;
                }
                $element.html(ctrl.template);
                $compile($element.contents())(scope);
            }
        };
    }
];
ngInitDirective = ngDirective({
    priority: 450,
    compile: function () {
        return {
            pre: function (scope, element, attrs) {
                scope.$eval(attrs.ngInit);
            }
        };
    }
});
ngListDirective = function () {
    return {
        restrict: 'A',
        priority: 100,
        require: 'ngModel',
        link: function (scope, element, attr, ctrl) {
            var ngList = attr.ngList || ', ';
            var trimValues = attr.ngTrim !== 'false';
            var separator = trimValues ? trim(ngList) : ngList;
            var parse = function (viewValue) {
                if (isUndefined(viewValue))
                    return;
                var list = [];
                if (viewValue) {
                    forEach(viewValue.split(separator), function (value) {
                        if (value)
                            list.push(trimValues ? trim(value) : value);
                    });
                }
                return list;
            };
            ctrl.$parsers.push(parse);
            ctrl.$formatters.push(function (value) {
                if (isArray(value)) {
                    return value.join(ngList);
                }
                return undefined;
            });
            ctrl.$isEmpty = function (value) {
                return !value || !value.length;
            };
        }
    };
};
VALID_CLASS = 'ng-valid';
INVALID_CLASS = 'ng-invalid';
PRISTINE_CLASS = 'ng-pristine';
DIRTY_CLASS = 'ng-dirty';
UNTOUCHED_CLASS = 'ng-untouched';
TOUCHED_CLASS = 'ng-touched';
EMPTY_CLASS = 'ng-empty';
NOT_EMPTY_CLASS = 'ng-not-empty';
ngModelMinErr = minErr('ngModel');
NgModelController.$inject = [
    '$scope',
    '$exceptionHandler',
    '$attrs',
    '$element',
    '$parse',
    '$animate',
    '$timeout',
    '$q',
    '$interpolate'
];
NgModelController.prototype = {
    $$initGetterSetters: function () {
        if (this.$options.getOption('getterSetter')) {
            var invokeModelGetter = this.$$parse(this.$$attr.ngModel + '()'), invokeModelSetter = this.$$parse(this.$$attr.ngModel + '($$$p)');
            this.$$ngModelGet = function ($scope) {
                var modelValue = this.$$parsedNgModel($scope);
                if (isFunction(modelValue)) {
                    modelValue = invokeModelGetter($scope);
                }
                return modelValue;
            };
            this.$$ngModelSet = function ($scope, newValue) {
                if (isFunction(this.$$parsedNgModel($scope))) {
                    invokeModelSetter($scope, {
                        $$$p: newValue
                    });
                } else {
                    this.$$parsedNgModelAssign($scope, newValue);
                }
            };
        } else if (!this.$$parsedNgModel.assign) {
            throw ngModelMinErr('nonassign', 'Expression \'{0}\' is non-assignable. Element: {1}', this.$$attr.ngModel, startingTag(this.$$element));
        }
    },
    $render: noop,
    $isEmpty: function (value) {
        return isUndefined(value) || value === '' || value === null || value !== value;
    },
    $$updateEmptyClasses: function (value) {
        if (this.$isEmpty(value)) {
            this.$$animate.removeClass(this.$$element, NOT_EMPTY_CLASS);
            this.$$animate.addClass(this.$$element, EMPTY_CLASS);
        } else {
            this.$$animate.removeClass(this.$$element, EMPTY_CLASS);
            this.$$animate.addClass(this.$$element, NOT_EMPTY_CLASS);
        }
    },
    $setPristine: function () {
        this.$dirty = false;
        this.$pristine = true;
        this.$$animate.removeClass(this.$$element, DIRTY_CLASS);
        this.$$animate.addClass(this.$$element, PRISTINE_CLASS);
    },
    $setDirty: function () {
        this.$dirty = true;
        this.$pristine = false;
        this.$$animate.removeClass(this.$$element, PRISTINE_CLASS);
        this.$$animate.addClass(this.$$element, DIRTY_CLASS);
        this.$$parentForm.$setDirty();
    },
    $setUntouched: function () {
        this.$touched = false;
        this.$untouched = true;
        this.$$animate.setClass(this.$$element, UNTOUCHED_CLASS, TOUCHED_CLASS);
    },
    $setTouched: function () {
        this.$touched = true;
        this.$untouched = false;
        this.$$animate.setClass(this.$$element, TOUCHED_CLASS, UNTOUCHED_CLASS);
    },
    $rollbackViewValue: function () {
        this.$$timeout.cancel(this.$$pendingDebounce);
        this.$viewValue = this.$$lastCommittedViewValue;
        this.$render();
    },
    $validate: function () {
        if (isNumberNaN(this.$modelValue)) {
            return;
        }
        var viewValue = this.$$lastCommittedViewValue;
        var modelValue = this.$$rawModelValue;
        var prevValid = this.$valid;
        var prevModelValue = this.$modelValue;
        var allowInvalid = this.$options.getOption('allowInvalid');
        var that = this;
        this.$$runValidators(modelValue, viewValue, function (allValid) {
            if (!allowInvalid && prevValid !== allValid) {
                that.$modelValue = allValid ? modelValue : undefined;
                if (that.$modelValue !== prevModelValue) {
                    that.$$writeModelToScope();
                }
            }
        });
    },
    $$runValidators: function (modelValue, viewValue, doneCallback) {
        this.$$currentValidationRunId++;
        var localValidationRunId = this.$$currentValidationRunId;
        var that = this;
        if (!processParseErrors()) {
            validationDone(false);
            return;
        }
        if (!processSyncValidators()) {
            validationDone(false);
            return;
        }
        processAsyncValidators();
        function processParseErrors() {
            var errorKey = that.$$parserName || 'parse';
            if (isUndefined(that.$$parserValid)) {
                setValidity(errorKey, null);
            } else {
                if (!that.$$parserValid) {
                    forEach(that.$validators, function (v, name) {
                        setValidity(name, null);
                    });
                    forEach(that.$asyncValidators, function (v, name) {
                        setValidity(name, null);
                    });
                }
                setValidity(errorKey, that.$$parserValid);
                return that.$$parserValid;
            }
            return true;
        }
        function processSyncValidators() {
            var syncValidatorsValid = true;
            forEach(that.$validators, function (validator, name) {
                var result = Boolean(validator(modelValue, viewValue));
                syncValidatorsValid = syncValidatorsValid && result;
                setValidity(name, result);
            });
            if (!syncValidatorsValid) {
                forEach(that.$asyncValidators, function (v, name) {
                    setValidity(name, null);
                });
                return false;
            }
            return true;
        }
        function processAsyncValidators() {
            var validatorPromises = [];
            var allValid = true;
            forEach(that.$asyncValidators, function (validator, name) {
                var promise = validator(modelValue, viewValue);
                if (!isPromiseLike(promise)) {
                    throw ngModelMinErr('nopromise', 'Expected asynchronous validator to return a promise but got \'{0}\' instead.', promise);
                }
                setValidity(name, undefined);
                validatorPromises.push(promise.then(function () {
                    setValidity(name, true);
                }, function () {
                    allValid = false;
                    setValidity(name, false);
                }));
            });
            if (!validatorPromises.length) {
                validationDone(true);
            } else {
                that.$$q.all(validatorPromises).then(function () {
                    validationDone(allValid);
                }, noop);
            }
        }
        function setValidity(name, isValid) {
            if (localValidationRunId === that.$$currentValidationRunId) {
                that.$setValidity(name, isValid);
            }
        }
        function validationDone(allValid) {
            if (localValidationRunId === that.$$currentValidationRunId) {
                doneCallback(allValid);
            }
        }
    },
    $commitViewValue: function () {
        var viewValue = this.$viewValue;
        this.$$timeout.cancel(this.$$pendingDebounce);
        if (this.$$lastCommittedViewValue === viewValue && (viewValue !== '' || !this.$$hasNativeValidators)) {
            return;
        }
        this.$$updateEmptyClasses(viewValue);
        this.$$lastCommittedViewValue = viewValue;
        if (this.$pristine) {
            this.$setDirty();
        }
        this.$$parseAndValidate();
    },
    $$parseAndValidate: function () {
        var viewValue = this.$$lastCommittedViewValue;
        var modelValue = viewValue;
        var that = this;
        this.$$parserValid = isUndefined(modelValue) ? undefined : true;
        if (this.$$parserValid) {
            for (var i = 0; i < this.$parsers.length; i++) {
                modelValue = this.$parsers[i](modelValue);
                if (isUndefined(modelValue)) {
                    this.$$parserValid = false;
                    break;
                }
            }
        }
        if (isNumberNaN(this.$modelValue)) {
            this.$modelValue = this.$$ngModelGet(this.$$scope);
        }
        var prevModelValue = this.$modelValue;
        var allowInvalid = this.$options.getOption('allowInvalid');
        this.$$rawModelValue = modelValue;
        if (allowInvalid) {
            this.$modelValue = modelValue;
            writeToModelIfNeeded();
        }
        this.$$runValidators(modelValue, this.$$lastCommittedViewValue, function (allValid) {
            if (!allowInvalid) {
                that.$modelValue = allValid ? modelValue : undefined;
                writeToModelIfNeeded();
            }
        });
        function writeToModelIfNeeded() {
            if (that.$modelValue !== prevModelValue) {
                that.$$writeModelToScope();
            }
        }
    },
    $$writeModelToScope: function () {
        this.$$ngModelSet(this.$$scope, this.$modelValue);
        forEach(this.$viewChangeListeners, function (listener) {
            try {
                listener();
            } catch (e) {
                this.$$exceptionHandler(e);
            }
        }, this);
    },
    $setViewValue: function (value, trigger) {
        this.$viewValue = value;
        if (this.$options.getOption('updateOnDefault')) {
            this.$$debounceViewValueCommit(trigger);
        }
    },
    $$debounceViewValueCommit: function (trigger) {
        var debounceDelay = this.$options.getOption('debounce');
        if (isNumber(debounceDelay[trigger])) {
            debounceDelay = debounceDelay[trigger];
        } else if (isNumber(debounceDelay['default'])) {
            debounceDelay = debounceDelay['default'];
        }
        this.$$timeout.cancel(this.$$pendingDebounce);
        var that = this;
        if (debounceDelay > 0) {
            this.$$pendingDebounce = this.$$timeout(function () {
                that.$commitViewValue();
            }, debounceDelay);
        } else if (this.$$scope.$root.$$phase) {
            this.$commitViewValue();
        } else {
            this.$$scope.$apply(function () {
                that.$commitViewValue();
            });
        }
    },
    $overrideModelOptions: function (options) {
        this.$options = this.$options.createChild(options);
    }
};
addSetValidityMethod({
    clazz: NgModelController,
    set: function (object, property) {
        object[property] = true;
    },
    unset: function (object, property) {
        delete object[property];
    }
});
ngModelDirective = [
    '$rootScope',
    function ($rootScope) {
        return {
            restrict: 'A',
            require: [
                'ngModel',
                '^?form',
                '^?ngModelOptions'
            ],
            controller: NgModelController,
            priority: 1,
            compile: function ngModelCompile(element) {
                element.addClass(PRISTINE_CLASS).addClass(UNTOUCHED_CLASS).addClass(VALID_CLASS);
                return {
                    pre: function ngModelPreLink(scope, element, attr, ctrls) {
                        var modelCtrl = ctrls[0], formCtrl = ctrls[1] || modelCtrl.$$parentForm, optionsCtrl = ctrls[2];
                        if (optionsCtrl) {
                            modelCtrl.$options = optionsCtrl.$options;
                        }
                        modelCtrl.$$initGetterSetters();
                        formCtrl.$addControl(modelCtrl);
                        attr.$observe('name', function (newValue) {
                            if (modelCtrl.$name !== newValue) {
                                modelCtrl.$$parentForm.$$renameControl(modelCtrl, newValue);
                            }
                        });
                        scope.$on('$destroy', function () {
                            modelCtrl.$$parentForm.$removeControl(modelCtrl);
                        });
                    },
                    post: function ngModelPostLink(scope, element, attr, ctrls) {
                        var modelCtrl = ctrls[0];
                        if (modelCtrl.$options.getOption('updateOn')) {
                            element.on(modelCtrl.$options.getOption('updateOn'), function (ev) {
                                modelCtrl.$$debounceViewValueCommit(ev && ev.type);
                            });
                        }
                        function setTouched() {
                            modelCtrl.$setTouched();
                        }
                        element.on('blur', function () {
                            if (modelCtrl.$touched)
                                return;
                            if ($rootScope.$$phase) {
                                scope.$evalAsync(setTouched);
                            } else {
                                scope.$apply(setTouched);
                            }
                        });
                    }
                };
            }
        };
    }
];
DEFAULT_REGEXP = /(\s+|^)default(\s+|$)/;
ModelOptions.prototype = {
    getOption: function (name) {
        return this.$$options[name];
    },
    createChild: function (options) {
        var inheritAll = false;
        options = extend({}, options);
        forEach(options, function (option, key) {
            if (option === '$inherit') {
                if (key === '*') {
                    inheritAll = true;
                } else {
                    options[key] = this.$$options[key];
                    if (key === 'updateOn') {
                        options.updateOnDefault = this.$$options.updateOnDefault;
                    }
                }
            } else {
                if (key === 'updateOn') {
                    options.updateOnDefault = false;
                    options[key] = trim(option.replace(DEFAULT_REGEXP, function () {
                        options.updateOnDefault = true;
                        return ' ';
                    }));
                }
            }
        }, this);
        if (inheritAll) {
            delete options['*'];
            defaults(options, this.$$options);
        }
        defaults(options, defaultModelOptions.$$options);
        return new ModelOptions(options);
    }
};
defaultModelOptions = new ModelOptions({
    updateOn: '',
    updateOnDefault: true,
    debounce: 0,
    getterSetter: false,
    allowInvalid: false,
    timezone: null
});
ngModelOptionsDirective = function () {
    NgModelOptionsController.$inject = [
        '$attrs',
        '$scope'
    ];
    function NgModelOptionsController($attrs, $scope) {
        this.$$attrs = $attrs;
        this.$$scope = $scope;
    }
    NgModelOptionsController.prototype = {
        $onInit: function () {
            var parentOptions = this.parentCtrl ? this.parentCtrl.$options : defaultModelOptions;
            var modelOptionsDefinition = this.$$scope.$eval(this.$$attrs.ngModelOptions);
            this.$options = parentOptions.createChild(modelOptionsDefinition);
        }
    };
    return {
        restrict: 'A',
        priority: 10,
        require: {
            parentCtrl: '?^^ngModelOptions'
        },
        bindToController: true,
        controller: NgModelOptionsController
    };
};
ngNonBindableDirective = ngDirective({
    terminal: true,
    priority: 1000
});
ngOptionsMinErr = minErr('ngOptions');
NG_OPTIONS_REGEXP = /^\s*([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+group\s+by\s+([\s\S]+?))?(?:\s+disable\s+when\s+([\s\S]+?))?\s+for\s+(?:([$\w][$\w]*)|(?:\(\s*([$\w][$\w]*)\s*,\s*([$\w][$\w]*)\s*\)))\s+in\s+([\s\S]+?)(?:\s+track\s+by\s+([\s\S]+?))?$/;
ngOptionsDirective = [
    '$compile',
    '$document',
    '$parse',
    function ($compile, $document, $parse) {
        function parseOptionsExpression(optionsExp, selectElement, scope) {
            var match = optionsExp.match(NG_OPTIONS_REGEXP);
            if (!match) {
                throw ngOptionsMinErr('iexp', 'Expected expression in form of ' + '\'_select_ (as _label_)? for (_key_,)?_value_ in _collection_\'' + ' but got \'{0}\'. Element: {1}', optionsExp, startingTag(selectElement));
            }
            var valueName = match[5] || match[7];
            var keyName = match[6];
            var selectAs = / as /.test(match[0]) && match[1];
            var trackBy = match[9];
            var valueFn = $parse(match[2] ? match[1] : valueName);
            var selectAsFn = selectAs && $parse(selectAs);
            var viewValueFn = selectAsFn || valueFn;
            var trackByFn = trackBy && $parse(trackBy);
            var getTrackByValueFn = trackBy ? function (value, locals) {
                return trackByFn(scope, locals);
            } : function getHashOfValue(value) {
                return hashKey(value);
            };
            var getTrackByValue = function (value, key) {
                return getTrackByValueFn(value, getLocals(value, key));
            };
            var displayFn = $parse(match[2] || match[1]);
            var groupByFn = $parse(match[3] || '');
            var disableWhenFn = $parse(match[4] || '');
            var valuesFn = $parse(match[8]);
            var locals = {};
            var getLocals = keyName ? function (value, key) {
                locals[keyName] = key;
                locals[valueName] = value;
                return locals;
            } : function (value) {
                locals[valueName] = value;
                return locals;
            };
            function Option(selectValue, viewValue, label, group, disabled) {
                this.selectValue = selectValue;
                this.viewValue = viewValue;
                this.label = label;
                this.group = group;
                this.disabled = disabled;
            }
            function getOptionValuesKeys(optionValues) {
                var optionValuesKeys;
                if (!keyName && isArrayLike(optionValues)) {
                    optionValuesKeys = optionValues;
                } else {
                    optionValuesKeys = [];
                    for (var itemKey in optionValues) {
                        if (optionValues.hasOwnProperty(itemKey) && itemKey.charAt(0) !== '$') {
                            optionValuesKeys.push(itemKey);
                        }
                    }
                }
                return optionValuesKeys;
            }
            return {
                trackBy: trackBy,
                getTrackByValue: getTrackByValue,
                getWatchables: $parse(valuesFn, function (optionValues) {
                    var watchedArray = [];
                    optionValues = optionValues || [];
                    var optionValuesKeys = getOptionValuesKeys(optionValues);
                    var optionValuesLength = optionValuesKeys.length;
                    for (var index = 0; index < optionValuesLength; index++) {
                        var key = optionValues === optionValuesKeys ? index : optionValuesKeys[index];
                        var value = optionValues[key];
                        var locals = getLocals(value, key);
                        var selectValue = getTrackByValueFn(value, locals);
                        watchedArray.push(selectValue);
                        if (match[2] || match[1]) {
                            var label = displayFn(scope, locals);
                            watchedArray.push(label);
                        }
                        if (match[4]) {
                            var disableWhen = disableWhenFn(scope, locals);
                            watchedArray.push(disableWhen);
                        }
                    }
                    return watchedArray;
                }),
                getOptions: function () {
                    var optionItems = [];
                    var selectValueMap = {};
                    var optionValues = valuesFn(scope) || [];
                    var optionValuesKeys = getOptionValuesKeys(optionValues);
                    var optionValuesLength = optionValuesKeys.length;
                    for (var index = 0; index < optionValuesLength; index++) {
                        var key = optionValues === optionValuesKeys ? index : optionValuesKeys[index];
                        var value = optionValues[key];
                        var locals = getLocals(value, key);
                        var viewValue = viewValueFn(scope, locals);
                        var selectValue = getTrackByValueFn(viewValue, locals);
                        var label = displayFn(scope, locals);
                        var group = groupByFn(scope, locals);
                        var disabled = disableWhenFn(scope, locals);
                        var optionItem = new Option(selectValue, viewValue, label, group, disabled);
                        optionItems.push(optionItem);
                        selectValueMap[selectValue] = optionItem;
                    }
                    return {
                        items: optionItems,
                        selectValueMap: selectValueMap,
                        getOptionFromViewValue: function (value) {
                            return selectValueMap[getTrackByValue(value)];
                        },
                        getViewValueFromOption: function (option) {
                            return trackBy ? copy(option.viewValue) : option.viewValue;
                        }
                    };
                }
            };
        }
        var optionTemplate = window.document.createElement('option'), optGroupTemplate = window.document.createElement('optgroup');
        function ngOptionsPostLink(scope, selectElement, attr, ctrls) {
            var selectCtrl = ctrls[0];
            var ngModelCtrl = ctrls[1];
            var multiple = attr.multiple;
            for (var i = 0, children = selectElement.children(), ii = children.length; i < ii; i++) {
                if (children[i].value === '') {
                    selectCtrl.hasEmptyOption = true;
                    selectCtrl.emptyOption = children.eq(i);
                    break;
                }
            }
            var providedEmptyOption = !!selectCtrl.emptyOption;
            var unknownOption = jqLite(optionTemplate.cloneNode(false));
            unknownOption.val('?');
            var options;
            var ngOptions = parseOptionsExpression(attr.ngOptions, selectElement, scope);
            var listFragment = $document[0].createDocumentFragment();
            selectCtrl.generateUnknownOptionValue = function (val) {
                return '?';
            };
            if (!multiple) {
                selectCtrl.writeValue = function writeNgOptionsValue(value) {
                    var selectedOption = options.selectValueMap[selectElement.val()];
                    var option = options.getOptionFromViewValue(value);
                    if (selectedOption)
                        selectedOption.element.removeAttribute('selected');
                    if (option) {
                        if (selectElement[0].value !== option.selectValue) {
                            selectCtrl.removeUnknownOption();
                            selectCtrl.unselectEmptyOption();
                            selectElement[0].value = option.selectValue;
                            option.element.selected = true;
                        }
                        option.element.setAttribute('selected', 'selected');
                    } else {
                        if (providedEmptyOption) {
                            selectCtrl.selectEmptyOption();
                        } else if (selectCtrl.unknownOption.parent().length) {
                            selectCtrl.updateUnknownOption(value);
                        } else {
                            selectCtrl.renderUnknownOption(value);
                        }
                    }
                };
                selectCtrl.readValue = function readNgOptionsValue() {
                    var selectedOption = options.selectValueMap[selectElement.val()];
                    if (selectedOption && !selectedOption.disabled) {
                        selectCtrl.unselectEmptyOption();
                        selectCtrl.removeUnknownOption();
                        return options.getViewValueFromOption(selectedOption);
                    }
                    return null;
                };
                if (ngOptions.trackBy) {
                    scope.$watch(function () {
                        return ngOptions.getTrackByValue(ngModelCtrl.$viewValue);
                    }, function () {
                        ngModelCtrl.$render();
                    });
                }
            } else {
                selectCtrl.writeValue = function writeNgOptionsMultiple(values) {
                    var selectedOptions = values && values.map(getAndUpdateSelectedOption) || [];
                    options.items.forEach(function (option) {
                        if (option.element.selected && !includes(selectedOptions, option)) {
                            option.element.selected = false;
                        }
                    });
                };
                selectCtrl.readValue = function readNgOptionsMultiple() {
                    var selectedValues = selectElement.val() || [], selections = [];
                    forEach(selectedValues, function (value) {
                        var option = options.selectValueMap[value];
                        if (option && !option.disabled)
                            selections.push(options.getViewValueFromOption(option));
                    });
                    return selections;
                };
                if (ngOptions.trackBy) {
                    scope.$watchCollection(function () {
                        if (isArray(ngModelCtrl.$viewValue)) {
                            return ngModelCtrl.$viewValue.map(function (value) {
                                return ngOptions.getTrackByValue(value);
                            });
                        }
                    }, function () {
                        ngModelCtrl.$render();
                    });
                }
            }
            if (providedEmptyOption) {
                selectCtrl.emptyOption.remove();
                $compile(selectCtrl.emptyOption)(scope);
                if (selectCtrl.emptyOption[0].nodeType === NODE_TYPE_COMMENT) {
                    selectCtrl.hasEmptyOption = false;
                    selectCtrl.registerOption = function (optionScope, optionEl) {
                        if (optionEl.val() === '') {
                            selectCtrl.hasEmptyOption = true;
                            selectCtrl.emptyOption = optionEl;
                            selectCtrl.emptyOption.removeClass('ng-scope');
                            ngModelCtrl.$render();
                            optionEl.on('$destroy', function () {
                                selectCtrl.hasEmptyOption = false;
                                selectCtrl.emptyOption = undefined;
                            });
                        }
                    };
                } else {
                    selectCtrl.emptyOption.removeClass('ng-scope');
                }
            }
            selectElement.empty();
            updateOptions();
            scope.$watchCollection(ngOptions.getWatchables, updateOptions);
            function addOptionElement(option, parent) {
                var optionElement = optionTemplate.cloneNode(false);
                parent.appendChild(optionElement);
                updateOptionElement(option, optionElement);
            }
            function getAndUpdateSelectedOption(viewValue) {
                var option = options.getOptionFromViewValue(viewValue);
                var element = option && option.element;
                if (element && !element.selected)
                    element.selected = true;
                return option;
            }
            function updateOptionElement(option, element) {
                option.element = element;
                element.disabled = option.disabled;
                if (option.label !== element.label) {
                    element.label = option.label;
                    element.textContent = option.label;
                }
                element.value = option.selectValue;
            }
            function updateOptions() {
                var previousValue = options && selectCtrl.readValue();
                if (options) {
                    for (var i = options.items.length - 1; i >= 0; i--) {
                        var option = options.items[i];
                        if (isDefined(option.group)) {
                            jqLiteRemove(option.element.parentNode);
                        } else {
                            jqLiteRemove(option.element);
                        }
                    }
                }
                options = ngOptions.getOptions();
                var groupElementMap = {};
                if (providedEmptyOption) {
                    selectElement.prepend(selectCtrl.emptyOption);
                }
                options.items.forEach(function addOption(option) {
                    var groupElement;
                    if (isDefined(option.group)) {
                        groupElement = groupElementMap[option.group];
                        if (!groupElement) {
                            groupElement = optGroupTemplate.cloneNode(false);
                            listFragment.appendChild(groupElement);
                            groupElement.label = option.group === null ? 'null' : option.group;
                            groupElementMap[option.group] = groupElement;
                        }
                        addOptionElement(option, groupElement);
                    } else {
                        addOptionElement(option, listFragment);
                    }
                });
                selectElement[0].appendChild(listFragment);
                ngModelCtrl.$render();
                if (!ngModelCtrl.$isEmpty(previousValue)) {
                    var nextValue = selectCtrl.readValue();
                    var isNotPrimitive = ngOptions.trackBy || multiple;
                    if (isNotPrimitive ? !equals(previousValue, nextValue) : previousValue !== nextValue) {
                        ngModelCtrl.$setViewValue(nextValue);
                        ngModelCtrl.$render();
                    }
                }
            }
        }
        return {
            restrict: 'A',
            terminal: true,
            require: [
                'select',
                'ngModel'
            ],
            link: {
                pre: function ngOptionsPreLink(scope, selectElement, attr, ctrls) {
                    ctrls[0].registerOption = noop;
                },
                post: ngOptionsPostLink
            }
        };
    }
];
ngPluralizeDirective = [
    '$locale',
    '$interpolate',
    '$log',
    function ($locale, $interpolate, $log) {
        var BRACE = /{}/g, IS_WHEN = /^when(Minus)?(.+)$/;
        return {
            link: function (scope, element, attr) {
                var numberExp = attr.count, whenExp = attr.$attr.when && element.attr(attr.$attr.when), offset = attr.offset || 0, whens = scope.$eval(whenExp) || {}, whensExpFns = {}, startSymbol = $interpolate.startSymbol(), endSymbol = $interpolate.endSymbol(), braceReplacement = startSymbol + numberExp + '-' + offset + endSymbol, watchRemover = angular.noop, lastCount;
                forEach(attr, function (expression, attributeName) {
                    var tmpMatch = IS_WHEN.exec(attributeName);
                    if (tmpMatch) {
                        var whenKey = (tmpMatch[1] ? '-' : '') + lowercase(tmpMatch[2]);
                        whens[whenKey] = element.attr(attr.$attr[attributeName]);
                    }
                });
                forEach(whens, function (expression, key) {
                    whensExpFns[key] = $interpolate(expression.replace(BRACE, braceReplacement));
                });
                scope.$watch(numberExp, function ngPluralizeWatchAction(newVal) {
                    var count = parseFloat(newVal);
                    var countIsNaN = isNumberNaN(count);
                    if (!countIsNaN && !(count in whens)) {
                        count = $locale.pluralCat(count - offset);
                    }
                    if (count !== lastCount && !(countIsNaN && isNumberNaN(lastCount))) {
                        watchRemover();
                        var whenExpFn = whensExpFns[count];
                        if (isUndefined(whenExpFn)) {
                            if (newVal != null) {
                                $log.debug('ngPluralize: no rule defined for \'' + count + '\' in ' + whenExp);
                            }
                            watchRemover = noop;
                            updateElementText();
                        } else {
                            watchRemover = scope.$watch(whenExpFn, updateElementText);
                        }
                        lastCount = count;
                    }
                });
                function updateElementText(newText) {
                    element.text(newText || '');
                }
            }
        };
    }
];
ngRepeatDirective = [
    '$parse',
    '$animate',
    '$compile',
    function ($parse, $animate, $compile) {
        var NG_REMOVED = '$$NG_REMOVED';
        var ngRepeatMinErr = minErr('ngRepeat');
        var updateScope = function (scope, index, valueIdentifier, value, keyIdentifier, key, arrayLength) {
            scope[valueIdentifier] = value;
            if (keyIdentifier)
                scope[keyIdentifier] = key;
            scope.$index = index;
            scope.$first = index === 0;
            scope.$last = index === arrayLength - 1;
            scope.$middle = !(scope.$first || scope.$last);
            scope.$odd = !(scope.$even = (index & 1) === 0);
        };
        var getBlockStart = function (block) {
            return block.clone[0];
        };
        var getBlockEnd = function (block) {
            return block.clone[block.clone.length - 1];
        };
        return {
            restrict: 'A',
            multiElement: true,
            transclude: 'element',
            priority: 1000,
            terminal: true,
            $$tlb: true,
            compile: function ngRepeatCompile($element, $attr) {
                var expression = $attr.ngRepeat;
                var ngRepeatEndComment = $compile.$$createComment('end ngRepeat', expression);
                var match = expression.match(/^\s*([\s\S]+?)\s+in\s+([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+track\s+by\s+([\s\S]+?))?\s*$/);
                if (!match) {
                    throw ngRepeatMinErr('iexp', 'Expected expression in form of \'_item_ in _collection_[ track by _id_]\' but got \'{0}\'.', expression);
                }
                var lhs = match[1];
                var rhs = match[2];
                var aliasAs = match[3];
                var trackByExp = match[4];
                match = lhs.match(/^(?:(\s*[$\w]+)|\(\s*([$\w]+)\s*,\s*([$\w]+)\s*\))$/);
                if (!match) {
                    throw ngRepeatMinErr('iidexp', '\'_item_\' in \'_item_ in _collection_\' should be an identifier or \'(_key_, _value_)\' expression, but got \'{0}\'.', lhs);
                }
                var valueIdentifier = match[3] || match[1];
                var keyIdentifier = match[2];
                if (aliasAs && (!/^[$a-zA-Z_][$a-zA-Z0-9_]*$/.test(aliasAs) || /^(null|undefined|this|\$index|\$first|\$middle|\$last|\$even|\$odd|\$parent|\$root|\$id)$/.test(aliasAs))) {
                    throw ngRepeatMinErr('badident', 'alias \'{0}\' is invalid --- must be a valid JS identifier which is not a reserved name.', aliasAs);
                }
                var trackByExpGetter, trackByIdExpFn, trackByIdArrayFn, trackByIdObjFn;
                var hashFnLocals = {
                    $id: hashKey
                };
                if (trackByExp) {
                    trackByExpGetter = $parse(trackByExp);
                } else {
                    trackByIdArrayFn = function (key, value) {
                        return hashKey(value);
                    };
                    trackByIdObjFn = function (key) {
                        return key;
                    };
                }
                return function ngRepeatLink($scope, $element, $attr, ctrl, $transclude) {
                    if (trackByExpGetter) {
                        trackByIdExpFn = function (key, value, index) {
                            if (keyIdentifier)
                                hashFnLocals[keyIdentifier] = key;
                            hashFnLocals[valueIdentifier] = value;
                            hashFnLocals.$index = index;
                            return trackByExpGetter($scope, hashFnLocals);
                        };
                    }
                    var lastBlockMap = createMap();
                    $scope.$watchCollection(rhs, function ngRepeatAction(collection) {
                        var index, length, previousNode = $element[0], nextNode, nextBlockMap = createMap(), collectionLength, key, value, trackById, trackByIdFn, collectionKeys, block, nextBlockOrder, elementsToRemove;
                        if (aliasAs) {
                            $scope[aliasAs] = collection;
                        }
                        if (isArrayLike(collection)) {
                            collectionKeys = collection;
                            trackByIdFn = trackByIdExpFn || trackByIdArrayFn;
                        } else {
                            trackByIdFn = trackByIdExpFn || trackByIdObjFn;
                            collectionKeys = [];
                            for (var itemKey in collection) {
                                if (hasOwnProperty.call(collection, itemKey) && itemKey.charAt(0) !== '$') {
                                    collectionKeys.push(itemKey);
                                }
                            }
                        }
                        collectionLength = collectionKeys.length;
                        nextBlockOrder = new Array(collectionLength);
                        for (index = 0; index < collectionLength; index++) {
                            key = collection === collectionKeys ? index : collectionKeys[index];
                            value = collection[key];
                            trackById = trackByIdFn(key, value, index);
                            if (lastBlockMap[trackById]) {
                                block = lastBlockMap[trackById];
                                delete lastBlockMap[trackById];
                                nextBlockMap[trackById] = block;
                                nextBlockOrder[index] = block;
                            } else if (nextBlockMap[trackById]) {
                                forEach(nextBlockOrder, function (block) {
                                    if (block && block.scope)
                                        lastBlockMap[block.id] = block;
                                });
                                throw ngRepeatMinErr('dupes', 'Duplicates in a repeater are not allowed. Use \'track by\' expression to specify unique keys. Repeater: {0}, Duplicate key: {1}, Duplicate value: {2}', expression, trackById, value);
                            } else {
                                nextBlockOrder[index] = {
                                    id: trackById,
                                    scope: undefined,
                                    clone: undefined
                                };
                                nextBlockMap[trackById] = true;
                            }
                        }
                        for (var blockKey in lastBlockMap) {
                            block = lastBlockMap[blockKey];
                            elementsToRemove = getBlockNodes(block.clone);
                            $animate.leave(elementsToRemove);
                            if (elementsToRemove[0].parentNode) {
                                for (index = 0, length = elementsToRemove.length; index < length; index++) {
                                    elementsToRemove[index][NG_REMOVED] = true;
                                }
                            }
                            block.scope.$destroy();
                        }
                        for (index = 0; index < collectionLength; index++) {
                            key = collection === collectionKeys ? index : collectionKeys[index];
                            value = collection[key];
                            block = nextBlockOrder[index];
                            if (block.scope) {
                                nextNode = previousNode;
                                do {
                                    nextNode = nextNode.nextSibling;
                                } while (nextNode && nextNode[NG_REMOVED]);
                                if (getBlockStart(block) !== nextNode) {
                                    $animate.move(getBlockNodes(block.clone), null, previousNode);
                                }
                                previousNode = getBlockEnd(block);
                                updateScope(block.scope, index, valueIdentifier, value, keyIdentifier, key, collectionLength);
                            } else {
                                $transclude(function ngRepeatTransclude(clone, scope) {
                                    block.scope = scope;
                                    var endNode = ngRepeatEndComment.cloneNode(false);
                                    clone[clone.length++] = endNode;
                                    $animate.enter(clone, null, previousNode);
                                    previousNode = endNode;
                                    block.clone = clone;
                                    nextBlockMap[block.id] = block;
                                    updateScope(block.scope, index, valueIdentifier, value, keyIdentifier, key, collectionLength);
                                });
                            }
                        }
                        lastBlockMap = nextBlockMap;
                    });
                };
            }
        };
    }
];
NG_HIDE_CLASS = 'ng-hide';
NG_HIDE_IN_PROGRESS_CLASS = 'ng-hide-animate';
ngShowDirective = [
    '$animate',
    function ($animate) {
        return {
            restrict: 'A',
            multiElement: true,
            link: function (scope, element, attr) {
                scope.$watch(attr.ngShow, function ngShowWatchAction(value) {
                    $animate[value ? 'removeClass' : 'addClass'](element, NG_HIDE_CLASS, {
                        tempClasses: NG_HIDE_IN_PROGRESS_CLASS
                    });
                });
            }
        };
    }
];
ngHideDirective = [
    '$animate',
    function ($animate) {
        return {
            restrict: 'A',
            multiElement: true,
            link: function (scope, element, attr) {
                scope.$watch(attr.ngHide, function ngHideWatchAction(value) {
                    $animate[value ? 'addClass' : 'removeClass'](element, NG_HIDE_CLASS, {
                        tempClasses: NG_HIDE_IN_PROGRESS_CLASS
                    });
                });
            }
        };
    }
];
ngStyleDirective = ngDirective(function (scope, element, attr) {
    scope.$watch(attr.ngStyle, function ngStyleWatchAction(newStyles, oldStyles) {
        if (oldStyles && newStyles !== oldStyles) {
            forEach(oldStyles, function (val, style) {
                element.css(style, '');
            });
        }
        if (newStyles)
            element.css(newStyles);
    }, true);
});
ngSwitchDirective = [
    '$animate',
    '$compile',
    function ($animate, $compile) {
        return {
            require: 'ngSwitch',
            controller: [
                '$scope',
                function NgSwitchController() {
                    this.cases = {};
                }
            ],
            link: function (scope, element, attr, ngSwitchController) {
                var watchExpr = attr.ngSwitch || attr.on, selectedTranscludes = [], selectedElements = [], previousLeaveAnimations = [], selectedScopes = [];
                var spliceFactory = function (array, index) {
                    return function (response) {
                        if (response !== false)
                            array.splice(index, 1);
                    };
                };
                scope.$watch(watchExpr, function ngSwitchWatchAction(value) {
                    var i, ii;
                    while (previousLeaveAnimations.length) {
                        $animate.cancel(previousLeaveAnimations.pop());
                    }
                    for (i = 0, ii = selectedScopes.length; i < ii; ++i) {
                        var selected = getBlockNodes(selectedElements[i].clone);
                        selectedScopes[i].$destroy();
                        var runner = previousLeaveAnimations[i] = $animate.leave(selected);
                        runner.done(spliceFactory(previousLeaveAnimations, i));
                    }
                    selectedElements.length = 0;
                    selectedScopes.length = 0;
                    if (selectedTranscludes = ngSwitchController.cases['!' + value] || ngSwitchController.cases['?']) {
                        forEach(selectedTranscludes, function (selectedTransclude) {
                            selectedTransclude.transclude(function (caseElement, selectedScope) {
                                selectedScopes.push(selectedScope);
                                var anchor = selectedTransclude.element;
                                caseElement[caseElement.length++] = $compile.$$createComment('end ngSwitchWhen');
                                var block = {
                                    clone: caseElement
                                };
                                selectedElements.push(block);
                                $animate.enter(caseElement, anchor.parent(), anchor);
                            });
                        });
                    }
                });
            }
        };
    }
];
ngSwitchWhenDirective = ngDirective({
    transclude: 'element',
    priority: 1200,
    require: '^ngSwitch',
    multiElement: true,
    link: function (scope, element, attrs, ctrl, $transclude) {
        var cases = attrs.ngSwitchWhen.split(attrs.ngSwitchWhenSeparator).sort().filter(function (element, index, array) {
            return array[index - 1] !== element;
        });
        forEach(cases, function (whenCase) {
            ctrl.cases['!' + whenCase] = ctrl.cases['!' + whenCase] || [];
            ctrl.cases['!' + whenCase].push({
                transclude: $transclude,
                element: element
            });
        });
    }
});
ngSwitchDefaultDirective = ngDirective({
    transclude: 'element',
    priority: 1200,
    require: '^ngSwitch',
    multiElement: true,
    link: function (scope, element, attr, ctrl, $transclude) {
        ctrl.cases['?'] = ctrl.cases['?'] || [];
        ctrl.cases['?'].push({
            transclude: $transclude,
            element: element
        });
    }
});
ngTranscludeMinErr = minErr('ngTransclude');
ngTranscludeDirective = [
    '$compile',
    function ($compile) {
        return {
            restrict: 'EAC',
            terminal: true,
            compile: function ngTranscludeCompile(tElement) {
                var fallbackLinkFn = $compile(tElement.contents());
                tElement.empty();
                return function ngTranscludePostLink($scope, $element, $attrs, controller, $transclude) {
                    if (!$transclude) {
                        throw ngTranscludeMinErr('orphan', 'Illegal use of ngTransclude directive in the template! ' + 'No parent directive that requires a transclusion found. ' + 'Element: {0}', startingTag($element));
                    }
                    if ($attrs.ngTransclude === $attrs.$attr.ngTransclude) {
                        $attrs.ngTransclude = '';
                    }
                    var slotName = $attrs.ngTransclude || $attrs.ngTranscludeSlot;
                    $transclude(ngTranscludeCloneAttachFn, null, slotName);
                    if (slotName && !$transclude.isSlotFilled(slotName)) {
                        useFallbackContent();
                    }
                    function ngTranscludeCloneAttachFn(clone, transcludedScope) {
                        if (clone.length && notWhitespace(clone)) {
                            $element.append(clone);
                        } else {
                            useFallbackContent();
                            transcludedScope.$destroy();
                        }
                    }
                    function useFallbackContent() {
                        fallbackLinkFn($scope, function (clone) {
                            $element.append(clone);
                        });
                    }
                    function notWhitespace(nodes) {
                        for (var i = 0, ii = nodes.length; i < ii; i++) {
                            var node = nodes[i];
                            if (node.nodeType !== NODE_TYPE_TEXT || node.nodeValue.trim()) {
                                return true;
                            }
                        }
                    }
                };
            }
        };
    }
];
scriptDirective = [
    '$templateCache',
    function ($templateCache) {
        return {
            restrict: 'E',
            terminal: true,
            compile: function (element, attr) {
                if (attr.type === 'text/ng-template') {
                    var templateUrl = attr.id, text = element[0].text;
                    $templateCache.put(templateUrl, text);
                }
            }
        };
    }
];
noopNgModelController = {
    $setViewValue: noop,
    $render: noop
};
SelectController = [
    '$element',
    '$scope',
    function ($element, $scope) {
        var self = this, optionsMap = new NgMap();
        self.selectValueMap = {};
        self.ngModelCtrl = noopNgModelController;
        self.multiple = false;
        self.unknownOption = jqLite(window.document.createElement('option'));
        self.hasEmptyOption = false;
        self.emptyOption = undefined;
        self.renderUnknownOption = function (val) {
            var unknownVal = self.generateUnknownOptionValue(val);
            self.unknownOption.val(unknownVal);
            $element.prepend(self.unknownOption);
            setOptionSelectedStatus(self.unknownOption, true);
            $element.val(unknownVal);
        };
        self.updateUnknownOption = function (val) {
            var unknownVal = self.generateUnknownOptionValue(val);
            self.unknownOption.val(unknownVal);
            setOptionSelectedStatus(self.unknownOption, true);
            $element.val(unknownVal);
        };
        self.generateUnknownOptionValue = function (val) {
            return '? ' + hashKey(val) + ' ?';
        };
        self.removeUnknownOption = function () {
            if (self.unknownOption.parent())
                self.unknownOption.remove();
        };
        self.selectEmptyOption = function () {
            if (self.emptyOption) {
                $element.val('');
                setOptionSelectedStatus(self.emptyOption, true);
            }
        };
        self.unselectEmptyOption = function () {
            if (self.hasEmptyOption) {
                self.emptyOption.removeAttr('selected');
            }
        };
        $scope.$on('$destroy', function () {
            self.renderUnknownOption = noop;
        });
        self.readValue = function readSingleValue() {
            var val = $element.val();
            var realVal = val in self.selectValueMap ? self.selectValueMap[val] : val;
            if (self.hasOption(realVal)) {
                return realVal;
            }
            return null;
        };
        self.writeValue = function writeSingleValue(value) {
            var currentlySelectedOption = $element[0].options[$element[0].selectedIndex];
            if (currentlySelectedOption)
                setOptionSelectedStatus(jqLite(currentlySelectedOption), false);
            if (self.hasOption(value)) {
                self.removeUnknownOption();
                var hashedVal = hashKey(value);
                $element.val(hashedVal in self.selectValueMap ? hashedVal : value);
                var selectedOption = $element[0].options[$element[0].selectedIndex];
                setOptionSelectedStatus(jqLite(selectedOption), true);
            } else {
                if (value == null && self.emptyOption) {
                    self.removeUnknownOption();
                    self.selectEmptyOption();
                } else if (self.unknownOption.parent().length) {
                    self.updateUnknownOption(value);
                } else {
                    self.renderUnknownOption(value);
                }
            }
        };
        self.addOption = function (value, element) {
            if (element[0].nodeType === NODE_TYPE_COMMENT)
                return;
            assertNotHasOwnProperty(value, '"option value"');
            if (value === '') {
                self.hasEmptyOption = true;
                self.emptyOption = element;
            }
            var count = optionsMap.get(value) || 0;
            optionsMap.set(value, count + 1);
            scheduleRender();
        };
        self.removeOption = function (value) {
            var count = optionsMap.get(value);
            if (count) {
                if (count === 1) {
                    optionsMap.delete(value);
                    if (value === '') {
                        self.hasEmptyOption = false;
                        self.emptyOption = undefined;
                    }
                } else {
                    optionsMap.set(value, count - 1);
                }
            }
        };
        self.hasOption = function (value) {
            return !!optionsMap.get(value);
        };
        var renderScheduled = false;
        function scheduleRender() {
            if (renderScheduled)
                return;
            renderScheduled = true;
            $scope.$$postDigest(function () {
                renderScheduled = false;
                self.ngModelCtrl.$render();
            });
        }
        var updateScheduled = false;
        function scheduleViewValueUpdate(renderAfter) {
            if (updateScheduled)
                return;
            updateScheduled = true;
            $scope.$$postDigest(function () {
                if ($scope.$$destroyed)
                    return;
                updateScheduled = false;
                self.ngModelCtrl.$setViewValue(self.readValue());
                if (renderAfter)
                    self.ngModelCtrl.$render();
            });
        }
        self.registerOption = function (optionScope, optionElement, optionAttrs, interpolateValueFn, interpolateTextFn) {
            if (optionAttrs.$attr.ngValue) {
                var oldVal, hashedVal = NaN;
                optionAttrs.$observe('value', function valueAttributeObserveAction(newVal) {
                    var removal;
                    var previouslySelected = optionElement.prop('selected');
                    if (isDefined(hashedVal)) {
                        self.removeOption(oldVal);
                        delete self.selectValueMap[hashedVal];
                        removal = true;
                    }
                    hashedVal = hashKey(newVal);
                    oldVal = newVal;
                    self.selectValueMap[hashedVal] = newVal;
                    self.addOption(newVal, optionElement);
                    optionElement.attr('value', hashedVal);
                    if (removal && previouslySelected) {
                        scheduleViewValueUpdate();
                    }
                });
            } else if (interpolateValueFn) {
                optionAttrs.$observe('value', function valueAttributeObserveAction(newVal) {
                    self.readValue();
                    var removal;
                    var previouslySelected = optionElement.prop('selected');
                    if (isDefined(oldVal)) {
                        self.removeOption(oldVal);
                        removal = true;
                    }
                    oldVal = newVal;
                    self.addOption(newVal, optionElement);
                    if (removal && previouslySelected) {
                        scheduleViewValueUpdate();
                    }
                });
            } else if (interpolateTextFn) {
                optionScope.$watch(interpolateTextFn, function interpolateWatchAction(newVal, oldVal) {
                    optionAttrs.$set('value', newVal);
                    var previouslySelected = optionElement.prop('selected');
                    if (oldVal !== newVal) {
                        self.removeOption(oldVal);
                    }
                    self.addOption(newVal, optionElement);
                    if (oldVal && previouslySelected) {
                        scheduleViewValueUpdate();
                    }
                });
            } else {
                self.addOption(optionAttrs.value, optionElement);
            }
            optionAttrs.$observe('disabled', function (newVal) {
                if (newVal === 'true' || newVal && optionElement.prop('selected')) {
                    if (self.multiple) {
                        scheduleViewValueUpdate(true);
                    } else {
                        self.ngModelCtrl.$setViewValue(null);
                        self.ngModelCtrl.$render();
                    }
                }
            });
            optionElement.on('$destroy', function () {
                var currentValue = self.readValue();
                var removeValue = optionAttrs.value;
                self.removeOption(removeValue);
                scheduleRender();
                if (self.multiple && currentValue && currentValue.indexOf(removeValue) !== -1 || currentValue === removeValue) {
                    scheduleViewValueUpdate(true);
                }
            });
        };
    }
];
selectDirective = function () {
    return {
        restrict: 'E',
        require: [
            'select',
            '?ngModel'
        ],
        controller: SelectController,
        priority: 1,
        link: {
            pre: selectPreLink,
            post: selectPostLink
        }
    };
    function selectPreLink(scope, element, attr, ctrls) {
        var selectCtrl = ctrls[0];
        var ngModelCtrl = ctrls[1];
        if (!ngModelCtrl) {
            selectCtrl.registerOption = noop;
            return;
        }
        selectCtrl.ngModelCtrl = ngModelCtrl;
        element.on('change', function () {
            selectCtrl.removeUnknownOption();
            scope.$apply(function () {
                ngModelCtrl.$setViewValue(selectCtrl.readValue());
            });
        });
        if (attr.multiple) {
            selectCtrl.multiple = true;
            selectCtrl.readValue = function readMultipleValue() {
                var array = [];
                forEach(element.find('option'), function (option) {
                    if (option.selected && !option.disabled) {
                        var val = option.value;
                        array.push(val in selectCtrl.selectValueMap ? selectCtrl.selectValueMap[val] : val);
                    }
                });
                return array;
            };
            selectCtrl.writeValue = function writeMultipleValue(value) {
                forEach(element.find('option'), function (option) {
                    var shouldBeSelected = !!value && (includes(value, option.value) || includes(value, selectCtrl.selectValueMap[option.value]));
                    var currentlySelected = option.selected;
                    if (shouldBeSelected !== currentlySelected) {
                        setOptionSelectedStatus(jqLite(option), shouldBeSelected);
                    }
                });
            };
            var lastView, lastViewRef = NaN;
            scope.$watch(function selectMultipleWatch() {
                if (lastViewRef === ngModelCtrl.$viewValue && !equals(lastView, ngModelCtrl.$viewValue)) {
                    lastView = shallowCopy(ngModelCtrl.$viewValue);
                    ngModelCtrl.$render();
                }
                lastViewRef = ngModelCtrl.$viewValue;
            });
            ngModelCtrl.$isEmpty = function (value) {
                return !value || value.length === 0;
            };
        }
    }
    function selectPostLink(scope, element, attrs, ctrls) {
        var ngModelCtrl = ctrls[1];
        if (!ngModelCtrl)
            return;
        var selectCtrl = ctrls[0];
        ngModelCtrl.$render = function () {
            selectCtrl.writeValue(ngModelCtrl.$viewValue);
        };
    }
};
optionDirective = [
    '$interpolate',
    function ($interpolate) {
        return {
            restrict: 'E',
            priority: 100,
            compile: function (element, attr) {
                var interpolateValueFn, interpolateTextFn;
                if (isDefined(attr.ngValue)) {
                } else if (isDefined(attr.value)) {
                    interpolateValueFn = $interpolate(attr.value, true);
                } else {
                    interpolateTextFn = $interpolate(element.text(), true);
                    if (!interpolateTextFn) {
                        attr.$set('value', element.text());
                    }
                }
                return function (scope, element, attr) {
                    var selectCtrlName = '$selectController', parent = element.parent(), selectCtrl = parent.data(selectCtrlName) || parent.parent().data(selectCtrlName);
                    if (selectCtrl) {
                        selectCtrl.registerOption(scope, element, attr, interpolateValueFn, interpolateTextFn);
                    }
                };
            }
        };
    }
];
requiredDirective = function () {
    return {
        restrict: 'A',
        require: '?ngModel',
        link: function (scope, elm, attr, ctrl) {
            if (!ctrl)
                return;
            attr.required = true;
            ctrl.$validators.required = function (modelValue, viewValue) {
                return !attr.required || !ctrl.$isEmpty(viewValue);
            };
            attr.$observe('required', function () {
                ctrl.$validate();
            });
        }
    };
};
patternDirective = function () {
    return {
        restrict: 'A',
        require: '?ngModel',
        link: function (scope, elm, attr, ctrl) {
            if (!ctrl)
                return;
            var regexp, patternExp = attr.ngPattern || attr.pattern;
            attr.$observe('pattern', function (regex) {
                if (isString(regex) && regex.length > 0) {
                    regex = new RegExp('^' + regex + '$');
                }
                if (regex && !regex.test) {
                    throw minErr('ngPattern')('noregexp', 'Expected {0} to be a RegExp but was {1}. Element: {2}', patternExp, regex, startingTag(elm));
                }
                regexp = regex || undefined;
                ctrl.$validate();
            });
            ctrl.$validators.pattern = function (modelValue, viewValue) {
                return ctrl.$isEmpty(viewValue) || isUndefined(regexp) || regexp.test(viewValue);
            };
        }
    };
};
maxlengthDirective = function () {
    return {
        restrict: 'A',
        require: '?ngModel',
        link: function (scope, elm, attr, ctrl) {
            if (!ctrl)
                return;
            var maxlength = -1;
            attr.$observe('maxlength', function (value) {
                var intVal = toInt(value);
                maxlength = isNumberNaN(intVal) ? -1 : intVal;
                ctrl.$validate();
            });
            ctrl.$validators.maxlength = function (modelValue, viewValue) {
                return maxlength < 0 || ctrl.$isEmpty(viewValue) || viewValue.length <= maxlength;
            };
        }
    };
};
minlengthDirective = function () {
    return {
        restrict: 'A',
        require: '?ngModel',
        link: function (scope, elm, attr, ctrl) {
            if (!ctrl)
                return;
            var minlength = 0;
            attr.$observe('minlength', function (value) {
                minlength = toInt(value) || 0;
                ctrl.$validate();
            });
            ctrl.$validators.minlength = function (modelValue, viewValue) {
                return ctrl.$isEmpty(viewValue) || viewValue.length >= minlength;
            };
        }
    };
};
if (window.angular.bootstrap) {
    if (window.console) {
        console.log('WARNING: Tried to load angular more than once.');
    }
    return;
}
bindJQuery();
publishExternalAPI(angular);
angular.module('ngLocale', [], [
    '$provide',
    function ($provide) {
        var PLURAL_CATEGORY = {
            ZERO: 'zero',
            ONE: 'one',
            TWO: 'two',
            FEW: 'few',
            MANY: 'many',
            OTHER: 'other'
        };
        function getDecimals(n) {
            n = n + '';
            var i = n.indexOf('.');
            return i == -1 ? 0 : n.length - i - 1;
        }
        function getVF(n, opt_precision) {
            var v = opt_precision;
            if (undefined === v) {
                v = Math.min(getDecimals(n), 3);
            }
            var base = Math.pow(10, v);
            var f = (n * base | 0) % base;
            return {
                v: v,
                f: f
            };
        }
        $provide.value('$locale', {
            'DATETIME_FORMATS': {
                'AMPMS': [
                    'AM',
                    'PM'
                ],
                'DAY': [
                    'Sunday',
                    'Monday',
                    'Tuesday',
                    'Wednesday',
                    'Thursday',
                    'Friday',
                    'Saturday'
                ],
                'ERANAMES': [
                    'Before Christ',
                    'Anno Domini'
                ],
                'ERAS': [
                    'BC',
                    'AD'
                ],
                'FIRSTDAYOFWEEK': 6,
                'MONTH': [
                    'January',
                    'February',
                    'March',
                    'April',
                    'May',
                    'June',
                    'July',
                    'August',
                    'September',
                    'October',
                    'November',
                    'December'
                ],
                'SHORTDAY': [
                    'Sun',
                    'Mon',
                    'Tue',
                    'Wed',
                    'Thu',
                    'Fri',
                    'Sat'
                ],
                'SHORTMONTH': [
                    'Jan',
                    'Feb',
                    'Mar',
                    'Apr',
                    'May',
                    'Jun',
                    'Jul',
                    'Aug',
                    'Sep',
                    'Oct',
                    'Nov',
                    'Dec'
                ],
                'STANDALONEMONTH': [
                    'January',
                    'February',
                    'March',
                    'April',
                    'May',
                    'June',
                    'July',
                    'August',
                    'September',
                    'October',
                    'November',
                    'December'
                ],
                'WEEKENDRANGE': [
                    5,
                    6
                ],
                'fullDate': 'EEEE, MMMM d, y',
                'longDate': 'MMMM d, y',
                'medium': 'MMM d, y h:mm:ss a',
                'mediumDate': 'MMM d, y',
                'mediumTime': 'h:mm:ss a',
                'short': 'M/d/yy h:mm a',
                'shortDate': 'M/d/yy',
                'shortTime': 'h:mm a'
            },
            'NUMBER_FORMATS': {
                'CURRENCY_SYM': '$',
                'DECIMAL_SEP': '.',
                'GROUP_SEP': ',',
                'PATTERNS': [
                    {
                        'gSize': 3,
                        'lgSize': 3,
                        'maxFrac': 3,
                        'minFrac': 0,
                        'minInt': 1,
                        'negPre': '-',
                        'negSuf': '',
                        'posPre': '',
                        'posSuf': ''
                    },
                    {
                        'gSize': 3,
                        'lgSize': 3,
                        'maxFrac': 2,
                        'minFrac': 2,
                        'minInt': 1,
                        'negPre': '-\xA4',
                        'negSuf': '',
                        'posPre': '\xA4',
                        'posSuf': ''
                    }
                ]
            },
            'id': 'en-us',
            'localeID': 'en_US',
            'pluralCat': function (n, opt_precision) {
                var i = n | 0;
                var vf = getVF(n, opt_precision);
                if (i == 1 && vf.v == 0) {
                    return PLURAL_CATEGORY.ONE;
                }
                return PLURAL_CATEGORY.OTHER;
            }
        });
    }
]);
jqLite(function () {
    angularInit(window.document, bootstrap);
});})), $__.fs.J$__v3645318688_2424_3))(window, 0, true, $__.uid);
((!(((vvv_tmp0 = ((window).angular, $__.os.oid1), "$$csp", $__.fs.J$__v3645318688_76_273.call(vvv_tmp0, 0, true, $__.uid)), $__.os.oid59).noInlineStyle, false)), (vvv_tmp2 = (vvv_tmp1 = ((window).angular, $__.os.oid1), "element", $__.fs.JQLite_93.call(vvv_tmp1, TAJS_restrictToType((document).head, "HTMLHeadElement"), 3, true, $__.uid)), "prepend", $__.fs.J$__v3645318688_316_334.call(vvv_tmp2, "<style type=\"text/css\">@charset \"UTF-8\";[ng\\:cloak],[ng-cloak],[data-ng-cloak],[x-ng-cloak],.ng-cloak,.x-ng-cloak,.ng-hide:not(.ng-hide-animate){display:none !important;}ng\\:form{display:block;}.ng-animate-shim{visibility:hidden;}.ng-anchor{position:absolute;}</style>", 0, true, $__.uid)));