Object.defineProperty(typeof window === 'undefined' ? global : window, '$__', { configurable: false, enumerable: false, value: {
    fs: {},
    os: {},
    functionRegExp: /^function .*\([\s\S]*\) {[\s\S]*\}$/g,
    refs: {
        pop: Array.prototype.pop,
        slice: Array.prototype.slice
    },
    uid: Symbol('bHvKvd19fGrk'),
    w: window
}});
(((($__.fs.J$__v494107025_14_3 = function J$__v494107025_14(global, factory) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
global = arguments[0], factory = arguments[1];
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    (typeof exports === 'object', typeof define === 'function'), (factory, $__.fs.J$__v494107025_3258_4)(global.THREE = (TAJS_restrictToType(global.THREE, 'undefined'), $__.os.oid0 = {}), 0, true, $__.uid);
    return;
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) : typeof define === 'function' && define.amd ? define(['exports'], factory) : factory(global.THREE = global.THREE || {});})), $__.fs.J$__v494107025_14_3))(this, (($__.fs.J$__v494107025_3258_4 = function J$__v494107025_3258(exports) {
'use strict';
var vvv_return, vvv_switch, vvv_tmp0, vvv_tmp1, vvv_tmp2, vvv_tmp3, vvv_tmp4, vvv_tmp5, vvv_tmp6, vvv_tmp7, vvv_tmp8, vvv_tmp9, vvv_tmp10, vvv_tmp11, vvv_tmp12, vvv_tmp13, vvv_tmp14, vvv_tmp15, vvv_tmp16, vvv_tmp17, vvv_tmp18, vvv_tmp19, vvv_tmp20, vvv_tmp21, EventDispatcher, REVISION, MOUSE, CullFaceNone, CullFaceBack, CullFaceFront, CullFaceFrontBack, FrontFaceDirectionCW, FrontFaceDirectionCCW, BasicShadowMap, PCFShadowMap, PCFSoftShadowMap, FrontSide, BackSide, DoubleSide, FlatShading, SmoothShading, NoColors, FaceColors, VertexColors, NoBlending, NormalBlending, AdditiveBlending, SubtractiveBlending, MultiplyBlending, CustomBlending, AddEquation, SubtractEquation, ReverseSubtractEquation, MinEquation, MaxEquation, ZeroFactor, OneFactor, SrcColorFactor, OneMinusSrcColorFactor, SrcAlphaFactor, OneMinusSrcAlphaFactor, DstAlphaFactor, OneMinusDstAlphaFactor, DstColorFactor, OneMinusDstColorFactor, SrcAlphaSaturateFactor, NeverDepth, AlwaysDepth, LessDepth, LessEqualDepth, EqualDepth, GreaterEqualDepth, GreaterDepth, NotEqualDepth, MultiplyOperation, MixOperation, AddOperation, NoToneMapping, LinearToneMapping, ReinhardToneMapping, Uncharted2ToneMapping, CineonToneMapping, UVMapping, CubeReflectionMapping, CubeRefractionMapping, EquirectangularReflectionMapping, EquirectangularRefractionMapping, SphericalReflectionMapping, CubeUVReflectionMapping, CubeUVRefractionMapping, RepeatWrapping, ClampToEdgeWrapping, MirroredRepeatWrapping, NearestFilter, NearestMipMapNearestFilter, NearestMipMapLinearFilter, LinearFilter, LinearMipMapNearestFilter, LinearMipMapLinearFilter, UnsignedByteType, ByteType, ShortType, UnsignedShortType, IntType, UnsignedIntType, FloatType, HalfFloatType, UnsignedShort4444Type, UnsignedShort5551Type, UnsignedShort565Type, UnsignedInt248Type, AlphaFormat, RGBFormat, RGBAFormat, LuminanceFormat, LuminanceAlphaFormat, RGBEFormat, DepthFormat, DepthStencilFormat, RGB_S3TC_DXT1_Format, RGBA_S3TC_DXT1_Format, RGBA_S3TC_DXT3_Format, RGBA_S3TC_DXT5_Format, RGB_PVRTC_4BPPV1_Format, RGB_PVRTC_2BPPV1_Format, RGBA_PVRTC_4BPPV1_Format, RGBA_PVRTC_2BPPV1_Format, RGB_ETC1_Format, LoopOnce, LoopRepeat, LoopPingPong, InterpolateDiscrete, InterpolateLinear, InterpolateSmooth, ZeroCurvatureEnding, ZeroSlopeEnding, WrapAroundEnding, TrianglesDrawMode, TriangleStripDrawMode, TriangleFanDrawMode, LinearEncoding, sRGBEncoding, GammaEncoding, RGBEEncoding, LogLuvEncoding, RGBM7Encoding, RGBM16Encoding, RGBDEncoding, BasicDepthPacking, RGBADepthPacking, Vector2, Texture, count, TextureIdCount, Matrix4, Quaternion, Vector3, SpritePlugin, Box2, LensFlarePlugin, CubeTexture, emptyTexture, emptyCubeTexture, UniformContainer, arrayCacheF32, arrayCacheI32, flatten, allocTexUnits, setValue1f, setValue1i, setValue2fv, setValue3fv, setValue4fv, setValue2fm, setValue3fm, setValue4fm, setValueT1, setValueT6, setValue2iv, setValue3iv, setValue4iv, getSingularSetter, setValue1fv, setValue1iv, setValueV2a, setValueV3a, setValueV4a, setValueM2a, setValueM3a, setValueM4a, setValueT1a, setValueT6a, getPureArraySetter, SingleUniform, PureArrayUniform, StructuredUniform, RePathPart, addUniform, parseUniform, WebGLUniforms, WebGLTextures, Vector4, WebGLState, WebGLRenderTarget, Material, count$1, MaterialIdCount, ShaderMaterial, alphamap_fragment, alphamap_pars_fragment, alphatest_fragment, aomap_fragment, aomap_pars_fragment, begin_vertex, beginnormal_vertex, bsdfs, bumpmap_pars_fragment, clipping_planes_fragment, clipping_planes_pars_fragment, clipping_planes_pars_vertex, clipping_planes_vertex, color_fragment, color_pars_fragment, color_pars_vertex, color_vertex, common, cube_uv_reflection_fragment, defaultnormal_vertex, displacementmap_pars_vertex, displacementmap_vertex, emissivemap_fragment, emissivemap_pars_fragment, encodings_fragment, encodings_pars_fragment, envmap_fragment, envmap_pars_fragment, envmap_pars_vertex, envmap_vertex, fog_fragment, fog_pars_fragment, lightmap_fragment, lightmap_pars_fragment, lights_lambert_vertex, lights_pars, lights_phong_fragment, lights_phong_pars_fragment, lights_physical_fragment, lights_physical_pars_fragment, lights_template, logdepthbuf_fragment, logdepthbuf_pars_fragment, logdepthbuf_pars_vertex, logdepthbuf_vertex, map_fragment, map_pars_fragment, map_particle_fragment, map_particle_pars_fragment, metalnessmap_fragment, metalnessmap_pars_fragment, morphnormal_vertex, morphtarget_pars_vertex, morphtarget_vertex, normal_flip, normal_fragment, normalmap_pars_fragment, packing, premultiplied_alpha_fragment, project_vertex, roughnessmap_fragment, roughnessmap_pars_fragment, shadowmap_pars_fragment, shadowmap_pars_vertex, shadowmap_vertex, shadowmask_pars_fragment, skinbase_vertex, skinning_pars_vertex, skinning_vertex, skinnormal_vertex, specularmap_fragment, specularmap_pars_fragment, tonemapping_fragment, tonemapping_pars_fragment, uv_pars_fragment, uv_pars_vertex, uv_vertex, uv2_pars_fragment, uv2_pars_vertex, uv2_vertex, worldpos_vertex, cube_frag, cube_vert, depth_frag, depth_vert, distanceRGBA_frag, distanceRGBA_vert, equirect_frag, equirect_vert, linedashed_frag, linedashed_vert, meshbasic_frag, meshbasic_vert, meshlambert_frag, meshlambert_vert, meshphong_frag, meshphong_vert, meshphysical_frag, meshphysical_vert, normal_frag, normal_vert, points_frag, points_vert, shadow_frag, shadow_vert, ShaderChunk, Color, UniformsLib, ShaderLib, MeshDepthMaterial, Box3, Sphere, Matrix3, Plane, Frustum, WebGLShadowMap, addLineNumbers, WebGLShader, WebGLProperties, programIdCount, getEncodingComponents, getTexelDecodingFunction, getTexelEncodingFunction, getToneMappingFunction, generateExtensions, generateDefines, fetchAttributeLocations, filterEmptyLine, replaceLightNums, parseIncludes, unrollLoops, WebGLProgram, WebGLPrograms, BufferAttribute, Int8Attribute, Uint8Attribute, Uint8ClampedAttribute, Int16Attribute, Uint16Attribute, Int32Attribute, Uint32Attribute, Float32Attribute, Float64Attribute, DynamicBufferAttribute, Face3, Euler, Layers, Object3D, count$3, Object3DIdCount, Geometry, count$2, GeometryIdCount, DirectGeometry, BufferGeometry, WebGLGeometries, WebGLObjects, WebGLLights, WebGLCapabilities, WebGLExtensions, WebGLIndexedBufferRenderer, WebGLClipping, WebGLBufferRenderer, WebGLRenderTargetCube, BoxBufferGeometry, Ray, Line3, Triangle, MeshBasicMaterial, Mesh, PlaneBufferGeometry, Camera, PerspectiveCamera, OrthographicCamera, WebGLRenderer, FogExp2, Fog, Scene, LensFlare, SpriteMaterial, Sprite, LOD, DataTexture, Skeleton, Bone, SkinnedMesh, LineBasicMaterial, Line, LineSegments, PointsMaterial, Points, Group, VideoTexture, CompressedTexture, CanvasTexture, DepthTexture, ShadowMaterial, RawShaderMaterial, MultiMaterial, MeshStandardMaterial, MeshPhysicalMaterial, MeshPhongMaterial, MeshNormalMaterial, MeshLambertMaterial, LineDashedMaterial, LoadingManager, XHRLoader, CompressedTextureLoader, DataTextureLoader, BinaryTextureLoader, ImageLoader, CubeTextureLoader, TextureLoader, Light, HemisphereLight, LightShadow, SpotLightShadow, SpotLight, PointLight, DirectionalLightShadow, DirectionalLight, AmbientLight, Interpolant, CubicInterpolant, LinearInterpolant, DiscreteInterpolant, KeyframeTrackPrototype, KeyframeTrackConstructor, VectorKeyframeTrack, QuaternionLinearInterpolant, QuaternionKeyframeTrack, NumberKeyframeTrack, StringKeyframeTrack, BooleanKeyframeTrack, ColorKeyframeTrack, KeyframeTrack, AnimationClip, MaterialLoader, BufferGeometryLoader, Loader, JSONLoader, ObjectLoader, Curve, LineCurve, CurvePath, EllipseCurve, SplineCurve, CubicBezierCurve, QuadraticBezierCurve, PathPrototype, TubeGeometry, ExtrudeGeometry, ShapeGeometry, Shape, Path, ShapePath, Font, FontLoader, context, getAudioContext, AudioLoader, StereoCamera, CubeCamera, AudioListener, Audio, PositionalAudio, AudioAnalyser, PropertyMixer, PropertyBinding, AnimationObjectGroup, AnimationAction, AnimationMixer, Uniform, InstancedBufferGeometry, InterleavedBufferAttribute, InterleavedBuffer, InstancedInterleavedBuffer, InstancedBufferAttribute, Raycaster, ascSort, intersectObject, Clock, Spline, Spherical, MorphBlendMesh, ImmediateRenderObject, WireframeGeometry, WireframeHelper, VertexNormalsHelper, SpotLightHelper, SkeletonHelper, SphereBufferGeometry, PointLightHelper, SphereGeometry, HemisphereLightHelper, GridHelper, FaceNormalsHelper, EdgesGeometry, EdgesHelper, DirectionalLightHelper, CameraHelper, BoxGeometry, BoundingBoxHelper, BoxHelper, CylinderBufferGeometry, lineGeometry, coneGeometry, ArrowHelper, AxisHelper, ParametricGeometry, PolyhedronGeometry, TetrahedronGeometry, OctahedronGeometry, IcosahedronGeometry, DodecahedronGeometry, TorusKnotBufferGeometry, TorusKnotGeometry, TorusBufferGeometry, TorusGeometry, TextGeometry, RingBufferGeometry, RingGeometry, PlaneGeometry, LatheBufferGeometry, LatheGeometry, CylinderGeometry, ConeGeometry, ConeBufferGeometry, CircleBufferGeometry, CircleGeometry, ClosedSplineCurve3, SplineCurve3, ArcCurve, Face4, LineStrip, LinePieces, PointCloud, ParticleSystem, PointCloudMaterial, ParticleBasicMaterial, ParticleSystemMaterial, Vertex, GeometryUtils, ImageUtils, Projector, CanvasRenderer;
EventDispatcher = function EventDispatcher() {
};
Vector2 = function Vector2(x, y) {
    this.x = x || 0;
    this.y = y || 0;
};
Texture = function Texture(image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) {
    Object.defineProperty(this, 'id', {
        value: TextureIdCount()
    });
    this.uuid = exports.Math.generateUUID();
    this.name = '';
    this.sourceFile = '';
    this.image = image !== undefined ? image : Texture.DEFAULT_IMAGE;
    this.mipmaps = [];
    this.mapping = mapping !== undefined ? mapping : Texture.DEFAULT_MAPPING;
    this.wrapS = wrapS !== undefined ? wrapS : ClampToEdgeWrapping;
    this.wrapT = wrapT !== undefined ? wrapT : ClampToEdgeWrapping;
    this.magFilter = magFilter !== undefined ? magFilter : LinearFilter;
    this.minFilter = minFilter !== undefined ? minFilter : LinearMipMapLinearFilter;
    this.anisotropy = anisotropy !== undefined ? anisotropy : 1;
    this.format = format !== undefined ? format : RGBAFormat;
    this.type = type !== undefined ? type : UnsignedByteType;
    this.offset = new Vector2(0, 0);
    this.repeat = new Vector2(1, 1);
    this.generateMipmaps = true;
    this.premultiplyAlpha = false;
    this.flipY = true;
    this.unpackAlignment = 4;
    this.encoding = encoding !== undefined ? encoding : LinearEncoding;
    this.version = 0;
    this.onUpdate = null;
};
TextureIdCount = function TextureIdCount() {
    return count++;
};
Matrix4 = function Matrix4() {
    this.elements = new Float32Array([
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1
    ]);
    if (arguments.length > 0) {
        console.error('THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.');
    }
};
Quaternion = function Quaternion(x, y, z, w) {
    this._x = x || 0;
    this._y = y || 0;
    this._z = z || 0;
    this._w = w !== undefined ? w : 1;
};
Vector3 = function Vector3(x, y, z) {
    this.x = x || 0;
    this.y = y || 0;
    this.z = z || 0;
};
SpritePlugin = function SpritePlugin(renderer, sprites) {
    var gl = renderer.context;
    var state = renderer.state;
    var vertexBuffer, elementBuffer;
    var program, attributes, uniforms;
    var texture;
    var spritePosition = new Vector3();
    var spriteRotation = new Quaternion();
    var spriteScale = new Vector3();
    function init() {
        var vertices = new Float32Array([
            -0.5,
            -0.5,
            0,
            0,
            0.5,
            -0.5,
            1,
            0,
            0.5,
            0.5,
            1,
            1,
            -0.5,
            0.5,
            0,
            1
        ]);
        var faces = new Uint16Array([
            0,
            1,
            2,
            0,
            2,
            3
        ]);
        vertexBuffer = gl.createBuffer();
        elementBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, elementBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW);
        program = createProgram();
        attributes = {
            position: gl.getAttribLocation(program, 'position'),
            uv: gl.getAttribLocation(program, 'uv')
        };
        uniforms = {
            uvOffset: gl.getUniformLocation(program, 'uvOffset'),
            uvScale: gl.getUniformLocation(program, 'uvScale'),
            rotation: gl.getUniformLocation(program, 'rotation'),
            scale: gl.getUniformLocation(program, 'scale'),
            color: gl.getUniformLocation(program, 'color'),
            map: gl.getUniformLocation(program, 'map'),
            opacity: gl.getUniformLocation(program, 'opacity'),
            modelViewMatrix: gl.getUniformLocation(program, 'modelViewMatrix'),
            projectionMatrix: gl.getUniformLocation(program, 'projectionMatrix'),
            fogType: gl.getUniformLocation(program, 'fogType'),
            fogDensity: gl.getUniformLocation(program, 'fogDensity'),
            fogNear: gl.getUniformLocation(program, 'fogNear'),
            fogFar: gl.getUniformLocation(program, 'fogFar'),
            fogColor: gl.getUniformLocation(program, 'fogColor'),
            alphaTest: gl.getUniformLocation(program, 'alphaTest')
        };
        var canvas = document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');
        canvas.width = 8;
        canvas.height = 8;
        var context = canvas.getContext('2d');
        context.fillStyle = 'white';
        context.fillRect(0, 0, 8, 8);
        texture = new Texture(canvas);
        texture.needsUpdate = true;
    }
    this.render = function (scene, camera) {
        if (sprites.length === 0)
            return;
        if (program === undefined) {
            init();
        }
        gl.useProgram(program);
        state.initAttributes();
        state.enableAttribute(attributes.position);
        state.enableAttribute(attributes.uv);
        state.disableUnusedAttributes();
        state.disable(gl.CULL_FACE);
        state.enable(gl.BLEND);
        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
        gl.vertexAttribPointer(attributes.position, 2, gl.FLOAT, false, 2 * 8, 0);
        gl.vertexAttribPointer(attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, elementBuffer);
        gl.uniformMatrix4fv(uniforms.projectionMatrix, false, camera.projectionMatrix.elements);
        state.activeTexture(gl.TEXTURE0);
        gl.uniform1i(uniforms.map, 0);
        var oldFogType = 0;
        var sceneFogType = 0;
        var fog = scene.fog;
        if (fog) {
            gl.uniform3f(uniforms.fogColor, fog.color.r, fog.color.g, fog.color.b);
            if (fog && fog.isFog) {
                gl.uniform1f(uniforms.fogNear, fog.near);
                gl.uniform1f(uniforms.fogFar, fog.far);
                gl.uniform1i(uniforms.fogType, 1);
                oldFogType = 1;
                sceneFogType = 1;
            } else if (fog && fog.isFogExp2) {
                gl.uniform1f(uniforms.fogDensity, fog.density);
                gl.uniform1i(uniforms.fogType, 2);
                oldFogType = 2;
                sceneFogType = 2;
            }
        } else {
            gl.uniform1i(uniforms.fogType, 0);
            oldFogType = 0;
            sceneFogType = 0;
        }
        for (var i = 0, l = sprites.length; i < l; i++) {
            var sprite = sprites[i];
            sprite.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, sprite.matrixWorld);
            sprite.z = -sprite.modelViewMatrix.elements[14];
        }
        sprites.sort(painterSortStable);
        var scale = [];
        for (var i = 0, l = sprites.length; i < l; i++) {
            var sprite = sprites[i];
            var material = sprite.material;
            if (material.visible === false)
                continue;
            gl.uniform1f(uniforms.alphaTest, material.alphaTest);
            gl.uniformMatrix4fv(uniforms.modelViewMatrix, false, sprite.modelViewMatrix.elements);
            sprite.matrixWorld.decompose(spritePosition, spriteRotation, spriteScale);
            scale[0] = spriteScale.x;
            scale[1] = spriteScale.y;
            var fogType = 0;
            if (scene.fog && material.fog) {
                fogType = sceneFogType;
            }
            if (oldFogType !== fogType) {
                gl.uniform1i(uniforms.fogType, fogType);
                oldFogType = fogType;
            }
            if (material.map !== null) {
                gl.uniform2f(uniforms.uvOffset, material.map.offset.x, material.map.offset.y);
                gl.uniform2f(uniforms.uvScale, material.map.repeat.x, material.map.repeat.y);
            } else {
                gl.uniform2f(uniforms.uvOffset, 0, 0);
                gl.uniform2f(uniforms.uvScale, 1, 1);
            }
            gl.uniform1f(uniforms.opacity, material.opacity);
            gl.uniform3f(uniforms.color, material.color.r, material.color.g, material.color.b);
            gl.uniform1f(uniforms.rotation, material.rotation);
            gl.uniform2fv(uniforms.scale, scale);
            state.setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst);
            state.setDepthTest(material.depthTest);
            state.setDepthWrite(material.depthWrite);
            if (material.map) {
                renderer.setTexture2D(material.map, 0);
            } else {
                renderer.setTexture2D(texture, 0);
            }
            gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
        }
        state.enable(gl.CULL_FACE);
        renderer.resetGLState();
    };
    function createProgram() {
        var program = gl.createProgram();
        var vertexShader = gl.createShader(gl.VERTEX_SHADER);
        var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(vertexShader, [
            'precision ' + renderer.getPrecision() + ' float;',
            'uniform mat4 modelViewMatrix;',
            'uniform mat4 projectionMatrix;',
            'uniform float rotation;',
            'uniform vec2 scale;',
            'uniform vec2 uvOffset;',
            'uniform vec2 uvScale;',
            'attribute vec2 position;',
            'attribute vec2 uv;',
            'varying vec2 vUV;',
            'void main() {',
            'vUV = uvOffset + uv * uvScale;',
            'vec2 alignedPosition = position * scale;',
            'vec2 rotatedPosition;',
            'rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;',
            'rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;',
            'vec4 finalPosition;',
            'finalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );',
            'finalPosition.xy += rotatedPosition;',
            'finalPosition = projectionMatrix * finalPosition;',
            'gl_Position = finalPosition;',
            '}'
        ].join('\n'));
        gl.shaderSource(fragmentShader, [
            'precision ' + renderer.getPrecision() + ' float;',
            'uniform vec3 color;',
            'uniform sampler2D map;',
            'uniform float opacity;',
            'uniform int fogType;',
            'uniform vec3 fogColor;',
            'uniform float fogDensity;',
            'uniform float fogNear;',
            'uniform float fogFar;',
            'uniform float alphaTest;',
            'varying vec2 vUV;',
            'void main() {',
            'vec4 texture = texture2D( map, vUV );',
            'if ( texture.a < alphaTest ) discard;',
            'gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );',
            'if ( fogType > 0 ) {',
            'float depth = gl_FragCoord.z / gl_FragCoord.w;',
            'float fogFactor = 0.0;',
            'if ( fogType == 1 ) {',
            'fogFactor = smoothstep( fogNear, fogFar, depth );',
            '} else {',
            'const float LOG2 = 1.442695;',
            'fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );',
            'fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );',
            '}',
            'gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );',
            '}',
            '}'
        ].join('\n'));
        gl.compileShader(vertexShader);
        gl.compileShader(fragmentShader);
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        return program;
    }
    function painterSortStable(a, b) {
        if (a.renderOrder !== b.renderOrder) {
            return a.renderOrder - b.renderOrder;
        } else if (a.z !== b.z) {
            return b.z - a.z;
        } else {
            return b.id - a.id;
        }
    }
};
Box2 = function Box2(min, max) {
    this.min = min !== undefined ? min : new Vector2(+Infinity, +Infinity);
    this.max = max !== undefined ? max : new Vector2(-Infinity, -Infinity);
};
LensFlarePlugin = function LensFlarePlugin(renderer, flares) {
    var gl = renderer.context;
    var state = renderer.state;
    var vertexBuffer, elementBuffer;
    var shader, program, attributes, uniforms;
    var tempTexture, occlusionTexture;
    function init() {
        var vertices = new Float32Array([
            -1,
            -1,
            0,
            0,
            1,
            -1,
            1,
            0,
            1,
            1,
            1,
            1,
            -1,
            1,
            0,
            1
        ]);
        var faces = new Uint16Array([
            0,
            1,
            2,
            0,
            2,
            3
        ]);
        vertexBuffer = gl.createBuffer();
        elementBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, elementBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW);
        tempTexture = gl.createTexture();
        occlusionTexture = gl.createTexture();
        state.bindTexture(gl.TEXTURE_2D, tempTexture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, 16, 16, 0, gl.RGB, gl.UNSIGNED_BYTE, null);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        state.bindTexture(gl.TEXTURE_2D, occlusionTexture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 16, 16, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        shader = {
            vertexShader: [
                'uniform lowp int renderType;',
                'uniform vec3 screenPosition;',
                'uniform vec2 scale;',
                'uniform float rotation;',
                'uniform sampler2D occlusionMap;',
                'attribute vec2 position;',
                'attribute vec2 uv;',
                'varying vec2 vUV;',
                'varying float vVisibility;',
                'void main() {',
                'vUV = uv;',
                'vec2 pos = position;',
                'if ( renderType == 2 ) {',
                'vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );',
                'visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );',
                'visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );',
                'visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );',
                'visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );',
                'visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );',
                'visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );',
                'visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );',
                'visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );',
                'vVisibility =        visibility.r / 9.0;',
                'vVisibility *= 1.0 - visibility.g / 9.0;',
                'vVisibility *=       visibility.b / 9.0;',
                'vVisibility *= 1.0 - visibility.a / 9.0;',
                'pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;',
                'pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;',
                '}',
                'gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );',
                '}'
            ].join('\n'),
            fragmentShader: [
                'uniform lowp int renderType;',
                'uniform sampler2D map;',
                'uniform float opacity;',
                'uniform vec3 color;',
                'varying vec2 vUV;',
                'varying float vVisibility;',
                'void main() {',
                'if ( renderType == 0 ) {',
                'gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );',
                '} else if ( renderType == 1 ) {',
                'gl_FragColor = texture2D( map, vUV );',
                '} else {',
                'vec4 texture = texture2D( map, vUV );',
                'texture.a *= opacity * vVisibility;',
                'gl_FragColor = texture;',
                'gl_FragColor.rgb *= color;',
                '}',
                '}'
            ].join('\n')
        };
        program = createProgram(shader);
        attributes = {
            vertex: gl.getAttribLocation(program, 'position'),
            uv: gl.getAttribLocation(program, 'uv')
        };
        uniforms = {
            renderType: gl.getUniformLocation(program, 'renderType'),
            map: gl.getUniformLocation(program, 'map'),
            occlusionMap: gl.getUniformLocation(program, 'occlusionMap'),
            opacity: gl.getUniformLocation(program, 'opacity'),
            color: gl.getUniformLocation(program, 'color'),
            scale: gl.getUniformLocation(program, 'scale'),
            rotation: gl.getUniformLocation(program, 'rotation'),
            screenPosition: gl.getUniformLocation(program, 'screenPosition')
        };
    }
    this.render = function (scene, camera, viewport) {
        if (flares.length === 0)
            return;
        var tempPosition = new Vector3();
        var invAspect = viewport.w / viewport.z, halfViewportWidth = viewport.z * 0.5, halfViewportHeight = viewport.w * 0.5;
        var size = 16 / viewport.w, scale = new Vector2(size * invAspect, size);
        var screenPosition = new Vector3(1, 1, 0), screenPositionPixels = new Vector2(1, 1);
        var validArea = new Box2();
        validArea.min.set(0, 0);
        validArea.max.set(viewport.z - 16, viewport.w - 16);
        if (program === undefined) {
            init();
        }
        gl.useProgram(program);
        state.initAttributes();
        state.enableAttribute(attributes.vertex);
        state.enableAttribute(attributes.uv);
        state.disableUnusedAttributes();
        gl.uniform1i(uniforms.occlusionMap, 0);
        gl.uniform1i(uniforms.map, 1);
        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
        gl.vertexAttribPointer(attributes.vertex, 2, gl.FLOAT, false, 2 * 8, 0);
        gl.vertexAttribPointer(attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, elementBuffer);
        state.disable(gl.CULL_FACE);
        state.setDepthWrite(false);
        for (var i = 0, l = flares.length; i < l; i++) {
            size = 16 / viewport.w;
            scale.set(size * invAspect, size);
            var flare = flares[i];
            tempPosition.set(flare.matrixWorld.elements[12], flare.matrixWorld.elements[13], flare.matrixWorld.elements[14]);
            tempPosition.applyMatrix4(camera.matrixWorldInverse);
            tempPosition.applyProjection(camera.projectionMatrix);
            screenPosition.copy(tempPosition);
            screenPositionPixels.x = viewport.x + screenPosition.x * halfViewportWidth + halfViewportWidth - 8;
            screenPositionPixels.y = viewport.y + screenPosition.y * halfViewportHeight + halfViewportHeight - 8;
            if (validArea.containsPoint(screenPositionPixels) === true) {
                state.activeTexture(gl.TEXTURE0);
                state.bindTexture(gl.TEXTURE_2D, null);
                state.activeTexture(gl.TEXTURE1);
                state.bindTexture(gl.TEXTURE_2D, tempTexture);
                gl.copyTexImage2D(gl.TEXTURE_2D, 0, gl.RGB, screenPositionPixels.x, screenPositionPixels.y, 16, 16, 0);
                gl.uniform1i(uniforms.renderType, 0);
                gl.uniform2f(uniforms.scale, scale.x, scale.y);
                gl.uniform3f(uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z);
                state.disable(gl.BLEND);
                state.enable(gl.DEPTH_TEST);
                gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
                state.activeTexture(gl.TEXTURE0);
                state.bindTexture(gl.TEXTURE_2D, occlusionTexture);
                gl.copyTexImage2D(gl.TEXTURE_2D, 0, gl.RGBA, screenPositionPixels.x, screenPositionPixels.y, 16, 16, 0);
                gl.uniform1i(uniforms.renderType, 1);
                state.disable(gl.DEPTH_TEST);
                state.activeTexture(gl.TEXTURE1);
                state.bindTexture(gl.TEXTURE_2D, tempTexture);
                gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
                flare.positionScreen.copy(screenPosition);
                if (flare.customUpdateCallback) {
                    flare.customUpdateCallback(flare);
                } else {
                    flare.updateLensFlares();
                }
                gl.uniform1i(uniforms.renderType, 2);
                state.enable(gl.BLEND);
                for (var j = 0, jl = flare.lensFlares.length; j < jl; j++) {
                    var sprite = flare.lensFlares[j];
                    if (sprite.opacity > 0.001 && sprite.scale > 0.001) {
                        screenPosition.x = sprite.x;
                        screenPosition.y = sprite.y;
                        screenPosition.z = sprite.z;
                        size = sprite.size * sprite.scale / viewport.w;
                        scale.x = size * invAspect;
                        scale.y = size;
                        gl.uniform3f(uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z);
                        gl.uniform2f(uniforms.scale, scale.x, scale.y);
                        gl.uniform1f(uniforms.rotation, sprite.rotation);
                        gl.uniform1f(uniforms.opacity, sprite.opacity);
                        gl.uniform3f(uniforms.color, sprite.color.r, sprite.color.g, sprite.color.b);
                        state.setBlending(sprite.blending, sprite.blendEquation, sprite.blendSrc, sprite.blendDst);
                        renderer.setTexture2D(sprite.texture, 1);
                        gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
                    }
                }
            }
        }
        state.enable(gl.CULL_FACE);
        state.enable(gl.DEPTH_TEST);
        state.setDepthWrite(true);
        renderer.resetGLState();
    };
    function createProgram(shader) {
        var program = gl.createProgram();
        var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
        var vertexShader = gl.createShader(gl.VERTEX_SHADER);
        var prefix = 'precision ' + renderer.getPrecision() + ' float;\n';
        gl.shaderSource(fragmentShader, prefix + shader.fragmentShader);
        gl.shaderSource(vertexShader, prefix + shader.vertexShader);
        gl.compileShader(fragmentShader);
        gl.compileShader(vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.attachShader(program, vertexShader);
        gl.linkProgram(program);
        return program;
    }
};
CubeTexture = function CubeTexture(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) {
    images = images !== undefined ? images : [];
    mapping = mapping !== undefined ? mapping : CubeReflectionMapping;
    Texture.call(this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
    this.flipY = false;
};
UniformContainer = function UniformContainer() {
    this.seq = [];
    this.map = {};
};
flatten = function flatten(array, nBlocks, blockSize) {
    var firstElem = array[0];
    if (firstElem <= 0 || firstElem > 0)
        return array;
    var n = nBlocks * blockSize, r = arrayCacheF32[n];
    if (r === undefined) {
        r = new Float32Array(n);
        arrayCacheF32[n] = r;
    }
    if (nBlocks !== 0) {
        firstElem.toArray(r, 0);
        for (var i = 1, offset = 0; i !== nBlocks; ++i) {
            offset += blockSize;
            array[i].toArray(r, offset);
        }
    }
    return r;
};
allocTexUnits = function allocTexUnits(renderer, n) {
    var r = arrayCacheI32[n];
    if (r === undefined) {
        r = new Int32Array(n);
        arrayCacheI32[n] = r;
    }
    for (var i = 0; i !== n; ++i)
        r[i] = renderer.allocTextureUnit();
    return r;
};
setValue1f = function setValue1f(gl, v) {
    gl.uniform1f(this.addr, v);
};
setValue1i = function setValue1i(gl, v) {
    gl.uniform1i(this.addr, v);
};
setValue2fv = function setValue2fv(gl, v) {
    if (v.x === undefined)
        gl.uniform2fv(this.addr, v);
    else
        gl.uniform2f(this.addr, v.x, v.y);
};
setValue3fv = function setValue3fv(gl, v) {
    if (v.x !== undefined)
        gl.uniform3f(this.addr, v.x, v.y, v.z);
    else if (v.r !== undefined)
        gl.uniform3f(this.addr, v.r, v.g, v.b);
    else
        gl.uniform3fv(this.addr, v);
};
setValue4fv = function setValue4fv(gl, v) {
    if (v.x === undefined)
        gl.uniform4fv(this.addr, v);
    else
        gl.uniform4f(this.addr, v.x, v.y, v.z, v.w);
};
setValue2fm = function setValue2fm(gl, v) {
    gl.uniformMatrix2fv(this.addr, false, v.elements || v);
};
setValue3fm = function setValue3fm(gl, v) {
    gl.uniformMatrix3fv(this.addr, false, v.elements || v);
};
setValue4fm = function setValue4fm(gl, v) {
    gl.uniformMatrix4fv(this.addr, false, v.elements || v);
};
setValueT1 = function setValueT1(gl, v, renderer) {
    var unit = renderer.allocTextureUnit();
    gl.uniform1i(this.addr, unit);
    renderer.setTexture2D(v || emptyTexture, unit);
};
setValueT6 = function setValueT6(gl, v, renderer) {
    var unit = renderer.allocTextureUnit();
    gl.uniform1i(this.addr, unit);
    renderer.setTextureCube(v || emptyCubeTexture, unit);
};
setValue2iv = function setValue2iv(gl, v) {
    gl.uniform2iv(this.addr, v);
};
setValue3iv = function setValue3iv(gl, v) {
    gl.uniform3iv(this.addr, v);
};
setValue4iv = function setValue4iv(gl, v) {
    gl.uniform4iv(this.addr, v);
};
getSingularSetter = function getSingularSetter(type) {
    switch (type) {
    case 5126:
        return setValue1f;
    case 35664:
        return setValue2fv;
    case 35665:
        return setValue3fv;
    case 35666:
        return setValue4fv;
    case 35674:
        return setValue2fm;
    case 35675:
        return setValue3fm;
    case 35676:
        return setValue4fm;
    case 35678:
        return setValueT1;
    case 35680:
        return setValueT6;
    case 5124:
    case 35670:
        return setValue1i;
    case 35667:
    case 35671:
        return setValue2iv;
    case 35668:
    case 35672:
        return setValue3iv;
    case 35669:
    case 35673:
        return setValue4iv;
    }
};
setValue1fv = function setValue1fv(gl, v) {
    gl.uniform1fv(this.addr, v);
};
setValue1iv = function setValue1iv(gl, v) {
    gl.uniform1iv(this.addr, v);
};
setValueV2a = function setValueV2a(gl, v) {
    gl.uniform2fv(this.addr, flatten(v, this.size, 2));
};
setValueV3a = function setValueV3a(gl, v) {
    gl.uniform3fv(this.addr, flatten(v, this.size, 3));
};
setValueV4a = function setValueV4a(gl, v) {
    gl.uniform4fv(this.addr, flatten(v, this.size, 4));
};
setValueM2a = function setValueM2a(gl, v) {
    gl.uniformMatrix2fv(this.addr, false, flatten(v, this.size, 4));
};
setValueM3a = function setValueM3a(gl, v) {
    gl.uniformMatrix3fv(this.addr, false, flatten(v, this.size, 9));
};
setValueM4a = function setValueM4a(gl, v) {
    gl.uniformMatrix4fv(this.addr, false, flatten(v, this.size, 16));
};
setValueT1a = function setValueT1a(gl, v, renderer) {
    var n = v.length, units = allocTexUnits(renderer, n);
    gl.uniform1iv(this.addr, units);
    for (var i = 0; i !== n; ++i) {
        renderer.setTexture2D(v[i] || emptyTexture, units[i]);
    }
};
setValueT6a = function setValueT6a(gl, v, renderer) {
    var n = v.length, units = allocTexUnits(renderer, n);
    gl.uniform1iv(this.addr, units);
    for (var i = 0; i !== n; ++i) {
        renderer.setTextureCube(v[i] || emptyCubeTexture, units[i]);
    }
};
getPureArraySetter = function getPureArraySetter(type) {
    switch (type) {
    case 5126:
        return setValue1fv;
    case 35664:
        return setValueV2a;
    case 35665:
        return setValueV3a;
    case 35666:
        return setValueV4a;
    case 35674:
        return setValueM2a;
    case 35675:
        return setValueM3a;
    case 35676:
        return setValueM4a;
    case 35678:
        return setValueT1a;
    case 35680:
        return setValueT6a;
    case 5124:
    case 35670:
        return setValue1iv;
    case 35667:
    case 35671:
        return setValue2iv;
    case 35668:
    case 35672:
        return setValue3iv;
    case 35669:
    case 35673:
        return setValue4iv;
    }
};
SingleUniform = function SingleUniform(id, activeInfo, addr) {
    this.id = id;
    this.addr = addr;
    this.setValue = getSingularSetter(activeInfo.type);
};
PureArrayUniform = function PureArrayUniform(id, activeInfo, addr) {
    this.id = id;
    this.addr = addr;
    this.size = activeInfo.size;
    this.setValue = getPureArraySetter(activeInfo.type);
};
StructuredUniform = function StructuredUniform(id) {
    this.id = id;
    UniformContainer.call(this);
};
addUniform = function addUniform(container, uniformObject) {
    container.seq.push(uniformObject);
    container.map[uniformObject.id] = uniformObject;
};
parseUniform = function parseUniform(activeInfo, addr, container) {
    var path = activeInfo.name, pathLength = path.length;
    RePathPart.lastIndex = 0;
    for (;;) {
        var match = RePathPart.exec(path), matchEnd = RePathPart.lastIndex, id = match[1], idIsIndex = match[2] === ']', subscript = match[3];
        if (idIsIndex)
            id = id | 0;
        if (subscript === undefined || subscript === '[' && matchEnd + 2 === pathLength) {
            addUniform(container, subscript === undefined ? new SingleUniform(id, activeInfo, addr) : new PureArrayUniform(id, activeInfo, addr));
            break;
        } else {
            var map = container.map, next = map[id];
            if (next === undefined) {
                next = new StructuredUniform(id);
                addUniform(container, next);
            }
            container = next;
        }
    }
};
WebGLUniforms = function WebGLUniforms(gl, program, renderer) {
    UniformContainer.call(this);
    this.renderer = renderer;
    var n = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
    for (var i = 0; i !== n; ++i) {
        var info = gl.getActiveUniform(program, i), path = info.name, addr = gl.getUniformLocation(program, path);
        parseUniform(info, addr, this);
    }
};
WebGLTextures = function WebGLTextures(_gl, extensions, state, properties, capabilities, paramThreeToGL, info) {
    var _infoMemory = info.memory;
    var _isWebGL2 = typeof WebGL2RenderingContext !== 'undefined' && _gl instanceof WebGL2RenderingContext;
    function clampToMaxSize(image, maxSize) {
        if (image.width > maxSize || image.height > maxSize) {
            var scale = maxSize / Math.max(image.width, image.height);
            var canvas = document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');
            canvas.width = Math.floor(image.width * scale);
            canvas.height = Math.floor(image.height * scale);
            var context = canvas.getContext('2d');
            context.drawImage(image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height);
            console.warn('THREE.WebGLRenderer: image is too big (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image);
            return canvas;
        }
        return image;
    }
    function isPowerOfTwo(image) {
        return exports.Math.isPowerOfTwo(image.width) && exports.Math.isPowerOfTwo(image.height);
    }
    function makePowerOfTwo(image) {
        if (image instanceof HTMLImageElement || image instanceof HTMLCanvasElement) {
            var canvas = document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');
            canvas.width = exports.Math.nearestPowerOfTwo(image.width);
            canvas.height = exports.Math.nearestPowerOfTwo(image.height);
            var context = canvas.getContext('2d');
            context.drawImage(image, 0, 0, canvas.width, canvas.height);
            console.warn('THREE.WebGLRenderer: image is not power of two (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image);
            return canvas;
        }
        return image;
    }
    function textureNeedsPowerOfTwo(texture) {
        if (texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping)
            return true;
        if (texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter)
            return true;
        return false;
    }
    function filterFallback(f) {
        if (f === NearestFilter || f === NearestMipMapNearestFilter || f === NearestMipMapLinearFilter) {
            return _gl.NEAREST;
        }
        return _gl.LINEAR;
    }
    function onTextureDispose(event) {
        var texture = event.target;
        texture.removeEventListener('dispose', onTextureDispose);
        deallocateTexture(texture);
        _infoMemory.textures--;
    }
    function onRenderTargetDispose(event) {
        var renderTarget = event.target;
        renderTarget.removeEventListener('dispose', onRenderTargetDispose);
        deallocateRenderTarget(renderTarget);
        _infoMemory.textures--;
    }
    function deallocateTexture(texture) {
        var textureProperties = properties.get(texture);
        if (texture.image && textureProperties.__image__webglTextureCube) {
            _gl.deleteTexture(textureProperties.__image__webglTextureCube);
        } else {
            if (textureProperties.__webglInit === undefined)
                return;
            _gl.deleteTexture(textureProperties.__webglTexture);
        }
        properties.delete(texture);
    }
    function deallocateRenderTarget(renderTarget) {
        var renderTargetProperties = properties.get(renderTarget);
        var textureProperties = properties.get(renderTarget.texture);
        if (!renderTarget)
            return;
        if (textureProperties.__webglTexture !== undefined) {
            _gl.deleteTexture(textureProperties.__webglTexture);
        }
        if (renderTarget.depthTexture) {
            renderTarget.depthTexture.dispose();
        }
        if (renderTarget && renderTarget.isWebGLRenderTargetCube) {
            for (var i = 0; i < 6; i++) {
                _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i]);
                if (renderTargetProperties.__webglDepthbuffer)
                    _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer[i]);
            }
        } else {
            _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer);
            if (renderTargetProperties.__webglDepthbuffer)
                _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer);
        }
        properties.delete(renderTarget.texture);
        properties.delete(renderTarget);
    }
    function setTexture2D(texture, slot) {
        var textureProperties = properties.get(texture);
        if (texture.version > 0 && textureProperties.__version !== texture.version) {
            var image = texture.image;
            if (image === undefined) {
                console.warn('THREE.WebGLRenderer: Texture marked for update but image is undefined', texture);
            } else if (image.complete === false) {
                console.warn('THREE.WebGLRenderer: Texture marked for update but image is incomplete', texture);
            } else {
                uploadTexture(textureProperties, texture, slot);
                return;
            }
        }
        state.activeTexture(_gl.TEXTURE0 + slot);
        state.bindTexture(_gl.TEXTURE_2D, textureProperties.__webglTexture);
    }
    function setTextureCube(texture, slot) {
        var textureProperties = properties.get(texture);
        if (texture.image.length === 6) {
            if (texture.version > 0 && textureProperties.__version !== texture.version) {
                if (!textureProperties.__image__webglTextureCube) {
                    texture.addEventListener('dispose', onTextureDispose);
                    textureProperties.__image__webglTextureCube = _gl.createTexture();
                    _infoMemory.textures++;
                }
                state.activeTexture(_gl.TEXTURE0 + slot);
                state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube);
                _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);
                var isCompressed = texture && texture.isCompressedTexture;
                var isDataTexture = texture.image[0] && texture.image[0].isDataTexture;
                var cubeImage = [];
                for (var i = 0; i < 6; i++) {
                    if (!isCompressed && !isDataTexture) {
                        cubeImage[i] = clampToMaxSize(texture.image[i], capabilities.maxCubemapSize);
                    } else {
                        cubeImage[i] = isDataTexture ? texture.image[i].image : texture.image[i];
                    }
                }
                var image = cubeImage[0], isPowerOfTwoImage = isPowerOfTwo(image), glFormat = paramThreeToGL(texture.format), glType = paramThreeToGL(texture.type);
                setTextureParameters(_gl.TEXTURE_CUBE_MAP, texture, isPowerOfTwoImage);
                for (var i = 0; i < 6; i++) {
                    if (!isCompressed) {
                        if (isDataTexture) {
                            state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, cubeImage[i].width, cubeImage[i].height, 0, glFormat, glType, cubeImage[i].data);
                        } else {
                            state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, glFormat, glType, cubeImage[i]);
                        }
                    } else {
                        var mipmap, mipmaps = cubeImage[i].mipmaps;
                        for (var j = 0, jl = mipmaps.length; j < jl; j++) {
                            mipmap = mipmaps[j];
                            if (texture.format !== RGBAFormat && texture.format !== RGBFormat) {
                                if (state.getCompressedTextureFormats().indexOf(glFormat) > -1) {
                                    state.compressedTexImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, mipmap.data);
                                } else {
                                    console.warn('THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()');
                                }
                            } else {
                                state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
                            }
                        }
                    }
                }
                if (texture.generateMipmaps && isPowerOfTwoImage) {
                    _gl.generateMipmap(_gl.TEXTURE_CUBE_MAP);
                }
                textureProperties.__version = texture.version;
                if (texture.onUpdate)
                    texture.onUpdate(texture);
            } else {
                state.activeTexture(_gl.TEXTURE0 + slot);
                state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube);
            }
        }
    }
    function setTextureCubeDynamic(texture, slot) {
        state.activeTexture(_gl.TEXTURE0 + slot);
        state.bindTexture(_gl.TEXTURE_CUBE_MAP, properties.get(texture).__webglTexture);
    }
    function setTextureParameters(textureType, texture, isPowerOfTwoImage) {
        var extension;
        if (isPowerOfTwoImage) {
            _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, paramThreeToGL(texture.wrapS));
            _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, paramThreeToGL(texture.wrapT));
            _gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, paramThreeToGL(texture.magFilter));
            _gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, paramThreeToGL(texture.minFilter));
        } else {
            _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE);
            _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE);
            if (texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping) {
                console.warn('THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.', texture);
            }
            _gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, filterFallback(texture.magFilter));
            _gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, filterFallback(texture.minFilter));
            if (texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter) {
                console.warn('THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.', texture);
            }
        }
        extension = extensions.get('EXT_texture_filter_anisotropic');
        if (extension) {
            if (texture.type === FloatType && extensions.get('OES_texture_float_linear') === null)
                return;
            if (texture.type === HalfFloatType && extensions.get('OES_texture_half_float_linear') === null)
                return;
            if (texture.anisotropy > 1 || properties.get(texture).__currentAnisotropy) {
                _gl.texParameterf(textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(texture.anisotropy, capabilities.getMaxAnisotropy()));
                properties.get(texture).__currentAnisotropy = texture.anisotropy;
            }
        }
    }
    function uploadTexture(textureProperties, texture, slot) {
        if (textureProperties.__webglInit === undefined) {
            textureProperties.__webglInit = true;
            texture.addEventListener('dispose', onTextureDispose);
            textureProperties.__webglTexture = _gl.createTexture();
            _infoMemory.textures++;
        }
        state.activeTexture(_gl.TEXTURE0 + slot);
        state.bindTexture(_gl.TEXTURE_2D, textureProperties.__webglTexture);
        _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);
        _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha);
        _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, texture.unpackAlignment);
        var image = clampToMaxSize(texture.image, capabilities.maxTextureSize);
        if (textureNeedsPowerOfTwo(texture) && isPowerOfTwo(image) === false) {
            image = makePowerOfTwo(image);
        }
        var isPowerOfTwoImage = isPowerOfTwo(image), glFormat = paramThreeToGL(texture.format), glType = paramThreeToGL(texture.type);
        setTextureParameters(_gl.TEXTURE_2D, texture, isPowerOfTwoImage);
        var mipmap, mipmaps = texture.mipmaps;
        if (texture && texture.isDepthTexture) {
            var internalFormat = _gl.DEPTH_COMPONENT;
            if (texture.type === FloatType) {
                if (!_isWebGL2)
                    throw new Error('Float Depth Texture only supported in WebGL2.0');
                internalFormat = _gl.DEPTH_COMPONENT32F;
            } else if (_isWebGL2) {
                internalFormat = _gl.DEPTH_COMPONENT16;
            }
            if (texture.format === DepthStencilFormat) {
                internalFormat = _gl.DEPTH_STENCIL;
            }
            state.texImage2D(_gl.TEXTURE_2D, 0, internalFormat, image.width, image.height, 0, glFormat, glType, null);
        } else if (texture && texture.isDataTexture) {
            if (mipmaps.length > 0 && isPowerOfTwoImage) {
                for (var i = 0, il = mipmaps.length; i < il; i++) {
                    mipmap = mipmaps[i];
                    state.texImage2D(_gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
                }
                texture.generateMipmaps = false;
            } else {
                state.texImage2D(_gl.TEXTURE_2D, 0, glFormat, image.width, image.height, 0, glFormat, glType, image.data);
            }
        } else if (texture && texture.isCompressedTexture) {
            for (var i = 0, il = mipmaps.length; i < il; i++) {
                mipmap = mipmaps[i];
                if (texture.format !== RGBAFormat && texture.format !== RGBFormat) {
                    if (state.getCompressedTextureFormats().indexOf(glFormat) > -1) {
                        state.compressedTexImage2D(_gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, mipmap.data);
                    } else {
                        console.warn('THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()');
                    }
                } else {
                    state.texImage2D(_gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
                }
            }
        } else {
            if (mipmaps.length > 0 && isPowerOfTwoImage) {
                for (var i = 0, il = mipmaps.length; i < il; i++) {
                    mipmap = mipmaps[i];
                    state.texImage2D(_gl.TEXTURE_2D, i, glFormat, glFormat, glType, mipmap);
                }
                texture.generateMipmaps = false;
            } else {
                state.texImage2D(_gl.TEXTURE_2D, 0, glFormat, glFormat, glType, image);
            }
        }
        if (texture.generateMipmaps && isPowerOfTwoImage)
            _gl.generateMipmap(_gl.TEXTURE_2D);
        textureProperties.__version = texture.version;
        if (texture.onUpdate)
            texture.onUpdate(texture);
    }
    function setupFrameBufferTexture(framebuffer, renderTarget, attachment, textureTarget) {
        var glFormat = paramThreeToGL(renderTarget.texture.format);
        var glType = paramThreeToGL(renderTarget.texture.type);
        state.texImage2D(textureTarget, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null);
        _gl.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
        _gl.framebufferTexture2D(_gl.FRAMEBUFFER, attachment, textureTarget, properties.get(renderTarget.texture).__webglTexture, 0);
        _gl.bindFramebuffer(_gl.FRAMEBUFFER, null);
    }
    function setupRenderBufferStorage(renderbuffer, renderTarget) {
        _gl.bindRenderbuffer(_gl.RENDERBUFFER, renderbuffer);
        if (renderTarget.depthBuffer && !renderTarget.stencilBuffer) {
            _gl.renderbufferStorage(_gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height);
            _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer);
        } else if (renderTarget.depthBuffer && renderTarget.stencilBuffer) {
            _gl.renderbufferStorage(_gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height);
            _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer);
        } else {
            _gl.renderbufferStorage(_gl.RENDERBUFFER, _gl.RGBA4, renderTarget.width, renderTarget.height);
        }
        _gl.bindRenderbuffer(_gl.RENDERBUFFER, null);
    }
    function setupDepthTexture(framebuffer, renderTarget) {
        var isCube = renderTarget && renderTarget.isWebGLRenderTargetCube;
        if (isCube)
            throw new Error('Depth Texture with cube render targets is not supported!');
        _gl.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
        if (!(renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture)) {
            throw new Error('renderTarget.depthTexture must be an instance of THREE.DepthTexture');
        }
        if (!properties.get(renderTarget.depthTexture).__webglTexture || renderTarget.depthTexture.image.width !== renderTarget.width || renderTarget.depthTexture.image.height !== renderTarget.height) {
            renderTarget.depthTexture.image.width = renderTarget.width;
            renderTarget.depthTexture.image.height = renderTarget.height;
            renderTarget.depthTexture.needsUpdate = true;
        }
        setTexture2D(renderTarget.depthTexture, 0);
        var webglDepthTexture = properties.get(renderTarget.depthTexture).__webglTexture;
        if (renderTarget.depthTexture.format === DepthFormat) {
            _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0);
        } else if (renderTarget.depthTexture.format === DepthStencilFormat) {
            _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0);
        } else {
            throw new Error('Unknown depthTexture format');
        }
    }
    function setupDepthRenderbuffer(renderTarget) {
        var renderTargetProperties = properties.get(renderTarget);
        var isCube = renderTarget && renderTarget.isWebGLRenderTargetCube;
        if (renderTarget.depthTexture) {
            if (isCube)
                throw new Error('target.depthTexture not supported in Cube render targets');
            setupDepthTexture(renderTargetProperties.__webglFramebuffer, renderTarget);
        } else {
            if (isCube) {
                renderTargetProperties.__webglDepthbuffer = [];
                for (var i = 0; i < 6; i++) {
                    _gl.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[i]);
                    renderTargetProperties.__webglDepthbuffer[i] = _gl.createRenderbuffer();
                    setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer[i], renderTarget);
                }
            } else {
                _gl.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);
                renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
                setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer, renderTarget);
            }
        }
        _gl.bindFramebuffer(_gl.FRAMEBUFFER, null);
    }
    function setupRenderTarget(renderTarget) {
        var renderTargetProperties = properties.get(renderTarget);
        var textureProperties = properties.get(renderTarget.texture);
        renderTarget.addEventListener('dispose', onRenderTargetDispose);
        textureProperties.__webglTexture = _gl.createTexture();
        _infoMemory.textures++;
        var isCube = renderTarget && renderTarget.isWebGLRenderTargetCube;
        var isTargetPowerOfTwo = isPowerOfTwo(renderTarget);
        if (isCube) {
            renderTargetProperties.__webglFramebuffer = [];
            for (var i = 0; i < 6; i++) {
                renderTargetProperties.__webglFramebuffer[i] = _gl.createFramebuffer();
            }
        } else {
            renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();
        }
        if (isCube) {
            state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture);
            setTextureParameters(_gl.TEXTURE_CUBE_MAP, renderTarget.texture, isTargetPowerOfTwo);
            for (var i = 0; i < 6; i++) {
                setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i], renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i);
            }
            if (renderTarget.texture.generateMipmaps && isTargetPowerOfTwo)
                _gl.generateMipmap(_gl.TEXTURE_CUBE_MAP);
            state.bindTexture(_gl.TEXTURE_CUBE_MAP, null);
        } else {
            state.bindTexture(_gl.TEXTURE_2D, textureProperties.__webglTexture);
            setTextureParameters(_gl.TEXTURE_2D, renderTarget.texture, isTargetPowerOfTwo);
            setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D);
            if (renderTarget.texture.generateMipmaps && isTargetPowerOfTwo)
                _gl.generateMipmap(_gl.TEXTURE_2D);
            state.bindTexture(_gl.TEXTURE_2D, null);
        }
        if (renderTarget.depthBuffer) {
            setupDepthRenderbuffer(renderTarget);
        }
    }
    function updateRenderTargetMipmap(renderTarget) {
        var texture = renderTarget.texture;
        if (texture.generateMipmaps && isPowerOfTwo(renderTarget) && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter) {
            var target = renderTarget && renderTarget.isWebGLRenderTargetCube ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D;
            var webglTexture = properties.get(texture).__webglTexture;
            state.bindTexture(target, webglTexture);
            _gl.generateMipmap(target);
            state.bindTexture(target, null);
        }
    }
    this.setTexture2D = setTexture2D;
    this.setTextureCube = setTextureCube;
    this.setTextureCubeDynamic = setTextureCubeDynamic;
    this.setupRenderTarget = setupRenderTarget;
    this.updateRenderTargetMipmap = updateRenderTargetMipmap;
};
Vector4 = function Vector4(x, y, z, w) {
    this.x = x || 0;
    this.y = y || 0;
    this.z = z || 0;
    this.w = w !== undefined ? w : 1;
};
WebGLState = function WebGLState(gl, extensions, paramThreeToGL) {
    function ColorBuffer() {
        var locked = false;
        var color = new Vector4();
        var currentColorMask = null;
        var currentColorClear = new Vector4();
        return {
            setMask: function (colorMask) {
                if (currentColorMask !== colorMask && !locked) {
                    gl.colorMask(colorMask, colorMask, colorMask, colorMask);
                    currentColorMask = colorMask;
                }
            },
            setLocked: function (lock) {
                locked = lock;
            },
            setClear: function (r, g, b, a) {
                color.set(r, g, b, a);
                if (currentColorClear.equals(color) === false) {
                    gl.clearColor(r, g, b, a);
                    currentColorClear.copy(color);
                }
            },
            reset: function () {
                locked = false;
                currentColorMask = null;
                currentColorClear.set(0, 0, 0, 1);
            }
        };
    }
    function DepthBuffer() {
        var locked = false;
        var currentDepthMask = null;
        var currentDepthFunc = null;
        var currentDepthClear = null;
        return {
            setTest: function (depthTest) {
                if (depthTest) {
                    enable(gl.DEPTH_TEST);
                } else {
                    disable(gl.DEPTH_TEST);
                }
            },
            setMask: function (depthMask) {
                if (currentDepthMask !== depthMask && !locked) {
                    gl.depthMask(depthMask);
                    currentDepthMask = depthMask;
                }
            },
            setFunc: function (depthFunc) {
                if (currentDepthFunc !== depthFunc) {
                    if (depthFunc) {
                        switch (depthFunc) {
                        case NeverDepth:
                            gl.depthFunc(gl.NEVER);
                            break;
                        case AlwaysDepth:
                            gl.depthFunc(gl.ALWAYS);
                            break;
                        case LessDepth:
                            gl.depthFunc(gl.LESS);
                            break;
                        case LessEqualDepth:
                            gl.depthFunc(gl.LEQUAL);
                            break;
                        case EqualDepth:
                            gl.depthFunc(gl.EQUAL);
                            break;
                        case GreaterEqualDepth:
                            gl.depthFunc(gl.GEQUAL);
                            break;
                        case GreaterDepth:
                            gl.depthFunc(gl.GREATER);
                            break;
                        case NotEqualDepth:
                            gl.depthFunc(gl.NOTEQUAL);
                            break;
                        default:
                            gl.depthFunc(gl.LEQUAL);
                        }
                    } else {
                        gl.depthFunc(gl.LEQUAL);
                    }
                    currentDepthFunc = depthFunc;
                }
            },
            setLocked: function (lock) {
                locked = lock;
            },
            setClear: function (depth) {
                if (currentDepthClear !== depth) {
                    gl.clearDepth(depth);
                    currentDepthClear = depth;
                }
            },
            reset: function () {
                locked = false;
                currentDepthMask = null;
                currentDepthFunc = null;
                currentDepthClear = null;
            }
        };
    }
    function StencilBuffer() {
        var locked = false;
        var currentStencilMask = null;
        var currentStencilFunc = null;
        var currentStencilRef = null;
        var currentStencilFuncMask = null;
        var currentStencilFail = null;
        var currentStencilZFail = null;
        var currentStencilZPass = null;
        var currentStencilClear = null;
        return {
            setTest: function (stencilTest) {
                if (stencilTest) {
                    enable(gl.STENCIL_TEST);
                } else {
                    disable(gl.STENCIL_TEST);
                }
            },
            setMask: function (stencilMask) {
                if (currentStencilMask !== stencilMask && !locked) {
                    gl.stencilMask(stencilMask);
                    currentStencilMask = stencilMask;
                }
            },
            setFunc: function (stencilFunc, stencilRef, stencilMask) {
                if (currentStencilFunc !== stencilFunc || currentStencilRef !== stencilRef || currentStencilFuncMask !== stencilMask) {
                    gl.stencilFunc(stencilFunc, stencilRef, stencilMask);
                    currentStencilFunc = stencilFunc;
                    currentStencilRef = stencilRef;
                    currentStencilFuncMask = stencilMask;
                }
            },
            setOp: function (stencilFail, stencilZFail, stencilZPass) {
                if (currentStencilFail !== stencilFail || currentStencilZFail !== stencilZFail || currentStencilZPass !== stencilZPass) {
                    gl.stencilOp(stencilFail, stencilZFail, stencilZPass);
                    currentStencilFail = stencilFail;
                    currentStencilZFail = stencilZFail;
                    currentStencilZPass = stencilZPass;
                }
            },
            setLocked: function (lock) {
                locked = lock;
            },
            setClear: function (stencil) {
                if (currentStencilClear !== stencil) {
                    gl.clearStencil(stencil);
                    currentStencilClear = stencil;
                }
            },
            reset: function () {
                locked = false;
                currentStencilMask = null;
                currentStencilFunc = null;
                currentStencilRef = null;
                currentStencilFuncMask = null;
                currentStencilFail = null;
                currentStencilZFail = null;
                currentStencilZPass = null;
                currentStencilClear = null;
            }
        };
    }
    var colorBuffer = new ColorBuffer();
    var depthBuffer = new DepthBuffer();
    var stencilBuffer = new StencilBuffer();
    var maxVertexAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
    var newAttributes = new Uint8Array(maxVertexAttributes);
    var enabledAttributes = new Uint8Array(maxVertexAttributes);
    var attributeDivisors = new Uint8Array(maxVertexAttributes);
    var capabilities = {};
    var compressedTextureFormats = null;
    var currentBlending = null;
    var currentBlendEquation = null;
    var currentBlendSrc = null;
    var currentBlendDst = null;
    var currentBlendEquationAlpha = null;
    var currentBlendSrcAlpha = null;
    var currentBlendDstAlpha = null;
    var currentPremultipledAlpha = false;
    var currentFlipSided = null;
    var currentCullFace = null;
    var currentLineWidth = null;
    var currentPolygonOffsetFactor = null;
    var currentPolygonOffsetUnits = null;
    var currentScissorTest = null;
    var maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
    var currentTextureSlot = null;
    var currentBoundTextures = {};
    var currentScissor = new Vector4();
    var currentViewport = new Vector4();
    function createTexture(type, target, count) {
        var data = new Uint8Array(4);
        var texture = gl.createTexture();
        gl.bindTexture(type, texture);
        gl.texParameteri(type, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.texParameteri(type, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        for (var i = 0; i < count; i++) {
            gl.texImage2D(target + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);
        }
        return texture;
    }
    var emptyTextures = {};
    emptyTextures[gl.TEXTURE_2D] = createTexture(gl.TEXTURE_2D, gl.TEXTURE_2D, 1);
    emptyTextures[gl.TEXTURE_CUBE_MAP] = createTexture(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_CUBE_MAP_POSITIVE_X, 6);
    function init() {
        clearColor(0, 0, 0, 1);
        clearDepth(1);
        clearStencil(0);
        enable(gl.DEPTH_TEST);
        setDepthFunc(LessEqualDepth);
        setFlipSided(false);
        setCullFace(CullFaceBack);
        enable(gl.CULL_FACE);
        enable(gl.BLEND);
        setBlending(NormalBlending);
    }
    function initAttributes() {
        for (var i = 0, l = newAttributes.length; i < l; i++) {
            newAttributes[i] = 0;
        }
    }
    function enableAttribute(attribute) {
        newAttributes[attribute] = 1;
        if (enabledAttributes[attribute] === 0) {
            gl.enableVertexAttribArray(attribute);
            enabledAttributes[attribute] = 1;
        }
        if (attributeDivisors[attribute] !== 0) {
            var extension = extensions.get('ANGLE_instanced_arrays');
            extension.vertexAttribDivisorANGLE(attribute, 0);
            attributeDivisors[attribute] = 0;
        }
    }
    function enableAttributeAndDivisor(attribute, meshPerAttribute, extension) {
        newAttributes[attribute] = 1;
        if (enabledAttributes[attribute] === 0) {
            gl.enableVertexAttribArray(attribute);
            enabledAttributes[attribute] = 1;
        }
        if (attributeDivisors[attribute] !== meshPerAttribute) {
            extension.vertexAttribDivisorANGLE(attribute, meshPerAttribute);
            attributeDivisors[attribute] = meshPerAttribute;
        }
    }
    function disableUnusedAttributes() {
        for (var i = 0, l = enabledAttributes.length; i !== l; ++i) {
            if (enabledAttributes[i] !== newAttributes[i]) {
                gl.disableVertexAttribArray(i);
                enabledAttributes[i] = 0;
            }
        }
    }
    function enable(id) {
        if (capabilities[id] !== true) {
            gl.enable(id);
            capabilities[id] = true;
        }
    }
    function disable(id) {
        if (capabilities[id] !== false) {
            gl.disable(id);
            capabilities[id] = false;
        }
    }
    function getCompressedTextureFormats() {
        if (compressedTextureFormats === null) {
            compressedTextureFormats = [];
            if (extensions.get('WEBGL_compressed_texture_pvrtc') || extensions.get('WEBGL_compressed_texture_s3tc') || extensions.get('WEBGL_compressed_texture_etc1')) {
                var formats = gl.getParameter(gl.COMPRESSED_TEXTURE_FORMATS);
                for (var i = 0; i < formats.length; i++) {
                    compressedTextureFormats.push(formats[i]);
                }
            }
        }
        return compressedTextureFormats;
    }
    function setBlending(blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha) {
        if (blending !== NoBlending) {
            enable(gl.BLEND);
        } else {
            disable(gl.BLEND);
            currentBlending = blending;
            return;
        }
        if (blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha) {
            if (blending === AdditiveBlending) {
                if (premultipliedAlpha) {
                    gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
                    gl.blendFuncSeparate(gl.ONE, gl.ONE, gl.ONE, gl.ONE);
                } else {
                    gl.blendEquation(gl.FUNC_ADD);
                    gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
                }
            } else if (blending === SubtractiveBlending) {
                if (premultipliedAlpha) {
                    gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
                    gl.blendFuncSeparate(gl.ZERO, gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ONE_MINUS_SRC_ALPHA);
                } else {
                    gl.blendEquation(gl.FUNC_ADD);
                    gl.blendFunc(gl.ZERO, gl.ONE_MINUS_SRC_COLOR);
                }
            } else if (blending === MultiplyBlending) {
                if (premultipliedAlpha) {
                    gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
                    gl.blendFuncSeparate(gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA);
                } else {
                    gl.blendEquation(gl.FUNC_ADD);
                    gl.blendFunc(gl.ZERO, gl.SRC_COLOR);
                }
            } else {
                if (premultipliedAlpha) {
                    gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
                    gl.blendFuncSeparate(gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
                } else {
                    gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
                    gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
                }
            }
            currentBlending = blending;
            currentPremultipledAlpha = premultipliedAlpha;
        }
        if (blending === CustomBlending) {
            blendEquationAlpha = blendEquationAlpha || blendEquation;
            blendSrcAlpha = blendSrcAlpha || blendSrc;
            blendDstAlpha = blendDstAlpha || blendDst;
            if (blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha) {
                gl.blendEquationSeparate(paramThreeToGL(blendEquation), paramThreeToGL(blendEquationAlpha));
                currentBlendEquation = blendEquation;
                currentBlendEquationAlpha = blendEquationAlpha;
            }
            if (blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha) {
                gl.blendFuncSeparate(paramThreeToGL(blendSrc), paramThreeToGL(blendDst), paramThreeToGL(blendSrcAlpha), paramThreeToGL(blendDstAlpha));
                currentBlendSrc = blendSrc;
                currentBlendDst = blendDst;
                currentBlendSrcAlpha = blendSrcAlpha;
                currentBlendDstAlpha = blendDstAlpha;
            }
        } else {
            currentBlendEquation = null;
            currentBlendSrc = null;
            currentBlendDst = null;
            currentBlendEquationAlpha = null;
            currentBlendSrcAlpha = null;
            currentBlendDstAlpha = null;
        }
    }
    function setColorWrite(colorWrite) {
        colorBuffer.setMask(colorWrite);
    }
    function setDepthTest(depthTest) {
        depthBuffer.setTest(depthTest);
    }
    function setDepthWrite(depthWrite) {
        depthBuffer.setMask(depthWrite);
    }
    function setDepthFunc(depthFunc) {
        depthBuffer.setFunc(depthFunc);
    }
    function setStencilTest(stencilTest) {
        stencilBuffer.setTest(stencilTest);
    }
    function setStencilWrite(stencilWrite) {
        stencilBuffer.setMask(stencilWrite);
    }
    function setStencilFunc(stencilFunc, stencilRef, stencilMask) {
        stencilBuffer.setFunc(stencilFunc, stencilRef, stencilMask);
    }
    function setStencilOp(stencilFail, stencilZFail, stencilZPass) {
        stencilBuffer.setOp(stencilFail, stencilZFail, stencilZPass);
    }
    function setFlipSided(flipSided) {
        if (currentFlipSided !== flipSided) {
            if (flipSided) {
                gl.frontFace(gl.CW);
            } else {
                gl.frontFace(gl.CCW);
            }
            currentFlipSided = flipSided;
        }
    }
    function setCullFace(cullFace) {
        if (cullFace !== CullFaceNone) {
            enable(gl.CULL_FACE);
            if (cullFace !== currentCullFace) {
                if (cullFace === CullFaceBack) {
                    gl.cullFace(gl.BACK);
                } else if (cullFace === CullFaceFront) {
                    gl.cullFace(gl.FRONT);
                } else {
                    gl.cullFace(gl.FRONT_AND_BACK);
                }
            }
        } else {
            disable(gl.CULL_FACE);
        }
        currentCullFace = cullFace;
    }
    function setLineWidth(width) {
        if (width !== currentLineWidth) {
            gl.lineWidth(width);
            currentLineWidth = width;
        }
    }
    function setPolygonOffset(polygonOffset, factor, units) {
        if (polygonOffset) {
            enable(gl.POLYGON_OFFSET_FILL);
            if (currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units) {
                gl.polygonOffset(factor, units);
                currentPolygonOffsetFactor = factor;
                currentPolygonOffsetUnits = units;
            }
        } else {
            disable(gl.POLYGON_OFFSET_FILL);
        }
    }
    function getScissorTest() {
        return currentScissorTest;
    }
    function setScissorTest(scissorTest) {
        currentScissorTest = scissorTest;
        if (scissorTest) {
            enable(gl.SCISSOR_TEST);
        } else {
            disable(gl.SCISSOR_TEST);
        }
    }
    function activeTexture(webglSlot) {
        if (webglSlot === undefined)
            webglSlot = gl.TEXTURE0 + maxTextures - 1;
        if (currentTextureSlot !== webglSlot) {
            gl.activeTexture(webglSlot);
            currentTextureSlot = webglSlot;
        }
    }
    function bindTexture(webglType, webglTexture) {
        if (currentTextureSlot === null) {
            activeTexture();
        }
        var boundTexture = currentBoundTextures[currentTextureSlot];
        if (boundTexture === undefined) {
            boundTexture = {
                type: undefined,
                texture: undefined
            };
            currentBoundTextures[currentTextureSlot] = boundTexture;
        }
        if (boundTexture.type !== webglType || boundTexture.texture !== webglTexture) {
            gl.bindTexture(webglType, webglTexture || emptyTextures[webglType]);
            boundTexture.type = webglType;
            boundTexture.texture = webglTexture;
        }
    }
    function compressedTexImage2D() {
        try {
            gl.compressedTexImage2D.apply(gl, arguments);
        } catch (error) {
            console.error(error);
        }
    }
    function texImage2D() {
        try {
            gl.texImage2D.apply(gl, arguments);
        } catch (error) {
            console.error(error);
        }
    }
    function clearColor(r, g, b, a) {
        colorBuffer.setClear(r, g, b, a);
    }
    function clearDepth(depth) {
        depthBuffer.setClear(depth);
    }
    function clearStencil(stencil) {
        stencilBuffer.setClear(stencil);
    }
    function scissor(scissor) {
        if (currentScissor.equals(scissor) === false) {
            gl.scissor(scissor.x, scissor.y, scissor.z, scissor.w);
            currentScissor.copy(scissor);
        }
    }
    function viewport(viewport) {
        if (currentViewport.equals(viewport) === false) {
            gl.viewport(viewport.x, viewport.y, viewport.z, viewport.w);
            currentViewport.copy(viewport);
        }
    }
    function reset() {
        for (var i = 0; i < enabledAttributes.length; i++) {
            if (enabledAttributes[i] === 1) {
                gl.disableVertexAttribArray(i);
                enabledAttributes[i] = 0;
            }
        }
        capabilities = {};
        compressedTextureFormats = null;
        currentTextureSlot = null;
        currentBoundTextures = {};
        currentBlending = null;
        currentFlipSided = null;
        currentCullFace = null;
        colorBuffer.reset();
        depthBuffer.reset();
        stencilBuffer.reset();
    }
    return {
        buffers: {
            color: colorBuffer,
            depth: depthBuffer,
            stencil: stencilBuffer
        },
        init: init,
        initAttributes: initAttributes,
        enableAttribute: enableAttribute,
        enableAttributeAndDivisor: enableAttributeAndDivisor,
        disableUnusedAttributes: disableUnusedAttributes,
        enable: enable,
        disable: disable,
        getCompressedTextureFormats: getCompressedTextureFormats,
        setBlending: setBlending,
        setColorWrite: setColorWrite,
        setDepthTest: setDepthTest,
        setDepthWrite: setDepthWrite,
        setDepthFunc: setDepthFunc,
        setStencilTest: setStencilTest,
        setStencilWrite: setStencilWrite,
        setStencilFunc: setStencilFunc,
        setStencilOp: setStencilOp,
        setFlipSided: setFlipSided,
        setCullFace: setCullFace,
        setLineWidth: setLineWidth,
        setPolygonOffset: setPolygonOffset,
        getScissorTest: getScissorTest,
        setScissorTest: setScissorTest,
        activeTexture: activeTexture,
        bindTexture: bindTexture,
        compressedTexImage2D: compressedTexImage2D,
        texImage2D: texImage2D,
        clearColor: clearColor,
        clearDepth: clearDepth,
        clearStencil: clearStencil,
        scissor: scissor,
        viewport: viewport,
        reset: reset
    };
};
WebGLRenderTarget = function WebGLRenderTarget(width, height, options) {
    this.uuid = exports.Math.generateUUID();
    this.width = width;
    this.height = height;
    this.scissor = new Vector4(0, 0, width, height);
    this.scissorTest = false;
    this.viewport = new Vector4(0, 0, width, height);
    options = options || {};
    if (options.minFilter === undefined)
        options.minFilter = LinearFilter;
    this.texture = new Texture(undefined, undefined, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding);
    this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
    this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;
    this.depthTexture = options.depthTexture !== undefined ? options.depthTexture : null;
};
Material = function Material() {
    Object.defineProperty(this, 'id', {
        value: MaterialIdCount()
    });
    this.uuid = exports.Math.generateUUID();
    this.name = '';
    this.type = 'Material';
    this.fog = true;
    this.lights = true;
    this.blending = NormalBlending;
    this.side = FrontSide;
    this.shading = SmoothShading;
    this.vertexColors = NoColors;
    this.opacity = 1;
    this.transparent = false;
    this.blendSrc = SrcAlphaFactor;
    this.blendDst = OneMinusSrcAlphaFactor;
    this.blendEquation = AddEquation;
    this.blendSrcAlpha = null;
    this.blendDstAlpha = null;
    this.blendEquationAlpha = null;
    this.depthFunc = LessEqualDepth;
    this.depthTest = true;
    this.depthWrite = true;
    this.clippingPlanes = null;
    this.clipShadows = false;
    this.colorWrite = true;
    this.precision = null;
    this.polygonOffset = false;
    this.polygonOffsetFactor = 0;
    this.polygonOffsetUnits = 0;
    this.alphaTest = 0;
    this.premultipliedAlpha = false;
    this.overdraw = 0;
    this.visible = true;
    this._needsUpdate = true;
};
MaterialIdCount = function MaterialIdCount() {
    return count$1++;
};
ShaderMaterial = function ShaderMaterial(parameters) {
    Material.call(this);
    this.type = 'ShaderMaterial';
    this.defines = {};
    this.uniforms = {};
    this.vertexShader = 'void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}';
    this.fragmentShader = 'void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}';
    this.linewidth = 1;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.fog = false;
    this.lights = false;
    this.clipping = false;
    this.skinning = false;
    this.morphTargets = false;
    this.morphNormals = false;
    this.extensions = {
        derivatives: false,
        fragDepth: false,
        drawBuffers: false,
        shaderTextureLOD: false
    };
    this.defaultAttributeValues = {
        'color': [
            1,
            1,
            1
        ],
        'uv': [
            0,
            0
        ],
        'uv2': [
            0,
            0
        ]
    };
    this.index0AttributeName = undefined;
    if (parameters !== undefined) {
        if (parameters.attributes !== undefined) {
            console.error('THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.');
        }
        this.setValues(parameters);
    }
};
Color = function Color(r, g, b) {
    if (g === undefined && b === undefined) {
        return this.set(r);
    }
    return this.setRGB(r, g, b);
};
MeshDepthMaterial = function MeshDepthMaterial(parameters) {
    Material.call(this);
    this.type = 'MeshDepthMaterial';
    this.depthPacking = BasicDepthPacking;
    this.skinning = false;
    this.morphTargets = false;
    this.map = null;
    this.alphaMap = null;
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.fog = false;
    this.lights = false;
    this.setValues(parameters);
};
Box3 = function Box3(min, max) {
    this.min = min !== undefined ? min : new Vector3(+Infinity, +Infinity, +Infinity);
    this.max = max !== undefined ? max : new Vector3(-Infinity, -Infinity, -Infinity);
};
Sphere = function Sphere(center, radius) {
    this.center = center !== undefined ? center : new Vector3();
    this.radius = radius !== undefined ? radius : 0;
};
Matrix3 = function Matrix3() {
    this.elements = new Float32Array([
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1
    ]);
    if (arguments.length > 0) {
        console.error('THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.');
    }
};
Plane = function Plane(normal, constant) {
    this.normal = normal !== undefined ? normal : new Vector3(1, 0, 0);
    this.constant = constant !== undefined ? constant : 0;
};
Frustum = function Frustum(p0, p1, p2, p3, p4, p5) {
    this.planes = [
        p0 !== undefined ? p0 : new Plane(),
        p1 !== undefined ? p1 : new Plane(),
        p2 !== undefined ? p2 : new Plane(),
        p3 !== undefined ? p3 : new Plane(),
        p4 !== undefined ? p4 : new Plane(),
        p5 !== undefined ? p5 : new Plane()
    ];
};
WebGLShadowMap = function WebGLShadowMap(_renderer, _lights, _objects, capabilities) {
    var _gl = _renderer.context, _state = _renderer.state, _frustum = new Frustum(), _projScreenMatrix = new Matrix4(), _lightShadows = _lights.shadows, _shadowMapSize = new Vector2(), _maxShadowMapSize = new Vector2(capabilities.maxTextureSize, capabilities.maxTextureSize), _lookTarget = new Vector3(), _lightPositionWorld = new Vector3(), _renderList = [], _MorphingFlag = 1, _SkinningFlag = 2, _NumberOfMaterialVariants = (_MorphingFlag | _SkinningFlag) + 1, _depthMaterials = new Array(_NumberOfMaterialVariants), _distanceMaterials = new Array(_NumberOfMaterialVariants), _materialCache = {};
    var cubeDirections = [
        new Vector3(1, 0, 0),
        new Vector3(-1, 0, 0),
        new Vector3(0, 0, 1),
        new Vector3(0, 0, -1),
        new Vector3(0, 1, 0),
        new Vector3(0, -1, 0)
    ];
    var cubeUps = [
        new Vector3(0, 1, 0),
        new Vector3(0, 1, 0),
        new Vector3(0, 1, 0),
        new Vector3(0, 1, 0),
        new Vector3(0, 0, 1),
        new Vector3(0, 0, -1)
    ];
    var cube2DViewPorts = [
        new Vector4(),
        new Vector4(),
        new Vector4(),
        new Vector4(),
        new Vector4(),
        new Vector4()
    ];
    var depthMaterialTemplate = new MeshDepthMaterial();
    depthMaterialTemplate.depthPacking = RGBADepthPacking;
    depthMaterialTemplate.clipping = true;
    var distanceShader = ShaderLib['distanceRGBA'];
    var distanceUniforms = exports.UniformsUtils.clone(distanceShader.uniforms);
    for (var i = 0; i !== _NumberOfMaterialVariants; ++i) {
        var useMorphing = (i & _MorphingFlag) !== 0;
        var useSkinning = (i & _SkinningFlag) !== 0;
        var depthMaterial = depthMaterialTemplate.clone();
        depthMaterial.morphTargets = useMorphing;
        depthMaterial.skinning = useSkinning;
        _depthMaterials[i] = depthMaterial;
        var distanceMaterial = new ShaderMaterial({
            defines: {
                'USE_SHADOWMAP': ''
            },
            uniforms: distanceUniforms,
            vertexShader: distanceShader.vertexShader,
            fragmentShader: distanceShader.fragmentShader,
            morphTargets: useMorphing,
            skinning: useSkinning,
            clipping: true
        });
        _distanceMaterials[i] = distanceMaterial;
    }
    var scope = this;
    this.enabled = false;
    this.autoUpdate = true;
    this.needsUpdate = false;
    this.type = PCFShadowMap;
    this.renderReverseSided = true;
    this.renderSingleSided = true;
    this.render = function (scene, camera) {
        if (scope.enabled === false)
            return;
        if (scope.autoUpdate === false && scope.needsUpdate === false)
            return;
        if (_lightShadows.length === 0)
            return;
        _state.clearColor(1, 1, 1, 1);
        _state.disable(_gl.BLEND);
        _state.setDepthTest(true);
        _state.setScissorTest(false);
        var faceCount, isPointLight;
        for (var i = 0, il = _lightShadows.length; i < il; i++) {
            var light = _lightShadows[i];
            var shadow = light.shadow;
            if (shadow === undefined) {
                console.warn('THREE.WebGLShadowMap:', light, 'has no shadow.');
                continue;
            }
            var shadowCamera = shadow.camera;
            _shadowMapSize.copy(shadow.mapSize);
            _shadowMapSize.min(_maxShadowMapSize);
            if (light && light.isPointLight) {
                faceCount = 6;
                isPointLight = true;
                var vpWidth = _shadowMapSize.x;
                var vpHeight = _shadowMapSize.y;
                cube2DViewPorts[0].set(vpWidth * 2, vpHeight, vpWidth, vpHeight);
                cube2DViewPorts[1].set(0, vpHeight, vpWidth, vpHeight);
                cube2DViewPorts[2].set(vpWidth * 3, vpHeight, vpWidth, vpHeight);
                cube2DViewPorts[3].set(vpWidth, vpHeight, vpWidth, vpHeight);
                cube2DViewPorts[4].set(vpWidth * 3, 0, vpWidth, vpHeight);
                cube2DViewPorts[5].set(vpWidth, 0, vpWidth, vpHeight);
                _shadowMapSize.x *= 4;
                _shadowMapSize.y *= 2;
            } else {
                faceCount = 1;
                isPointLight = false;
            }
            if (shadow.map === null) {
                var pars = {
                    minFilter: NearestFilter,
                    magFilter: NearestFilter,
                    format: RGBAFormat
                };
                shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
                shadowCamera.updateProjectionMatrix();
            }
            if (shadow && shadow.isSpotLightShadow) {
                shadow.update(light);
            }
            var shadowMap = shadow.map;
            var shadowMatrix = shadow.matrix;
            _lightPositionWorld.setFromMatrixPosition(light.matrixWorld);
            shadowCamera.position.copy(_lightPositionWorld);
            _renderer.setRenderTarget(shadowMap);
            _renderer.clear();
            for (var face = 0; face < faceCount; face++) {
                if (isPointLight) {
                    _lookTarget.copy(shadowCamera.position);
                    _lookTarget.add(cubeDirections[face]);
                    shadowCamera.up.copy(cubeUps[face]);
                    shadowCamera.lookAt(_lookTarget);
                    var vpDimensions = cube2DViewPorts[face];
                    _state.viewport(vpDimensions);
                } else {
                    _lookTarget.setFromMatrixPosition(light.target.matrixWorld);
                    shadowCamera.lookAt(_lookTarget);
                }
                shadowCamera.updateMatrixWorld();
                shadowCamera.matrixWorldInverse.getInverse(shadowCamera.matrixWorld);
                shadowMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);
                shadowMatrix.multiply(shadowCamera.projectionMatrix);
                shadowMatrix.multiply(shadowCamera.matrixWorldInverse);
                _projScreenMatrix.multiplyMatrices(shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse);
                _frustum.setFromMatrix(_projScreenMatrix);
                _renderList.length = 0;
                projectObject(scene, camera, shadowCamera);
                for (var j = 0, jl = _renderList.length; j < jl; j++) {
                    var object = _renderList[j];
                    var geometry = _objects.update(object);
                    var material = object.material;
                    if (material && material.isMultiMaterial) {
                        var groups = geometry.groups;
                        var materials = material.materials;
                        for (var k = 0, kl = groups.length; k < kl; k++) {
                            var group = groups[k];
                            var groupMaterial = materials[group.materialIndex];
                            if (groupMaterial.visible === true) {
                                var depthMaterial = getDepthMaterial(object, groupMaterial, isPointLight, _lightPositionWorld);
                                _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, group);
                            }
                        }
                    } else {
                        var depthMaterial = getDepthMaterial(object, material, isPointLight, _lightPositionWorld);
                        _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, null);
                    }
                }
            }
        }
        var clearColor = _renderer.getClearColor(), clearAlpha = _renderer.getClearAlpha();
        _renderer.setClearColor(clearColor, clearAlpha);
        scope.needsUpdate = false;
    };
    function getDepthMaterial(object, material, isPointLight, lightPositionWorld) {
        var geometry = object.geometry;
        var result = null;
        var materialVariants = _depthMaterials;
        var customMaterial = object.customDepthMaterial;
        if (isPointLight) {
            materialVariants = _distanceMaterials;
            customMaterial = object.customDistanceMaterial;
        }
        if (!customMaterial) {
            var useMorphing = false;
            if (material.morphTargets) {
                if (geometry && geometry.isBufferGeometry) {
                    useMorphing = geometry.morphAttributes && geometry.morphAttributes.position && geometry.morphAttributes.position.length > 0;
                } else if (geometry && geometry.isGeometry) {
                    useMorphing = geometry.morphTargets && geometry.morphTargets.length > 0;
                }
            }
            var useSkinning = object.isSkinnedMesh && material.skinning;
            var variantIndex = 0;
            if (useMorphing)
                variantIndex |= _MorphingFlag;
            if (useSkinning)
                variantIndex |= _SkinningFlag;
            result = materialVariants[variantIndex];
        } else {
            result = customMaterial;
        }
        if (_renderer.localClippingEnabled && material.clipShadows === true && material.clippingPlanes.length !== 0) {
            var keyA = result.uuid, keyB = material.uuid;
            var materialsForVariant = _materialCache[keyA];
            if (materialsForVariant === undefined) {
                materialsForVariant = {};
                _materialCache[keyA] = materialsForVariant;
            }
            var cachedMaterial = materialsForVariant[keyB];
            if (cachedMaterial === undefined) {
                cachedMaterial = result.clone();
                materialsForVariant[keyB] = cachedMaterial;
            }
            result = cachedMaterial;
        }
        result.visible = material.visible;
        result.wireframe = material.wireframe;
        var side = material.side;
        if (scope.renderSingleSided && side == DoubleSide) {
            side = FrontSide;
        }
        if (scope.renderReverseSided) {
            if (side === FrontSide)
                side = BackSide;
            else if (side === BackSide)
                side = FrontSide;
        }
        result.side = side;
        result.clipShadows = material.clipShadows;
        result.clippingPlanes = material.clippingPlanes;
        result.wireframeLinewidth = material.wireframeLinewidth;
        result.linewidth = material.linewidth;
        if (isPointLight && result.uniforms.lightPos !== undefined) {
            result.uniforms.lightPos.value.copy(lightPositionWorld);
        }
        return result;
    }
    function projectObject(object, camera, shadowCamera) {
        if (object.visible === false)
            return;
        var visible = (object.layers.mask & camera.layers.mask) !== 0;
        if (visible && (object.isMesh || object.isLine || object.isPoints)) {
            if (object.castShadow && (object.frustumCulled === false || _frustum.intersectsObject(object) === true)) {
                var material = object.material;
                if (material.visible === true) {
                    object.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse, object.matrixWorld);
                    _renderList.push(object);
                }
            }
        }
        var children = object.children;
        for (var i = 0, l = children.length; i < l; i++) {
            projectObject(children[i], camera, shadowCamera);
        }
    }
};
addLineNumbers = function addLineNumbers(string) {
    var lines = string.split('\n');
    for (var i = 0; i < lines.length; i++) {
        lines[i] = i + 1 + ': ' + lines[i];
    }
    return lines.join('\n');
};
WebGLShader = function WebGLShader(gl, type, string) {
    var shader = gl.createShader(type);
    gl.shaderSource(shader, string);
    gl.compileShader(shader);
    if (gl.getShaderParameter(shader, gl.COMPILE_STATUS) === false) {
        console.error('THREE.WebGLShader: Shader couldn\'t compile.');
    }
    if (gl.getShaderInfoLog(shader) !== '') {
        console.warn('THREE.WebGLShader: gl.getShaderInfoLog()', type === gl.VERTEX_SHADER ? 'vertex' : 'fragment', gl.getShaderInfoLog(shader), addLineNumbers(string));
    }
    return shader;
};
WebGLProperties = function WebGLProperties() {
    var properties = {};
    return {
        get: function (object) {
            var uuid = object.uuid;
            var map = properties[uuid];
            if (map === undefined) {
                map = {};
                properties[uuid] = map;
            }
            return map;
        },
        delete: function (object) {
            delete properties[object.uuid];
        },
        clear: function () {
            properties = {};
        }
    };
};
getEncodingComponents = function getEncodingComponents(encoding) {
    switch (encoding) {
    case LinearEncoding:
        return [
            'Linear',
            '( value )'
        ];
    case sRGBEncoding:
        return [
            'sRGB',
            '( value )'
        ];
    case RGBEEncoding:
        return [
            'RGBE',
            '( value )'
        ];
    case RGBM7Encoding:
        return [
            'RGBM',
            '( value, 7.0 )'
        ];
    case RGBM16Encoding:
        return [
            'RGBM',
            '( value, 16.0 )'
        ];
    case RGBDEncoding:
        return [
            'RGBD',
            '( value, 256.0 )'
        ];
    case GammaEncoding:
        return [
            'Gamma',
            '( value, float( GAMMA_FACTOR ) )'
        ];
    default:
        throw new Error('unsupported encoding: ' + encoding);
    }
};
getTexelDecodingFunction = function getTexelDecodingFunction(functionName, encoding) {
    var components = getEncodingComponents(encoding);
    return 'vec4 ' + functionName + '( vec4 value ) { return ' + components[0] + 'ToLinear' + components[1] + '; }';
};
getTexelEncodingFunction = function getTexelEncodingFunction(functionName, encoding) {
    var components = getEncodingComponents(encoding);
    return 'vec4 ' + functionName + '( vec4 value ) { return LinearTo' + components[0] + components[1] + '; }';
};
getToneMappingFunction = function getToneMappingFunction(functionName, toneMapping) {
    var toneMappingName;
    switch (toneMapping) {
    case LinearToneMapping:
        toneMappingName = 'Linear';
        break;
    case ReinhardToneMapping:
        toneMappingName = 'Reinhard';
        break;
    case Uncharted2ToneMapping:
        toneMappingName = 'Uncharted2';
        break;
    case CineonToneMapping:
        toneMappingName = 'OptimizedCineon';
        break;
    default:
        throw new Error('unsupported toneMapping: ' + toneMapping);
    }
    return 'vec3 ' + functionName + '( vec3 color ) { return ' + toneMappingName + 'ToneMapping( color ); }';
};
generateExtensions = function generateExtensions(extensions, parameters, rendererExtensions) {
    extensions = extensions || {};
    var chunks = [
        extensions.derivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.normalMap || parameters.flatShading ? '#extension GL_OES_standard_derivatives : enable' : '',
        (extensions.fragDepth || parameters.logarithmicDepthBuffer) && rendererExtensions.get('EXT_frag_depth') ? '#extension GL_EXT_frag_depth : enable' : '',
        extensions.drawBuffers && rendererExtensions.get('WEBGL_draw_buffers') ? '#extension GL_EXT_draw_buffers : require' : '',
        (extensions.shaderTextureLOD || parameters.envMap) && rendererExtensions.get('EXT_shader_texture_lod') ? '#extension GL_EXT_shader_texture_lod : enable' : ''
    ];
    return chunks.filter(filterEmptyLine).join('\n');
};
generateDefines = function generateDefines(defines) {
    var chunks = [];
    for (var name in defines) {
        var value = defines[name];
        if (value === false)
            continue;
        chunks.push('#define ' + name + ' ' + value);
    }
    return chunks.join('\n');
};
fetchAttributeLocations = function fetchAttributeLocations(gl, program, identifiers) {
    var attributes = {};
    var n = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
    for (var i = 0; i < n; i++) {
        var info = gl.getActiveAttrib(program, i);
        var name = info.name;
        attributes[name] = gl.getAttribLocation(program, name);
    }
    return attributes;
};
filterEmptyLine = function filterEmptyLine(string) {
    return string !== '';
};
replaceLightNums = function replaceLightNums(string, parameters) {
    return string.replace(/NUM_DIR_LIGHTS/g, parameters.numDirLights).replace(/NUM_SPOT_LIGHTS/g, parameters.numSpotLights).replace(/NUM_POINT_LIGHTS/g, parameters.numPointLights).replace(/NUM_HEMI_LIGHTS/g, parameters.numHemiLights);
};
parseIncludes = function parseIncludes(string) {
    var pattern = /#include +<([\w\d.]+)>/g;
    function replace(match, include) {
        var replace = ShaderChunk[include];
        if (replace === undefined) {
            throw new Error('Can not resolve #include <' + include + '>');
        }
        return parseIncludes(replace);
    }
    return string.replace(pattern, replace);
};
unrollLoops = function unrollLoops(string) {
    var pattern = /for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;
    function replace(match, start, end, snippet) {
        var unroll = '';
        for (var i = parseInt(start); i < parseInt(end); i++) {
            unroll += snippet.replace(/\[ i \]/g, '[ ' + i + ' ]');
        }
        return unroll;
    }
    return string.replace(pattern, replace);
};
WebGLProgram = function WebGLProgram(renderer, code, material, parameters) {
    var gl = renderer.context;
    var extensions = material.extensions;
    var defines = material.defines;
    var vertexShader = material.__webglShader.vertexShader;
    var fragmentShader = material.__webglShader.fragmentShader;
    var shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';
    if (parameters.shadowMapType === PCFShadowMap) {
        shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';
    } else if (parameters.shadowMapType === PCFSoftShadowMap) {
        shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';
    }
    var envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
    var envMapModeDefine = 'ENVMAP_MODE_REFLECTION';
    var envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
    if (parameters.envMap) {
        switch (material.envMap.mapping) {
        case CubeReflectionMapping:
        case CubeRefractionMapping:
            envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
            break;
        case CubeUVReflectionMapping:
        case CubeUVRefractionMapping:
            envMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';
            break;
        case EquirectangularReflectionMapping:
        case EquirectangularRefractionMapping:
            envMapTypeDefine = 'ENVMAP_TYPE_EQUIREC';
            break;
        case SphericalReflectionMapping:
            envMapTypeDefine = 'ENVMAP_TYPE_SPHERE';
            break;
        }
        switch (material.envMap.mapping) {
        case CubeRefractionMapping:
        case EquirectangularRefractionMapping:
            envMapModeDefine = 'ENVMAP_MODE_REFRACTION';
            break;
        }
        switch (material.combine) {
        case MultiplyOperation:
            envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
            break;
        case MixOperation:
            envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';
            break;
        case AddOperation:
            envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';
            break;
        }
    }
    var gammaFactorDefine = renderer.gammaFactor > 0 ? renderer.gammaFactor : 1;
    var customExtensions = generateExtensions(extensions, parameters, renderer.extensions);
    var customDefines = generateDefines(defines);
    var program = gl.createProgram();
    var prefixVertex, prefixFragment;
    if (material.isRawShaderMaterial) {
        prefixVertex = [
            customDefines,
            '\n'
        ].filter(filterEmptyLine).join('\n');
        prefixFragment = [
            customExtensions,
            customDefines,
            '\n'
        ].filter(filterEmptyLine).join('\n');
    } else {
        prefixVertex = [
            'precision ' + parameters.precision + ' float;',
            'precision ' + parameters.precision + ' int;',
            '#define SHADER_NAME ' + material.__webglShader.name,
            customDefines,
            parameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',
            '#define GAMMA_FACTOR ' + gammaFactorDefine,
            '#define MAX_BONES ' + parameters.maxBones,
            parameters.map ? '#define USE_MAP' : '',
            parameters.envMap ? '#define USE_ENVMAP' : '',
            parameters.envMap ? '#define ' + envMapModeDefine : '',
            parameters.lightMap ? '#define USE_LIGHTMAP' : '',
            parameters.aoMap ? '#define USE_AOMAP' : '',
            parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
            parameters.bumpMap ? '#define USE_BUMPMAP' : '',
            parameters.normalMap ? '#define USE_NORMALMAP' : '',
            parameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '',
            parameters.specularMap ? '#define USE_SPECULARMAP' : '',
            parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
            parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
            parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
            parameters.vertexColors ? '#define USE_COLOR' : '',
            parameters.flatShading ? '#define FLAT_SHADED' : '',
            parameters.skinning ? '#define USE_SKINNING' : '',
            parameters.useVertexTexture ? '#define BONE_TEXTURE' : '',
            parameters.morphTargets ? '#define USE_MORPHTARGETS' : '',
            parameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '',
            parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
            parameters.flipSided ? '#define FLIP_SIDED' : '',
            '#define NUM_CLIPPING_PLANES ' + parameters.numClippingPlanes,
            parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
            parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',
            parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',
            parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
            parameters.logarithmicDepthBuffer && renderer.extensions.get('EXT_frag_depth') ? '#define USE_LOGDEPTHBUF_EXT' : '',
            'uniform mat4 modelMatrix;',
            'uniform mat4 modelViewMatrix;',
            'uniform mat4 projectionMatrix;',
            'uniform mat4 viewMatrix;',
            'uniform mat3 normalMatrix;',
            'uniform vec3 cameraPosition;',
            'attribute vec3 position;',
            'attribute vec3 normal;',
            'attribute vec2 uv;',
            '#ifdef USE_COLOR',
            '\tattribute vec3 color;',
            '#endif',
            '#ifdef USE_MORPHTARGETS',
            '\tattribute vec3 morphTarget0;',
            '\tattribute vec3 morphTarget1;',
            '\tattribute vec3 morphTarget2;',
            '\tattribute vec3 morphTarget3;',
            '\t#ifdef USE_MORPHNORMALS',
            '\t\tattribute vec3 morphNormal0;',
            '\t\tattribute vec3 morphNormal1;',
            '\t\tattribute vec3 morphNormal2;',
            '\t\tattribute vec3 morphNormal3;',
            '\t#else',
            '\t\tattribute vec3 morphTarget4;',
            '\t\tattribute vec3 morphTarget5;',
            '\t\tattribute vec3 morphTarget6;',
            '\t\tattribute vec3 morphTarget7;',
            '\t#endif',
            '#endif',
            '#ifdef USE_SKINNING',
            '\tattribute vec4 skinIndex;',
            '\tattribute vec4 skinWeight;',
            '#endif',
            '\n'
        ].filter(filterEmptyLine).join('\n');
        prefixFragment = [
            customExtensions,
            'precision ' + parameters.precision + ' float;',
            'precision ' + parameters.precision + ' int;',
            '#define SHADER_NAME ' + material.__webglShader.name,
            customDefines,
            parameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest : '',
            '#define GAMMA_FACTOR ' + gammaFactorDefine,
            parameters.useFog && parameters.fog ? '#define USE_FOG' : '',
            parameters.useFog && parameters.fogExp ? '#define FOG_EXP2' : '',
            parameters.map ? '#define USE_MAP' : '',
            parameters.envMap ? '#define USE_ENVMAP' : '',
            parameters.envMap ? '#define ' + envMapTypeDefine : '',
            parameters.envMap ? '#define ' + envMapModeDefine : '',
            parameters.envMap ? '#define ' + envMapBlendingDefine : '',
            parameters.lightMap ? '#define USE_LIGHTMAP' : '',
            parameters.aoMap ? '#define USE_AOMAP' : '',
            parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
            parameters.bumpMap ? '#define USE_BUMPMAP' : '',
            parameters.normalMap ? '#define USE_NORMALMAP' : '',
            parameters.specularMap ? '#define USE_SPECULARMAP' : '',
            parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
            parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
            parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
            parameters.vertexColors ? '#define USE_COLOR' : '',
            parameters.flatShading ? '#define FLAT_SHADED' : '',
            parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
            parameters.flipSided ? '#define FLIP_SIDED' : '',
            '#define NUM_CLIPPING_PLANES ' + parameters.numClippingPlanes,
            parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
            parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',
            parameters.premultipliedAlpha ? '#define PREMULTIPLIED_ALPHA' : '',
            parameters.physicallyCorrectLights ? '#define PHYSICALLY_CORRECT_LIGHTS' : '',
            parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
            parameters.logarithmicDepthBuffer && renderer.extensions.get('EXT_frag_depth') ? '#define USE_LOGDEPTHBUF_EXT' : '',
            parameters.envMap && renderer.extensions.get('EXT_shader_texture_lod') ? '#define TEXTURE_LOD_EXT' : '',
            'uniform mat4 viewMatrix;',
            'uniform vec3 cameraPosition;',
            parameters.toneMapping !== NoToneMapping ? '#define TONE_MAPPING' : '',
            parameters.toneMapping !== NoToneMapping ? ShaderChunk['tonemapping_pars_fragment'] : '',
            parameters.toneMapping !== NoToneMapping ? getToneMappingFunction('toneMapping', parameters.toneMapping) : '',
            parameters.outputEncoding || parameters.mapEncoding || parameters.envMapEncoding || parameters.emissiveMapEncoding ? ShaderChunk['encodings_pars_fragment'] : '',
            parameters.mapEncoding ? getTexelDecodingFunction('mapTexelToLinear', parameters.mapEncoding) : '',
            parameters.envMapEncoding ? getTexelDecodingFunction('envMapTexelToLinear', parameters.envMapEncoding) : '',
            parameters.emissiveMapEncoding ? getTexelDecodingFunction('emissiveMapTexelToLinear', parameters.emissiveMapEncoding) : '',
            parameters.outputEncoding ? getTexelEncodingFunction('linearToOutputTexel', parameters.outputEncoding) : '',
            parameters.depthPacking ? '#define DEPTH_PACKING ' + material.depthPacking : '',
            '\n'
        ].filter(filterEmptyLine).join('\n');
    }
    vertexShader = parseIncludes(vertexShader, parameters);
    vertexShader = replaceLightNums(vertexShader, parameters);
    fragmentShader = parseIncludes(fragmentShader, parameters);
    fragmentShader = replaceLightNums(fragmentShader, parameters);
    if (!material.isShaderMaterial) {
        vertexShader = unrollLoops(vertexShader);
        fragmentShader = unrollLoops(fragmentShader);
    }
    var vertexGlsl = prefixVertex + vertexShader;
    var fragmentGlsl = prefixFragment + fragmentShader;
    var glVertexShader = WebGLShader(gl, gl.VERTEX_SHADER, vertexGlsl);
    var glFragmentShader = WebGLShader(gl, gl.FRAGMENT_SHADER, fragmentGlsl);
    gl.attachShader(program, glVertexShader);
    gl.attachShader(program, glFragmentShader);
    if (material.index0AttributeName !== undefined) {
        gl.bindAttribLocation(program, 0, material.index0AttributeName);
    } else if (parameters.morphTargets === true) {
        gl.bindAttribLocation(program, 0, 'position');
    }
    gl.linkProgram(program);
    var programLog = gl.getProgramInfoLog(program);
    var vertexLog = gl.getShaderInfoLog(glVertexShader);
    var fragmentLog = gl.getShaderInfoLog(glFragmentShader);
    var runnable = true;
    var haveDiagnostics = true;
    if (gl.getProgramParameter(program, gl.LINK_STATUS) === false) {
        runnable = false;
        console.error('THREE.WebGLProgram: shader error: ', gl.getError(), 'gl.VALIDATE_STATUS', gl.getProgramParameter(program, gl.VALIDATE_STATUS), 'gl.getProgramInfoLog', programLog, vertexLog, fragmentLog);
    } else if (programLog !== '') {
        console.warn('THREE.WebGLProgram: gl.getProgramInfoLog()', programLog);
    } else if (vertexLog === '' || fragmentLog === '') {
        haveDiagnostics = false;
    }
    if (haveDiagnostics) {
        this.diagnostics = {
            runnable: runnable,
            material: material,
            programLog: programLog,
            vertexShader: {
                log: vertexLog,
                prefix: prefixVertex
            },
            fragmentShader: {
                log: fragmentLog,
                prefix: prefixFragment
            }
        };
    }
    gl.deleteShader(glVertexShader);
    gl.deleteShader(glFragmentShader);
    var cachedUniforms;
    this.getUniforms = function () {
        if (cachedUniforms === undefined) {
            cachedUniforms = new WebGLUniforms(gl, program, renderer);
        }
        return cachedUniforms;
    };
    var cachedAttributes;
    this.getAttributes = function () {
        if (cachedAttributes === undefined) {
            cachedAttributes = fetchAttributeLocations(gl, program);
        }
        return cachedAttributes;
    };
    this.destroy = function () {
        gl.deleteProgram(program);
        this.program = undefined;
    };
    Object.defineProperties(this, {
        uniforms: {
            get: function () {
                console.warn('THREE.WebGLProgram: .uniforms is now .getUniforms().');
                return this.getUniforms();
            }
        },
        attributes: {
            get: function () {
                console.warn('THREE.WebGLProgram: .attributes is now .getAttributes().');
                return this.getAttributes();
            }
        }
    });
    this.id = programIdCount++;
    this.code = code;
    this.usedTimes = 1;
    this.program = program;
    this.vertexShader = glVertexShader;
    this.fragmentShader = glFragmentShader;
    return this;
};
WebGLPrograms = function WebGLPrograms(renderer, capabilities) {
    var programs = [];
    var shaderIDs = {
        MeshDepthMaterial: 'depth',
        MeshNormalMaterial: 'normal',
        MeshBasicMaterial: 'basic',
        MeshLambertMaterial: 'lambert',
        MeshPhongMaterial: 'phong',
        MeshStandardMaterial: 'physical',
        MeshPhysicalMaterial: 'physical',
        LineBasicMaterial: 'basic',
        LineDashedMaterial: 'dashed',
        PointsMaterial: 'points'
    };
    var parameterNames = [
        'precision',
        'supportsVertexTextures',
        'map',
        'mapEncoding',
        'envMap',
        'envMapMode',
        'envMapEncoding',
        'lightMap',
        'aoMap',
        'emissiveMap',
        'emissiveMapEncoding',
        'bumpMap',
        'normalMap',
        'displacementMap',
        'specularMap',
        'roughnessMap',
        'metalnessMap',
        'alphaMap',
        'combine',
        'vertexColors',
        'fog',
        'useFog',
        'fogExp',
        'flatShading',
        'sizeAttenuation',
        'logarithmicDepthBuffer',
        'skinning',
        'maxBones',
        'useVertexTexture',
        'morphTargets',
        'morphNormals',
        'maxMorphTargets',
        'maxMorphNormals',
        'premultipliedAlpha',
        'numDirLights',
        'numPointLights',
        'numSpotLights',
        'numHemiLights',
        'shadowMapEnabled',
        'shadowMapType',
        'toneMapping',
        'physicallyCorrectLights',
        'alphaTest',
        'doubleSided',
        'flipSided',
        'numClippingPlanes',
        'depthPacking'
    ];
    function allocateBones(object) {
        if (capabilities.floatVertexTextures && object && object.skeleton && object.skeleton.useVertexTexture) {
            return 1024;
        } else {
            var nVertexUniforms = capabilities.maxVertexUniforms;
            var nVertexMatrices = Math.floor((nVertexUniforms - 20) / 4);
            var maxBones = nVertexMatrices;
            if (object !== undefined && (object && object.isSkinnedMesh)) {
                maxBones = Math.min(object.skeleton.bones.length, maxBones);
                if (maxBones < object.skeleton.bones.length) {
                    console.warn('WebGLRenderer: too many bones - ' + object.skeleton.bones.length + ', this GPU supports just ' + maxBones + ' (try OpenGL instead of ANGLE)');
                }
            }
            return maxBones;
        }
    }
    function getTextureEncodingFromMap(map, gammaOverrideLinear) {
        var encoding;
        if (!map) {
            encoding = LinearEncoding;
        } else if (map && map.isTexture) {
            encoding = map.encoding;
        } else if (map && map.isWebGLRenderTarget) {
            console.warn('THREE.WebGLPrograms.getTextureEncodingFromMap: don\'t use render targets as textures. Use their .texture property instead.');
            encoding = map.texture.encoding;
        }
        if (encoding === LinearEncoding && gammaOverrideLinear) {
            encoding = GammaEncoding;
        }
        return encoding;
    }
    this.getParameters = function (material, lights, fog, nClipPlanes, object) {
        var shaderID = shaderIDs[material.type];
        var maxBones = allocateBones(object);
        var precision = renderer.getPrecision();
        if (material.precision !== null) {
            precision = capabilities.getMaxPrecision(material.precision);
            if (precision !== material.precision) {
                console.warn('THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.');
            }
        }
        var currentRenderTarget = renderer.getCurrentRenderTarget();
        var parameters = {
            shaderID: shaderID,
            precision: precision,
            supportsVertexTextures: capabilities.vertexTextures,
            outputEncoding: getTextureEncodingFromMap(!currentRenderTarget ? null : currentRenderTarget.texture, renderer.gammaOutput),
            map: !!material.map,
            mapEncoding: getTextureEncodingFromMap(material.map, renderer.gammaInput),
            envMap: !!material.envMap,
            envMapMode: material.envMap && material.envMap.mapping,
            envMapEncoding: getTextureEncodingFromMap(material.envMap, renderer.gammaInput),
            envMapCubeUV: !!material.envMap && (material.envMap.mapping === CubeUVReflectionMapping || material.envMap.mapping === CubeUVRefractionMapping),
            lightMap: !!material.lightMap,
            aoMap: !!material.aoMap,
            emissiveMap: !!material.emissiveMap,
            emissiveMapEncoding: getTextureEncodingFromMap(material.emissiveMap, renderer.gammaInput),
            bumpMap: !!material.bumpMap,
            normalMap: !!material.normalMap,
            displacementMap: !!material.displacementMap,
            roughnessMap: !!material.roughnessMap,
            metalnessMap: !!material.metalnessMap,
            specularMap: !!material.specularMap,
            alphaMap: !!material.alphaMap,
            combine: material.combine,
            vertexColors: material.vertexColors,
            fog: !!fog,
            useFog: material.fog,
            fogExp: fog && fog.isFogExp2,
            flatShading: material.shading === FlatShading,
            sizeAttenuation: material.sizeAttenuation,
            logarithmicDepthBuffer: capabilities.logarithmicDepthBuffer,
            skinning: material.skinning,
            maxBones: maxBones,
            useVertexTexture: capabilities.floatVertexTextures && object && object.skeleton && object.skeleton.useVertexTexture,
            morphTargets: material.morphTargets,
            morphNormals: material.morphNormals,
            maxMorphTargets: renderer.maxMorphTargets,
            maxMorphNormals: renderer.maxMorphNormals,
            numDirLights: lights.directional.length,
            numPointLights: lights.point.length,
            numSpotLights: lights.spot.length,
            numHemiLights: lights.hemi.length,
            numClippingPlanes: nClipPlanes,
            shadowMapEnabled: renderer.shadowMap.enabled && object.receiveShadow && lights.shadows.length > 0,
            shadowMapType: renderer.shadowMap.type,
            toneMapping: renderer.toneMapping,
            physicallyCorrectLights: renderer.physicallyCorrectLights,
            premultipliedAlpha: material.premultipliedAlpha,
            alphaTest: material.alphaTest,
            doubleSided: material.side === DoubleSide,
            flipSided: material.side === BackSide,
            depthPacking: material.depthPacking !== undefined ? material.depthPacking : false
        };
        return parameters;
    };
    this.getProgramCode = function (material, parameters) {
        var array = [];
        if (parameters.shaderID) {
            array.push(parameters.shaderID);
        } else {
            array.push(material.fragmentShader);
            array.push(material.vertexShader);
        }
        if (material.defines !== undefined) {
            for (var name in material.defines) {
                array.push(name);
                array.push(material.defines[name]);
            }
        }
        for (var i = 0; i < parameterNames.length; i++) {
            array.push(parameters[parameterNames[i]]);
        }
        return array.join();
    };
    this.acquireProgram = function (material, parameters, code) {
        var program;
        for (var p = 0, pl = programs.length; p < pl; p++) {
            var programInfo = programs[p];
            if (programInfo.code === code) {
                program = programInfo;
                ++program.usedTimes;
                break;
            }
        }
        if (program === undefined) {
            program = new WebGLProgram(renderer, code, material, parameters);
            programs.push(program);
        }
        return program;
    };
    this.releaseProgram = function (program) {
        if (--program.usedTimes === 0) {
            var i = programs.indexOf(program);
            programs[i] = programs[programs.length - 1];
            programs.pop();
            program.destroy();
        }
    };
    this.programs = programs;
};
BufferAttribute = function BufferAttribute(array, itemSize, normalized) {
    if (Array.isArray(array)) {
        throw new TypeError('THREE.BufferAttribute: array should be a Typed Array.');
    }
    this.uuid = exports.Math.generateUUID();
    this.array = array;
    this.itemSize = itemSize;
    this.normalized = normalized === true;
    this.dynamic = false;
    this.updateRange = {
        offset: 0,
        count: -1
    };
    this.version = 0;
};
Int8Attribute = function Int8Attribute(array, itemSize) {
    return new BufferAttribute(new Int8Array(array), itemSize);
};
Uint8Attribute = function Uint8Attribute(array, itemSize) {
    return new BufferAttribute(new Uint8Array(array), itemSize);
};
Uint8ClampedAttribute = function Uint8ClampedAttribute(array, itemSize) {
    return new BufferAttribute(new Uint8ClampedArray(array), itemSize);
};
Int16Attribute = function Int16Attribute(array, itemSize) {
    return new BufferAttribute(new Int16Array(array), itemSize);
};
Uint16Attribute = function Uint16Attribute(array, itemSize) {
    return new BufferAttribute(new Uint16Array(array), itemSize);
};
Int32Attribute = function Int32Attribute(array, itemSize) {
    return new BufferAttribute(new Int32Array(array), itemSize);
};
Uint32Attribute = function Uint32Attribute(array, itemSize) {
    return new BufferAttribute(new Uint32Array(array), itemSize);
};
Float32Attribute = function Float32Attribute(array, itemSize) {
    return new BufferAttribute(new Float32Array(array), itemSize);
};
Float64Attribute = function Float64Attribute(array, itemSize) {
    return new BufferAttribute(new Float64Array(array), itemSize);
};
DynamicBufferAttribute = function DynamicBufferAttribute(array, itemSize) {
    console.warn('THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead.');
    return new BufferAttribute(array, itemSize).setDynamic(true);
};
Face3 = function Face3(a, b, c, normal, color, materialIndex) {
    this.a = a;
    this.b = b;
    this.c = c;
    this.normal = normal && normal.isVector3 ? normal : new Vector3();
    this.vertexNormals = Array.isArray(normal) ? normal : [];
    this.color = color && color.isColor ? color : new Color();
    this.vertexColors = Array.isArray(color) ? color : [];
    this.materialIndex = materialIndex !== undefined ? materialIndex : 0;
};
Euler = function Euler(x, y, z, order) {
    this._x = x || 0;
    this._y = y || 0;
    this._z = z || 0;
    this._order = order || Euler.DefaultOrder;
};
Layers = function Layers() {
    this.mask = 1;
};
Object3D = function Object3D() {
    Object.defineProperty(this, 'id', {
        value: Object3DIdCount()
    });
    this.uuid = exports.Math.generateUUID();
    this.name = '';
    this.type = 'Object3D';
    this.parent = null;
    this.children = [];
    this.up = Object3D.DefaultUp.clone();
    var position = new Vector3();
    var rotation = new Euler();
    var quaternion = new Quaternion();
    var scale = new Vector3(1, 1, 1);
    function onRotationChange() {
        quaternion.setFromEuler(rotation, false);
    }
    function onQuaternionChange() {
        rotation.setFromQuaternion(quaternion, undefined, false);
    }
    rotation.onChange(onRotationChange);
    quaternion.onChange(onQuaternionChange);
    Object.defineProperties(this, {
        position: {
            enumerable: true,
            value: position
        },
        rotation: {
            enumerable: true,
            value: rotation
        },
        quaternion: {
            enumerable: true,
            value: quaternion
        },
        scale: {
            enumerable: true,
            value: scale
        },
        modelViewMatrix: {
            value: new Matrix4()
        },
        normalMatrix: {
            value: new Matrix3()
        }
    });
    this.matrix = new Matrix4();
    this.matrixWorld = new Matrix4();
    this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;
    this.matrixWorldNeedsUpdate = false;
    this.layers = new Layers();
    this.visible = true;
    this.castShadow = false;
    this.receiveShadow = false;
    this.frustumCulled = true;
    this.renderOrder = 0;
    this.userData = {};
};
Object3DIdCount = function Object3DIdCount() {
    return count$3++;
};
Geometry = function Geometry() {
    Object.defineProperty(this, 'id', {
        value: GeometryIdCount()
    });
    this.uuid = exports.Math.generateUUID();
    this.name = '';
    this.type = 'Geometry';
    this.vertices = [];
    this.colors = [];
    this.faces = [];
    this.faceVertexUvs = [[]];
    this.morphTargets = [];
    this.morphNormals = [];
    this.skinWeights = [];
    this.skinIndices = [];
    this.lineDistances = [];
    this.boundingBox = null;
    this.boundingSphere = null;
    this.elementsNeedUpdate = false;
    this.verticesNeedUpdate = false;
    this.uvsNeedUpdate = false;
    this.normalsNeedUpdate = false;
    this.colorsNeedUpdate = false;
    this.lineDistancesNeedUpdate = false;
    this.groupsNeedUpdate = false;
};
GeometryIdCount = function GeometryIdCount() {
    return count$2++;
};
DirectGeometry = function DirectGeometry() {
    Object.defineProperty(this, 'id', {
        value: GeometryIdCount()
    });
    this.uuid = exports.Math.generateUUID();
    this.name = '';
    this.type = 'DirectGeometry';
    this.indices = [];
    this.vertices = [];
    this.normals = [];
    this.colors = [];
    this.uvs = [];
    this.uvs2 = [];
    this.groups = [];
    this.morphTargets = {};
    this.skinWeights = [];
    this.skinIndices = [];
    this.boundingBox = null;
    this.boundingSphere = null;
    this.verticesNeedUpdate = false;
    this.normalsNeedUpdate = false;
    this.colorsNeedUpdate = false;
    this.uvsNeedUpdate = false;
    this.groupsNeedUpdate = false;
};
BufferGeometry = function BufferGeometry() {
    Object.defineProperty(this, 'id', {
        value: GeometryIdCount()
    });
    this.uuid = exports.Math.generateUUID();
    this.name = '';
    this.type = 'BufferGeometry';
    this.index = null;
    this.attributes = {};
    this.morphAttributes = {};
    this.groups = [];
    this.boundingBox = null;
    this.boundingSphere = null;
    this.drawRange = {
        start: 0,
        count: Infinity
    };
};
WebGLGeometries = function WebGLGeometries(gl, properties, info) {
    var geometries = {};
    function onGeometryDispose(event) {
        var geometry = event.target;
        var buffergeometry = geometries[geometry.id];
        if (buffergeometry.index !== null) {
            deleteAttribute(buffergeometry.index);
        }
        deleteAttributes(buffergeometry.attributes);
        geometry.removeEventListener('dispose', onGeometryDispose);
        delete geometries[geometry.id];
        var property = properties.get(geometry);
        if (property.wireframe) {
            deleteAttribute(property.wireframe);
        }
        properties.delete(geometry);
        var bufferproperty = properties.get(buffergeometry);
        if (bufferproperty.wireframe) {
            deleteAttribute(bufferproperty.wireframe);
        }
        properties.delete(buffergeometry);
        info.memory.geometries--;
    }
    function getAttributeBuffer(attribute) {
        if (attribute.isInterleavedBufferAttribute) {
            return properties.get(attribute.data).__webglBuffer;
        }
        return properties.get(attribute).__webglBuffer;
    }
    function deleteAttribute(attribute) {
        var buffer = getAttributeBuffer(attribute);
        if (buffer !== undefined) {
            gl.deleteBuffer(buffer);
            removeAttributeBuffer(attribute);
        }
    }
    function deleteAttributes(attributes) {
        for (var name in attributes) {
            deleteAttribute(attributes[name]);
        }
    }
    function removeAttributeBuffer(attribute) {
        if (attribute.isInterleavedBufferAttribute) {
            properties.delete(attribute.data);
        } else {
            properties.delete(attribute);
        }
    }
    return {
        get: function (object) {
            var geometry = object.geometry;
            if (geometries[geometry.id] !== undefined) {
                return geometries[geometry.id];
            }
            geometry.addEventListener('dispose', onGeometryDispose);
            var buffergeometry;
            if (geometry.isBufferGeometry) {
                buffergeometry = geometry;
            } else if (geometry.isGeometry) {
                if (geometry._bufferGeometry === undefined) {
                    geometry._bufferGeometry = new BufferGeometry().setFromObject(object);
                }
                buffergeometry = geometry._bufferGeometry;
            }
            geometries[geometry.id] = buffergeometry;
            info.memory.geometries++;
            return buffergeometry;
        }
    };
};
WebGLObjects = function WebGLObjects(gl, properties, info) {
    var geometries = new WebGLGeometries(gl, properties, info);
    function update(object) {
        var geometry = geometries.get(object);
        if (object.geometry.isGeometry) {
            geometry.updateFromObject(object);
        }
        var index = geometry.index;
        var attributes = geometry.attributes;
        if (index !== null) {
            updateAttribute(index, gl.ELEMENT_ARRAY_BUFFER);
        }
        for (var name in attributes) {
            updateAttribute(attributes[name], gl.ARRAY_BUFFER);
        }
        var morphAttributes = geometry.morphAttributes;
        for (var name in morphAttributes) {
            var array = morphAttributes[name];
            for (var i = 0, l = array.length; i < l; i++) {
                updateAttribute(array[i], gl.ARRAY_BUFFER);
            }
        }
        return geometry;
    }
    function updateAttribute(attribute, bufferType) {
        var data = attribute.isInterleavedBufferAttribute ? attribute.data : attribute;
        var attributeProperties = properties.get(data);
        if (attributeProperties.__webglBuffer === undefined) {
            createBuffer(attributeProperties, data, bufferType);
        } else if (attributeProperties.version !== data.version) {
            updateBuffer(attributeProperties, data, bufferType);
        }
    }
    function createBuffer(attributeProperties, data, bufferType) {
        attributeProperties.__webglBuffer = gl.createBuffer();
        gl.bindBuffer(bufferType, attributeProperties.__webglBuffer);
        var usage = data.dynamic ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;
        gl.bufferData(bufferType, data.array, usage);
        attributeProperties.version = data.version;
    }
    function updateBuffer(attributeProperties, data, bufferType) {
        gl.bindBuffer(bufferType, attributeProperties.__webglBuffer);
        if (data.dynamic === false || data.updateRange.count === -1) {
            gl.bufferSubData(bufferType, 0, data.array);
        } else if (data.updateRange.count === 0) {
            console.error('THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.');
        } else {
            gl.bufferSubData(bufferType, data.updateRange.offset * data.array.BYTES_PER_ELEMENT, data.array.subarray(data.updateRange.offset, data.updateRange.offset + data.updateRange.count));
            data.updateRange.count = 0;
        }
        attributeProperties.version = data.version;
    }
    function getAttributeBuffer(attribute) {
        if (attribute.isInterleavedBufferAttribute) {
            return properties.get(attribute.data).__webglBuffer;
        }
        return properties.get(attribute).__webglBuffer;
    }
    function getWireframeAttribute(geometry) {
        var property = properties.get(geometry);
        if (property.wireframe !== undefined) {
            return property.wireframe;
        }
        var indices = [];
        var index = geometry.index;
        var attributes = geometry.attributes;
        var position = attributes.position;
        if (index !== null) {
            var edges = {};
            var array = index.array;
            for (var i = 0, l = array.length; i < l; i += 3) {
                var a = array[i + 0];
                var b = array[i + 1];
                var c = array[i + 2];
                if (checkEdge(edges, a, b))
                    indices.push(a, b);
                if (checkEdge(edges, b, c))
                    indices.push(b, c);
                if (checkEdge(edges, c, a))
                    indices.push(c, a);
            }
        } else {
            var array = attributes.position.array;
            for (var i = 0, l = array.length / 3 - 1; i < l; i += 3) {
                var a = i + 0;
                var b = i + 1;
                var c = i + 2;
                indices.push(a, b, b, c, c, a);
            }
        }
        var TypeArray = position.count > 65535 ? Uint32Array : Uint16Array;
        var attribute = new BufferAttribute(new TypeArray(indices), 1);
        updateAttribute(attribute, gl.ELEMENT_ARRAY_BUFFER);
        property.wireframe = attribute;
        return attribute;
    }
    function checkEdge(edges, a, b) {
        if (a > b) {
            var tmp = a;
            a = b;
            b = tmp;
        }
        var list = edges[a];
        if (list === undefined) {
            edges[a] = [b];
            return true;
        } else if (list.indexOf(b) === -1) {
            list.push(b);
            return true;
        }
        return false;
    }
    return {
        getAttributeBuffer: getAttributeBuffer,
        getWireframeAttribute: getWireframeAttribute,
        update: update
    };
};
WebGLLights = function WebGLLights() {
    var lights = {};
    return {
        get: function (light) {
            if (lights[light.id] !== undefined) {
                return lights[light.id];
            }
            var uniforms;
            switch (light.type) {
            case 'DirectionalLight':
                uniforms = {
                    direction: new Vector3(),
                    color: new Color(),
                    shadow: false,
                    shadowBias: 0,
                    shadowRadius: 1,
                    shadowMapSize: new Vector2()
                };
                break;
            case 'SpotLight':
                uniforms = {
                    position: new Vector3(),
                    direction: new Vector3(),
                    color: new Color(),
                    distance: 0,
                    coneCos: 0,
                    penumbraCos: 0,
                    decay: 0,
                    shadow: false,
                    shadowBias: 0,
                    shadowRadius: 1,
                    shadowMapSize: new Vector2()
                };
                break;
            case 'PointLight':
                uniforms = {
                    position: new Vector3(),
                    color: new Color(),
                    distance: 0,
                    decay: 0,
                    shadow: false,
                    shadowBias: 0,
                    shadowRadius: 1,
                    shadowMapSize: new Vector2()
                };
                break;
            case 'HemisphereLight':
                uniforms = {
                    direction: new Vector3(),
                    skyColor: new Color(),
                    groundColor: new Color()
                };
                break;
            }
            lights[light.id] = uniforms;
            return uniforms;
        }
    };
};
WebGLCapabilities = function WebGLCapabilities(gl, extensions, parameters) {
    var maxAnisotropy;
    function getMaxAnisotropy() {
        if (maxAnisotropy !== undefined)
            return maxAnisotropy;
        var extension = extensions.get('EXT_texture_filter_anisotropic');
        if (extension !== null) {
            maxAnisotropy = gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
        } else {
            maxAnisotropy = 0;
        }
        return maxAnisotropy;
    }
    function getMaxPrecision(precision) {
        if (precision === 'highp') {
            if (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT).precision > 0 && gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT).precision > 0) {
                return 'highp';
            }
            precision = 'mediump';
        }
        if (precision === 'mediump') {
            if (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_FLOAT).precision > 0 && gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT).precision > 0) {
                return 'mediump';
            }
        }
        return 'lowp';
    }
    var precision = parameters.precision !== undefined ? parameters.precision : 'highp';
    var maxPrecision = getMaxPrecision(precision);
    if (maxPrecision !== precision) {
        console.warn('THREE.WebGLRenderer:', precision, 'not supported, using', maxPrecision, 'instead.');
        precision = maxPrecision;
    }
    var logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true && !!extensions.get('EXT_frag_depth');
    var maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
    var maxVertexTextures = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
    var maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
    var maxCubemapSize = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);
    var maxAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
    var maxVertexUniforms = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);
    var maxVaryings = gl.getParameter(gl.MAX_VARYING_VECTORS);
    var maxFragmentUniforms = gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS);
    var vertexTextures = maxVertexTextures > 0;
    var floatFragmentTextures = !!extensions.get('OES_texture_float');
    var floatVertexTextures = vertexTextures && floatFragmentTextures;
    return {
        getMaxAnisotropy: getMaxAnisotropy,
        getMaxPrecision: getMaxPrecision,
        precision: precision,
        logarithmicDepthBuffer: logarithmicDepthBuffer,
        maxTextures: maxTextures,
        maxVertexTextures: maxVertexTextures,
        maxTextureSize: maxTextureSize,
        maxCubemapSize: maxCubemapSize,
        maxAttributes: maxAttributes,
        maxVertexUniforms: maxVertexUniforms,
        maxVaryings: maxVaryings,
        maxFragmentUniforms: maxFragmentUniforms,
        vertexTextures: vertexTextures,
        floatFragmentTextures: floatFragmentTextures,
        floatVertexTextures: floatVertexTextures
    };
};
WebGLExtensions = function WebGLExtensions(gl) {
    var extensions = {};
    return {
        get: function (name) {
            if (extensions[name] !== undefined) {
                return extensions[name];
            }
            var extension;
            switch (name) {
            case 'WEBGL_depth_texture':
                extension = gl.getExtension('WEBGL_depth_texture') || gl.getExtension('MOZ_WEBGL_depth_texture') || gl.getExtension('WEBKIT_WEBGL_depth_texture');
                break;
            case 'EXT_texture_filter_anisotropic':
                extension = gl.getExtension('EXT_texture_filter_anisotropic') || gl.getExtension('MOZ_EXT_texture_filter_anisotropic') || gl.getExtension('WEBKIT_EXT_texture_filter_anisotropic');
                break;
            case 'WEBGL_compressed_texture_s3tc':
                extension = gl.getExtension('WEBGL_compressed_texture_s3tc') || gl.getExtension('MOZ_WEBGL_compressed_texture_s3tc') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc');
                break;
            case 'WEBGL_compressed_texture_pvrtc':
                extension = gl.getExtension('WEBGL_compressed_texture_pvrtc') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc');
                break;
            case 'WEBGL_compressed_texture_etc1':
                extension = gl.getExtension('WEBGL_compressed_texture_etc1');
                break;
            default:
                extension = gl.getExtension(name);
            }
            if (extension === null) {
                console.warn('THREE.WebGLRenderer: ' + name + ' extension not supported.');
            }
            extensions[name] = extension;
            return extension;
        }
    };
};
WebGLIndexedBufferRenderer = function WebGLIndexedBufferRenderer(gl, extensions, infoRender) {
    var mode;
    function setMode(value) {
        mode = value;
    }
    var type, size;
    function setIndex(index) {
        if (index.array instanceof Uint32Array && extensions.get('OES_element_index_uint')) {
            type = gl.UNSIGNED_INT;
            size = 4;
        } else {
            type = gl.UNSIGNED_SHORT;
            size = 2;
        }
    }
    function render(start, count) {
        gl.drawElements(mode, count, type, start * size);
        infoRender.calls++;
        infoRender.vertices += count;
        if (mode === gl.TRIANGLES)
            infoRender.faces += count / 3;
    }
    function renderInstances(geometry, start, count) {
        var extension = extensions.get('ANGLE_instanced_arrays');
        if (extension === null) {
            console.error('THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');
            return;
        }
        extension.drawElementsInstancedANGLE(mode, count, type, start * size, geometry.maxInstancedCount);
        infoRender.calls++;
        infoRender.vertices += count * geometry.maxInstancedCount;
        if (mode === gl.TRIANGLES)
            infoRender.faces += geometry.maxInstancedCount * count / 3;
    }
    return {
        setMode: setMode,
        setIndex: setIndex,
        render: render,
        renderInstances: renderInstances
    };
};
WebGLClipping = function WebGLClipping() {
    var scope = this, globalState = null, numGlobalPlanes = 0, localClippingEnabled = false, renderingShadows = false, plane = new Plane(), viewNormalMatrix = new Matrix3(), uniform = {
            value: null,
            needsUpdate: false
        };
    this.uniform = uniform;
    this.numPlanes = 0;
    this.init = function (planes, enableLocalClipping, camera) {
        var enabled = planes.length !== 0 || enableLocalClipping || numGlobalPlanes !== 0 || localClippingEnabled;
        localClippingEnabled = enableLocalClipping;
        globalState = projectPlanes(planes, camera, 0);
        numGlobalPlanes = planes.length;
        return enabled;
    };
    this.beginShadows = function () {
        renderingShadows = true;
        projectPlanes(null);
    };
    this.endShadows = function () {
        renderingShadows = false;
        resetGlobalState();
    };
    this.setState = function (planes, clipShadows, camera, cache, fromCache) {
        if (!localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && !clipShadows) {
            if (renderingShadows) {
                projectPlanes(null);
            } else {
                resetGlobalState();
            }
        } else {
            var nGlobal = renderingShadows ? 0 : numGlobalPlanes, lGlobal = nGlobal * 4, dstArray = cache.clippingState || null;
            uniform.value = dstArray;
            dstArray = projectPlanes(planes, camera, lGlobal, fromCache);
            for (var i = 0; i !== lGlobal; ++i) {
                dstArray[i] = globalState[i];
            }
            cache.clippingState = dstArray;
            this.numPlanes += nGlobal;
        }
    };
    function resetGlobalState() {
        if (uniform.value !== globalState) {
            uniform.value = globalState;
            uniform.needsUpdate = numGlobalPlanes > 0;
        }
        scope.numPlanes = numGlobalPlanes;
    }
    function projectPlanes(planes, camera, dstOffset, skipTransform) {
        var nPlanes = planes !== null ? planes.length : 0, dstArray = null;
        if (nPlanes !== 0) {
            dstArray = uniform.value;
            if (skipTransform !== true || dstArray === null) {
                var flatSize = dstOffset + nPlanes * 4, viewMatrix = camera.matrixWorldInverse;
                viewNormalMatrix.getNormalMatrix(viewMatrix);
                if (dstArray === null || dstArray.length < flatSize) {
                    dstArray = new Float32Array(flatSize);
                }
                for (var i = 0, i4 = dstOffset; i !== nPlanes; ++i, i4 += 4) {
                    plane.copy(planes[i]).applyMatrix4(viewMatrix, viewNormalMatrix);
                    plane.normal.toArray(dstArray, i4);
                    dstArray[i4 + 3] = plane.constant;
                }
            }
            uniform.value = dstArray;
            uniform.needsUpdate = true;
        }
        scope.numPlanes = nPlanes;
        return dstArray;
    }
};
WebGLBufferRenderer = function WebGLBufferRenderer(gl, extensions, infoRender) {
    var mode;
    function setMode(value) {
        mode = value;
    }
    function render(start, count) {
        gl.drawArrays(mode, start, count);
        infoRender.calls++;
        infoRender.vertices += count;
        if (mode === gl.TRIANGLES)
            infoRender.faces += count / 3;
    }
    function renderInstances(geometry) {
        var extension = extensions.get('ANGLE_instanced_arrays');
        if (extension === null) {
            console.error('THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');
            return;
        }
        var position = geometry.attributes.position;
        var count = 0;
        if (position && position.isInterleavedBufferAttribute) {
            count = position.data.count;
            extension.drawArraysInstancedANGLE(mode, 0, count, geometry.maxInstancedCount);
        } else {
            count = position.count;
            extension.drawArraysInstancedANGLE(mode, 0, count, geometry.maxInstancedCount);
        }
        infoRender.calls++;
        infoRender.vertices += count * geometry.maxInstancedCount;
        if (mode === gl.TRIANGLES)
            infoRender.faces += geometry.maxInstancedCount * count / 3;
    }
    return {
        setMode: setMode,
        render: render,
        renderInstances: renderInstances
    };
};
WebGLRenderTargetCube = function WebGLRenderTargetCube(width, height, options) {
    WebGLRenderTarget.call(this, width, height, options);
    this.activeCubeFace = 0;
    this.activeMipMapLevel = 0;
};
BoxBufferGeometry = function BoxBufferGeometry(width, height, depth, widthSegments, heightSegments, depthSegments) {
    BufferGeometry.call(this);
    this.type = 'BoxBufferGeometry';
    this.parameters = {
        width: width,
        height: height,
        depth: depth,
        widthSegments: widthSegments,
        heightSegments: heightSegments,
        depthSegments: depthSegments
    };
    var scope = this;
    widthSegments = Math.floor(widthSegments) || 1;
    heightSegments = Math.floor(heightSegments) || 1;
    depthSegments = Math.floor(depthSegments) || 1;
    var vertexCount = calculateVertexCount(widthSegments, heightSegments, depthSegments);
    var indexCount = calculateIndexCount(widthSegments, heightSegments, depthSegments);
    var indices = new (indexCount > 65535 ? Uint32Array : Uint16Array)(indexCount);
    var vertices = new Float32Array(vertexCount * 3);
    var normals = new Float32Array(vertexCount * 3);
    var uvs = new Float32Array(vertexCount * 2);
    var vertexBufferOffset = 0;
    var uvBufferOffset = 0;
    var indexBufferOffset = 0;
    var numberOfVertices = 0;
    var groupStart = 0;
    buildPlane('z', 'y', 'x', -1, -1, depth, height, width, depthSegments, heightSegments, 0);
    buildPlane('z', 'y', 'x', 1, -1, depth, height, -width, depthSegments, heightSegments, 1);
    buildPlane('x', 'z', 'y', 1, 1, width, depth, height, widthSegments, depthSegments, 2);
    buildPlane('x', 'z', 'y', 1, -1, width, depth, -height, widthSegments, depthSegments, 3);
    buildPlane('x', 'y', 'z', 1, -1, width, height, depth, widthSegments, heightSegments, 4);
    buildPlane('x', 'y', 'z', -1, -1, width, height, -depth, widthSegments, heightSegments, 5);
    this.setIndex(new BufferAttribute(indices, 1));
    this.addAttribute('position', new BufferAttribute(vertices, 3));
    this.addAttribute('normal', new BufferAttribute(normals, 3));
    this.addAttribute('uv', new BufferAttribute(uvs, 2));
    function calculateVertexCount(w, h, d) {
        var vertices = 0;
        vertices += (w + 1) * (h + 1) * 2;
        vertices += (w + 1) * (d + 1) * 2;
        vertices += (d + 1) * (h + 1) * 2;
        return vertices;
    }
    function calculateIndexCount(w, h, d) {
        var index = 0;
        index += w * h * 2;
        index += w * d * 2;
        index += d * h * 2;
        return index * 6;
    }
    function buildPlane(u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex) {
        var segmentWidth = width / gridX;
        var segmentHeight = height / gridY;
        var widthHalf = width / 2;
        var heightHalf = height / 2;
        var depthHalf = depth / 2;
        var gridX1 = gridX + 1;
        var gridY1 = gridY + 1;
        var vertexCounter = 0;
        var groupCount = 0;
        var vector = new Vector3();
        for (var iy = 0; iy < gridY1; iy++) {
            var y = iy * segmentHeight - heightHalf;
            for (var ix = 0; ix < gridX1; ix++) {
                var x = ix * segmentWidth - widthHalf;
                vector[u] = x * udir;
                vector[v] = y * vdir;
                vector[w] = depthHalf;
                vertices[vertexBufferOffset] = vector.x;
                vertices[vertexBufferOffset + 1] = vector.y;
                vertices[vertexBufferOffset + 2] = vector.z;
                vector[u] = 0;
                vector[v] = 0;
                vector[w] = depth > 0 ? 1 : -1;
                normals[vertexBufferOffset] = vector.x;
                normals[vertexBufferOffset + 1] = vector.y;
                normals[vertexBufferOffset + 2] = vector.z;
                uvs[uvBufferOffset] = ix / gridX;
                uvs[uvBufferOffset + 1] = 1 - iy / gridY;
                vertexBufferOffset += 3;
                uvBufferOffset += 2;
                vertexCounter += 1;
            }
        }
        for (iy = 0; iy < gridY; iy++) {
            for (ix = 0; ix < gridX; ix++) {
                var a = numberOfVertices + ix + gridX1 * iy;
                var b = numberOfVertices + ix + gridX1 * (iy + 1);
                var c = numberOfVertices + (ix + 1) + gridX1 * (iy + 1);
                var d = numberOfVertices + (ix + 1) + gridX1 * iy;
                indices[indexBufferOffset] = a;
                indices[indexBufferOffset + 1] = b;
                indices[indexBufferOffset + 2] = d;
                indices[indexBufferOffset + 3] = b;
                indices[indexBufferOffset + 4] = c;
                indices[indexBufferOffset + 5] = d;
                indexBufferOffset += 6;
                groupCount += 6;
            }
        }
        scope.addGroup(groupStart, groupCount, materialIndex);
        groupStart += groupCount;
        numberOfVertices += vertexCounter;
    }
};
Ray = function Ray(origin, direction) {
    this.origin = origin !== undefined ? origin : new Vector3();
    this.direction = direction !== undefined ? direction : new Vector3();
};
Line3 = function Line3(start, end) {
    this.start = start !== undefined ? start : new Vector3();
    this.end = end !== undefined ? end : new Vector3();
};
Triangle = function Triangle(a, b, c) {
    this.a = a !== undefined ? a : new Vector3();
    this.b = b !== undefined ? b : new Vector3();
    this.c = c !== undefined ? c : new Vector3();
};
MeshBasicMaterial = function MeshBasicMaterial(parameters) {
    Material.call(this);
    this.type = 'MeshBasicMaterial';
    this.color = new Color(16777215);
    this.map = null;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.specularMap = null;
    this.alphaMap = null;
    this.envMap = null;
    this.combine = MultiplyOperation;
    this.reflectivity = 1;
    this.refractionRatio = 0.98;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = 'round';
    this.wireframeLinejoin = 'round';
    this.skinning = false;
    this.morphTargets = false;
    this.lights = false;
    this.setValues(parameters);
};
Mesh = function Mesh(geometry, material) {
    Object3D.call(this);
    this.type = 'Mesh';
    this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
    this.material = material !== undefined ? material : new MeshBasicMaterial({
        color: Math.random() * 16777215
    });
    this.drawMode = TrianglesDrawMode;
    this.updateMorphTargets();
};
PlaneBufferGeometry = function PlaneBufferGeometry(width, height, widthSegments, heightSegments) {
    BufferGeometry.call(this);
    this.type = 'PlaneBufferGeometry';
    this.parameters = {
        width: width,
        height: height,
        widthSegments: widthSegments,
        heightSegments: heightSegments
    };
    var width_half = width / 2;
    var height_half = height / 2;
    var gridX = Math.floor(widthSegments) || 1;
    var gridY = Math.floor(heightSegments) || 1;
    var gridX1 = gridX + 1;
    var gridY1 = gridY + 1;
    var segment_width = width / gridX;
    var segment_height = height / gridY;
    var vertices = new Float32Array(gridX1 * gridY1 * 3);
    var normals = new Float32Array(gridX1 * gridY1 * 3);
    var uvs = new Float32Array(gridX1 * gridY1 * 2);
    var offset = 0;
    var offset2 = 0;
    for (var iy = 0; iy < gridY1; iy++) {
        var y = iy * segment_height - height_half;
        for (var ix = 0; ix < gridX1; ix++) {
            var x = ix * segment_width - width_half;
            vertices[offset] = x;
            vertices[offset + 1] = -y;
            normals[offset + 2] = 1;
            uvs[offset2] = ix / gridX;
            uvs[offset2 + 1] = 1 - iy / gridY;
            offset += 3;
            offset2 += 2;
        }
    }
    offset = 0;
    var indices = new (vertices.length / 3 > 65535 ? Uint32Array : Uint16Array)(gridX * gridY * 6);
    for (var iy = 0; iy < gridY; iy++) {
        for (var ix = 0; ix < gridX; ix++) {
            var a = ix + gridX1 * iy;
            var b = ix + gridX1 * (iy + 1);
            var c = ix + 1 + gridX1 * (iy + 1);
            var d = ix + 1 + gridX1 * iy;
            indices[offset] = a;
            indices[offset + 1] = b;
            indices[offset + 2] = d;
            indices[offset + 3] = b;
            indices[offset + 4] = c;
            indices[offset + 5] = d;
            offset += 6;
        }
    }
    this.setIndex(new BufferAttribute(indices, 1));
    this.addAttribute('position', new BufferAttribute(vertices, 3));
    this.addAttribute('normal', new BufferAttribute(normals, 3));
    this.addAttribute('uv', new BufferAttribute(uvs, 2));
};
Camera = function Camera() {
    Object3D.call(this);
    this.type = 'Camera';
    this.matrixWorldInverse = new Matrix4();
    this.projectionMatrix = new Matrix4();
};
PerspectiveCamera = function PerspectiveCamera(fov, aspect, near, far) {
    Camera.call(this);
    this.type = 'PerspectiveCamera';
    this.fov = fov !== undefined ? fov : 50;
    this.zoom = 1;
    this.near = near !== undefined ? near : 0.1;
    this.far = far !== undefined ? far : 2000;
    this.focus = 10;
    this.aspect = aspect !== undefined ? aspect : 1;
    this.view = null;
    this.filmGauge = 35;
    this.filmOffset = 0;
    this.updateProjectionMatrix();
};
OrthographicCamera = function OrthographicCamera(left, right, top, bottom, near, far) {
    Camera.call(this);
    this.type = 'OrthographicCamera';
    this.zoom = 1;
    this.view = null;
    this.left = left;
    this.right = right;
    this.top = top;
    this.bottom = bottom;
    this.near = near !== undefined ? near : 0.1;
    this.far = far !== undefined ? far : 2000;
    this.updateProjectionMatrix();
};
WebGLRenderer = function WebGLRenderer(parameters) {
    console.log('THREE.WebGLRenderer', REVISION);
    parameters = parameters || {};
    var _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas'), _context = parameters.context !== undefined ? parameters.context : null, _alpha = parameters.alpha !== undefined ? parameters.alpha : false, _depth = parameters.depth !== undefined ? parameters.depth : true, _stencil = parameters.stencil !== undefined ? parameters.stencil : true, _antialias = parameters.antialias !== undefined ? parameters.antialias : false, _premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true, _preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false;
    var lights = [];
    var opaqueObjects = [];
    var opaqueObjectsLastIndex = -1;
    var transparentObjects = [];
    var transparentObjectsLastIndex = -1;
    var morphInfluences = new Float32Array(8);
    var sprites = [];
    var lensFlares = [];
    this.domElement = _canvas;
    this.context = null;
    this.autoClear = true;
    this.autoClearColor = true;
    this.autoClearDepth = true;
    this.autoClearStencil = true;
    this.sortObjects = true;
    this.clippingPlanes = [];
    this.localClippingEnabled = false;
    this.gammaFactor = 2;
    this.gammaInput = false;
    this.gammaOutput = false;
    this.physicallyCorrectLights = false;
    this.toneMapping = LinearToneMapping;
    this.toneMappingExposure = 1;
    this.toneMappingWhitePoint = 1;
    this.maxMorphTargets = 8;
    this.maxMorphNormals = 4;
    var _this = this, _currentProgram = null, _currentRenderTarget = null, _currentFramebuffer = null, _currentMaterialId = -1, _currentGeometryProgram = '', _currentCamera = null, _currentScissor = new Vector4(), _currentScissorTest = null, _currentViewport = new Vector4(), _usedTextureUnits = 0, _clearColor = new Color(0), _clearAlpha = 0, _width = _canvas.width, _height = _canvas.height, _pixelRatio = 1, _scissor = new Vector4(0, 0, _width, _height), _scissorTest = false, _viewport = new Vector4(0, 0, _width, _height), _frustum = new Frustum(), _clipping = new WebGLClipping(), _clippingEnabled = false, _localClippingEnabled = false, _sphere = new Sphere(), _projScreenMatrix = new Matrix4(), _vector3 = new Vector3(), _lights = {
            hash: '',
            ambient: [
                0,
                0,
                0
            ],
            directional: [],
            directionalShadowMap: [],
            directionalShadowMatrix: [],
            spot: [],
            spotShadowMap: [],
            spotShadowMatrix: [],
            point: [],
            pointShadowMap: [],
            pointShadowMatrix: [],
            hemi: [],
            shadows: []
        }, _infoRender = {
            calls: 0,
            vertices: 0,
            faces: 0,
            points: 0
        };
    this.info = {
        render: _infoRender,
        memory: {
            geometries: 0,
            textures: 0
        },
        programs: null
    };
    var _gl;
    try {
        var attributes = {
            alpha: _alpha,
            depth: _depth,
            stencil: _stencil,
            antialias: _antialias,
            premultipliedAlpha: _premultipliedAlpha,
            preserveDrawingBuffer: _preserveDrawingBuffer
        };
        _gl = _context || _canvas.getContext('webgl', attributes) || _canvas.getContext('experimental-webgl', attributes);
        if (_gl === null) {
            if (_canvas.getContext('webgl') !== null) {
                throw 'Error creating WebGL context with your selected attributes.';
            } else {
                throw 'Error creating WebGL context.';
            }
        }
        if (_gl.getShaderPrecisionFormat === undefined) {
            _gl.getShaderPrecisionFormat = function () {
                return {
                    'rangeMin': 1,
                    'rangeMax': 1,
                    'precision': 1
                };
            };
        }
        _canvas.addEventListener('webglcontextlost', onContextLost, false);
    } catch (error) {
        console.error('THREE.WebGLRenderer: ' + error);
    }
    var extensions = new WebGLExtensions(_gl);
    extensions.get('WEBGL_depth_texture');
    extensions.get('OES_texture_float');
    extensions.get('OES_texture_float_linear');
    extensions.get('OES_texture_half_float');
    extensions.get('OES_texture_half_float_linear');
    extensions.get('OES_standard_derivatives');
    extensions.get('ANGLE_instanced_arrays');
    if (extensions.get('OES_element_index_uint')) {
        BufferGeometry.MaxIndex = 4294967296;
    }
    var capabilities = new WebGLCapabilities(_gl, extensions, parameters);
    var state = new WebGLState(_gl, extensions, paramThreeToGL);
    var properties = new WebGLProperties();
    var textures = new WebGLTextures(_gl, extensions, state, properties, capabilities, paramThreeToGL, this.info);
    var objects = new WebGLObjects(_gl, properties, this.info);
    var programCache = new WebGLPrograms(this, capabilities);
    var lightCache = new WebGLLights();
    this.info.programs = programCache.programs;
    var bufferRenderer = new WebGLBufferRenderer(_gl, extensions, _infoRender);
    var indexedBufferRenderer = new WebGLIndexedBufferRenderer(_gl, extensions, _infoRender);
    var backgroundCamera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);
    var backgroundCamera2 = new PerspectiveCamera();
    var backgroundPlaneMesh = new Mesh(new PlaneBufferGeometry(2, 2), new MeshBasicMaterial({
        depthTest: false,
        depthWrite: false,
        fog: false
    }));
    var backgroundBoxShader = ShaderLib['cube'];
    var backgroundBoxMesh = new Mesh(new BoxBufferGeometry(5, 5, 5), new ShaderMaterial({
        uniforms: backgroundBoxShader.uniforms,
        vertexShader: backgroundBoxShader.vertexShader,
        fragmentShader: backgroundBoxShader.fragmentShader,
        side: BackSide,
        depthTest: false,
        depthWrite: false,
        fog: false
    }));
    function getTargetPixelRatio() {
        return _currentRenderTarget === null ? _pixelRatio : 1;
    }
    function glClearColor(r, g, b, a) {
        if (_premultipliedAlpha === true) {
            r *= a;
            g *= a;
            b *= a;
        }
        state.clearColor(r, g, b, a);
    }
    function setDefaultGLState() {
        state.init();
        state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio));
        state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio));
        glClearColor(_clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha);
    }
    function resetGLState() {
        _currentProgram = null;
        _currentCamera = null;
        _currentGeometryProgram = '';
        _currentMaterialId = -1;
        state.reset();
    }
    setDefaultGLState();
    this.context = _gl;
    this.capabilities = capabilities;
    this.extensions = extensions;
    this.properties = properties;
    this.state = state;
    var shadowMap = new WebGLShadowMap(this, _lights, objects, capabilities);
    this.shadowMap = shadowMap;
    var spritePlugin = new SpritePlugin(this, sprites);
    var lensFlarePlugin = new LensFlarePlugin(this, lensFlares);
    this.getContext = function () {
        return _gl;
    };
    this.getContextAttributes = function () {
        return _gl.getContextAttributes();
    };
    this.forceContextLoss = function () {
        extensions.get('WEBGL_lose_context').loseContext();
    };
    this.getMaxAnisotropy = function () {
        return capabilities.getMaxAnisotropy();
    };
    this.getPrecision = function () {
        return capabilities.precision;
    };
    this.getPixelRatio = function () {
        return _pixelRatio;
    };
    this.setPixelRatio = function (value) {
        if (value === undefined)
            return;
        _pixelRatio = value;
        this.setSize(_viewport.z, _viewport.w, false);
    };
    this.getSize = function () {
        return {
            width: _width,
            height: _height
        };
    };
    this.setSize = function (width, height, updateStyle) {
        _width = width;
        _height = height;
        _canvas.width = width * _pixelRatio;
        _canvas.height = height * _pixelRatio;
        if (updateStyle !== false) {
            _canvas.style.width = width + 'px';
            _canvas.style.height = height + 'px';
        }
        this.setViewport(0, 0, width, height);
    };
    this.setViewport = function (x, y, width, height) {
        state.viewport(_viewport.set(x, y, width, height));
    };
    this.setScissor = function (x, y, width, height) {
        state.scissor(_scissor.set(x, y, width, height));
    };
    this.setScissorTest = function (boolean) {
        state.setScissorTest(_scissorTest = boolean);
    };
    this.getClearColor = function () {
        return _clearColor;
    };
    this.setClearColor = function (color, alpha) {
        _clearColor.set(color);
        _clearAlpha = alpha !== undefined ? alpha : 1;
        glClearColor(_clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha);
    };
    this.getClearAlpha = function () {
        return _clearAlpha;
    };
    this.setClearAlpha = function (alpha) {
        _clearAlpha = alpha;
        glClearColor(_clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha);
    };
    this.clear = function (color, depth, stencil) {
        var bits = 0;
        if (color === undefined || color)
            bits |= _gl.COLOR_BUFFER_BIT;
        if (depth === undefined || depth)
            bits |= _gl.DEPTH_BUFFER_BIT;
        if (stencil === undefined || stencil)
            bits |= _gl.STENCIL_BUFFER_BIT;
        _gl.clear(bits);
    };
    this.clearColor = function () {
        this.clear(true, false, false);
    };
    this.clearDepth = function () {
        this.clear(false, true, false);
    };
    this.clearStencil = function () {
        this.clear(false, false, true);
    };
    this.clearTarget = function (renderTarget, color, depth, stencil) {
        this.setRenderTarget(renderTarget);
        this.clear(color, depth, stencil);
    };
    this.resetGLState = resetGLState;
    this.dispose = function () {
        transparentObjects = [];
        transparentObjectsLastIndex = -1;
        opaqueObjects = [];
        opaqueObjectsLastIndex = -1;
        _canvas.removeEventListener('webglcontextlost', onContextLost, false);
    };
    function onContextLost(event) {
        event.preventDefault();
        resetGLState();
        setDefaultGLState();
        properties.clear();
    }
    function onMaterialDispose(event) {
        var material = event.target;
        material.removeEventListener('dispose', onMaterialDispose);
        deallocateMaterial(material);
    }
    function deallocateMaterial(material) {
        releaseMaterialProgramReference(material);
        properties.delete(material);
    }
    function releaseMaterialProgramReference(material) {
        var programInfo = properties.get(material).program;
        material.program = undefined;
        if (programInfo !== undefined) {
            programCache.releaseProgram(programInfo);
        }
    }
    this.renderBufferImmediate = function (object, program, material) {
        state.initAttributes();
        var buffers = properties.get(object);
        if (object.hasPositions && !buffers.position)
            buffers.position = _gl.createBuffer();
        if (object.hasNormals && !buffers.normal)
            buffers.normal = _gl.createBuffer();
        if (object.hasUvs && !buffers.uv)
            buffers.uv = _gl.createBuffer();
        if (object.hasColors && !buffers.color)
            buffers.color = _gl.createBuffer();
        var attributes = program.getAttributes();
        if (object.hasPositions) {
            _gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.position);
            _gl.bufferData(_gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW);
            state.enableAttribute(attributes.position);
            _gl.vertexAttribPointer(attributes.position, 3, _gl.FLOAT, false, 0, 0);
        }
        if (object.hasNormals) {
            _gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.normal);
            if (!material.isMeshPhongMaterial && !material.isMeshStandardMaterial && material.shading === FlatShading) {
                for (var i = 0, l = object.count * 3; i < l; i += 9) {
                    var array = object.normalArray;
                    var nx = (array[i + 0] + array[i + 3] + array[i + 6]) / 3;
                    var ny = (array[i + 1] + array[i + 4] + array[i + 7]) / 3;
                    var nz = (array[i + 2] + array[i + 5] + array[i + 8]) / 3;
                    array[i + 0] = nx;
                    array[i + 1] = ny;
                    array[i + 2] = nz;
                    array[i + 3] = nx;
                    array[i + 4] = ny;
                    array[i + 5] = nz;
                    array[i + 6] = nx;
                    array[i + 7] = ny;
                    array[i + 8] = nz;
                }
            }
            _gl.bufferData(_gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW);
            state.enableAttribute(attributes.normal);
            _gl.vertexAttribPointer(attributes.normal, 3, _gl.FLOAT, false, 0, 0);
        }
        if (object.hasUvs && material.map) {
            _gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.uv);
            _gl.bufferData(_gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW);
            state.enableAttribute(attributes.uv);
            _gl.vertexAttribPointer(attributes.uv, 2, _gl.FLOAT, false, 0, 0);
        }
        if (object.hasColors && material.vertexColors !== NoColors) {
            _gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.color);
            _gl.bufferData(_gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW);
            state.enableAttribute(attributes.color);
            _gl.vertexAttribPointer(attributes.color, 3, _gl.FLOAT, false, 0, 0);
        }
        state.disableUnusedAttributes();
        _gl.drawArrays(_gl.TRIANGLES, 0, object.count);
        object.count = 0;
    };
    this.renderBufferDirect = function (camera, fog, geometry, material, object, group) {
        setMaterial(material);
        var program = setProgram(camera, fog, material, object);
        var updateBuffers = false;
        var geometryProgram = geometry.id + '_' + program.id + '_' + material.wireframe;
        if (geometryProgram !== _currentGeometryProgram) {
            _currentGeometryProgram = geometryProgram;
            updateBuffers = true;
        }
        var morphTargetInfluences = object.morphTargetInfluences;
        if (morphTargetInfluences !== undefined) {
            var activeInfluences = [];
            for (var i = 0, l = morphTargetInfluences.length; i < l; i++) {
                var influence = morphTargetInfluences[i];
                activeInfluences.push([
                    influence,
                    i
                ]);
            }
            activeInfluences.sort(absNumericalSort);
            if (activeInfluences.length > 8) {
                activeInfluences.length = 8;
            }
            var morphAttributes = geometry.morphAttributes;
            for (var i = 0, l = activeInfluences.length; i < l; i++) {
                var influence = activeInfluences[i];
                morphInfluences[i] = influence[0];
                if (influence[0] !== 0) {
                    var index = influence[1];
                    if (material.morphTargets === true && morphAttributes.position)
                        geometry.addAttribute('morphTarget' + i, morphAttributes.position[index]);
                    if (material.morphNormals === true && morphAttributes.normal)
                        geometry.addAttribute('morphNormal' + i, morphAttributes.normal[index]);
                } else {
                    if (material.morphTargets === true)
                        geometry.removeAttribute('morphTarget' + i);
                    if (material.morphNormals === true)
                        geometry.removeAttribute('morphNormal' + i);
                }
            }
            program.getUniforms().setValue(_gl, 'morphTargetInfluences', morphInfluences);
            updateBuffers = true;
        }
        var index = geometry.index;
        var position = geometry.attributes.position;
        if (material.wireframe === true) {
            index = objects.getWireframeAttribute(geometry);
        }
        var renderer;
        if (index !== null) {
            renderer = indexedBufferRenderer;
            renderer.setIndex(index);
        } else {
            renderer = bufferRenderer;
        }
        if (updateBuffers) {
            setupVertexAttributes(material, program, geometry);
            if (index !== null) {
                _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, objects.getAttributeBuffer(index));
            }
        }
        var dataStart = 0;
        var dataCount = Infinity;
        if (index !== null) {
            dataCount = index.count;
        } else if (position !== undefined) {
            dataCount = position.count;
        }
        var rangeStart = geometry.drawRange.start;
        var rangeCount = geometry.drawRange.count;
        var groupStart = group !== null ? group.start : 0;
        var groupCount = group !== null ? group.count : Infinity;
        var drawStart = Math.max(dataStart, rangeStart, groupStart);
        var drawEnd = Math.min(dataStart + dataCount, rangeStart + rangeCount, groupStart + groupCount) - 1;
        var drawCount = Math.max(0, drawEnd - drawStart + 1);
        if (object.isMesh) {
            if (material.wireframe === true) {
                state.setLineWidth(material.wireframeLinewidth * getTargetPixelRatio());
                renderer.setMode(_gl.LINES);
            } else {
                switch (object.drawMode) {
                case TrianglesDrawMode:
                    renderer.setMode(_gl.TRIANGLES);
                    break;
                case TriangleStripDrawMode:
                    renderer.setMode(_gl.TRIANGLE_STRIP);
                    break;
                case TriangleFanDrawMode:
                    renderer.setMode(_gl.TRIANGLE_FAN);
                    break;
                }
            }
        } else if (object.isLine) {
            var lineWidth = material.linewidth;
            if (lineWidth === undefined)
                lineWidth = 1;
            state.setLineWidth(lineWidth * getTargetPixelRatio());
            if (object.isLineSegments) {
                renderer.setMode(_gl.LINES);
            } else {
                renderer.setMode(_gl.LINE_STRIP);
            }
        } else if (object.isPoints) {
            renderer.setMode(_gl.POINTS);
        }
        if (geometry && geometry.isInstancedBufferGeometry) {
            if (geometry.maxInstancedCount > 0) {
                renderer.renderInstances(geometry, drawStart, drawCount);
            }
        } else {
            renderer.render(drawStart, drawCount);
        }
    };
    function setupVertexAttributes(material, program, geometry, startIndex) {
        var extension;
        if (geometry && geometry.isInstancedBufferGeometry) {
            extension = extensions.get('ANGLE_instanced_arrays');
            if (extension === null) {
                console.error('THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');
                return;
            }
        }
        if (startIndex === undefined)
            startIndex = 0;
        state.initAttributes();
        var geometryAttributes = geometry.attributes;
        var programAttributes = program.getAttributes();
        var materialDefaultAttributeValues = material.defaultAttributeValues;
        for (var name in programAttributes) {
            var programAttribute = programAttributes[name];
            if (programAttribute >= 0) {
                var geometryAttribute = geometryAttributes[name];
                if (geometryAttribute !== undefined) {
                    var type = _gl.FLOAT;
                    var array = geometryAttribute.array;
                    var normalized = geometryAttribute.normalized;
                    if (array instanceof Float32Array) {
                        type = _gl.FLOAT;
                    } else if (array instanceof Float64Array) {
                        console.warn('Unsupported data buffer format: Float64Array');
                    } else if (array instanceof Uint16Array) {
                        type = _gl.UNSIGNED_SHORT;
                    } else if (array instanceof Int16Array) {
                        type = _gl.SHORT;
                    } else if (array instanceof Uint32Array) {
                        type = _gl.UNSIGNED_INT;
                    } else if (array instanceof Int32Array) {
                        type = _gl.INT;
                    } else if (array instanceof Int8Array) {
                        type = _gl.BYTE;
                    } else if (array instanceof Uint8Array) {
                        type = _gl.UNSIGNED_BYTE;
                    }
                    var size = geometryAttribute.itemSize;
                    var buffer = objects.getAttributeBuffer(geometryAttribute);
                    if (geometryAttribute && geometryAttribute.isInterleavedBufferAttribute) {
                        var data = geometryAttribute.data;
                        var stride = data.stride;
                        var offset = geometryAttribute.offset;
                        if (data && data.isInstancedInterleavedBuffer) {
                            state.enableAttributeAndDivisor(programAttribute, data.meshPerAttribute, extension);
                            if (geometry.maxInstancedCount === undefined) {
                                geometry.maxInstancedCount = data.meshPerAttribute * data.count;
                            }
                        } else {
                            state.enableAttribute(programAttribute);
                        }
                        _gl.bindBuffer(_gl.ARRAY_BUFFER, buffer);
                        _gl.vertexAttribPointer(programAttribute, size, type, normalized, stride * data.array.BYTES_PER_ELEMENT, (startIndex * stride + offset) * data.array.BYTES_PER_ELEMENT);
                    } else {
                        if (geometryAttribute && geometryAttribute.isInstancedBufferAttribute) {
                            state.enableAttributeAndDivisor(programAttribute, geometryAttribute.meshPerAttribute, extension);
                            if (geometry.maxInstancedCount === undefined) {
                                geometry.maxInstancedCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;
                            }
                        } else {
                            state.enableAttribute(programAttribute);
                        }
                        _gl.bindBuffer(_gl.ARRAY_BUFFER, buffer);
                        _gl.vertexAttribPointer(programAttribute, size, type, normalized, 0, startIndex * size * geometryAttribute.array.BYTES_PER_ELEMENT);
                    }
                } else if (materialDefaultAttributeValues !== undefined) {
                    var value = materialDefaultAttributeValues[name];
                    if (value !== undefined) {
                        switch (value.length) {
                        case 2:
                            _gl.vertexAttrib2fv(programAttribute, value);
                            break;
                        case 3:
                            _gl.vertexAttrib3fv(programAttribute, value);
                            break;
                        case 4:
                            _gl.vertexAttrib4fv(programAttribute, value);
                            break;
                        default:
                            _gl.vertexAttrib1fv(programAttribute, value);
                        }
                    }
                }
            }
        }
        state.disableUnusedAttributes();
    }
    function absNumericalSort(a, b) {
        return Math.abs(b[0]) - Math.abs(a[0]);
    }
    function painterSortStable(a, b) {
        if (a.object.renderOrder !== b.object.renderOrder) {
            return a.object.renderOrder - b.object.renderOrder;
        } else if (a.material.program && b.material.program && a.material.program !== b.material.program) {
            return a.material.program.id - b.material.program.id;
        } else if (a.material.id !== b.material.id) {
            return a.material.id - b.material.id;
        } else if (a.z !== b.z) {
            return a.z - b.z;
        } else {
            return a.id - b.id;
        }
    }
    function reversePainterSortStable(a, b) {
        if (a.object.renderOrder !== b.object.renderOrder) {
            return a.object.renderOrder - b.object.renderOrder;
        }
        if (a.z !== b.z) {
            return b.z - a.z;
        } else {
            return a.id - b.id;
        }
    }
    this.render = function (scene, camera, renderTarget, forceClear) {
        if ((camera && camera.isCamera) === false) {
            console.error('THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.');
            return;
        }
        var fog = scene.fog;
        _currentGeometryProgram = '';
        _currentMaterialId = -1;
        _currentCamera = null;
        if (scene.autoUpdate === true)
            scene.updateMatrixWorld();
        if (camera.parent === null)
            camera.updateMatrixWorld();
        camera.matrixWorldInverse.getInverse(camera.matrixWorld);
        _projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
        _frustum.setFromMatrix(_projScreenMatrix);
        lights.length = 0;
        opaqueObjectsLastIndex = -1;
        transparentObjectsLastIndex = -1;
        sprites.length = 0;
        lensFlares.length = 0;
        _localClippingEnabled = this.localClippingEnabled;
        _clippingEnabled = _clipping.init(this.clippingPlanes, _localClippingEnabled, camera);
        projectObject(scene, camera);
        opaqueObjects.length = opaqueObjectsLastIndex + 1;
        transparentObjects.length = transparentObjectsLastIndex + 1;
        if (_this.sortObjects === true) {
            opaqueObjects.sort(painterSortStable);
            transparentObjects.sort(reversePainterSortStable);
        }
        if (_clippingEnabled)
            _clipping.beginShadows();
        setupShadows(lights);
        shadowMap.render(scene, camera);
        setupLights(lights, camera);
        if (_clippingEnabled)
            _clipping.endShadows();
        _infoRender.calls = 0;
        _infoRender.vertices = 0;
        _infoRender.faces = 0;
        _infoRender.points = 0;
        if (renderTarget === undefined) {
            renderTarget = null;
        }
        this.setRenderTarget(renderTarget);
        var background = scene.background;
        if (background === null) {
            glClearColor(_clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha);
        } else if (background && background.isColor) {
            glClearColor(background.r, background.g, background.b, 1);
            forceClear = true;
        }
        if (this.autoClear || forceClear) {
            this.clear(this.autoClearColor, this.autoClearDepth, this.autoClearStencil);
        }
        if (background && background.isCubeTexture) {
            backgroundCamera2.projectionMatrix.copy(camera.projectionMatrix);
            backgroundCamera2.matrixWorld.extractRotation(camera.matrixWorld);
            backgroundCamera2.matrixWorldInverse.getInverse(backgroundCamera2.matrixWorld);
            backgroundBoxMesh.material.uniforms['tCube'].value = background;
            backgroundBoxMesh.modelViewMatrix.multiplyMatrices(backgroundCamera2.matrixWorldInverse, backgroundBoxMesh.matrixWorld);
            objects.update(backgroundBoxMesh);
            _this.renderBufferDirect(backgroundCamera2, null, backgroundBoxMesh.geometry, backgroundBoxMesh.material, backgroundBoxMesh, null);
        } else if (background && background.isTexture) {
            backgroundPlaneMesh.material.map = background;
            objects.update(backgroundPlaneMesh);
            _this.renderBufferDirect(backgroundCamera, null, backgroundPlaneMesh.geometry, backgroundPlaneMesh.material, backgroundPlaneMesh, null);
        }
        if (scene.overrideMaterial) {
            var overrideMaterial = scene.overrideMaterial;
            renderObjects(opaqueObjects, camera, fog, overrideMaterial);
            renderObjects(transparentObjects, camera, fog, overrideMaterial);
        } else {
            state.setBlending(NoBlending);
            renderObjects(opaqueObjects, camera, fog);
            renderObjects(transparentObjects, camera, fog);
        }
        spritePlugin.render(scene, camera);
        lensFlarePlugin.render(scene, camera, _currentViewport);
        if (renderTarget) {
            textures.updateRenderTargetMipmap(renderTarget);
        }
        state.setDepthTest(true);
        state.setDepthWrite(true);
        state.setColorWrite(true);
    };
    function pushRenderItem(object, geometry, material, z, group) {
        var array, index;
        if (material.transparent) {
            array = transparentObjects;
            index = ++transparentObjectsLastIndex;
        } else {
            array = opaqueObjects;
            index = ++opaqueObjectsLastIndex;
        }
        var renderItem = array[index];
        if (renderItem !== undefined) {
            renderItem.id = object.id;
            renderItem.object = object;
            renderItem.geometry = geometry;
            renderItem.material = material;
            renderItem.z = _vector3.z;
            renderItem.group = group;
        } else {
            renderItem = {
                id: object.id,
                object: object,
                geometry: geometry,
                material: material,
                z: _vector3.z,
                group: group
            };
            array.push(renderItem);
        }
    }
    function isObjectViewable(object) {
        var geometry = object.geometry;
        if (geometry.boundingSphere === null)
            geometry.computeBoundingSphere();
        _sphere.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld);
        return isSphereViewable(_sphere);
    }
    function isSpriteViewable(sprite) {
        _sphere.center.set(0, 0, 0);
        _sphere.radius = 0.7071067811865476;
        _sphere.applyMatrix4(sprite.matrixWorld);
        return isSphereViewable(_sphere);
    }
    function isSphereViewable(sphere) {
        if (!_frustum.intersectsSphere(sphere))
            return false;
        var numPlanes = _clipping.numPlanes;
        if (numPlanes === 0)
            return true;
        var planes = _this.clippingPlanes, center = sphere.center, negRad = -sphere.radius, i = 0;
        do {
            if (planes[i].distanceToPoint(center) < negRad)
                return false;
        } while (++i !== numPlanes);
        return true;
    }
    function projectObject(object, camera) {
        if (object.visible === false)
            return;
        var visible = (object.layers.mask & camera.layers.mask) !== 0;
        if (visible) {
            if (object.isLight) {
                lights.push(object);
            } else if (object.isSprite) {
                if (object.frustumCulled === false || isSpriteViewable(object) === true) {
                    sprites.push(object);
                }
            } else if (object.isLensFlare) {
                lensFlares.push(object);
            } else if (object.isImmediateRenderObject) {
                if (_this.sortObjects === true) {
                    _vector3.setFromMatrixPosition(object.matrixWorld);
                    _vector3.applyProjection(_projScreenMatrix);
                }
                pushRenderItem(object, null, object.material, _vector3.z, null);
            } else if (object.isMesh || object.isLine || object.isPoints) {
                if (object.isSkinnedMesh) {
                    object.skeleton.update();
                }
                if (object.frustumCulled === false || isObjectViewable(object) === true) {
                    var material = object.material;
                    if (material.visible === true) {
                        if (_this.sortObjects === true) {
                            _vector3.setFromMatrixPosition(object.matrixWorld);
                            _vector3.applyProjection(_projScreenMatrix);
                        }
                        var geometry = objects.update(object);
                        if (material.isMultiMaterial) {
                            var groups = geometry.groups;
                            var materials = material.materials;
                            for (var i = 0, l = groups.length; i < l; i++) {
                                var group = groups[i];
                                var groupMaterial = materials[group.materialIndex];
                                if (groupMaterial.visible === true) {
                                    pushRenderItem(object, geometry, groupMaterial, _vector3.z, group);
                                }
                            }
                        } else {
                            pushRenderItem(object, geometry, material, _vector3.z, null);
                        }
                    }
                }
            }
        }
        var children = object.children;
        for (var i = 0, l = children.length; i < l; i++) {
            projectObject(children[i], camera);
        }
    }
    function renderObjects(renderList, camera, fog, overrideMaterial) {
        for (var i = 0, l = renderList.length; i < l; i++) {
            var renderItem = renderList[i];
            var object = renderItem.object;
            var geometry = renderItem.geometry;
            var material = overrideMaterial === undefined ? renderItem.material : overrideMaterial;
            var group = renderItem.group;
            object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);
            object.normalMatrix.getNormalMatrix(object.modelViewMatrix);
            if (object.isImmediateRenderObject) {
                setMaterial(material);
                var program = setProgram(camera, fog, material, object);
                _currentGeometryProgram = '';
                object.render(function (object) {
                    _this.renderBufferImmediate(object, program, material);
                });
            } else {
                _this.renderBufferDirect(camera, fog, geometry, material, object, group);
            }
        }
    }
    function initMaterial(material, fog, object) {
        var materialProperties = properties.get(material);
        var parameters = programCache.getParameters(material, _lights, fog, _clipping.numPlanes, object);
        var code = programCache.getProgramCode(material, parameters);
        var program = materialProperties.program;
        var programChange = true;
        if (program === undefined) {
            material.addEventListener('dispose', onMaterialDispose);
        } else if (program.code !== code) {
            releaseMaterialProgramReference(material);
        } else if (parameters.shaderID !== undefined) {
            return;
        } else {
            programChange = false;
        }
        if (programChange) {
            if (parameters.shaderID) {
                var shader = ShaderLib[parameters.shaderID];
                materialProperties.__webglShader = {
                    name: material.type,
                    uniforms: exports.UniformsUtils.clone(shader.uniforms),
                    vertexShader: shader.vertexShader,
                    fragmentShader: shader.fragmentShader
                };
            } else {
                materialProperties.__webglShader = {
                    name: material.type,
                    uniforms: material.uniforms,
                    vertexShader: material.vertexShader,
                    fragmentShader: material.fragmentShader
                };
            }
            material.__webglShader = materialProperties.__webglShader;
            program = programCache.acquireProgram(material, parameters, code);
            materialProperties.program = program;
            material.program = program;
        }
        var attributes = program.getAttributes();
        if (material.morphTargets) {
            material.numSupportedMorphTargets = 0;
            for (var i = 0; i < _this.maxMorphTargets; i++) {
                if (attributes['morphTarget' + i] >= 0) {
                    material.numSupportedMorphTargets++;
                }
            }
        }
        if (material.morphNormals) {
            material.numSupportedMorphNormals = 0;
            for (var i = 0; i < _this.maxMorphNormals; i++) {
                if (attributes['morphNormal' + i] >= 0) {
                    material.numSupportedMorphNormals++;
                }
            }
        }
        var uniforms = materialProperties.__webglShader.uniforms;
        if (!material.isShaderMaterial && !material.isRawShaderMaterial | material.clipping === true) {
            materialProperties.numClippingPlanes = _clipping.numPlanes;
            uniforms.clippingPlanes = _clipping.uniform;
        }
        materialProperties.fog = fog;
        materialProperties.lightsHash = _lights.hash;
        if (material.lights) {
            uniforms.ambientLightColor.value = _lights.ambient;
            uniforms.directionalLights.value = _lights.directional;
            uniforms.spotLights.value = _lights.spot;
            uniforms.pointLights.value = _lights.point;
            uniforms.hemisphereLights.value = _lights.hemi;
            uniforms.directionalShadowMap.value = _lights.directionalShadowMap;
            uniforms.directionalShadowMatrix.value = _lights.directionalShadowMatrix;
            uniforms.spotShadowMap.value = _lights.spotShadowMap;
            uniforms.spotShadowMatrix.value = _lights.spotShadowMatrix;
            uniforms.pointShadowMap.value = _lights.pointShadowMap;
            uniforms.pointShadowMatrix.value = _lights.pointShadowMatrix;
        }
        var progUniforms = materialProperties.program.getUniforms(), uniformsList = WebGLUniforms.seqWithValue(progUniforms.seq, uniforms);
        materialProperties.uniformsList = uniformsList;
        materialProperties.dynamicUniforms = WebGLUniforms.splitDynamic(uniformsList, uniforms);
    }
    function setMaterial(material) {
        material.side === DoubleSide ? state.disable(_gl.CULL_FACE) : state.enable(_gl.CULL_FACE);
        state.setFlipSided(material.side === BackSide);
        material.transparent === true ? state.setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha) : state.setBlending(NoBlending);
        state.setDepthFunc(material.depthFunc);
        state.setDepthTest(material.depthTest);
        state.setDepthWrite(material.depthWrite);
        state.setColorWrite(material.colorWrite);
        state.setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits);
    }
    function setProgram(camera, fog, material, object) {
        _usedTextureUnits = 0;
        var materialProperties = properties.get(material);
        if (_clippingEnabled) {
            if (_localClippingEnabled || camera !== _currentCamera) {
                var useCache = camera === _currentCamera && material.id === _currentMaterialId;
                _clipping.setState(material.clippingPlanes, material.clipShadows, camera, materialProperties, useCache);
            }
        }
        if (material.needsUpdate === false) {
            if (materialProperties.program === undefined) {
                material.needsUpdate = true;
            } else if (material.fog && materialProperties.fog !== fog) {
                material.needsUpdate = true;
            } else if (material.lights && materialProperties.lightsHash !== _lights.hash) {
                material.needsUpdate = true;
            } else if (materialProperties.numClippingPlanes !== undefined && materialProperties.numClippingPlanes !== _clipping.numPlanes) {
                material.needsUpdate = true;
            }
        }
        if (material.needsUpdate) {
            initMaterial(material, fog, object);
            material.needsUpdate = false;
        }
        var refreshProgram = false;
        var refreshMaterial = false;
        var refreshLights = false;
        var program = materialProperties.program, p_uniforms = program.getUniforms(), m_uniforms = materialProperties.__webglShader.uniforms;
        if (program.id !== _currentProgram) {
            _gl.useProgram(program.program);
            _currentProgram = program.id;
            refreshProgram = true;
            refreshMaterial = true;
            refreshLights = true;
        }
        if (material.id !== _currentMaterialId) {
            _currentMaterialId = material.id;
            refreshMaterial = true;
        }
        if (refreshProgram || camera !== _currentCamera) {
            p_uniforms.set(_gl, camera, 'projectionMatrix');
            if (capabilities.logarithmicDepthBuffer) {
                p_uniforms.setValue(_gl, 'logDepthBufFC', 2 / (Math.log(camera.far + 1) / Math.LN2));
            }
            if (camera !== _currentCamera) {
                _currentCamera = camera;
                refreshMaterial = true;
                refreshLights = true;
            }
            if (material.isShaderMaterial || material.isMeshPhongMaterial || material.isMeshStandardMaterial || material.envMap) {
                var uCamPos = p_uniforms.map.cameraPosition;
                if (uCamPos !== undefined) {
                    uCamPos.setValue(_gl, _vector3.setFromMatrixPosition(camera.matrixWorld));
                }
            }
            if (material.isMeshPhongMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial || material.skinning) {
                p_uniforms.setValue(_gl, 'viewMatrix', camera.matrixWorldInverse);
            }
            p_uniforms.set(_gl, _this, 'toneMappingExposure');
            p_uniforms.set(_gl, _this, 'toneMappingWhitePoint');
        }
        if (material.skinning) {
            p_uniforms.setOptional(_gl, object, 'bindMatrix');
            p_uniforms.setOptional(_gl, object, 'bindMatrixInverse');
            var skeleton = object.skeleton;
            if (skeleton) {
                if (capabilities.floatVertexTextures && skeleton.useVertexTexture) {
                    p_uniforms.set(_gl, skeleton, 'boneTexture');
                    p_uniforms.set(_gl, skeleton, 'boneTextureWidth');
                    p_uniforms.set(_gl, skeleton, 'boneTextureHeight');
                } else {
                    p_uniforms.setOptional(_gl, skeleton, 'boneMatrices');
                }
            }
        }
        if (refreshMaterial) {
            if (material.lights) {
                markUniformsLightsNeedsUpdate(m_uniforms, refreshLights);
            }
            if (fog && material.fog) {
                refreshUniformsFog(m_uniforms, fog);
            }
            if (material.isMeshBasicMaterial || material.isMeshLambertMaterial || material.isMeshPhongMaterial || material.isMeshStandardMaterial || material.isMeshDepthMaterial) {
                refreshUniformsCommon(m_uniforms, material);
            }
            if (material.isLineBasicMaterial) {
                refreshUniformsLine(m_uniforms, material);
            } else if (material.isLineDashedMaterial) {
                refreshUniformsLine(m_uniforms, material);
                refreshUniformsDash(m_uniforms, material);
            } else if (material.isPointsMaterial) {
                refreshUniformsPoints(m_uniforms, material);
            } else if (material.isMeshLambertMaterial) {
                refreshUniformsLambert(m_uniforms, material);
            } else if (material.isMeshPhongMaterial) {
                refreshUniformsPhong(m_uniforms, material);
            } else if (material.isMeshPhysicalMaterial) {
                refreshUniformsPhysical(m_uniforms, material);
            } else if (material.isMeshStandardMaterial) {
                refreshUniformsStandard(m_uniforms, material);
            } else if (material.isMeshDepthMaterial) {
                if (material.displacementMap) {
                    m_uniforms.displacementMap.value = material.displacementMap;
                    m_uniforms.displacementScale.value = material.displacementScale;
                    m_uniforms.displacementBias.value = material.displacementBias;
                }
            } else if (material.isMeshNormalMaterial) {
                m_uniforms.opacity.value = material.opacity;
            }
            WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, _this);
        }
        p_uniforms.set(_gl, object, 'modelViewMatrix');
        p_uniforms.set(_gl, object, 'normalMatrix');
        p_uniforms.setValue(_gl, 'modelMatrix', object.matrixWorld);
        var dynUniforms = materialProperties.dynamicUniforms;
        if (dynUniforms !== null) {
            WebGLUniforms.evalDynamic(dynUniforms, m_uniforms, object, camera);
            WebGLUniforms.upload(_gl, dynUniforms, m_uniforms, _this);
        }
        return program;
    }
    function refreshUniformsCommon(uniforms, material) {
        uniforms.opacity.value = material.opacity;
        uniforms.diffuse.value = material.color;
        if (material.emissive) {
            uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity);
        }
        uniforms.map.value = material.map;
        uniforms.specularMap.value = material.specularMap;
        uniforms.alphaMap.value = material.alphaMap;
        if (material.aoMap) {
            uniforms.aoMap.value = material.aoMap;
            uniforms.aoMapIntensity.value = material.aoMapIntensity;
        }
        var uvScaleMap;
        if (material.map) {
            uvScaleMap = material.map;
        } else if (material.specularMap) {
            uvScaleMap = material.specularMap;
        } else if (material.displacementMap) {
            uvScaleMap = material.displacementMap;
        } else if (material.normalMap) {
            uvScaleMap = material.normalMap;
        } else if (material.bumpMap) {
            uvScaleMap = material.bumpMap;
        } else if (material.roughnessMap) {
            uvScaleMap = material.roughnessMap;
        } else if (material.metalnessMap) {
            uvScaleMap = material.metalnessMap;
        } else if (material.alphaMap) {
            uvScaleMap = material.alphaMap;
        } else if (material.emissiveMap) {
            uvScaleMap = material.emissiveMap;
        }
        if (uvScaleMap !== undefined) {
            if (uvScaleMap.isWebGLRenderTarget) {
                uvScaleMap = uvScaleMap.texture;
            }
            var offset = uvScaleMap.offset;
            var repeat = uvScaleMap.repeat;
            uniforms.offsetRepeat.value.set(offset.x, offset.y, repeat.x, repeat.y);
        }
        uniforms.envMap.value = material.envMap;
        uniforms.flipEnvMap.value = !(material.envMap && material.envMap.isCubeTexture) ? 1 : -1;
        uniforms.reflectivity.value = material.reflectivity;
        uniforms.refractionRatio.value = material.refractionRatio;
    }
    function refreshUniformsLine(uniforms, material) {
        uniforms.diffuse.value = material.color;
        uniforms.opacity.value = material.opacity;
    }
    function refreshUniformsDash(uniforms, material) {
        uniforms.dashSize.value = material.dashSize;
        uniforms.totalSize.value = material.dashSize + material.gapSize;
        uniforms.scale.value = material.scale;
    }
    function refreshUniformsPoints(uniforms, material) {
        uniforms.diffuse.value = material.color;
        uniforms.opacity.value = material.opacity;
        uniforms.size.value = material.size * _pixelRatio;
        uniforms.scale.value = _canvas.clientHeight * 0.5;
        uniforms.map.value = material.map;
        if (material.map !== null) {
            var offset = material.map.offset;
            var repeat = material.map.repeat;
            uniforms.offsetRepeat.value.set(offset.x, offset.y, repeat.x, repeat.y);
        }
    }
    function refreshUniformsFog(uniforms, fog) {
        uniforms.fogColor.value = fog.color;
        if (fog.isFog) {
            uniforms.fogNear.value = fog.near;
            uniforms.fogFar.value = fog.far;
        } else if (fog.isFogExp2) {
            uniforms.fogDensity.value = fog.density;
        }
    }
    function refreshUniformsLambert(uniforms, material) {
        if (material.lightMap) {
            uniforms.lightMap.value = material.lightMap;
            uniforms.lightMapIntensity.value = material.lightMapIntensity;
        }
        if (material.emissiveMap) {
            uniforms.emissiveMap.value = material.emissiveMap;
        }
    }
    function refreshUniformsPhong(uniforms, material) {
        uniforms.specular.value = material.specular;
        uniforms.shininess.value = Math.max(material.shininess, 0.0001);
        if (material.lightMap) {
            uniforms.lightMap.value = material.lightMap;
            uniforms.lightMapIntensity.value = material.lightMapIntensity;
        }
        if (material.emissiveMap) {
            uniforms.emissiveMap.value = material.emissiveMap;
        }
        if (material.bumpMap) {
            uniforms.bumpMap.value = material.bumpMap;
            uniforms.bumpScale.value = material.bumpScale;
        }
        if (material.normalMap) {
            uniforms.normalMap.value = material.normalMap;
            uniforms.normalScale.value.copy(material.normalScale);
        }
        if (material.displacementMap) {
            uniforms.displacementMap.value = material.displacementMap;
            uniforms.displacementScale.value = material.displacementScale;
            uniforms.displacementBias.value = material.displacementBias;
        }
    }
    function refreshUniformsStandard(uniforms, material) {
        uniforms.roughness.value = material.roughness;
        uniforms.metalness.value = material.metalness;
        if (material.roughnessMap) {
            uniforms.roughnessMap.value = material.roughnessMap;
        }
        if (material.metalnessMap) {
            uniforms.metalnessMap.value = material.metalnessMap;
        }
        if (material.lightMap) {
            uniforms.lightMap.value = material.lightMap;
            uniforms.lightMapIntensity.value = material.lightMapIntensity;
        }
        if (material.emissiveMap) {
            uniforms.emissiveMap.value = material.emissiveMap;
        }
        if (material.bumpMap) {
            uniforms.bumpMap.value = material.bumpMap;
            uniforms.bumpScale.value = material.bumpScale;
        }
        if (material.normalMap) {
            uniforms.normalMap.value = material.normalMap;
            uniforms.normalScale.value.copy(material.normalScale);
        }
        if (material.displacementMap) {
            uniforms.displacementMap.value = material.displacementMap;
            uniforms.displacementScale.value = material.displacementScale;
            uniforms.displacementBias.value = material.displacementBias;
        }
        if (material.envMap) {
            uniforms.envMapIntensity.value = material.envMapIntensity;
        }
    }
    function refreshUniformsPhysical(uniforms, material) {
        uniforms.clearCoat.value = material.clearCoat;
        uniforms.clearCoatRoughness.value = material.clearCoatRoughness;
        refreshUniformsStandard(uniforms, material);
    }
    function markUniformsLightsNeedsUpdate(uniforms, value) {
        uniforms.ambientLightColor.needsUpdate = value;
        uniforms.directionalLights.needsUpdate = value;
        uniforms.pointLights.needsUpdate = value;
        uniforms.spotLights.needsUpdate = value;
        uniforms.hemisphereLights.needsUpdate = value;
    }
    function setupShadows(lights) {
        var lightShadowsLength = 0;
        for (var i = 0, l = lights.length; i < l; i++) {
            var light = lights[i];
            if (light.castShadow) {
                _lights.shadows[lightShadowsLength++] = light;
            }
        }
        _lights.shadows.length = lightShadowsLength;
    }
    function setupLights(lights, camera) {
        var l, ll, light, r = 0, g = 0, b = 0, color, intensity, distance, shadowMap, viewMatrix = camera.matrixWorldInverse, directionalLength = 0, pointLength = 0, spotLength = 0, hemiLength = 0;
        for (l = 0, ll = lights.length; l < ll; l++) {
            light = lights[l];
            color = light.color;
            intensity = light.intensity;
            distance = light.distance;
            shadowMap = light.shadow && light.shadow.map ? light.shadow.map.texture : null;
            if (light.isAmbientLight) {
                r += color.r * intensity;
                g += color.g * intensity;
                b += color.b * intensity;
            } else if (light.isDirectionalLight) {
                var uniforms = lightCache.get(light);
                uniforms.color.copy(light.color).multiplyScalar(light.intensity);
                uniforms.direction.setFromMatrixPosition(light.matrixWorld);
                _vector3.setFromMatrixPosition(light.target.matrixWorld);
                uniforms.direction.sub(_vector3);
                uniforms.direction.transformDirection(viewMatrix);
                uniforms.shadow = light.castShadow;
                if (light.castShadow) {
                    uniforms.shadowBias = light.shadow.bias;
                    uniforms.shadowRadius = light.shadow.radius;
                    uniforms.shadowMapSize = light.shadow.mapSize;
                }
                _lights.directionalShadowMap[directionalLength] = shadowMap;
                _lights.directionalShadowMatrix[directionalLength] = light.shadow.matrix;
                _lights.directional[directionalLength++] = uniforms;
            } else if (light.isSpotLight) {
                var uniforms = lightCache.get(light);
                uniforms.position.setFromMatrixPosition(light.matrixWorld);
                uniforms.position.applyMatrix4(viewMatrix);
                uniforms.color.copy(color).multiplyScalar(intensity);
                uniforms.distance = distance;
                uniforms.direction.setFromMatrixPosition(light.matrixWorld);
                _vector3.setFromMatrixPosition(light.target.matrixWorld);
                uniforms.direction.sub(_vector3);
                uniforms.direction.transformDirection(viewMatrix);
                uniforms.coneCos = Math.cos(light.angle);
                uniforms.penumbraCos = Math.cos(light.angle * (1 - light.penumbra));
                uniforms.decay = light.distance === 0 ? 0 : light.decay;
                uniforms.shadow = light.castShadow;
                if (light.castShadow) {
                    uniforms.shadowBias = light.shadow.bias;
                    uniforms.shadowRadius = light.shadow.radius;
                    uniforms.shadowMapSize = light.shadow.mapSize;
                }
                _lights.spotShadowMap[spotLength] = shadowMap;
                _lights.spotShadowMatrix[spotLength] = light.shadow.matrix;
                _lights.spot[spotLength++] = uniforms;
            } else if (light.isPointLight) {
                var uniforms = lightCache.get(light);
                uniforms.position.setFromMatrixPosition(light.matrixWorld);
                uniforms.position.applyMatrix4(viewMatrix);
                uniforms.color.copy(light.color).multiplyScalar(light.intensity);
                uniforms.distance = light.distance;
                uniforms.decay = light.distance === 0 ? 0 : light.decay;
                uniforms.shadow = light.castShadow;
                if (light.castShadow) {
                    uniforms.shadowBias = light.shadow.bias;
                    uniforms.shadowRadius = light.shadow.radius;
                    uniforms.shadowMapSize = light.shadow.mapSize;
                }
                _lights.pointShadowMap[pointLength] = shadowMap;
                if (_lights.pointShadowMatrix[pointLength] === undefined) {
                    _lights.pointShadowMatrix[pointLength] = new Matrix4();
                }
                _vector3.setFromMatrixPosition(light.matrixWorld).negate();
                _lights.pointShadowMatrix[pointLength].identity().setPosition(_vector3);
                _lights.point[pointLength++] = uniforms;
            } else if (light.isHemisphereLight) {
                var uniforms = lightCache.get(light);
                uniforms.direction.setFromMatrixPosition(light.matrixWorld);
                uniforms.direction.transformDirection(viewMatrix);
                uniforms.direction.normalize();
                uniforms.skyColor.copy(light.color).multiplyScalar(intensity);
                uniforms.groundColor.copy(light.groundColor).multiplyScalar(intensity);
                _lights.hemi[hemiLength++] = uniforms;
            }
        }
        _lights.ambient[0] = r;
        _lights.ambient[1] = g;
        _lights.ambient[2] = b;
        _lights.directional.length = directionalLength;
        _lights.spot.length = spotLength;
        _lights.point.length = pointLength;
        _lights.hemi.length = hemiLength;
        _lights.hash = directionalLength + ',' + pointLength + ',' + spotLength + ',' + hemiLength + ',' + _lights.shadows.length;
    }
    this.setFaceCulling = function (cullFace, frontFaceDirection) {
        state.setCullFace(cullFace);
        state.setFlipSided(frontFaceDirection === FrontFaceDirectionCW);
    };
    function allocTextureUnit() {
        var textureUnit = _usedTextureUnits;
        if (textureUnit >= capabilities.maxTextures) {
            console.warn('WebGLRenderer: trying to use ' + textureUnit + ' texture units while this GPU supports only ' + capabilities.maxTextures);
        }
        _usedTextureUnits += 1;
        return textureUnit;
    }
    this.allocTextureUnit = allocTextureUnit;
    this.setTexture2D = function () {
        var warned = false;
        return function setTexture2D(texture, slot) {
            if (texture && texture.isWebGLRenderTarget) {
                if (!warned) {
                    console.warn('THREE.WebGLRenderer.setTexture2D: don\'t use render targets as textures. Use their .texture property instead.');
                    warned = true;
                }
                texture = texture.texture;
            }
            textures.setTexture2D(texture, slot);
        };
    }();
    this.setTexture = function () {
        var warned = false;
        return function setTexture(texture, slot) {
            if (!warned) {
                console.warn('THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead.');
                warned = true;
            }
            textures.setTexture2D(texture, slot);
        };
    }();
    this.setTextureCube = function () {
        var warned = false;
        return function setTextureCube(texture, slot) {
            if (texture && texture.isWebGLRenderTargetCube) {
                if (!warned) {
                    console.warn('THREE.WebGLRenderer.setTextureCube: don\'t use cube render targets as textures. Use their .texture property instead.');
                    warned = true;
                }
                texture = texture.texture;
            }
            if (texture && texture.isCubeTexture || Array.isArray(texture.image) && texture.image.length === 6) {
                textures.setTextureCube(texture, slot);
            } else {
                textures.setTextureCubeDynamic(texture, slot);
            }
        };
    }();
    this.getCurrentRenderTarget = function () {
        return _currentRenderTarget;
    };
    this.setRenderTarget = function (renderTarget) {
        _currentRenderTarget = renderTarget;
        if (renderTarget && properties.get(renderTarget).__webglFramebuffer === undefined) {
            textures.setupRenderTarget(renderTarget);
        }
        var isCube = renderTarget && renderTarget.isWebGLRenderTargetCube;
        var framebuffer;
        if (renderTarget) {
            var renderTargetProperties = properties.get(renderTarget);
            if (isCube) {
                framebuffer = renderTargetProperties.__webglFramebuffer[renderTarget.activeCubeFace];
            } else {
                framebuffer = renderTargetProperties.__webglFramebuffer;
            }
            _currentScissor.copy(renderTarget.scissor);
            _currentScissorTest = renderTarget.scissorTest;
            _currentViewport.copy(renderTarget.viewport);
        } else {
            framebuffer = null;
            _currentScissor.copy(_scissor).multiplyScalar(_pixelRatio);
            _currentScissorTest = _scissorTest;
            _currentViewport.copy(_viewport).multiplyScalar(_pixelRatio);
        }
        if (_currentFramebuffer !== framebuffer) {
            _gl.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
            _currentFramebuffer = framebuffer;
        }
        state.scissor(_currentScissor);
        state.setScissorTest(_currentScissorTest);
        state.viewport(_currentViewport);
        if (isCube) {
            var textureProperties = properties.get(renderTarget.texture);
            _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + renderTarget.activeCubeFace, textureProperties.__webglTexture, renderTarget.activeMipMapLevel);
        }
    };
    this.readRenderTargetPixels = function (renderTarget, x, y, width, height, buffer) {
        if ((renderTarget && renderTarget.isWebGLRenderTarget) === false) {
            console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.');
            return;
        }
        var framebuffer = properties.get(renderTarget).__webglFramebuffer;
        if (framebuffer) {
            var restore = false;
            if (framebuffer !== _currentFramebuffer) {
                _gl.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
                restore = true;
            }
            try {
                var texture = renderTarget.texture;
                var textureFormat = texture.format;
                var textureType = texture.type;
                if (textureFormat !== RGBAFormat && paramThreeToGL(textureFormat) !== _gl.getParameter(_gl.IMPLEMENTATION_COLOR_READ_FORMAT)) {
                    console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.');
                    return;
                }
                if (textureType !== UnsignedByteType && paramThreeToGL(textureType) !== _gl.getParameter(_gl.IMPLEMENTATION_COLOR_READ_TYPE) && !(textureType === FloatType && (extensions.get('OES_texture_float') || extensions.get('WEBGL_color_buffer_float'))) && !(textureType === HalfFloatType && extensions.get('EXT_color_buffer_half_float'))) {
                    console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.');
                    return;
                }
                if (_gl.checkFramebufferStatus(_gl.FRAMEBUFFER) === _gl.FRAMEBUFFER_COMPLETE) {
                    if (x >= 0 && x <= renderTarget.width - width && (y >= 0 && y <= renderTarget.height - height)) {
                        _gl.readPixels(x, y, width, height, paramThreeToGL(textureFormat), paramThreeToGL(textureType), buffer);
                    }
                } else {
                    console.error('THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.');
                }
            } finally {
                if (restore) {
                    _gl.bindFramebuffer(_gl.FRAMEBUFFER, _currentFramebuffer);
                }
            }
        }
    };
    function paramThreeToGL(p) {
        var extension;
        if (p === RepeatWrapping)
            return _gl.REPEAT;
        if (p === ClampToEdgeWrapping)
            return _gl.CLAMP_TO_EDGE;
        if (p === MirroredRepeatWrapping)
            return _gl.MIRRORED_REPEAT;
        if (p === NearestFilter)
            return _gl.NEAREST;
        if (p === NearestMipMapNearestFilter)
            return _gl.NEAREST_MIPMAP_NEAREST;
        if (p === NearestMipMapLinearFilter)
            return _gl.NEAREST_MIPMAP_LINEAR;
        if (p === LinearFilter)
            return _gl.LINEAR;
        if (p === LinearMipMapNearestFilter)
            return _gl.LINEAR_MIPMAP_NEAREST;
        if (p === LinearMipMapLinearFilter)
            return _gl.LINEAR_MIPMAP_LINEAR;
        if (p === UnsignedByteType)
            return _gl.UNSIGNED_BYTE;
        if (p === UnsignedShort4444Type)
            return _gl.UNSIGNED_SHORT_4_4_4_4;
        if (p === UnsignedShort5551Type)
            return _gl.UNSIGNED_SHORT_5_5_5_1;
        if (p === UnsignedShort565Type)
            return _gl.UNSIGNED_SHORT_5_6_5;
        if (p === ByteType)
            return _gl.BYTE;
        if (p === ShortType)
            return _gl.SHORT;
        if (p === UnsignedShortType)
            return _gl.UNSIGNED_SHORT;
        if (p === IntType)
            return _gl.INT;
        if (p === UnsignedIntType)
            return _gl.UNSIGNED_INT;
        if (p === FloatType)
            return _gl.FLOAT;
        extension = extensions.get('OES_texture_half_float');
        if (extension !== null) {
            if (p === HalfFloatType)
                return extension.HALF_FLOAT_OES;
        }
        if (p === AlphaFormat)
            return _gl.ALPHA;
        if (p === RGBFormat)
            return _gl.RGB;
        if (p === RGBAFormat)
            return _gl.RGBA;
        if (p === LuminanceFormat)
            return _gl.LUMINANCE;
        if (p === LuminanceAlphaFormat)
            return _gl.LUMINANCE_ALPHA;
        if (p === DepthFormat)
            return _gl.DEPTH_COMPONENT;
        if (p === DepthStencilFormat)
            return _gl.DEPTH_STENCIL;
        if (p === AddEquation)
            return _gl.FUNC_ADD;
        if (p === SubtractEquation)
            return _gl.FUNC_SUBTRACT;
        if (p === ReverseSubtractEquation)
            return _gl.FUNC_REVERSE_SUBTRACT;
        if (p === ZeroFactor)
            return _gl.ZERO;
        if (p === OneFactor)
            return _gl.ONE;
        if (p === SrcColorFactor)
            return _gl.SRC_COLOR;
        if (p === OneMinusSrcColorFactor)
            return _gl.ONE_MINUS_SRC_COLOR;
        if (p === SrcAlphaFactor)
            return _gl.SRC_ALPHA;
        if (p === OneMinusSrcAlphaFactor)
            return _gl.ONE_MINUS_SRC_ALPHA;
        if (p === DstAlphaFactor)
            return _gl.DST_ALPHA;
        if (p === OneMinusDstAlphaFactor)
            return _gl.ONE_MINUS_DST_ALPHA;
        if (p === DstColorFactor)
            return _gl.DST_COLOR;
        if (p === OneMinusDstColorFactor)
            return _gl.ONE_MINUS_DST_COLOR;
        if (p === SrcAlphaSaturateFactor)
            return _gl.SRC_ALPHA_SATURATE;
        extension = extensions.get('WEBGL_compressed_texture_s3tc');
        if (extension !== null) {
            if (p === RGB_S3TC_DXT1_Format)
                return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
            if (p === RGBA_S3TC_DXT1_Format)
                return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
            if (p === RGBA_S3TC_DXT3_Format)
                return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
            if (p === RGBA_S3TC_DXT5_Format)
                return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;
        }
        extension = extensions.get('WEBGL_compressed_texture_pvrtc');
        if (extension !== null) {
            if (p === RGB_PVRTC_4BPPV1_Format)
                return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
            if (p === RGB_PVRTC_2BPPV1_Format)
                return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
            if (p === RGBA_PVRTC_4BPPV1_Format)
                return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
            if (p === RGBA_PVRTC_2BPPV1_Format)
                return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
        }
        extension = extensions.get('WEBGL_compressed_texture_etc1');
        if (extension !== null) {
            if (p === RGB_ETC1_Format)
                return extension.COMPRESSED_RGB_ETC1_WEBGL;
        }
        extension = extensions.get('EXT_blend_minmax');
        if (extension !== null) {
            if (p === MinEquation)
                return extension.MIN_EXT;
            if (p === MaxEquation)
                return extension.MAX_EXT;
        }
        extension = extensions.get('WEBGL_depth_texture');
        if (extension !== null) {
            if (p === UnsignedInt248Type)
                return extension.UNSIGNED_INT_24_8_WEBGL;
        }
        return 0;
    }
};
FogExp2 = function FogExp2(color, density) {
    this.name = '';
    this.color = new Color(color);
    this.density = density !== undefined ? density : 0.00025;
};
Fog = function Fog(color, near, far) {
    this.name = '';
    this.color = new Color(color);
    this.near = near !== undefined ? near : 1;
    this.far = far !== undefined ? far : 1000;
};
Scene = function Scene() {
    Object3D.call(this);
    this.type = 'Scene';
    this.background = null;
    this.fog = null;
    this.overrideMaterial = null;
    this.autoUpdate = true;
};
LensFlare = function LensFlare(texture, size, distance, blending, color) {
    Object3D.call(this);
    this.lensFlares = [];
    this.positionScreen = new Vector3();
    this.customUpdateCallback = undefined;
    if (texture !== undefined) {
        this.add(texture, size, distance, blending, color);
    }
};
SpriteMaterial = function SpriteMaterial(parameters) {
    Material.call(this);
    this.type = 'SpriteMaterial';
    this.color = new Color(16777215);
    this.map = null;
    this.rotation = 0;
    this.fog = false;
    this.lights = false;
    this.setValues(parameters);
};
Sprite = function Sprite(material) {
    Object3D.call(this);
    this.type = 'Sprite';
    this.material = material !== undefined ? material : new SpriteMaterial();
};
LOD = function LOD() {
    Object3D.call(this);
    this.type = 'LOD';
    Object.defineProperties(this, {
        levels: {
            enumerable: true,
            value: []
        }
    });
};
DataTexture = function DataTexture(data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {
    Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
    this.image = {
        data: data,
        width: width,
        height: height
    };
    this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
    this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;
    this.flipY = false;
    this.generateMipmaps = false;
};
Skeleton = function Skeleton(bones, boneInverses, useVertexTexture) {
    this.useVertexTexture = useVertexTexture !== undefined ? useVertexTexture : true;
    this.identityMatrix = new Matrix4();
    bones = bones || [];
    this.bones = bones.slice(0);
    if (this.useVertexTexture) {
        var size = Math.sqrt(this.bones.length * 4);
        size = exports.Math.nextPowerOfTwo(Math.ceil(size));
        size = Math.max(size, 4);
        this.boneTextureWidth = size;
        this.boneTextureHeight = size;
        this.boneMatrices = new Float32Array(this.boneTextureWidth * this.boneTextureHeight * 4);
        this.boneTexture = new DataTexture(this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, RGBAFormat, FloatType);
    } else {
        this.boneMatrices = new Float32Array(16 * this.bones.length);
    }
    if (boneInverses === undefined) {
        this.calculateInverses();
    } else {
        if (this.bones.length === boneInverses.length) {
            this.boneInverses = boneInverses.slice(0);
        } else {
            console.warn('THREE.Skeleton bonInverses is the wrong length.');
            this.boneInverses = [];
            for (var b = 0, bl = this.bones.length; b < bl; b++) {
                this.boneInverses.push(new Matrix4());
            }
        }
    }
};
Bone = function Bone(skin) {
    Object3D.call(this);
    this.type = 'Bone';
    this.skin = skin;
};
SkinnedMesh = function SkinnedMesh(geometry, material, useVertexTexture) {
    Mesh.call(this, geometry, material);
    this.type = 'SkinnedMesh';
    this.bindMode = 'attached';
    this.bindMatrix = new Matrix4();
    this.bindMatrixInverse = new Matrix4();
    var bones = [];
    if (this.geometry && this.geometry.bones !== undefined) {
        var bone, gbone;
        for (var b = 0, bl = this.geometry.bones.length; b < bl; ++b) {
            gbone = this.geometry.bones[b];
            bone = new Bone(this);
            bones.push(bone);
            bone.name = gbone.name;
            bone.position.fromArray(gbone.pos);
            bone.quaternion.fromArray(gbone.rotq);
            if (gbone.scl !== undefined)
                bone.scale.fromArray(gbone.scl);
        }
        for (var b = 0, bl = this.geometry.bones.length; b < bl; ++b) {
            gbone = this.geometry.bones[b];
            if (gbone.parent !== -1 && gbone.parent !== null && bones[gbone.parent] !== undefined) {
                bones[gbone.parent].add(bones[b]);
            } else {
                this.add(bones[b]);
            }
        }
    }
    this.normalizeSkinWeights();
    this.updateMatrixWorld(true);
    this.bind(new Skeleton(bones, undefined, useVertexTexture), this.matrixWorld);
};
LineBasicMaterial = function LineBasicMaterial(parameters) {
    Material.call(this);
    this.type = 'LineBasicMaterial';
    this.color = new Color(16777215);
    this.linewidth = 1;
    this.linecap = 'round';
    this.linejoin = 'round';
    this.lights = false;
    this.setValues(parameters);
};
Line = function Line(geometry, material, mode) {
    if (mode === 1) {
        console.warn('THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead.');
        return new LineSegments(geometry, material);
    }
    Object3D.call(this);
    this.type = 'Line';
    this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
    this.material = material !== undefined ? material : new LineBasicMaterial({
        color: Math.random() * 16777215
    });
};
LineSegments = function LineSegments(geometry, material) {
    Line.call(this, geometry, material);
    this.type = 'LineSegments';
};
PointsMaterial = function PointsMaterial(parameters) {
    Material.call(this);
    this.type = 'PointsMaterial';
    this.color = new Color(16777215);
    this.map = null;
    this.size = 1;
    this.sizeAttenuation = true;
    this.lights = false;
    this.setValues(parameters);
};
Points = function Points(geometry, material) {
    Object3D.call(this);
    this.type = 'Points';
    this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
    this.material = material !== undefined ? material : new PointsMaterial({
        color: Math.random() * 16777215
    });
};
Group = function Group() {
    Object3D.call(this);
    this.type = 'Group';
};
VideoTexture = function VideoTexture(video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
    Texture.call(this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
    this.generateMipmaps = false;
    var scope = this;
    function update() {
        requestAnimationFrame(update);
        if (video.readyState >= video.HAVE_CURRENT_DATA) {
            scope.needsUpdate = true;
        }
    }
    update();
};
CompressedTexture = function CompressedTexture(mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {
    Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
    this.image = {
        width: width,
        height: height
    };
    this.mipmaps = mipmaps;
    this.flipY = false;
    this.generateMipmaps = false;
};
CanvasTexture = function CanvasTexture(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
    Texture.call(this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
    this.needsUpdate = true;
};
DepthTexture = function DepthTexture(width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format) {
    format = format !== undefined ? format : DepthFormat;
    if (format !== DepthFormat && format !== DepthStencilFormat) {
        throw new Error('DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat');
    }
    Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
    this.image = {
        width: width,
        height: height
    };
    this.type = type !== undefined ? type : UnsignedShortType;
    this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
    this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;
    this.flipY = false;
    this.generateMipmaps = false;
};
ShadowMaterial = function ShadowMaterial() {
    ShaderMaterial.call(this, {
        uniforms: exports.UniformsUtils.merge([
            UniformsLib['lights'],
            {
                opacity: {
                    value: 1
                }
            }
        ]),
        vertexShader: ShaderChunk['shadow_vert'],
        fragmentShader: ShaderChunk['shadow_frag']
    });
    this.lights = true;
    this.transparent = true;
    Object.defineProperties(this, {
        opacity: {
            enumerable: true,
            get: function () {
                return this.uniforms.opacity.value;
            },
            set: function (value) {
                this.uniforms.opacity.value = value;
            }
        }
    });
};
RawShaderMaterial = function RawShaderMaterial(parameters) {
    ShaderMaterial.call(this, parameters);
    this.type = 'RawShaderMaterial';
};
MultiMaterial = function MultiMaterial(materials) {
    this.uuid = exports.Math.generateUUID();
    this.type = 'MultiMaterial';
    this.materials = materials instanceof Array ? materials : [];
    this.visible = true;
};
MeshStandardMaterial = function MeshStandardMaterial(parameters) {
    Material.call(this);
    this.defines = {
        'STANDARD': ''
    };
    this.type = 'MeshStandardMaterial';
    this.color = new Color(16777215);
    this.roughness = 0.5;
    this.metalness = 0.5;
    this.map = null;
    this.lightMap = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.emissive = new Color(0);
    this.emissiveIntensity = 1;
    this.emissiveMap = null;
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalScale = new Vector2(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.roughnessMap = null;
    this.metalnessMap = null;
    this.alphaMap = null;
    this.envMap = null;
    this.envMapIntensity = 1;
    this.refractionRatio = 0.98;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = 'round';
    this.wireframeLinejoin = 'round';
    this.skinning = false;
    this.morphTargets = false;
    this.morphNormals = false;
    this.setValues(parameters);
};
MeshPhysicalMaterial = function MeshPhysicalMaterial(parameters) {
    MeshStandardMaterial.call(this);
    this.defines = {
        'PHYSICAL': ''
    };
    this.type = 'MeshPhysicalMaterial';
    this.reflectivity = 0.5;
    this.clearCoat = 0;
    this.clearCoatRoughness = 0;
    this.setValues(parameters);
};
MeshPhongMaterial = function MeshPhongMaterial(parameters) {
    Material.call(this);
    this.type = 'MeshPhongMaterial';
    this.color = new Color(16777215);
    this.specular = new Color(1118481);
    this.shininess = 30;
    this.map = null;
    this.lightMap = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.emissive = new Color(0);
    this.emissiveIntensity = 1;
    this.emissiveMap = null;
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalScale = new Vector2(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.specularMap = null;
    this.alphaMap = null;
    this.envMap = null;
    this.combine = MultiplyOperation;
    this.reflectivity = 1;
    this.refractionRatio = 0.98;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = 'round';
    this.wireframeLinejoin = 'round';
    this.skinning = false;
    this.morphTargets = false;
    this.morphNormals = false;
    this.setValues(parameters);
};
MeshNormalMaterial = function MeshNormalMaterial(parameters) {
    Material.call(this, parameters);
    this.type = 'MeshNormalMaterial';
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.fog = false;
    this.lights = false;
    this.morphTargets = false;
    this.setValues(parameters);
};
MeshLambertMaterial = function MeshLambertMaterial(parameters) {
    Material.call(this);
    this.type = 'MeshLambertMaterial';
    this.color = new Color(16777215);
    this.map = null;
    this.lightMap = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.emissive = new Color(0);
    this.emissiveIntensity = 1;
    this.emissiveMap = null;
    this.specularMap = null;
    this.alphaMap = null;
    this.envMap = null;
    this.combine = MultiplyOperation;
    this.reflectivity = 1;
    this.refractionRatio = 0.98;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = 'round';
    this.wireframeLinejoin = 'round';
    this.skinning = false;
    this.morphTargets = false;
    this.morphNormals = false;
    this.setValues(parameters);
};
LineDashedMaterial = function LineDashedMaterial(parameters) {
    Material.call(this);
    this.type = 'LineDashedMaterial';
    this.color = new Color(16777215);
    this.linewidth = 1;
    this.scale = 1;
    this.dashSize = 3;
    this.gapSize = 1;
    this.lights = false;
    this.setValues(parameters);
};
LoadingManager = function LoadingManager(onLoad, onProgress, onError) {
    var scope = this;
    var isLoading = false, itemsLoaded = 0, itemsTotal = 0;
    this.onStart = undefined;
    this.onLoad = onLoad;
    this.onProgress = onProgress;
    this.onError = onError;
    this.itemStart = function (url) {
        itemsTotal++;
        if (isLoading === false) {
            if (scope.onStart !== undefined) {
                scope.onStart(url, itemsLoaded, itemsTotal);
            }
        }
        isLoading = true;
    };
    this.itemEnd = function (url) {
        itemsLoaded++;
        if (scope.onProgress !== undefined) {
            scope.onProgress(url, itemsLoaded, itemsTotal);
        }
        if (itemsLoaded === itemsTotal) {
            isLoading = false;
            if (scope.onLoad !== undefined) {
                scope.onLoad();
            }
        }
    };
    this.itemError = function (url) {
        if (scope.onError !== undefined) {
            scope.onError(url);
        }
    };
};
XHRLoader = function XHRLoader(manager) {
    this.manager = manager !== undefined ? manager : exports.DefaultLoadingManager;
};
CompressedTextureLoader = function CompressedTextureLoader(manager) {
    this.manager = manager !== undefined ? manager : exports.DefaultLoadingManager;
    this._parser = null;
};
BinaryTextureLoader = function BinaryTextureLoader(manager) {
    this.manager = manager !== undefined ? manager : exports.DefaultLoadingManager;
    this._parser = null;
};
ImageLoader = function ImageLoader(manager) {
    this.manager = manager !== undefined ? manager : exports.DefaultLoadingManager;
};
CubeTextureLoader = function CubeTextureLoader(manager) {
    this.manager = manager !== undefined ? manager : exports.DefaultLoadingManager;
};
TextureLoader = function TextureLoader(manager) {
    this.manager = manager !== undefined ? manager : exports.DefaultLoadingManager;
};
Light = function Light(color, intensity) {
    Object3D.call(this);
    this.type = 'Light';
    this.color = new Color(color);
    this.intensity = intensity !== undefined ? intensity : 1;
    this.receiveShadow = undefined;
};
HemisphereLight = function HemisphereLight(skyColor, groundColor, intensity) {
    Light.call(this, skyColor, intensity);
    this.type = 'HemisphereLight';
    this.castShadow = undefined;
    this.position.copy(Object3D.DefaultUp);
    this.updateMatrix();
    this.groundColor = new Color(groundColor);
};
LightShadow = function LightShadow(camera) {
    this.camera = camera;
    this.bias = 0;
    this.radius = 1;
    this.mapSize = new Vector2(512, 512);
    this.map = null;
    this.matrix = new Matrix4();
};
SpotLightShadow = function SpotLightShadow() {
    LightShadow.call(this, new PerspectiveCamera(50, 1, 0.5, 500));
};
SpotLight = function SpotLight(color, intensity, distance, angle, penumbra, decay) {
    Light.call(this, color, intensity);
    this.type = 'SpotLight';
    this.position.copy(Object3D.DefaultUp);
    this.updateMatrix();
    this.target = new Object3D();
    Object.defineProperty(this, 'power', {
        get: function () {
            return this.intensity * Math.PI;
        },
        set: function (power) {
            this.intensity = power / Math.PI;
        }
    });
    this.distance = distance !== undefined ? distance : 0;
    this.angle = angle !== undefined ? angle : Math.PI / 3;
    this.penumbra = penumbra !== undefined ? penumbra : 0;
    this.decay = decay !== undefined ? decay : 1;
    this.shadow = new SpotLightShadow();
};
PointLight = function PointLight(color, intensity, distance, decay) {
    Light.call(this, color, intensity);
    this.type = 'PointLight';
    Object.defineProperty(this, 'power', {
        get: function () {
            return this.intensity * 4 * Math.PI;
        },
        set: function (power) {
            this.intensity = power / (4 * Math.PI);
        }
    });
    this.distance = distance !== undefined ? distance : 0;
    this.decay = decay !== undefined ? decay : 1;
    this.shadow = new LightShadow(new PerspectiveCamera(90, 1, 0.5, 500));
};
DirectionalLightShadow = function DirectionalLightShadow(light) {
    LightShadow.call(this, new OrthographicCamera(-5, 5, 5, -5, 0.5, 500));
};
DirectionalLight = function DirectionalLight(color, intensity) {
    Light.call(this, color, intensity);
    this.type = 'DirectionalLight';
    this.position.copy(Object3D.DefaultUp);
    this.updateMatrix();
    this.target = new Object3D();
    this.shadow = new DirectionalLightShadow();
};
AmbientLight = function AmbientLight(color, intensity) {
    Light.call(this, color, intensity);
    this.type = 'AmbientLight';
    this.castShadow = undefined;
};
Interpolant = function Interpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    this.parameterPositions = parameterPositions;
    this._cachedIndex = 0;
    this.resultBuffer = resultBuffer !== undefined ? resultBuffer : new sampleValues.constructor(sampleSize);
    this.sampleValues = sampleValues;
    this.valueSize = sampleSize;
};
CubicInterpolant = function CubicInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
    this._weightPrev = -0;
    this._offsetPrev = -0;
    this._weightNext = -0;
    this._offsetNext = -0;
};
LinearInterpolant = function LinearInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
};
DiscreteInterpolant = function DiscreteInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
};
KeyframeTrackConstructor = function KeyframeTrackConstructor(name, times, values, interpolation) {
    if (name === undefined)
        throw new Error('track name is undefined');
    if (times === undefined || times.length === 0) {
        throw new Error('no keyframes in track named ' + name);
    }
    this.name = name;
    this.times = exports.AnimationUtils.convertArray(times, this.TimeBufferType);
    this.values = exports.AnimationUtils.convertArray(values, this.ValueBufferType);
    this.setInterpolation(interpolation || this.DefaultInterpolation);
    this.validate();
    this.optimize();
};
VectorKeyframeTrack = function VectorKeyframeTrack(name, times, values, interpolation) {
    KeyframeTrackConstructor.call(this, name, times, values, interpolation);
};
QuaternionLinearInterpolant = function QuaternionLinearInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
};
QuaternionKeyframeTrack = function QuaternionKeyframeTrack(name, times, values, interpolation) {
    KeyframeTrackConstructor.call(this, name, times, values, interpolation);
};
NumberKeyframeTrack = function NumberKeyframeTrack(name, times, values, interpolation) {
    KeyframeTrackConstructor.call(this, name, times, values, interpolation);
};
StringKeyframeTrack = function StringKeyframeTrack(name, times, values, interpolation) {
    KeyframeTrackConstructor.call(this, name, times, values, interpolation);
};
BooleanKeyframeTrack = function BooleanKeyframeTrack(name, times, values) {
    KeyframeTrackConstructor.call(this, name, times, values);
};
ColorKeyframeTrack = function ColorKeyframeTrack(name, times, values, interpolation) {
    KeyframeTrackConstructor.call(this, name, times, values, interpolation);
};
KeyframeTrack = function KeyframeTrack(name, times, values, interpolation) {
    KeyframeTrackConstructor.apply(this, arguments);
};
AnimationClip = function AnimationClip(name, duration, tracks) {
    this.name = name;
    this.tracks = tracks;
    this.duration = duration !== undefined ? duration : -1;
    this.uuid = exports.Math.generateUUID();
    if (this.duration < 0) {
        this.resetDuration();
    }
    this.trim();
    this.optimize();
};
MaterialLoader = function MaterialLoader(manager) {
    this.manager = manager !== undefined ? manager : exports.DefaultLoadingManager;
    this.textures = {};
};
BufferGeometryLoader = function BufferGeometryLoader(manager) {
    this.manager = manager !== undefined ? manager : exports.DefaultLoadingManager;
};
Loader = function Loader() {
    this.onLoadStart = function () {
    };
    this.onLoadProgress = function () {
    };
    this.onLoadComplete = function () {
    };
};
JSONLoader = function JSONLoader(manager) {
    if (typeof manager === 'boolean') {
        console.warn('THREE.JSONLoader: showStatus parameter has been removed from constructor.');
        manager = undefined;
    }
    this.manager = manager !== undefined ? manager : exports.DefaultLoadingManager;
    this.withCredentials = false;
};
ObjectLoader = function ObjectLoader(manager) {
    this.manager = manager !== undefined ? manager : exports.DefaultLoadingManager;
    this.texturePath = '';
};
Curve = function Curve() {
};
LineCurve = function LineCurve(v1, v2) {
    this.v1 = v1;
    this.v2 = v2;
};
CurvePath = function CurvePath() {
    this.curves = [];
    this.autoClose = false;
};
EllipseCurve = function EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
    this.aX = aX;
    this.aY = aY;
    this.xRadius = xRadius;
    this.yRadius = yRadius;
    this.aStartAngle = aStartAngle;
    this.aEndAngle = aEndAngle;
    this.aClockwise = aClockwise;
    this.aRotation = aRotation || 0;
};
SplineCurve = function SplineCurve(points) {
    this.points = points === undefined ? [] : points;
};
CubicBezierCurve = function CubicBezierCurve(v0, v1, v2, v3) {
    this.v0 = v0;
    this.v1 = v1;
    this.v2 = v2;
    this.v3 = v3;
};
QuadraticBezierCurve = function QuadraticBezierCurve(v0, v1, v2) {
    this.v0 = v0;
    this.v1 = v1;
    this.v2 = v2;
};
TubeGeometry = function TubeGeometry(path, segments, radius, radialSegments, closed, taper) {
    Geometry.call(this);
    this.type = 'TubeGeometry';
    this.parameters = {
        path: path,
        segments: segments,
        radius: radius,
        radialSegments: radialSegments,
        closed: closed,
        taper: taper
    };
    segments = segments || 64;
    radius = radius || 1;
    radialSegments = radialSegments || 8;
    closed = closed || false;
    taper = taper || TubeGeometry.NoTaper;
    var grid = [];
    var scope = this, tangent, normal, binormal, numpoints = segments + 1, u, v, r, cx, cy, pos, pos2 = new Vector3(), i, j, ip, jp, a, b, c, d, uva, uvb, uvc, uvd;
    var frames = new TubeGeometry.FrenetFrames(path, segments, closed), tangents = frames.tangents, normals = frames.normals, binormals = frames.binormals;
    this.tangents = tangents;
    this.normals = normals;
    this.binormals = binormals;
    function vert(x, y, z) {
        return scope.vertices.push(new Vector3(x, y, z)) - 1;
    }
    for (i = 0; i < numpoints; i++) {
        grid[i] = [];
        u = i / (numpoints - 1);
        pos = path.getPointAt(u);
        tangent = tangents[i];
        normal = normals[i];
        binormal = binormals[i];
        r = radius * taper(u);
        for (j = 0; j < radialSegments; j++) {
            v = j / radialSegments * 2 * Math.PI;
            cx = -r * Math.cos(v);
            cy = r * Math.sin(v);
            pos2.copy(pos);
            pos2.x += cx * normal.x + cy * binormal.x;
            pos2.y += cx * normal.y + cy * binormal.y;
            pos2.z += cx * normal.z + cy * binormal.z;
            grid[i][j] = vert(pos2.x, pos2.y, pos2.z);
        }
    }
    for (i = 0; i < segments; i++) {
        for (j = 0; j < radialSegments; j++) {
            ip = closed ? (i + 1) % segments : i + 1;
            jp = (j + 1) % radialSegments;
            a = grid[i][j];
            b = grid[ip][j];
            c = grid[ip][jp];
            d = grid[i][jp];
            uva = new Vector2(i / segments, j / radialSegments);
            uvb = new Vector2((i + 1) / segments, j / radialSegments);
            uvc = new Vector2((i + 1) / segments, (j + 1) / radialSegments);
            uvd = new Vector2(i / segments, (j + 1) / radialSegments);
            this.faces.push(new Face3(a, b, d));
            this.faceVertexUvs[0].push([
                uva,
                uvb,
                uvd
            ]);
            this.faces.push(new Face3(b, c, d));
            this.faceVertexUvs[0].push([
                uvb.clone(),
                uvc,
                uvd.clone()
            ]);
        }
    }
    this.computeFaceNormals();
    this.computeVertexNormals();
};
ExtrudeGeometry = function ExtrudeGeometry(shapes, options) {
    if (typeof shapes === 'undefined') {
        shapes = [];
        return;
    }
    Geometry.call(this);
    this.type = 'ExtrudeGeometry';
    shapes = Array.isArray(shapes) ? shapes : [shapes];
    this.addShapeList(shapes, options);
    this.computeFaceNormals();
};
ShapeGeometry = function ShapeGeometry(shapes, options) {
    Geometry.call(this);
    this.type = 'ShapeGeometry';
    if (Array.isArray(shapes) === false)
        shapes = [shapes];
    this.addShapeList(shapes, options);
    this.computeFaceNormals();
};
Shape = function Shape() {
    Path.apply(this, arguments);
    this.holes = [];
};
Path = function Path(points) {
    CurvePath.call(this);
    this.currentPoint = new Vector2();
    if (points) {
        this.fromPoints(points);
    }
};
ShapePath = function ShapePath() {
    this.subPaths = [];
    this.currentPath = null;
};
Font = function Font(data) {
    this.data = data;
};
FontLoader = function FontLoader(manager) {
    this.manager = manager !== undefined ? manager : exports.DefaultLoadingManager;
};
getAudioContext = function getAudioContext() {
    if (context === undefined) {
        context = new (window.AudioContext || window.webkitAudioContext)();
    }
    return context;
};
AudioLoader = function AudioLoader(manager) {
    this.manager = manager !== undefined ? manager : exports.DefaultLoadingManager;
};
StereoCamera = function StereoCamera() {
    this.type = 'StereoCamera';
    this.aspect = 1;
    this.eyeSep = 0.064;
    this.cameraL = new PerspectiveCamera();
    this.cameraL.layers.enable(1);
    this.cameraL.matrixAutoUpdate = false;
    this.cameraR = new PerspectiveCamera();
    this.cameraR.layers.enable(2);
    this.cameraR.matrixAutoUpdate = false;
};
CubeCamera = function CubeCamera(near, far, cubeResolution) {
    Object3D.call(this);
    this.type = 'CubeCamera';
    var fov = 90, aspect = 1;
    var cameraPX = new PerspectiveCamera(fov, aspect, near, far);
    cameraPX.up.set(0, -1, 0);
    cameraPX.lookAt(new Vector3(1, 0, 0));
    this.add(cameraPX);
    var cameraNX = new PerspectiveCamera(fov, aspect, near, far);
    cameraNX.up.set(0, -1, 0);
    cameraNX.lookAt(new Vector3(-1, 0, 0));
    this.add(cameraNX);
    var cameraPY = new PerspectiveCamera(fov, aspect, near, far);
    cameraPY.up.set(0, 0, 1);
    cameraPY.lookAt(new Vector3(0, 1, 0));
    this.add(cameraPY);
    var cameraNY = new PerspectiveCamera(fov, aspect, near, far);
    cameraNY.up.set(0, 0, -1);
    cameraNY.lookAt(new Vector3(0, -1, 0));
    this.add(cameraNY);
    var cameraPZ = new PerspectiveCamera(fov, aspect, near, far);
    cameraPZ.up.set(0, -1, 0);
    cameraPZ.lookAt(new Vector3(0, 0, 1));
    this.add(cameraPZ);
    var cameraNZ = new PerspectiveCamera(fov, aspect, near, far);
    cameraNZ.up.set(0, -1, 0);
    cameraNZ.lookAt(new Vector3(0, 0, -1));
    this.add(cameraNZ);
    var options = {
        format: RGBFormat,
        magFilter: LinearFilter,
        minFilter: LinearFilter
    };
    this.renderTarget = new WebGLRenderTargetCube(cubeResolution, cubeResolution, options);
    this.updateCubeMap = function (renderer, scene) {
        if (this.parent === null)
            this.updateMatrixWorld();
        var renderTarget = this.renderTarget;
        var generateMipmaps = renderTarget.texture.generateMipmaps;
        renderTarget.texture.generateMipmaps = false;
        renderTarget.activeCubeFace = 0;
        renderer.render(scene, cameraPX, renderTarget);
        renderTarget.activeCubeFace = 1;
        renderer.render(scene, cameraNX, renderTarget);
        renderTarget.activeCubeFace = 2;
        renderer.render(scene, cameraPY, renderTarget);
        renderTarget.activeCubeFace = 3;
        renderer.render(scene, cameraNY, renderTarget);
        renderTarget.activeCubeFace = 4;
        renderer.render(scene, cameraPZ, renderTarget);
        renderTarget.texture.generateMipmaps = generateMipmaps;
        renderTarget.activeCubeFace = 5;
        renderer.render(scene, cameraNZ, renderTarget);
        renderer.setRenderTarget(null);
    };
};
AudioListener = function AudioListener() {
    Object3D.call(this);
    this.type = 'AudioListener';
    this.context = getAudioContext();
    this.gain = this.context.createGain();
    this.gain.connect(this.context.destination);
    this.filter = null;
};
Audio = function Audio(listener) {
    Object3D.call(this);
    this.type = 'Audio';
    this.context = listener.context;
    this.source = this.context.createBufferSource();
    this.source.onended = this.onEnded.bind(this);
    this.gain = this.context.createGain();
    this.gain.connect(listener.getInput());
    this.autoplay = false;
    this.startTime = 0;
    this.playbackRate = 1;
    this.isPlaying = false;
    this.hasPlaybackControl = true;
    this.sourceType = 'empty';
    this.filters = [];
};
PositionalAudio = function PositionalAudio(listener) {
    Audio.call(this, listener);
    this.panner = this.context.createPanner();
    this.panner.connect(this.gain);
};
AudioAnalyser = function AudioAnalyser(audio, fftSize) {
    this.analyser = audio.context.createAnalyser();
    this.analyser.fftSize = fftSize !== undefined ? fftSize : 2048;
    this.data = new Uint8Array(this.analyser.frequencyBinCount);
    audio.getOutput().connect(this.analyser);
};
PropertyMixer = function PropertyMixer(binding, typeName, valueSize) {
    this.binding = binding;
    this.valueSize = valueSize;
    var bufferType = Float64Array, mixFunction;
    switch (typeName) {
    case 'quaternion':
        mixFunction = this._slerp;
        break;
    case 'string':
    case 'bool':
        bufferType = Array, mixFunction = this._select;
        break;
    default:
        mixFunction = this._lerp;
    }
    this.buffer = new bufferType(valueSize * 4);
    this._mixBufferRegion = mixFunction;
    this.cumulativeWeight = 0;
    this.useCount = 0;
    this.referenceCount = 0;
};
PropertyBinding = function PropertyBinding(rootNode, path, parsedPath) {
    this.path = path;
    this.parsedPath = parsedPath || PropertyBinding.parseTrackName(path);
    this.node = PropertyBinding.findNode(rootNode, this.parsedPath.nodeName) || rootNode;
    this.rootNode = rootNode;
};
AnimationObjectGroup = function AnimationObjectGroup(var_args) {
    this.uuid = exports.Math.generateUUID();
    this._objects = Array.prototype.slice.call(arguments);
    this.nCachedObjects_ = 0;
    var indices = {};
    this._indicesByUUID = indices;
    for (var i = 0, n = arguments.length; i !== n; ++i) {
        indices[arguments[i].uuid] = i;
    }
    this._paths = [];
    this._parsedPaths = [];
    this._bindings = [];
    this._bindingsIndicesByPath = {};
    var scope = this;
    this.stats = {
        objects: {
            get total() {
                return scope._objects.length;
            },
            get inUse() {
                return this.total - scope.nCachedObjects_;
            }
        },
        get bindingsPerObject() {
            return scope._bindings.length;
        }
    };
};
AnimationAction = function AnimationAction(mixer, clip, localRoot) {
    this._mixer = mixer;
    this._clip = clip;
    this._localRoot = localRoot || null;
    var tracks = clip.tracks, nTracks = tracks.length, interpolants = new Array(nTracks);
    var interpolantSettings = {
        endingStart: ZeroCurvatureEnding,
        endingEnd: ZeroCurvatureEnding
    };
    for (var i = 0; i !== nTracks; ++i) {
        var interpolant = tracks[i].createInterpolant(null);
        interpolants[i] = interpolant;
        interpolant.settings = interpolantSettings;
    }
    this._interpolantSettings = interpolantSettings;
    this._interpolants = interpolants;
    this._propertyBindings = new Array(nTracks);
    this._cacheIndex = null;
    this._byClipCacheIndex = null;
    this._timeScaleInterpolant = null;
    this._weightInterpolant = null;
    this.loop = LoopRepeat;
    this._loopCount = -1;
    this._startTime = null;
    this.time = 0;
    this.timeScale = 1;
    this._effectiveTimeScale = 1;
    this.weight = 1;
    this._effectiveWeight = 1;
    this.repetitions = Infinity;
    this.paused = false;
    this.enabled = true;
    this.clampWhenFinished = false;
    this.zeroSlopeAtStart = true;
    this.zeroSlopeAtEnd = true;
};
AnimationMixer = function AnimationMixer(root) {
    this._root = root;
    this._initMemoryManager();
    this._accuIndex = 0;
    this.time = 0;
    this.timeScale = 1;
};
Uniform = function Uniform(value) {
    if (typeof value === 'string') {
        console.warn('THREE.Uniform: Type parameter is no longer needed.');
        value = arguments[1];
    }
    this.value = value;
    this.dynamic = false;
};
InstancedBufferGeometry = function InstancedBufferGeometry() {
    BufferGeometry.call(this);
    this.type = 'InstancedBufferGeometry';
    this.maxInstancedCount = undefined;
};
InterleavedBufferAttribute = function InterleavedBufferAttribute(interleavedBuffer, itemSize, offset, normalized) {
    this.uuid = exports.Math.generateUUID();
    this.data = interleavedBuffer;
    this.itemSize = itemSize;
    this.offset = offset;
    this.normalized = normalized === true;
};
InterleavedBuffer = function InterleavedBuffer(array, stride) {
    this.uuid = exports.Math.generateUUID();
    this.array = array;
    this.stride = stride;
    this.dynamic = false;
    this.updateRange = {
        offset: 0,
        count: -1
    };
    this.version = 0;
};
InstancedInterleavedBuffer = function InstancedInterleavedBuffer(array, stride, meshPerAttribute) {
    InterleavedBuffer.call(this, array, stride);
    this.meshPerAttribute = meshPerAttribute || 1;
};
InstancedBufferAttribute = function InstancedBufferAttribute(array, itemSize, meshPerAttribute) {
    BufferAttribute.call(this, array, itemSize);
    this.meshPerAttribute = meshPerAttribute || 1;
};
Raycaster = function Raycaster(origin, direction, near, far) {
    this.ray = new Ray(origin, direction);
    this.near = near || 0;
    this.far = far || Infinity;
    this.params = {
        Mesh: {},
        Line: {},
        LOD: {},
        Points: {
            threshold: 1
        },
        Sprite: {}
    };
    Object.defineProperties(this.params, {
        PointCloud: {
            get: function () {
                console.warn('THREE.Raycaster: params.PointCloud has been renamed to params.Points.');
                return this.Points;
            }
        }
    });
};
ascSort = function ascSort(a, b) {
    return a.distance - b.distance;
};
intersectObject = function intersectObject(object, raycaster, intersects, recursive) {
    if (object.visible === false)
        return;
    object.raycast(raycaster, intersects);
    if (recursive === true) {
        var children = object.children;
        for (var i = 0, l = children.length; i < l; i++) {
            intersectObject(children[i], raycaster, intersects, true);
        }
    }
};
Clock = function Clock(autoStart) {
    this.autoStart = autoStart !== undefined ? autoStart : true;
    this.startTime = 0;
    this.oldTime = 0;
    this.elapsedTime = 0;
    this.running = false;
};
Spline = function Spline(points) {
    this.points = points;
    var c = [], v3 = {
            x: 0,
            y: 0,
            z: 0
        }, point, intPoint, weight, w2, w3, pa, pb, pc, pd;
    this.initFromArray = function (a) {
        this.points = [];
        for (var i = 0; i < a.length; i++) {
            this.points[i] = {
                x: a[i][0],
                y: a[i][1],
                z: a[i][2]
            };
        }
    };
    this.getPoint = function (k) {
        point = (this.points.length - 1) * k;
        intPoint = Math.floor(point);
        weight = point - intPoint;
        c[0] = intPoint === 0 ? intPoint : intPoint - 1;
        c[1] = intPoint;
        c[2] = intPoint > this.points.length - 2 ? this.points.length - 1 : intPoint + 1;
        c[3] = intPoint > this.points.length - 3 ? this.points.length - 1 : intPoint + 2;
        pa = this.points[c[0]];
        pb = this.points[c[1]];
        pc = this.points[c[2]];
        pd = this.points[c[3]];
        w2 = weight * weight;
        w3 = weight * w2;
        v3.x = interpolate(pa.x, pb.x, pc.x, pd.x, weight, w2, w3);
        v3.y = interpolate(pa.y, pb.y, pc.y, pd.y, weight, w2, w3);
        v3.z = interpolate(pa.z, pb.z, pc.z, pd.z, weight, w2, w3);
        return v3;
    };
    this.getControlPointsArray = function () {
        var i, p, l = this.points.length, coords = [];
        for (i = 0; i < l; i++) {
            p = this.points[i];
            coords[i] = [
                p.x,
                p.y,
                p.z
            ];
        }
        return coords;
    };
    this.getLength = function (nSubDivisions) {
        var i, index, nSamples, position, point = 0, intPoint = 0, oldIntPoint = 0, oldPosition = new Vector3(), tmpVec = new Vector3(), chunkLengths = [], totalLength = 0;
        chunkLengths[0] = 0;
        if (!nSubDivisions)
            nSubDivisions = 100;
        nSamples = this.points.length * nSubDivisions;
        oldPosition.copy(this.points[0]);
        for (i = 1; i < nSamples; i++) {
            index = i / nSamples;
            position = this.getPoint(index);
            tmpVec.copy(position);
            totalLength += tmpVec.distanceTo(oldPosition);
            oldPosition.copy(position);
            point = (this.points.length - 1) * index;
            intPoint = Math.floor(point);
            if (intPoint !== oldIntPoint) {
                chunkLengths[intPoint] = totalLength;
                oldIntPoint = intPoint;
            }
        }
        chunkLengths[chunkLengths.length] = totalLength;
        return {
            chunks: chunkLengths,
            total: totalLength
        };
    };
    this.reparametrizeByArcLength = function (samplingCoef) {
        var i, j, index, indexCurrent, indexNext, realDistance, sampling, position, newpoints = [], tmpVec = new Vector3(), sl = this.getLength();
        newpoints.push(tmpVec.copy(this.points[0]).clone());
        for (i = 1; i < this.points.length; i++) {
            realDistance = sl.chunks[i] - sl.chunks[i - 1];
            sampling = Math.ceil(samplingCoef * realDistance / sl.total);
            indexCurrent = (i - 1) / (this.points.length - 1);
            indexNext = i / (this.points.length - 1);
            for (j = 1; j < sampling - 1; j++) {
                index = indexCurrent + j * (1 / sampling) * (indexNext - indexCurrent);
                position = this.getPoint(index);
                newpoints.push(tmpVec.copy(position).clone());
            }
            newpoints.push(tmpVec.copy(this.points[i]).clone());
        }
        this.points = newpoints;
    };
    function interpolate(p0, p1, p2, p3, t, t2, t3) {
        var v0 = (p2 - p0) * 0.5, v1 = (p3 - p1) * 0.5;
        return (2 * (p1 - p2) + v0 + v1) * t3 + (-3 * (p1 - p2) - 2 * v0 - v1) * t2 + v0 * t + p1;
    }
};
Spherical = function Spherical(radius, phi, theta) {
    this.radius = radius !== undefined ? radius : 1;
    this.phi = phi !== undefined ? phi : 0;
    this.theta = theta !== undefined ? theta : 0;
    return this;
};
MorphBlendMesh = function MorphBlendMesh(geometry, material) {
    Mesh.call(this, geometry, material);
    this.animationsMap = {};
    this.animationsList = [];
    var numFrames = this.geometry.morphTargets.length;
    var name = '__default';
    var startFrame = 0;
    var endFrame = numFrames - 1;
    var fps = numFrames / 1;
    this.createAnimation(name, startFrame, endFrame, fps);
    this.setAnimationWeight(name, 1);
};
ImmediateRenderObject = function ImmediateRenderObject(material) {
    Object3D.call(this);
    this.material = material;
    this.render = function (renderCallback) {
    };
};
WireframeGeometry = function WireframeGeometry(geometry) {
    BufferGeometry.call(this);
    var edge = [
            0,
            0
        ], hash = {};
    function sortFunction(a, b) {
        return a - b;
    }
    var keys = [
        'a',
        'b',
        'c'
    ];
    if (geometry && geometry.isGeometry) {
        var vertices = geometry.vertices;
        var faces = geometry.faces;
        var numEdges = 0;
        var edges = new Uint32Array(6 * faces.length);
        for (var i = 0, l = faces.length; i < l; i++) {
            var face = faces[i];
            for (var j = 0; j < 3; j++) {
                edge[0] = face[keys[j]];
                edge[1] = face[keys[(j + 1) % 3]];
                edge.sort(sortFunction);
                var key = edge.toString();
                if (hash[key] === undefined) {
                    edges[2 * numEdges] = edge[0];
                    edges[2 * numEdges + 1] = edge[1];
                    hash[key] = true;
                    numEdges++;
                }
            }
        }
        var coords = new Float32Array(numEdges * 2 * 3);
        for (var i = 0, l = numEdges; i < l; i++) {
            for (var j = 0; j < 2; j++) {
                var vertex = vertices[edges[2 * i + j]];
                var index = 6 * i + 3 * j;
                coords[index + 0] = vertex.x;
                coords[index + 1] = vertex.y;
                coords[index + 2] = vertex.z;
            }
        }
        this.addAttribute('position', new BufferAttribute(coords, 3));
    } else if (geometry && geometry.isBufferGeometry) {
        if (geometry.index !== null) {
            var indices = geometry.index.array;
            var vertices = geometry.attributes.position;
            var groups = geometry.groups;
            var numEdges = 0;
            if (groups.length === 0) {
                geometry.addGroup(0, indices.length);
            }
            var edges = new Uint32Array(2 * indices.length);
            for (var o = 0, ol = groups.length; o < ol; ++o) {
                var group = groups[o];
                var start = group.start;
                var count = group.count;
                for (var i = start, il = start + count; i < il; i += 3) {
                    for (var j = 0; j < 3; j++) {
                        edge[0] = indices[i + j];
                        edge[1] = indices[i + (j + 1) % 3];
                        edge.sort(sortFunction);
                        var key = edge.toString();
                        if (hash[key] === undefined) {
                            edges[2 * numEdges] = edge[0];
                            edges[2 * numEdges + 1] = edge[1];
                            hash[key] = true;
                            numEdges++;
                        }
                    }
                }
            }
            var coords = new Float32Array(numEdges * 2 * 3);
            for (var i = 0, l = numEdges; i < l; i++) {
                for (var j = 0; j < 2; j++) {
                    var index = 6 * i + 3 * j;
                    var index2 = edges[2 * i + j];
                    coords[index + 0] = vertices.getX(index2);
                    coords[index + 1] = vertices.getY(index2);
                    coords[index + 2] = vertices.getZ(index2);
                }
            }
            this.addAttribute('position', new BufferAttribute(coords, 3));
        } else {
            var vertices = geometry.attributes.position.array;
            var numEdges = vertices.length / 3;
            var numTris = numEdges / 3;
            var coords = new Float32Array(numEdges * 2 * 3);
            for (var i = 0, l = numTris; i < l; i++) {
                for (var j = 0; j < 3; j++) {
                    var index = 18 * i + 6 * j;
                    var index1 = 9 * i + 3 * j;
                    coords[index + 0] = vertices[index1];
                    coords[index + 1] = vertices[index1 + 1];
                    coords[index + 2] = vertices[index1 + 2];
                    var index2 = 9 * i + 3 * ((j + 1) % 3);
                    coords[index + 3] = vertices[index2];
                    coords[index + 4] = vertices[index2 + 1];
                    coords[index + 5] = vertices[index2 + 2];
                }
            }
            this.addAttribute('position', new BufferAttribute(coords, 3));
        }
    }
};
WireframeHelper = function WireframeHelper(object, hex) {
    var color = hex !== undefined ? hex : 16777215;
    LineSegments.call(this, new WireframeGeometry(object.geometry), new LineBasicMaterial({
        color: color
    }));
    this.matrix = object.matrixWorld;
    this.matrixAutoUpdate = false;
};
VertexNormalsHelper = function VertexNormalsHelper(object, size, hex, linewidth) {
    this.object = object;
    this.size = size !== undefined ? size : 1;
    var color = hex !== undefined ? hex : 16711680;
    var width = linewidth !== undefined ? linewidth : 1;
    var nNormals = 0;
    var objGeometry = this.object.geometry;
    if (objGeometry && objGeometry.isGeometry) {
        nNormals = objGeometry.faces.length * 3;
    } else if (objGeometry && objGeometry.isBufferGeometry) {
        nNormals = objGeometry.attributes.normal.count;
    }
    var geometry = new BufferGeometry();
    var positions = new Float32Attribute(nNormals * 2 * 3, 3);
    geometry.addAttribute('position', positions);
    LineSegments.call(this, geometry, new LineBasicMaterial({
        color: color,
        linewidth: width
    }));
    this.matrixAutoUpdate = false;
    this.update();
};
SpotLightHelper = function SpotLightHelper(light) {
    Object3D.call(this);
    this.light = light;
    this.light.updateMatrixWorld();
    this.matrix = light.matrixWorld;
    this.matrixAutoUpdate = false;
    var geometry = new BufferGeometry();
    var positions = [
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1,
        0,
        1,
        0,
        0,
        0,
        -1,
        0,
        1,
        0,
        0,
        0,
        0,
        1,
        1,
        0,
        0,
        0,
        0,
        -1,
        1
    ];
    for (var i = 0, j = 1, l = 32; i < l; i++, j++) {
        var p1 = i / l * Math.PI * 2;
        var p2 = j / l * Math.PI * 2;
        positions.push(Math.cos(p1), Math.sin(p1), 1, Math.cos(p2), Math.sin(p2), 1);
    }
    geometry.addAttribute('position', new Float32Attribute(positions, 3));
    var material = new LineBasicMaterial({
        fog: false
    });
    this.cone = new LineSegments(geometry, material);
    this.add(this.cone);
    this.update();
};
SkeletonHelper = function SkeletonHelper(object) {
    this.bones = this.getBoneList(object);
    var geometry = new Geometry();
    for (var i = 0; i < this.bones.length; i++) {
        var bone = this.bones[i];
        if (bone.parent && bone.parent.isBone) {
            geometry.vertices.push(new Vector3());
            geometry.vertices.push(new Vector3());
            geometry.colors.push(new Color(0, 0, 1));
            geometry.colors.push(new Color(0, 1, 0));
        }
    }
    geometry.dynamic = true;
    var material = new LineBasicMaterial({
        vertexColors: VertexColors,
        depthTest: false,
        depthWrite: false,
        transparent: true
    });
    LineSegments.call(this, geometry, material);
    this.root = object;
    this.matrix = object.matrixWorld;
    this.matrixAutoUpdate = false;
    this.update();
};
SphereBufferGeometry = function SphereBufferGeometry(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength) {
    BufferGeometry.call(this);
    this.type = 'SphereBufferGeometry';
    this.parameters = {
        radius: radius,
        widthSegments: widthSegments,
        heightSegments: heightSegments,
        phiStart: phiStart,
        phiLength: phiLength,
        thetaStart: thetaStart,
        thetaLength: thetaLength
    };
    radius = radius || 50;
    widthSegments = Math.max(3, Math.floor(widthSegments) || 8);
    heightSegments = Math.max(2, Math.floor(heightSegments) || 6);
    phiStart = phiStart !== undefined ? phiStart : 0;
    phiLength = phiLength !== undefined ? phiLength : Math.PI * 2;
    thetaStart = thetaStart !== undefined ? thetaStart : 0;
    thetaLength = thetaLength !== undefined ? thetaLength : Math.PI;
    var thetaEnd = thetaStart + thetaLength;
    var vertexCount = (widthSegments + 1) * (heightSegments + 1);
    var positions = new BufferAttribute(new Float32Array(vertexCount * 3), 3);
    var normals = new BufferAttribute(new Float32Array(vertexCount * 3), 3);
    var uvs = new BufferAttribute(new Float32Array(vertexCount * 2), 2);
    var index = 0, vertices = [], normal = new Vector3();
    for (var y = 0; y <= heightSegments; y++) {
        var verticesRow = [];
        var v = y / heightSegments;
        for (var x = 0; x <= widthSegments; x++) {
            var u = x / widthSegments;
            var px = -radius * Math.cos(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
            var py = radius * Math.cos(thetaStart + v * thetaLength);
            var pz = radius * Math.sin(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
            normal.set(px, py, pz).normalize();
            positions.setXYZ(index, px, py, pz);
            normals.setXYZ(index, normal.x, normal.y, normal.z);
            uvs.setXY(index, u, 1 - v);
            verticesRow.push(index);
            index++;
        }
        vertices.push(verticesRow);
    }
    var indices = [];
    for (var y = 0; y < heightSegments; y++) {
        for (var x = 0; x < widthSegments; x++) {
            var v1 = vertices[y][x + 1];
            var v2 = vertices[y][x];
            var v3 = vertices[y + 1][x];
            var v4 = vertices[y + 1][x + 1];
            if (y !== 0 || thetaStart > 0)
                indices.push(v1, v2, v4);
            if (y !== heightSegments - 1 || thetaEnd < Math.PI)
                indices.push(v2, v3, v4);
        }
    }
    this.setIndex(new (positions.count > 65535 ? Uint32Attribute : Uint16Attribute)(indices, 1));
    this.addAttribute('position', positions);
    this.addAttribute('normal', normals);
    this.addAttribute('uv', uvs);
    this.boundingSphere = new Sphere(new Vector3(), radius);
};
PointLightHelper = function PointLightHelper(light, sphereSize) {
    this.light = light;
    this.light.updateMatrixWorld();
    var geometry = new SphereBufferGeometry(sphereSize, 4, 2);
    var material = new MeshBasicMaterial({
        wireframe: true,
        fog: false
    });
    material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
    Mesh.call(this, geometry, material);
    this.matrix = this.light.matrixWorld;
    this.matrixAutoUpdate = false;
};
SphereGeometry = function SphereGeometry(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength) {
    Geometry.call(this);
    this.type = 'SphereGeometry';
    this.parameters = {
        radius: radius,
        widthSegments: widthSegments,
        heightSegments: heightSegments,
        phiStart: phiStart,
        phiLength: phiLength,
        thetaStart: thetaStart,
        thetaLength: thetaLength
    };
    this.fromBufferGeometry(new SphereBufferGeometry(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength));
};
HemisphereLightHelper = function HemisphereLightHelper(light, sphereSize) {
    Object3D.call(this);
    this.light = light;
    this.light.updateMatrixWorld();
    this.matrix = light.matrixWorld;
    this.matrixAutoUpdate = false;
    this.colors = [
        new Color(),
        new Color()
    ];
    var geometry = new SphereGeometry(sphereSize, 4, 2);
    geometry.rotateX(-Math.PI / 2);
    for (var i = 0, il = 8; i < il; i++) {
        geometry.faces[i].color = this.colors[i < 4 ? 0 : 1];
    }
    var material = new MeshBasicMaterial({
        vertexColors: FaceColors,
        wireframe: true
    });
    this.lightSphere = new Mesh(geometry, material);
    this.add(this.lightSphere);
    this.update();
};
GridHelper = function GridHelper(size, divisions, color1, color2) {
    divisions = divisions || 1;
    color1 = new Color(color1 !== undefined ? color1 : 4473924);
    color2 = new Color(color2 !== undefined ? color2 : 8947848);
    var center = divisions / 2;
    var step = size * 2 / divisions;
    var vertices = [], colors = [];
    for (var i = 0, j = 0, k = -size; i <= divisions; i++, k += step) {
        vertices.push(-size, 0, k, size, 0, k);
        vertices.push(k, 0, -size, k, 0, size);
        var color = i === center ? color1 : color2;
        color.toArray(colors, j);
        j += 3;
        color.toArray(colors, j);
        j += 3;
        color.toArray(colors, j);
        j += 3;
        color.toArray(colors, j);
        j += 3;
    }
    var geometry = new BufferGeometry();
    geometry.addAttribute('position', new Float32Attribute(vertices, 3));
    geometry.addAttribute('color', new Float32Attribute(colors, 3));
    var material = new LineBasicMaterial({
        vertexColors: VertexColors
    });
    LineSegments.call(this, geometry, material);
};
FaceNormalsHelper = function FaceNormalsHelper(object, size, hex, linewidth) {
    this.object = object;
    this.size = size !== undefined ? size : 1;
    var color = hex !== undefined ? hex : 16776960;
    var width = linewidth !== undefined ? linewidth : 1;
    var nNormals = 0;
    var objGeometry = this.object.geometry;
    if (objGeometry && objGeometry.isGeometry) {
        nNormals = objGeometry.faces.length;
    } else {
        console.warn('THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.');
    }
    var geometry = new BufferGeometry();
    var positions = new Float32Attribute(nNormals * 2 * 3, 3);
    geometry.addAttribute('position', positions);
    LineSegments.call(this, geometry, new LineBasicMaterial({
        color: color,
        linewidth: width
    }));
    this.matrixAutoUpdate = false;
    this.update();
};
EdgesGeometry = function EdgesGeometry(geometry, thresholdAngle) {
    BufferGeometry.call(this);
    thresholdAngle = thresholdAngle !== undefined ? thresholdAngle : 1;
    var thresholdDot = Math.cos(exports.Math.DEG2RAD * thresholdAngle);
    var edge = [
            0,
            0
        ], hash = {};
    function sortFunction(a, b) {
        return a - b;
    }
    var keys = [
        'a',
        'b',
        'c'
    ];
    var geometry2;
    if (geometry && geometry.isBufferGeometry) {
        geometry2 = new Geometry();
        geometry2.fromBufferGeometry(geometry);
    } else {
        geometry2 = geometry.clone();
    }
    geometry2.mergeVertices();
    geometry2.computeFaceNormals();
    var vertices = geometry2.vertices;
    var faces = geometry2.faces;
    for (var i = 0, l = faces.length; i < l; i++) {
        var face = faces[i];
        for (var j = 0; j < 3; j++) {
            edge[0] = face[keys[j]];
            edge[1] = face[keys[(j + 1) % 3]];
            edge.sort(sortFunction);
            var key = edge.toString();
            if (hash[key] === undefined) {
                hash[key] = {
                    vert1: edge[0],
                    vert2: edge[1],
                    face1: i,
                    face2: undefined
                };
            } else {
                hash[key].face2 = i;
            }
        }
    }
    var coords = [];
    for (var key in hash) {
        var h = hash[key];
        if (h.face2 === undefined || faces[h.face1].normal.dot(faces[h.face2].normal) <= thresholdDot) {
            var vertex = vertices[h.vert1];
            coords.push(vertex.x);
            coords.push(vertex.y);
            coords.push(vertex.z);
            vertex = vertices[h.vert2];
            coords.push(vertex.x);
            coords.push(vertex.y);
            coords.push(vertex.z);
        }
    }
    this.addAttribute('position', new BufferAttribute(new Float32Array(coords), 3));
};
EdgesHelper = function EdgesHelper(object, hex, thresholdAngle) {
    var color = hex !== undefined ? hex : 16777215;
    LineSegments.call(this, new EdgesGeometry(object.geometry, thresholdAngle), new LineBasicMaterial({
        color: color
    }));
    this.matrix = object.matrixWorld;
    this.matrixAutoUpdate = false;
};
DirectionalLightHelper = function DirectionalLightHelper(light, size) {
    Object3D.call(this);
    this.light = light;
    this.light.updateMatrixWorld();
    this.matrix = light.matrixWorld;
    this.matrixAutoUpdate = false;
    if (size === undefined)
        size = 1;
    var geometry = new BufferGeometry();
    geometry.addAttribute('position', new Float32Attribute([
        -size,
        size,
        0,
        size,
        size,
        0,
        size,
        -size,
        0,
        -size,
        -size,
        0,
        -size,
        size,
        0
    ], 3));
    var material = new LineBasicMaterial({
        fog: false
    });
    this.add(new Line(geometry, material));
    geometry = new BufferGeometry();
    geometry.addAttribute('position', new Float32Attribute([
        0,
        0,
        0,
        0,
        0,
        1
    ], 3));
    this.add(new Line(geometry, material));
    this.update();
};
CameraHelper = function CameraHelper(camera) {
    var geometry = new Geometry();
    var material = new LineBasicMaterial({
        color: 16777215,
        vertexColors: FaceColors
    });
    var pointMap = {};
    var hexFrustum = 16755200;
    var hexCone = 16711680;
    var hexUp = 43775;
    var hexTarget = 16777215;
    var hexCross = 3355443;
    addLine('n1', 'n2', hexFrustum);
    addLine('n2', 'n4', hexFrustum);
    addLine('n4', 'n3', hexFrustum);
    addLine('n3', 'n1', hexFrustum);
    addLine('f1', 'f2', hexFrustum);
    addLine('f2', 'f4', hexFrustum);
    addLine('f4', 'f3', hexFrustum);
    addLine('f3', 'f1', hexFrustum);
    addLine('n1', 'f1', hexFrustum);
    addLine('n2', 'f2', hexFrustum);
    addLine('n3', 'f3', hexFrustum);
    addLine('n4', 'f4', hexFrustum);
    addLine('p', 'n1', hexCone);
    addLine('p', 'n2', hexCone);
    addLine('p', 'n3', hexCone);
    addLine('p', 'n4', hexCone);
    addLine('u1', 'u2', hexUp);
    addLine('u2', 'u3', hexUp);
    addLine('u3', 'u1', hexUp);
    addLine('c', 't', hexTarget);
    addLine('p', 'c', hexCross);
    addLine('cn1', 'cn2', hexCross);
    addLine('cn3', 'cn4', hexCross);
    addLine('cf1', 'cf2', hexCross);
    addLine('cf3', 'cf4', hexCross);
    function addLine(a, b, hex) {
        addPoint(a, hex);
        addPoint(b, hex);
    }
    function addPoint(id, hex) {
        geometry.vertices.push(new Vector3());
        geometry.colors.push(new Color(hex));
        if (pointMap[id] === undefined) {
            pointMap[id] = [];
        }
        pointMap[id].push(geometry.vertices.length - 1);
    }
    LineSegments.call(this, geometry, material);
    this.camera = camera;
    if (this.camera.updateProjectionMatrix)
        this.camera.updateProjectionMatrix();
    this.matrix = camera.matrixWorld;
    this.matrixAutoUpdate = false;
    this.pointMap = pointMap;
    this.update();
};
BoxGeometry = function BoxGeometry(width, height, depth, widthSegments, heightSegments, depthSegments) {
    Geometry.call(this);
    this.type = 'BoxGeometry';
    this.parameters = {
        width: width,
        height: height,
        depth: depth,
        widthSegments: widthSegments,
        heightSegments: heightSegments,
        depthSegments: depthSegments
    };
    this.fromBufferGeometry(new BoxBufferGeometry(width, height, depth, widthSegments, heightSegments, depthSegments));
    this.mergeVertices();
};
BoundingBoxHelper = function BoundingBoxHelper(object, hex) {
    var color = hex !== undefined ? hex : 8947848;
    this.object = object;
    this.box = new Box3();
    Mesh.call(this, new BoxGeometry(1, 1, 1), new MeshBasicMaterial({
        color: color,
        wireframe: true
    }));
};
BoxHelper = function BoxHelper(object, color) {
    if (color === undefined)
        color = 16776960;
    var indices = new Uint16Array([
        0,
        1,
        1,
        2,
        2,
        3,
        3,
        0,
        4,
        5,
        5,
        6,
        6,
        7,
        7,
        4,
        0,
        4,
        1,
        5,
        2,
        6,
        3,
        7
    ]);
    var positions = new Float32Array(8 * 3);
    var geometry = new BufferGeometry();
    geometry.setIndex(new BufferAttribute(indices, 1));
    geometry.addAttribute('position', new BufferAttribute(positions, 3));
    LineSegments.call(this, geometry, new LineBasicMaterial({
        color: color
    }));
    if (object !== undefined) {
        this.update(object);
    }
};
CylinderBufferGeometry = function CylinderBufferGeometry(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
    BufferGeometry.call(this);
    this.type = 'CylinderBufferGeometry';
    this.parameters = {
        radiusTop: radiusTop,
        radiusBottom: radiusBottom,
        height: height,
        radialSegments: radialSegments,
        heightSegments: heightSegments,
        openEnded: openEnded,
        thetaStart: thetaStart,
        thetaLength: thetaLength
    };
    var scope = this;
    radiusTop = radiusTop !== undefined ? radiusTop : 20;
    radiusBottom = radiusBottom !== undefined ? radiusBottom : 20;
    height = height !== undefined ? height : 100;
    radialSegments = Math.floor(radialSegments) || 8;
    heightSegments = Math.floor(heightSegments) || 1;
    openEnded = openEnded !== undefined ? openEnded : false;
    thetaStart = thetaStart !== undefined ? thetaStart : 0;
    thetaLength = thetaLength !== undefined ? thetaLength : 2 * Math.PI;
    var nbCap = 0;
    if (openEnded === false) {
        if (radiusTop > 0)
            nbCap++;
        if (radiusBottom > 0)
            nbCap++;
    }
    var vertexCount = calculateVertexCount();
    var indexCount = calculateIndexCount();
    var indices = new BufferAttribute(new (indexCount > 65535 ? Uint32Array : Uint16Array)(indexCount), 1);
    var vertices = new BufferAttribute(new Float32Array(vertexCount * 3), 3);
    var normals = new BufferAttribute(new Float32Array(vertexCount * 3), 3);
    var uvs = new BufferAttribute(new Float32Array(vertexCount * 2), 2);
    var index = 0, indexOffset = 0, indexArray = [], halfHeight = height / 2;
    var groupStart = 0;
    generateTorso();
    if (openEnded === false) {
        if (radiusTop > 0)
            generateCap(true);
        if (radiusBottom > 0)
            generateCap(false);
    }
    this.setIndex(indices);
    this.addAttribute('position', vertices);
    this.addAttribute('normal', normals);
    this.addAttribute('uv', uvs);
    function calculateVertexCount() {
        var count = (radialSegments + 1) * (heightSegments + 1);
        if (openEnded === false) {
            count += (radialSegments + 1) * nbCap + radialSegments * nbCap;
        }
        return count;
    }
    function calculateIndexCount() {
        var count = radialSegments * heightSegments * 2 * 3;
        if (openEnded === false) {
            count += radialSegments * nbCap * 3;
        }
        return count;
    }
    function generateTorso() {
        var x, y;
        var normal = new Vector3();
        var vertex = new Vector3();
        var groupCount = 0;
        var tanTheta = (radiusBottom - radiusTop) / height;
        for (y = 0; y <= heightSegments; y++) {
            var indexRow = [];
            var v = y / heightSegments;
            var radius = v * (radiusBottom - radiusTop) + radiusTop;
            for (x = 0; x <= radialSegments; x++) {
                var u = x / radialSegments;
                vertex.x = radius * Math.sin(u * thetaLength + thetaStart);
                vertex.y = -v * height + halfHeight;
                vertex.z = radius * Math.cos(u * thetaLength + thetaStart);
                vertices.setXYZ(index, vertex.x, vertex.y, vertex.z);
                normal.copy(vertex);
                if (radiusTop === 0 && y === 0 || radiusBottom === 0 && y === heightSegments) {
                    normal.x = Math.sin(u * thetaLength + thetaStart);
                    normal.z = Math.cos(u * thetaLength + thetaStart);
                }
                normal.setY(Math.sqrt(normal.x * normal.x + normal.z * normal.z) * tanTheta).normalize();
                normals.setXYZ(index, normal.x, normal.y, normal.z);
                uvs.setXY(index, u, 1 - v);
                indexRow.push(index);
                index++;
            }
            indexArray.push(indexRow);
        }
        for (x = 0; x < radialSegments; x++) {
            for (y = 0; y < heightSegments; y++) {
                var i1 = indexArray[y][x];
                var i2 = indexArray[y + 1][x];
                var i3 = indexArray[y + 1][x + 1];
                var i4 = indexArray[y][x + 1];
                indices.setX(indexOffset, i1);
                indexOffset++;
                indices.setX(indexOffset, i2);
                indexOffset++;
                indices.setX(indexOffset, i4);
                indexOffset++;
                indices.setX(indexOffset, i2);
                indexOffset++;
                indices.setX(indexOffset, i3);
                indexOffset++;
                indices.setX(indexOffset, i4);
                indexOffset++;
                groupCount += 6;
            }
        }
        scope.addGroup(groupStart, groupCount, 0);
        groupStart += groupCount;
    }
    function generateCap(top) {
        var x, centerIndexStart, centerIndexEnd;
        var uv = new Vector2();
        var vertex = new Vector3();
        var groupCount = 0;
        var radius = top === true ? radiusTop : radiusBottom;
        var sign = top === true ? 1 : -1;
        centerIndexStart = index;
        for (x = 1; x <= radialSegments; x++) {
            vertices.setXYZ(index, 0, halfHeight * sign, 0);
            normals.setXYZ(index, 0, sign, 0);
            uv.x = 0.5;
            uv.y = 0.5;
            uvs.setXY(index, uv.x, uv.y);
            index++;
        }
        centerIndexEnd = index;
        for (x = 0; x <= radialSegments; x++) {
            var u = x / radialSegments;
            var theta = u * thetaLength + thetaStart;
            var cosTheta = Math.cos(theta);
            var sinTheta = Math.sin(theta);
            vertex.x = radius * sinTheta;
            vertex.y = halfHeight * sign;
            vertex.z = radius * cosTheta;
            vertices.setXYZ(index, vertex.x, vertex.y, vertex.z);
            normals.setXYZ(index, 0, sign, 0);
            uv.x = cosTheta * 0.5 + 0.5;
            uv.y = sinTheta * 0.5 * sign + 0.5;
            uvs.setXY(index, uv.x, uv.y);
            index++;
        }
        for (x = 0; x < radialSegments; x++) {
            var c = centerIndexStart + x;
            var i = centerIndexEnd + x;
            if (top === true) {
                indices.setX(indexOffset, i);
                indexOffset++;
                indices.setX(indexOffset, i + 1);
                indexOffset++;
                indices.setX(indexOffset, c);
                indexOffset++;
            } else {
                indices.setX(indexOffset, i + 1);
                indexOffset++;
                indices.setX(indexOffset, i);
                indexOffset++;
                indices.setX(indexOffset, c);
                indexOffset++;
            }
            groupCount += 3;
        }
        scope.addGroup(groupStart, groupCount, top === true ? 1 : 2);
        groupStart += groupCount;
    }
};
ArrowHelper = function ArrowHelper(dir, origin, length, color, headLength, headWidth) {
    Object3D.call(this);
    if (color === undefined)
        color = 16776960;
    if (length === undefined)
        length = 1;
    if (headLength === undefined)
        headLength = 0.2 * length;
    if (headWidth === undefined)
        headWidth = 0.2 * headLength;
    this.position.copy(origin);
    this.line = new Line(lineGeometry, new LineBasicMaterial({
        color: color
    }));
    this.line.matrixAutoUpdate = false;
    this.add(this.line);
    this.cone = new Mesh(coneGeometry, new MeshBasicMaterial({
        color: color
    }));
    this.cone.matrixAutoUpdate = false;
    this.add(this.cone);
    this.setDirection(dir);
    this.setLength(length, headLength, headWidth);
};
AxisHelper = function AxisHelper(size) {
    size = size || 1;
    var vertices = new Float32Array([
        0,
        0,
        0,
        size,
        0,
        0,
        0,
        0,
        0,
        0,
        size,
        0,
        0,
        0,
        0,
        0,
        0,
        size
    ]);
    var colors = new Float32Array([
        1,
        0,
        0,
        1,
        0.6,
        0,
        0,
        1,
        0,
        0.6,
        1,
        0,
        0,
        0,
        1,
        0,
        0.6,
        1
    ]);
    var geometry = new BufferGeometry();
    geometry.addAttribute('position', new BufferAttribute(vertices, 3));
    geometry.addAttribute('color', new BufferAttribute(colors, 3));
    var material = new LineBasicMaterial({
        vertexColors: VertexColors
    });
    LineSegments.call(this, geometry, material);
};
ParametricGeometry = function ParametricGeometry(func, slices, stacks) {
    Geometry.call(this);
    this.type = 'ParametricGeometry';
    this.parameters = {
        func: func,
        slices: slices,
        stacks: stacks
    };
    var verts = this.vertices;
    var faces = this.faces;
    var uvs = this.faceVertexUvs[0];
    var i, j, p;
    var u, v;
    var sliceCount = slices + 1;
    for (i = 0; i <= stacks; i++) {
        v = i / stacks;
        for (j = 0; j <= slices; j++) {
            u = j / slices;
            p = func(u, v);
            verts.push(p);
        }
    }
    var a, b, c, d;
    var uva, uvb, uvc, uvd;
    for (i = 0; i < stacks; i++) {
        for (j = 0; j < slices; j++) {
            a = i * sliceCount + j;
            b = i * sliceCount + j + 1;
            c = (i + 1) * sliceCount + j + 1;
            d = (i + 1) * sliceCount + j;
            uva = new Vector2(j / slices, i / stacks);
            uvb = new Vector2((j + 1) / slices, i / stacks);
            uvc = new Vector2((j + 1) / slices, (i + 1) / stacks);
            uvd = new Vector2(j / slices, (i + 1) / stacks);
            faces.push(new Face3(a, b, d));
            uvs.push([
                uva,
                uvb,
                uvd
            ]);
            faces.push(new Face3(b, c, d));
            uvs.push([
                uvb.clone(),
                uvc,
                uvd.clone()
            ]);
        }
    }
    this.computeFaceNormals();
    this.computeVertexNormals();
};
PolyhedronGeometry = function PolyhedronGeometry(vertices, indices, radius, detail) {
    Geometry.call(this);
    this.type = 'PolyhedronGeometry';
    this.parameters = {
        vertices: vertices,
        indices: indices,
        radius: radius,
        detail: detail
    };
    radius = radius || 1;
    detail = detail || 0;
    var that = this;
    for (var i = 0, l = vertices.length; i < l; i += 3) {
        prepare(new Vector3(vertices[i], vertices[i + 1], vertices[i + 2]));
    }
    var p = this.vertices;
    var faces = [];
    for (var i = 0, j = 0, l = indices.length; i < l; i += 3, j++) {
        var v1 = p[indices[i]];
        var v2 = p[indices[i + 1]];
        var v3 = p[indices[i + 2]];
        faces[j] = new Face3(v1.index, v2.index, v3.index, [
            v1.clone(),
            v2.clone(),
            v3.clone()
        ]);
    }
    var centroid = new Vector3();
    for (var i = 0, l = faces.length; i < l; i++) {
        subdivide(faces[i], detail);
    }
    for (var i = 0, l = this.faceVertexUvs[0].length; i < l; i++) {
        var uvs = this.faceVertexUvs[0][i];
        var x0 = uvs[0].x;
        var x1 = uvs[1].x;
        var x2 = uvs[2].x;
        var max = Math.max(x0, x1, x2);
        var min = Math.min(x0, x1, x2);
        if (max > 0.9 && min < 0.1) {
            if (x0 < 0.2)
                uvs[0].x += 1;
            if (x1 < 0.2)
                uvs[1].x += 1;
            if (x2 < 0.2)
                uvs[2].x += 1;
        }
    }
    for (var i = 0, l = this.vertices.length; i < l; i++) {
        this.vertices[i].multiplyScalar(radius);
    }
    this.mergeVertices();
    this.computeFaceNormals();
    this.boundingSphere = new Sphere(new Vector3(), radius);
    function prepare(vector) {
        var vertex = vector.normalize().clone();
        vertex.index = that.vertices.push(vertex) - 1;
        var u = azimuth(vector) / 2 / Math.PI + 0.5;
        var v = inclination(vector) / Math.PI + 0.5;
        vertex.uv = new Vector2(u, 1 - v);
        return vertex;
    }
    function make(v1, v2, v3) {
        var face = new Face3(v1.index, v2.index, v3.index, [
            v1.clone(),
            v2.clone(),
            v3.clone()
        ]);
        that.faces.push(face);
        centroid.copy(v1).add(v2).add(v3).divideScalar(3);
        var azi = azimuth(centroid);
        that.faceVertexUvs[0].push([
            correctUV(v1.uv, v1, azi),
            correctUV(v2.uv, v2, azi),
            correctUV(v3.uv, v3, azi)
        ]);
    }
    function subdivide(face, detail) {
        var cols = Math.pow(2, detail);
        var a = prepare(that.vertices[face.a]);
        var b = prepare(that.vertices[face.b]);
        var c = prepare(that.vertices[face.c]);
        var v = [];
        for (var i = 0; i <= cols; i++) {
            v[i] = [];
            var aj = prepare(a.clone().lerp(c, i / cols));
            var bj = prepare(b.clone().lerp(c, i / cols));
            var rows = cols - i;
            for (var j = 0; j <= rows; j++) {
                if (j === 0 && i === cols) {
                    v[i][j] = aj;
                } else {
                    v[i][j] = prepare(aj.clone().lerp(bj, j / rows));
                }
            }
        }
        for (var i = 0; i < cols; i++) {
            for (var j = 0; j < 2 * (cols - i) - 1; j++) {
                var k = Math.floor(j / 2);
                if (j % 2 === 0) {
                    make(v[i][k + 1], v[i + 1][k], v[i][k]);
                } else {
                    make(v[i][k + 1], v[i + 1][k + 1], v[i + 1][k]);
                }
            }
        }
    }
    function azimuth(vector) {
        return Math.atan2(vector.z, -vector.x);
    }
    function inclination(vector) {
        return Math.atan2(-vector.y, Math.sqrt(vector.x * vector.x + vector.z * vector.z));
    }
    function correctUV(uv, vector, azimuth) {
        if (azimuth < 0 && uv.x === 1)
            uv = new Vector2(uv.x - 1, uv.y);
        if (vector.x === 0 && vector.z === 0)
            uv = new Vector2(azimuth / 2 / Math.PI + 0.5, uv.y);
        return uv.clone();
    }
};
TetrahedronGeometry = function TetrahedronGeometry(radius, detail) {
    var vertices = [
        1,
        1,
        1,
        -1,
        -1,
        1,
        -1,
        1,
        -1,
        1,
        -1,
        -1
    ];
    var indices = [
        2,
        1,
        0,
        0,
        3,
        2,
        1,
        3,
        0,
        2,
        3,
        1
    ];
    PolyhedronGeometry.call(this, vertices, indices, radius, detail);
    this.type = 'TetrahedronGeometry';
    this.parameters = {
        radius: radius,
        detail: detail
    };
};
OctahedronGeometry = function OctahedronGeometry(radius, detail) {
    var vertices = [
        1,
        0,
        0,
        -1,
        0,
        0,
        0,
        1,
        0,
        0,
        -1,
        0,
        0,
        0,
        1,
        0,
        0,
        -1
    ];
    var indices = [
        0,
        2,
        4,
        0,
        4,
        3,
        0,
        3,
        5,
        0,
        5,
        2,
        1,
        2,
        5,
        1,
        5,
        3,
        1,
        3,
        4,
        1,
        4,
        2
    ];
    PolyhedronGeometry.call(this, vertices, indices, radius, detail);
    this.type = 'OctahedronGeometry';
    this.parameters = {
        radius: radius,
        detail: detail
    };
};
IcosahedronGeometry = function IcosahedronGeometry(radius, detail) {
    var t = (1 + Math.sqrt(5)) / 2;
    var vertices = [
        -1,
        t,
        0,
        1,
        t,
        0,
        -1,
        -t,
        0,
        1,
        -t,
        0,
        0,
        -1,
        t,
        0,
        1,
        t,
        0,
        -1,
        -t,
        0,
        1,
        -t,
        t,
        0,
        -1,
        t,
        0,
        1,
        -t,
        0,
        -1,
        -t,
        0,
        1
    ];
    var indices = [
        0,
        11,
        5,
        0,
        5,
        1,
        0,
        1,
        7,
        0,
        7,
        10,
        0,
        10,
        11,
        1,
        5,
        9,
        5,
        11,
        4,
        11,
        10,
        2,
        10,
        7,
        6,
        7,
        1,
        8,
        3,
        9,
        4,
        3,
        4,
        2,
        3,
        2,
        6,
        3,
        6,
        8,
        3,
        8,
        9,
        4,
        9,
        5,
        2,
        4,
        11,
        6,
        2,
        10,
        8,
        6,
        7,
        9,
        8,
        1
    ];
    PolyhedronGeometry.call(this, vertices, indices, radius, detail);
    this.type = 'IcosahedronGeometry';
    this.parameters = {
        radius: radius,
        detail: detail
    };
};
DodecahedronGeometry = function DodecahedronGeometry(radius, detail) {
    var t = (1 + Math.sqrt(5)) / 2;
    var r = 1 / t;
    var vertices = [
        -1,
        -1,
        -1,
        -1,
        -1,
        1,
        -1,
        1,
        -1,
        -1,
        1,
        1,
        1,
        -1,
        -1,
        1,
        -1,
        1,
        1,
        1,
        -1,
        1,
        1,
        1,
        0,
        -r,
        -t,
        0,
        -r,
        t,
        0,
        r,
        -t,
        0,
        r,
        t,
        -r,
        -t,
        0,
        -r,
        t,
        0,
        r,
        -t,
        0,
        r,
        t,
        0,
        -t,
        0,
        -r,
        t,
        0,
        -r,
        -t,
        0,
        r,
        t,
        0,
        r
    ];
    var indices = [
        3,
        11,
        7,
        3,
        7,
        15,
        3,
        15,
        13,
        7,
        19,
        17,
        7,
        17,
        6,
        7,
        6,
        15,
        17,
        4,
        8,
        17,
        8,
        10,
        17,
        10,
        6,
        8,
        0,
        16,
        8,
        16,
        2,
        8,
        2,
        10,
        0,
        12,
        1,
        0,
        1,
        18,
        0,
        18,
        16,
        6,
        10,
        2,
        6,
        2,
        13,
        6,
        13,
        15,
        2,
        16,
        18,
        2,
        18,
        3,
        2,
        3,
        13,
        18,
        1,
        9,
        18,
        9,
        11,
        18,
        11,
        3,
        4,
        14,
        12,
        4,
        12,
        0,
        4,
        0,
        8,
        11,
        9,
        5,
        11,
        5,
        19,
        11,
        19,
        7,
        19,
        5,
        14,
        19,
        14,
        4,
        19,
        4,
        17,
        1,
        12,
        14,
        1,
        14,
        5,
        1,
        5,
        9
    ];
    PolyhedronGeometry.call(this, vertices, indices, radius, detail);
    this.type = 'DodecahedronGeometry';
    this.parameters = {
        radius: radius,
        detail: detail
    };
};
TorusKnotBufferGeometry = function TorusKnotBufferGeometry(radius, tube, tubularSegments, radialSegments, p, q) {
    BufferGeometry.call(this);
    this.type = 'TorusKnotBufferGeometry';
    this.parameters = {
        radius: radius,
        tube: tube,
        tubularSegments: tubularSegments,
        radialSegments: radialSegments,
        p: p,
        q: q
    };
    radius = radius || 100;
    tube = tube || 40;
    tubularSegments = Math.floor(tubularSegments) || 64;
    radialSegments = Math.floor(radialSegments) || 8;
    p = p || 2;
    q = q || 3;
    var vertexCount = (radialSegments + 1) * (tubularSegments + 1);
    var indexCount = radialSegments * tubularSegments * 2 * 3;
    var indices = new BufferAttribute(new (indexCount > 65535 ? Uint32Array : Uint16Array)(indexCount), 1);
    var vertices = new BufferAttribute(new Float32Array(vertexCount * 3), 3);
    var normals = new BufferAttribute(new Float32Array(vertexCount * 3), 3);
    var uvs = new BufferAttribute(new Float32Array(vertexCount * 2), 2);
    var i, j, index = 0, indexOffset = 0;
    var vertex = new Vector3();
    var normal = new Vector3();
    var uv = new Vector2();
    var P1 = new Vector3();
    var P2 = new Vector3();
    var B = new Vector3();
    var T = new Vector3();
    var N = new Vector3();
    for (i = 0; i <= tubularSegments; ++i) {
        var u = i / tubularSegments * p * Math.PI * 2;
        calculatePositionOnCurve(u, p, q, radius, P1);
        calculatePositionOnCurve(u + 0.01, p, q, radius, P2);
        T.subVectors(P2, P1);
        N.addVectors(P2, P1);
        B.crossVectors(T, N);
        N.crossVectors(B, T);
        B.normalize();
        N.normalize();
        for (j = 0; j <= radialSegments; ++j) {
            var v = j / radialSegments * Math.PI * 2;
            var cx = -tube * Math.cos(v);
            var cy = tube * Math.sin(v);
            vertex.x = P1.x + (cx * N.x + cy * B.x);
            vertex.y = P1.y + (cx * N.y + cy * B.y);
            vertex.z = P1.z + (cx * N.z + cy * B.z);
            vertices.setXYZ(index, vertex.x, vertex.y, vertex.z);
            normal.subVectors(vertex, P1).normalize();
            normals.setXYZ(index, normal.x, normal.y, normal.z);
            uv.x = i / tubularSegments;
            uv.y = j / radialSegments;
            uvs.setXY(index, uv.x, uv.y);
            index++;
        }
    }
    for (j = 1; j <= tubularSegments; j++) {
        for (i = 1; i <= radialSegments; i++) {
            var a = (radialSegments + 1) * (j - 1) + (i - 1);
            var b = (radialSegments + 1) * j + (i - 1);
            var c = (radialSegments + 1) * j + i;
            var d = (radialSegments + 1) * (j - 1) + i;
            indices.setX(indexOffset, a);
            indexOffset++;
            indices.setX(indexOffset, b);
            indexOffset++;
            indices.setX(indexOffset, d);
            indexOffset++;
            indices.setX(indexOffset, b);
            indexOffset++;
            indices.setX(indexOffset, c);
            indexOffset++;
            indices.setX(indexOffset, d);
            indexOffset++;
        }
    }
    this.setIndex(indices);
    this.addAttribute('position', vertices);
    this.addAttribute('normal', normals);
    this.addAttribute('uv', uvs);
    function calculatePositionOnCurve(u, p, q, radius, position) {
        var cu = Math.cos(u);
        var su = Math.sin(u);
        var quOverP = q / p * u;
        var cs = Math.cos(quOverP);
        position.x = radius * (2 + cs) * 0.5 * cu;
        position.y = radius * (2 + cs) * su * 0.5;
        position.z = radius * Math.sin(quOverP) * 0.5;
    }
};
TorusKnotGeometry = function TorusKnotGeometry(radius, tube, tubularSegments, radialSegments, p, q, heightScale) {
    Geometry.call(this);
    this.type = 'TorusKnotGeometry';
    this.parameters = {
        radius: radius,
        tube: tube,
        tubularSegments: tubularSegments,
        radialSegments: radialSegments,
        p: p,
        q: q
    };
    if (heightScale !== undefined)
        console.warn('THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead.');
    this.fromBufferGeometry(new TorusKnotBufferGeometry(radius, tube, tubularSegments, radialSegments, p, q));
    this.mergeVertices();
};
TorusBufferGeometry = function TorusBufferGeometry(radius, tube, radialSegments, tubularSegments, arc) {
    BufferGeometry.call(this);
    this.type = 'TorusBufferGeometry';
    this.parameters = {
        radius: radius,
        tube: tube,
        radialSegments: radialSegments,
        tubularSegments: tubularSegments,
        arc: arc
    };
    radius = radius || 100;
    tube = tube || 40;
    radialSegments = Math.floor(radialSegments) || 8;
    tubularSegments = Math.floor(tubularSegments) || 6;
    arc = arc || Math.PI * 2;
    var vertexCount = (radialSegments + 1) * (tubularSegments + 1);
    var indexCount = radialSegments * tubularSegments * 2 * 3;
    var indices = new (indexCount > 65535 ? Uint32Array : Uint16Array)(indexCount);
    var vertices = new Float32Array(vertexCount * 3);
    var normals = new Float32Array(vertexCount * 3);
    var uvs = new Float32Array(vertexCount * 2);
    var vertexBufferOffset = 0;
    var uvBufferOffset = 0;
    var indexBufferOffset = 0;
    var center = new Vector3();
    var vertex = new Vector3();
    var normal = new Vector3();
    var j, i;
    for (j = 0; j <= radialSegments; j++) {
        for (i = 0; i <= tubularSegments; i++) {
            var u = i / tubularSegments * arc;
            var v = j / radialSegments * Math.PI * 2;
            vertex.x = (radius + tube * Math.cos(v)) * Math.cos(u);
            vertex.y = (radius + tube * Math.cos(v)) * Math.sin(u);
            vertex.z = tube * Math.sin(v);
            vertices[vertexBufferOffset] = vertex.x;
            vertices[vertexBufferOffset + 1] = vertex.y;
            vertices[vertexBufferOffset + 2] = vertex.z;
            center.x = radius * Math.cos(u);
            center.y = radius * Math.sin(u);
            normal.subVectors(vertex, center).normalize();
            normals[vertexBufferOffset] = normal.x;
            normals[vertexBufferOffset + 1] = normal.y;
            normals[vertexBufferOffset + 2] = normal.z;
            uvs[uvBufferOffset] = i / tubularSegments;
            uvs[uvBufferOffset + 1] = j / radialSegments;
            vertexBufferOffset += 3;
            uvBufferOffset += 2;
        }
    }
    for (j = 1; j <= radialSegments; j++) {
        for (i = 1; i <= tubularSegments; i++) {
            var a = (tubularSegments + 1) * j + i - 1;
            var b = (tubularSegments + 1) * (j - 1) + i - 1;
            var c = (tubularSegments + 1) * (j - 1) + i;
            var d = (tubularSegments + 1) * j + i;
            indices[indexBufferOffset] = a;
            indices[indexBufferOffset + 1] = b;
            indices[indexBufferOffset + 2] = d;
            indices[indexBufferOffset + 3] = b;
            indices[indexBufferOffset + 4] = c;
            indices[indexBufferOffset + 5] = d;
            indexBufferOffset += 6;
        }
    }
    this.setIndex(new BufferAttribute(indices, 1));
    this.addAttribute('position', new BufferAttribute(vertices, 3));
    this.addAttribute('normal', new BufferAttribute(normals, 3));
    this.addAttribute('uv', new BufferAttribute(uvs, 2));
};
TorusGeometry = function TorusGeometry(radius, tube, radialSegments, tubularSegments, arc) {
    Geometry.call(this);
    this.type = 'TorusGeometry';
    this.parameters = {
        radius: radius,
        tube: tube,
        radialSegments: radialSegments,
        tubularSegments: tubularSegments,
        arc: arc
    };
    this.fromBufferGeometry(new TorusBufferGeometry(radius, tube, radialSegments, tubularSegments, arc));
};
TextGeometry = function TextGeometry(text, parameters) {
    parameters = parameters || {};
    var font = parameters.font;
    if ((font && font.isFont) === false) {
        console.error('THREE.TextGeometry: font parameter is not an instance of THREE.Font.');
        return new Geometry();
    }
    var shapes = font.generateShapes(text, parameters.size, parameters.curveSegments);
    parameters.amount = parameters.height !== undefined ? parameters.height : 50;
    if (parameters.bevelThickness === undefined)
        parameters.bevelThickness = 10;
    if (parameters.bevelSize === undefined)
        parameters.bevelSize = 8;
    if (parameters.bevelEnabled === undefined)
        parameters.bevelEnabled = false;
    ExtrudeGeometry.call(this, shapes, parameters);
    this.type = 'TextGeometry';
};
RingBufferGeometry = function RingBufferGeometry(innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength) {
    BufferGeometry.call(this);
    this.type = 'RingBufferGeometry';
    this.parameters = {
        innerRadius: innerRadius,
        outerRadius: outerRadius,
        thetaSegments: thetaSegments,
        phiSegments: phiSegments,
        thetaStart: thetaStart,
        thetaLength: thetaLength
    };
    innerRadius = innerRadius || 20;
    outerRadius = outerRadius || 50;
    thetaStart = thetaStart !== undefined ? thetaStart : 0;
    thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;
    thetaSegments = thetaSegments !== undefined ? Math.max(3, thetaSegments) : 8;
    phiSegments = phiSegments !== undefined ? Math.max(1, phiSegments) : 1;
    var vertexCount = (thetaSegments + 1) * (phiSegments + 1);
    var indexCount = thetaSegments * phiSegments * 2 * 3;
    var indices = new BufferAttribute(new (indexCount > 65535 ? Uint32Array : Uint16Array)(indexCount), 1);
    var vertices = new BufferAttribute(new Float32Array(vertexCount * 3), 3);
    var normals = new BufferAttribute(new Float32Array(vertexCount * 3), 3);
    var uvs = new BufferAttribute(new Float32Array(vertexCount * 2), 2);
    var index = 0, indexOffset = 0, segment;
    var radius = innerRadius;
    var radiusStep = (outerRadius - innerRadius) / phiSegments;
    var vertex = new Vector3();
    var uv = new Vector2();
    var j, i;
    for (j = 0; j <= phiSegments; j++) {
        for (i = 0; i <= thetaSegments; i++) {
            segment = thetaStart + i / thetaSegments * thetaLength;
            vertex.x = radius * Math.cos(segment);
            vertex.y = radius * Math.sin(segment);
            vertices.setXYZ(index, vertex.x, vertex.y, vertex.z);
            normals.setXYZ(index, 0, 0, 1);
            uv.x = (vertex.x / outerRadius + 1) / 2;
            uv.y = (vertex.y / outerRadius + 1) / 2;
            uvs.setXY(index, uv.x, uv.y);
            index++;
        }
        radius += radiusStep;
    }
    for (j = 0; j < phiSegments; j++) {
        var thetaSegmentLevel = j * (thetaSegments + 1);
        for (i = 0; i < thetaSegments; i++) {
            segment = i + thetaSegmentLevel;
            var a = segment;
            var b = segment + thetaSegments + 1;
            var c = segment + thetaSegments + 2;
            var d = segment + 1;
            indices.setX(indexOffset, a);
            indexOffset++;
            indices.setX(indexOffset, b);
            indexOffset++;
            indices.setX(indexOffset, c);
            indexOffset++;
            indices.setX(indexOffset, a);
            indexOffset++;
            indices.setX(indexOffset, c);
            indexOffset++;
            indices.setX(indexOffset, d);
            indexOffset++;
        }
    }
    this.setIndex(indices);
    this.addAttribute('position', vertices);
    this.addAttribute('normal', normals);
    this.addAttribute('uv', uvs);
};
RingGeometry = function RingGeometry(innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength) {
    Geometry.call(this);
    this.type = 'RingGeometry';
    this.parameters = {
        innerRadius: innerRadius,
        outerRadius: outerRadius,
        thetaSegments: thetaSegments,
        phiSegments: phiSegments,
        thetaStart: thetaStart,
        thetaLength: thetaLength
    };
    this.fromBufferGeometry(new RingBufferGeometry(innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength));
};
PlaneGeometry = function PlaneGeometry(width, height, widthSegments, heightSegments) {
    Geometry.call(this);
    this.type = 'PlaneGeometry';
    this.parameters = {
        width: width,
        height: height,
        widthSegments: widthSegments,
        heightSegments: heightSegments
    };
    this.fromBufferGeometry(new PlaneBufferGeometry(width, height, widthSegments, heightSegments));
};
LatheBufferGeometry = function LatheBufferGeometry(points, segments, phiStart, phiLength) {
    BufferGeometry.call(this);
    this.type = 'LatheBufferGeometry';
    this.parameters = {
        points: points,
        segments: segments,
        phiStart: phiStart,
        phiLength: phiLength
    };
    segments = Math.floor(segments) || 12;
    phiStart = phiStart || 0;
    phiLength = phiLength || Math.PI * 2;
    phiLength = exports.Math.clamp(phiLength, 0, Math.PI * 2);
    var vertexCount = (segments + 1) * points.length;
    var indexCount = segments * points.length * 2 * 3;
    var indices = new BufferAttribute(new (indexCount > 65535 ? Uint32Array : Uint16Array)(indexCount), 1);
    var vertices = new BufferAttribute(new Float32Array(vertexCount * 3), 3);
    var uvs = new BufferAttribute(new Float32Array(vertexCount * 2), 2);
    var index = 0, indexOffset = 0, base;
    var inverseSegments = 1 / segments;
    var vertex = new Vector3();
    var uv = new Vector2();
    var i, j;
    for (i = 0; i <= segments; i++) {
        var phi = phiStart + i * inverseSegments * phiLength;
        var sin = Math.sin(phi);
        var cos = Math.cos(phi);
        for (j = 0; j <= points.length - 1; j++) {
            vertex.x = points[j].x * sin;
            vertex.y = points[j].y;
            vertex.z = points[j].x * cos;
            vertices.setXYZ(index, vertex.x, vertex.y, vertex.z);
            uv.x = i / segments;
            uv.y = j / (points.length - 1);
            uvs.setXY(index, uv.x, uv.y);
            index++;
        }
    }
    for (i = 0; i < segments; i++) {
        for (j = 0; j < points.length - 1; j++) {
            base = j + i * points.length;
            var a = base;
            var b = base + points.length;
            var c = base + points.length + 1;
            var d = base + 1;
            indices.setX(indexOffset, a);
            indexOffset++;
            indices.setX(indexOffset, b);
            indexOffset++;
            indices.setX(indexOffset, d);
            indexOffset++;
            indices.setX(indexOffset, b);
            indexOffset++;
            indices.setX(indexOffset, c);
            indexOffset++;
            indices.setX(indexOffset, d);
            indexOffset++;
        }
    }
    this.setIndex(indices);
    this.addAttribute('position', vertices);
    this.addAttribute('uv', uvs);
    this.computeVertexNormals();
    if (phiLength === Math.PI * 2) {
        var normals = this.attributes.normal.array;
        var n1 = new Vector3();
        var n2 = new Vector3();
        var n = new Vector3();
        base = segments * points.length * 3;
        for (i = 0, j = 0; i < points.length; i++, j += 3) {
            n1.x = normals[j + 0];
            n1.y = normals[j + 1];
            n1.z = normals[j + 2];
            n2.x = normals[base + j + 0];
            n2.y = normals[base + j + 1];
            n2.z = normals[base + j + 2];
            n.addVectors(n1, n2).normalize();
            normals[j + 0] = normals[base + j + 0] = n.x;
            normals[j + 1] = normals[base + j + 1] = n.y;
            normals[j + 2] = normals[base + j + 2] = n.z;
        }
    }
};
LatheGeometry = function LatheGeometry(points, segments, phiStart, phiLength) {
    Geometry.call(this);
    this.type = 'LatheGeometry';
    this.parameters = {
        points: points,
        segments: segments,
        phiStart: phiStart,
        phiLength: phiLength
    };
    this.fromBufferGeometry(new LatheBufferGeometry(points, segments, phiStart, phiLength));
    this.mergeVertices();
};
CylinderGeometry = function CylinderGeometry(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
    Geometry.call(this);
    this.type = 'CylinderGeometry';
    this.parameters = {
        radiusTop: radiusTop,
        radiusBottom: radiusBottom,
        height: height,
        radialSegments: radialSegments,
        heightSegments: heightSegments,
        openEnded: openEnded,
        thetaStart: thetaStart,
        thetaLength: thetaLength
    };
    this.fromBufferGeometry(new CylinderBufferGeometry(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength));
    this.mergeVertices();
};
ConeGeometry = function ConeGeometry(radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
    CylinderGeometry.call(this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength);
    this.type = 'ConeGeometry';
    this.parameters = {
        radius: radius,
        height: height,
        radialSegments: radialSegments,
        heightSegments: heightSegments,
        openEnded: openEnded,
        thetaStart: thetaStart,
        thetaLength: thetaLength
    };
};
ConeBufferGeometry = function ConeBufferGeometry(radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
    CylinderBufferGeometry.call(this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength);
    this.type = 'ConeBufferGeometry';
    this.parameters = {
        radius: radius,
        height: height,
        radialSegments: radialSegments,
        heightSegments: heightSegments,
        thetaStart: thetaStart,
        thetaLength: thetaLength
    };
};
CircleBufferGeometry = function CircleBufferGeometry(radius, segments, thetaStart, thetaLength) {
    BufferGeometry.call(this);
    this.type = 'CircleBufferGeometry';
    this.parameters = {
        radius: radius,
        segments: segments,
        thetaStart: thetaStart,
        thetaLength: thetaLength
    };
    radius = radius || 50;
    segments = segments !== undefined ? Math.max(3, segments) : 8;
    thetaStart = thetaStart !== undefined ? thetaStart : 0;
    thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;
    var vertices = segments + 2;
    var positions = new Float32Array(vertices * 3);
    var normals = new Float32Array(vertices * 3);
    var uvs = new Float32Array(vertices * 2);
    normals[2] = 1;
    uvs[0] = 0.5;
    uvs[1] = 0.5;
    for (var s = 0, i = 3, ii = 2; s <= segments; s++, i += 3, ii += 2) {
        var segment = thetaStart + s / segments * thetaLength;
        positions[i] = radius * Math.cos(segment);
        positions[i + 1] = radius * Math.sin(segment);
        normals[i + 2] = 1;
        uvs[ii] = (positions[i] / radius + 1) / 2;
        uvs[ii + 1] = (positions[i + 1] / radius + 1) / 2;
    }
    var indices = [];
    for (var i = 1; i <= segments; i++) {
        indices.push(i, i + 1, 0);
    }
    this.setIndex(new BufferAttribute(new Uint16Array(indices), 1));
    this.addAttribute('position', new BufferAttribute(positions, 3));
    this.addAttribute('normal', new BufferAttribute(normals, 3));
    this.addAttribute('uv', new BufferAttribute(uvs, 2));
    this.boundingSphere = new Sphere(new Vector3(), radius);
};
CircleGeometry = function CircleGeometry(radius, segments, thetaStart, thetaLength) {
    Geometry.call(this);
    this.type = 'CircleGeometry';
    this.parameters = {
        radius: radius,
        segments: segments,
        thetaStart: thetaStart,
        thetaLength: thetaLength
    };
    this.fromBufferGeometry(new CircleBufferGeometry(radius, segments, thetaStart, thetaLength));
};
ClosedSplineCurve3 = function ClosedSplineCurve3(points) {
    console.warn('THREE.ClosedSplineCurve3 has been deprecated. Please use THREE.CatmullRomCurve3.');
    exports.CatmullRomCurve3.call(this, points);
    this.type = 'catmullrom';
    this.closed = true;
};
ArcCurve = function ArcCurve(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
    EllipseCurve.call(this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
};
Face4 = function Face4(a, b, c, d, normal, color, materialIndex) {
    console.warn('THREE.Face4 has been removed. A THREE.Face3 will be created instead.');
    return new Face3(a, b, c, normal, color, materialIndex);
};
PointCloud = function PointCloud(geometry, material) {
    console.warn('THREE.PointCloud has been renamed to THREE.Points.');
    return new Points(geometry, material);
};
ParticleSystem = function ParticleSystem(geometry, material) {
    console.warn('THREE.ParticleSystem has been renamed to THREE.Points.');
    return new Points(geometry, material);
};
PointCloudMaterial = function PointCloudMaterial(parameters) {
    console.warn('THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.');
    return new PointsMaterial(parameters);
};
ParticleBasicMaterial = function ParticleBasicMaterial(parameters) {
    console.warn('THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.');
    return new PointsMaterial(parameters);
};
ParticleSystemMaterial = function ParticleSystemMaterial(parameters) {
    console.warn('THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.');
    return new PointsMaterial(parameters);
};
Vertex = function Vertex(x, y, z) {
    console.warn('THREE.Vertex has been removed. Use THREE.Vector3 instead.');
    return new Vector3(x, y, z);
};
Projector = function Projector() {
    console.error('THREE.Projector has been moved to /examples/js/renderers/Projector.js.');
    this.projectVector = function (vector, camera) {
        console.warn('THREE.Projector: .projectVector() is now vector.project().');
        vector.project(camera);
    };
    this.unprojectVector = function (vector, camera) {
        console.warn('THREE.Projector: .unprojectVector() is now vector.unproject().');
        vector.unproject(camera);
    };
    this.pickingRay = function (vector, camera) {
        console.error('THREE.Projector: .pickingRay() is now raycaster.setFromCamera().');
    };
};
CanvasRenderer = function CanvasRenderer() {
    console.error('THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js');
    this.domElement = document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');
    this.clear = function () {
    };
    this.render = function () {
    };
    this.setClearColor = function () {
    };
    this.setSize = function () {
    };
};
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
exports = arguments[0];
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    EventDispatcher = ($__.fs.EventDispatcher_5 = function EventDispatcher() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');});
    Vector2 = ($__.fs.Vector2_6 = function Vector2(x, y) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
x = arguments[0], y = arguments[1];
switch (vvv_switch) {
case 0:
case 1:
case 2:
case 4:
case 10:
case 11:
case 12:
case 13:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(0 <= vvv_switch && vvv_switch <= 13);
    this.x = (x, 0);
    this.y = (y, 0);
    return;
case 3:
case 5:
case 6:
case 7:
case 8:
case 9:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(3 <= vvv_switch && vvv_switch <= 9);
    this.x = x;
    this.y = y;
    return;
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.x = x || 0;
this.y = y || 0;});
    Texture = ($__.fs.Texture_7 = function Texture(image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) {
var vvv_return, vvv_switch, vvv_tmp0;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
image = arguments[0], mapping = arguments[1], wrapS = arguments[2], wrapT = arguments[3], magFilter = arguments[4], minFilter = arguments[5], format = arguments[6], type = arguments[7], anisotropy = arguments[8], encoding = arguments[9];
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    Object['defineProperty'](this, 'id', $__.os.oid12 = {
        'value': (TextureIdCount, $__.fs.TextureIdCount_8)(0, true, $__.uid)
    });
    this.uuid = (vvv_tmp0 = ((exports, $__.os.oid0).Math, $__.os.oid3), 'generateUUID', $__.fs.generateUUID_286.call(vvv_tmp0, 0, true, $__.uid));
    this.name = '';
    this.sourceFile = '';
    this.image = (image !== undefined, TAJS_restrictToType(Texture.DEFAULT_IMAGE, 'undefined'));
    this.mipmaps = [];
    this.mapping = (mapping !== undefined, (Texture.DEFAULT_MAPPING, 300));
    this.wrapS = (wrapS !== undefined, ClampToEdgeWrapping);
    this.wrapT = (wrapT !== undefined, ClampToEdgeWrapping);
    this.magFilter = (magFilter !== undefined, LinearFilter);
    this.minFilter = (minFilter !== undefined, LinearMipMapLinearFilter);
    this.anisotropy = (anisotropy !== undefined, 1);
    this.format = (format !== undefined, RGBAFormat);
    this.type = (type !== undefined, UnsignedByteType);
    this.offset = new (Vector2, $__.fs.Vector2_6)(0, 0, 2, true, $__.uid);
    this.repeat = new (Vector2, $__.fs.Vector2_6)(1, 1, 3, true, $__.uid);
    this.generateMipmaps = true;
    this.premultiplyAlpha = false;
    this.flipY = true;
    this.unpackAlignment = 4;
    this.encoding = (encoding !== undefined, LinearEncoding);
    this.version = 0;
    this.onUpdate = null;
    return;
case 1:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 1);
    Object['defineProperty'](this, 'id', $__.os.oid13 = {
        'value': (TextureIdCount, $__.fs.TextureIdCount_8)(1, true, $__.uid)
    });
    this.uuid = (vvv_tmp0 = ((exports, $__.os.oid0).Math, $__.os.oid3), 'generateUUID', $__.fs.generateUUID_286.call(vvv_tmp0, 1, true, $__.uid));
    this.name = '';
    this.sourceFile = '';
    this.image = (image !== undefined, image);
    this.mipmaps = [];
    this.mapping = (mapping !== undefined, mapping);
    this.wrapS = (wrapS !== undefined, ClampToEdgeWrapping);
    this.wrapT = (wrapT !== undefined, ClampToEdgeWrapping);
    this.magFilter = (magFilter !== undefined, LinearFilter);
    this.minFilter = (minFilter !== undefined, LinearMipMapLinearFilter);
    this.anisotropy = (anisotropy !== undefined, 1);
    this.format = (format !== undefined, RGBAFormat);
    this.type = (type !== undefined, UnsignedByteType);
    this.offset = new (Vector2, $__.fs.Vector2_6)(0, 0, 4, true, $__.uid);
    this.repeat = new (Vector2, $__.fs.Vector2_6)(1, 1, 5, true, $__.uid);
    this.generateMipmaps = true;
    this.premultiplyAlpha = false;
    this.flipY = true;
    this.unpackAlignment = 4;
    this.encoding = (encoding !== undefined, LinearEncoding);
    this.version = 0;
    this.onUpdate = null;
    return;
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
Object.defineProperty(this, 'id', {
    value: TextureIdCount()
});
this.uuid = exports.Math.generateUUID();
this.name = '';
this.sourceFile = '';
this.image = image !== undefined ? image : Texture.DEFAULT_IMAGE;
this.mipmaps = [];
this.mapping = mapping !== undefined ? mapping : Texture.DEFAULT_MAPPING;
this.wrapS = wrapS !== undefined ? wrapS : ClampToEdgeWrapping;
this.wrapT = wrapT !== undefined ? wrapT : ClampToEdgeWrapping;
this.magFilter = magFilter !== undefined ? magFilter : LinearFilter;
this.minFilter = minFilter !== undefined ? minFilter : LinearMipMapLinearFilter;
this.anisotropy = anisotropy !== undefined ? anisotropy : 1;
this.format = format !== undefined ? format : RGBAFormat;
this.type = type !== undefined ? type : UnsignedByteType;
this.offset = new Vector2(0, 0);
this.repeat = new Vector2(1, 1);
this.generateMipmaps = true;
this.premultiplyAlpha = false;
this.flipY = true;
this.unpackAlignment = 4;
this.encoding = encoding !== undefined ? encoding : LinearEncoding;
this.version = 0;
this.onUpdate = null;}, $__.fs.Texture_7);
    TextureIdCount = ($__.fs.TextureIdCount_8 = function TextureIdCount() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
switch (vvv_switch) {
case 0:
case 1:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(0 <= vvv_switch && vvv_switch <= 1);
    return (count = +count + 1) - 1;
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return count++;});
    Matrix4 = ($__.fs.Matrix4_9 = function Matrix4() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
switch (vvv_switch) {
case 0:
case 1:
case 2:
case 3:
case 4:
case 5:
case 6:
case 7:
case 8:
case 9:
case 10:
case 11:
case 12:
case 13:
case 14:
case 15:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(0 <= vvv_switch && vvv_switch <= 15);
    this.elements = new Float32Array([
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1
    ]);
    (arguments.length, 0) > 0;
    return;
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.elements = new Float32Array([
    1,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    1
]);
if (arguments.length > 0) {
    console.error('THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.');
}});
    Quaternion = ($__.fs.Quaternion_10 = function Quaternion(x, y, z, w) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
x = arguments[0], y = arguments[1], z = arguments[2], w = arguments[3];
switch (vvv_switch) {
case 0:
case 1:
case 2:
case 3:
case 4:
case 5:
case 6:
case 7:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(0 <= vvv_switch && vvv_switch <= 7);
    this._x = (x, 0);
    this._y = (y, 0);
    this._z = (z, 0);
    this._w = (w !== undefined, 1);
    return;
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this._x = x || 0;
this._y = y || 0;
this._z = z || 0;
this._w = w !== undefined ? w : 1;}, $__.fs.Quaternion_10_0 = $__.fs.Quaternion_10, $__.fs.Quaternion_10);
    Vector3 = ($__.fs.Vector3_11 = function Vector3(x, y, z) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
x = arguments[0], y = arguments[1], z = arguments[2];
switch (vvv_switch) {
case 0:
case 1:
case 2:
case 3:
case 4:
case 5:
case 6:
case 7:
case 8:
case 9:
case 10:
case 11:
case 12:
case 15:
case 16:
case 17:
case 18:
case 19:
case 20:
case 21:
case 22:
case 27:
case 31:
case 32:
case 33:
case 36:
case 37:
case 38:
case 39:
case 40:
case 41:
case 42:
case 43:
case 44:
case 45:
case 46:
case 47:
case 48:
case 49:
case 50:
case 51:
case 52:
case 53:
case 54:
case 55:
case 56:
case 57:
case 58:
case 59:
case 60:
case 61:
case 62:
case 63:
case 64:
case 65:
case 66:
case 67:
case 68:
case 69:
case 70:
case 71:
case 72:
case 73:
case 74:
case 75:
case 76:
case 77:
case 78:
case 79:
case 80:
case 81:
case 82:
case 83:
case 84:
case 85:
case 86:
case 87:
case 88:
case 89:
case 90:
case 91:
case 92:
case 93:
case 95:
case 99:
case 100:
case 101:
case 102:
case 103:
case 104:
case 105:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(0 <= vvv_switch && vvv_switch <= 105);
    this.x = (x, 0);
    this.y = (y, 0);
    this.z = (z, 0);
    return;
case 13:
case 14:
case 34:
case 35:
case 96:
case 97:
case 98:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(13 <= vvv_switch && vvv_switch <= 98);
    this.x = x;
    this.y = y;
    this.z = z;
    return;
case 23:
case 25:
case 29:
case 94:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(23 <= vvv_switch && vvv_switch <= 94);
    this.x = (x, 0);
    this.y = y;
    this.z = (z, 0);
    return;
case 24:
case 28:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(24 <= vvv_switch && vvv_switch <= 28);
    this.x = x;
    this.y = (y, 0);
    this.z = (z, 0);
    return;
case 26:
case 30:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(26 <= vvv_switch && vvv_switch <= 30);
    this.x = (x, 0);
    this.y = (y, 0);
    this.z = z;
    return;
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.x = x || 0;
this.y = y || 0;
this.z = z || 0;});
    SpritePlugin = ($__.fs.SpritePlugin_12 = function SpritePlugin(renderer, sprites) {
var vvv_return, vvv_switch, gl, state, vertexBuffer, elementBuffer, program, attributes, uniforms, texture, spritePosition, spriteRotation, spriteScale, init, createProgram, painterSortStable;
init = function init() {
    var vertices = new Float32Array([
        -0.5,
        -0.5,
        0,
        0,
        0.5,
        -0.5,
        1,
        0,
        0.5,
        0.5,
        1,
        1,
        -0.5,
        0.5,
        0,
        1
    ]);
    var faces = new Uint16Array([
        0,
        1,
        2,
        0,
        2,
        3
    ]);
    vertexBuffer = gl.createBuffer();
    elementBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, elementBuffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW);
    program = createProgram();
    attributes = {
        position: gl.getAttribLocation(program, 'position'),
        uv: gl.getAttribLocation(program, 'uv')
    };
    uniforms = {
        uvOffset: gl.getUniformLocation(program, 'uvOffset'),
        uvScale: gl.getUniformLocation(program, 'uvScale'),
        rotation: gl.getUniformLocation(program, 'rotation'),
        scale: gl.getUniformLocation(program, 'scale'),
        color: gl.getUniformLocation(program, 'color'),
        map: gl.getUniformLocation(program, 'map'),
        opacity: gl.getUniformLocation(program, 'opacity'),
        modelViewMatrix: gl.getUniformLocation(program, 'modelViewMatrix'),
        projectionMatrix: gl.getUniformLocation(program, 'projectionMatrix'),
        fogType: gl.getUniformLocation(program, 'fogType'),
        fogDensity: gl.getUniformLocation(program, 'fogDensity'),
        fogNear: gl.getUniformLocation(program, 'fogNear'),
        fogFar: gl.getUniformLocation(program, 'fogFar'),
        fogColor: gl.getUniformLocation(program, 'fogColor'),
        alphaTest: gl.getUniformLocation(program, 'alphaTest')
    };
    var canvas = document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');
    canvas.width = 8;
    canvas.height = 8;
    var context = canvas.getContext('2d');
    context.fillStyle = 'white';
    context.fillRect(0, 0, 8, 8);
    texture = new Texture(canvas);
    texture.needsUpdate = true;
};
createProgram = function createProgram() {
    var program = gl.createProgram();
    var vertexShader = gl.createShader(gl.VERTEX_SHADER);
    var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
    gl.shaderSource(vertexShader, [
        'precision ' + renderer.getPrecision() + ' float;',
        'uniform mat4 modelViewMatrix;',
        'uniform mat4 projectionMatrix;',
        'uniform float rotation;',
        'uniform vec2 scale;',
        'uniform vec2 uvOffset;',
        'uniform vec2 uvScale;',
        'attribute vec2 position;',
        'attribute vec2 uv;',
        'varying vec2 vUV;',
        'void main() {',
        'vUV = uvOffset + uv * uvScale;',
        'vec2 alignedPosition = position * scale;',
        'vec2 rotatedPosition;',
        'rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;',
        'rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;',
        'vec4 finalPosition;',
        'finalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );',
        'finalPosition.xy += rotatedPosition;',
        'finalPosition = projectionMatrix * finalPosition;',
        'gl_Position = finalPosition;',
        '}'
    ].join('\n'));
    gl.shaderSource(fragmentShader, [
        'precision ' + renderer.getPrecision() + ' float;',
        'uniform vec3 color;',
        'uniform sampler2D map;',
        'uniform float opacity;',
        'uniform int fogType;',
        'uniform vec3 fogColor;',
        'uniform float fogDensity;',
        'uniform float fogNear;',
        'uniform float fogFar;',
        'uniform float alphaTest;',
        'varying vec2 vUV;',
        'void main() {',
        'vec4 texture = texture2D( map, vUV );',
        'if ( texture.a < alphaTest ) discard;',
        'gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );',
        'if ( fogType > 0 ) {',
        'float depth = gl_FragCoord.z / gl_FragCoord.w;',
        'float fogFactor = 0.0;',
        'if ( fogType == 1 ) {',
        'fogFactor = smoothstep( fogNear, fogFar, depth );',
        '} else {',
        'const float LOG2 = 1.442695;',
        'fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );',
        'fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );',
        '}',
        'gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );',
        '}',
        '}'
    ].join('\n'));
    gl.compileShader(vertexShader);
    gl.compileShader(fragmentShader);
    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader);
    gl.linkProgram(program);
    return program;
};
painterSortStable = function painterSortStable(a, b) {
    if (a.renderOrder !== b.renderOrder) {
        return a.renderOrder - b.renderOrder;
    } else if (a.z !== b.z) {
        return b.z - a.z;
    } else {
        return b.id - a.id;
    }
};
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
renderer = arguments[0], sprites = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
gl = renderer.context;
state = renderer.state;
spritePosition = new Vector3();
spriteRotation = new Quaternion();
spriteScale = new Vector3();
this.render = function (scene, camera) {
    if (sprites.length === 0)
        return;
    if (program === undefined) {
        init();
    }
    gl.useProgram(program);
    state.initAttributes();
    state.enableAttribute(attributes.position);
    state.enableAttribute(attributes.uv);
    state.disableUnusedAttributes();
    state.disable(gl.CULL_FACE);
    state.enable(gl.BLEND);
    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
    gl.vertexAttribPointer(attributes.position, 2, gl.FLOAT, false, 2 * 8, 0);
    gl.vertexAttribPointer(attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, elementBuffer);
    gl.uniformMatrix4fv(uniforms.projectionMatrix, false, camera.projectionMatrix.elements);
    state.activeTexture(gl.TEXTURE0);
    gl.uniform1i(uniforms.map, 0);
    var oldFogType = 0;
    var sceneFogType = 0;
    var fog = scene.fog;
    if (fog) {
        gl.uniform3f(uniforms.fogColor, fog.color.r, fog.color.g, fog.color.b);
        if (fog && fog.isFog) {
            gl.uniform1f(uniforms.fogNear, fog.near);
            gl.uniform1f(uniforms.fogFar, fog.far);
            gl.uniform1i(uniforms.fogType, 1);
            oldFogType = 1;
            sceneFogType = 1;
        } else if (fog && fog.isFogExp2) {
            gl.uniform1f(uniforms.fogDensity, fog.density);
            gl.uniform1i(uniforms.fogType, 2);
            oldFogType = 2;
            sceneFogType = 2;
        }
    } else {
        gl.uniform1i(uniforms.fogType, 0);
        oldFogType = 0;
        sceneFogType = 0;
    }
    for (var i = 0, l = sprites.length; i < l; i++) {
        var sprite = sprites[i];
        sprite.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, sprite.matrixWorld);
        sprite.z = -sprite.modelViewMatrix.elements[14];
    }
    sprites.sort(painterSortStable);
    var scale = [];
    for (var i = 0, l = sprites.length; i < l; i++) {
        var sprite = sprites[i];
        var material = sprite.material;
        if (material.visible === false)
            continue;
        gl.uniform1f(uniforms.alphaTest, material.alphaTest);
        gl.uniformMatrix4fv(uniforms.modelViewMatrix, false, sprite.modelViewMatrix.elements);
        sprite.matrixWorld.decompose(spritePosition, spriteRotation, spriteScale);
        scale[0] = spriteScale.x;
        scale[1] = spriteScale.y;
        var fogType = 0;
        if (scene.fog && material.fog) {
            fogType = sceneFogType;
        }
        if (oldFogType !== fogType) {
            gl.uniform1i(uniforms.fogType, fogType);
            oldFogType = fogType;
        }
        if (material.map !== null) {
            gl.uniform2f(uniforms.uvOffset, material.map.offset.x, material.map.offset.y);
            gl.uniform2f(uniforms.uvScale, material.map.repeat.x, material.map.repeat.y);
        } else {
            gl.uniform2f(uniforms.uvOffset, 0, 0);
            gl.uniform2f(uniforms.uvScale, 1, 1);
        }
        gl.uniform1f(uniforms.opacity, material.opacity);
        gl.uniform3f(uniforms.color, material.color.r, material.color.g, material.color.b);
        gl.uniform1f(uniforms.rotation, material.rotation);
        gl.uniform2fv(uniforms.scale, scale);
        state.setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst);
        state.setDepthTest(material.depthTest);
        state.setDepthWrite(material.depthWrite);
        if (material.map) {
            renderer.setTexture2D(material.map, 0);
        } else {
            renderer.setTexture2D(texture, 0);
        }
        gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
    }
    state.enable(gl.CULL_FACE);
    renderer.resetGLState();
};});
    Box2 = ($__.fs.Box2_13 = function Box2(min, max) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
min = arguments[0], max = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.min = min !== undefined ? min : new Vector2(+Infinity, +Infinity);
this.max = max !== undefined ? max : new Vector2(-Infinity, -Infinity);});
    LensFlarePlugin = ($__.fs.LensFlarePlugin_14 = function LensFlarePlugin(renderer, flares) {
var vvv_return, vvv_switch, gl, state, vertexBuffer, elementBuffer, shader, program, attributes, uniforms, tempTexture, occlusionTexture, init, createProgram;
init = function init() {
    var vertices = new Float32Array([
        -1,
        -1,
        0,
        0,
        1,
        -1,
        1,
        0,
        1,
        1,
        1,
        1,
        -1,
        1,
        0,
        1
    ]);
    var faces = new Uint16Array([
        0,
        1,
        2,
        0,
        2,
        3
    ]);
    vertexBuffer = gl.createBuffer();
    elementBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, elementBuffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW);
    tempTexture = gl.createTexture();
    occlusionTexture = gl.createTexture();
    state.bindTexture(gl.TEXTURE_2D, tempTexture);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, 16, 16, 0, gl.RGB, gl.UNSIGNED_BYTE, null);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    state.bindTexture(gl.TEXTURE_2D, occlusionTexture);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 16, 16, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    shader = {
        vertexShader: [
            'uniform lowp int renderType;',
            'uniform vec3 screenPosition;',
            'uniform vec2 scale;',
            'uniform float rotation;',
            'uniform sampler2D occlusionMap;',
            'attribute vec2 position;',
            'attribute vec2 uv;',
            'varying vec2 vUV;',
            'varying float vVisibility;',
            'void main() {',
            'vUV = uv;',
            'vec2 pos = position;',
            'if ( renderType == 2 ) {',
            'vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );',
            'visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );',
            'visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );',
            'visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );',
            'visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );',
            'visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );',
            'visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );',
            'visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );',
            'visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );',
            'vVisibility =        visibility.r / 9.0;',
            'vVisibility *= 1.0 - visibility.g / 9.0;',
            'vVisibility *=       visibility.b / 9.0;',
            'vVisibility *= 1.0 - visibility.a / 9.0;',
            'pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;',
            'pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;',
            '}',
            'gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );',
            '}'
        ].join('\n'),
        fragmentShader: [
            'uniform lowp int renderType;',
            'uniform sampler2D map;',
            'uniform float opacity;',
            'uniform vec3 color;',
            'varying vec2 vUV;',
            'varying float vVisibility;',
            'void main() {',
            'if ( renderType == 0 ) {',
            'gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );',
            '} else if ( renderType == 1 ) {',
            'gl_FragColor = texture2D( map, vUV );',
            '} else {',
            'vec4 texture = texture2D( map, vUV );',
            'texture.a *= opacity * vVisibility;',
            'gl_FragColor = texture;',
            'gl_FragColor.rgb *= color;',
            '}',
            '}'
        ].join('\n')
    };
    program = createProgram(shader);
    attributes = {
        vertex: gl.getAttribLocation(program, 'position'),
        uv: gl.getAttribLocation(program, 'uv')
    };
    uniforms = {
        renderType: gl.getUniformLocation(program, 'renderType'),
        map: gl.getUniformLocation(program, 'map'),
        occlusionMap: gl.getUniformLocation(program, 'occlusionMap'),
        opacity: gl.getUniformLocation(program, 'opacity'),
        color: gl.getUniformLocation(program, 'color'),
        scale: gl.getUniformLocation(program, 'scale'),
        rotation: gl.getUniformLocation(program, 'rotation'),
        screenPosition: gl.getUniformLocation(program, 'screenPosition')
    };
};
createProgram = function createProgram(shader) {
    var program = gl.createProgram();
    var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
    var vertexShader = gl.createShader(gl.VERTEX_SHADER);
    var prefix = 'precision ' + renderer.getPrecision() + ' float;\n';
    gl.shaderSource(fragmentShader, prefix + shader.fragmentShader);
    gl.shaderSource(vertexShader, prefix + shader.vertexShader);
    gl.compileShader(fragmentShader);
    gl.compileShader(vertexShader);
    gl.attachShader(program, fragmentShader);
    gl.attachShader(program, vertexShader);
    gl.linkProgram(program);
    return program;
};
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
renderer = arguments[0], flares = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
gl = renderer.context;
state = renderer.state;
this.render = function (scene, camera, viewport) {
    if (flares.length === 0)
        return;
    var tempPosition = new Vector3();
    var invAspect = viewport.w / viewport.z, halfViewportWidth = viewport.z * 0.5, halfViewportHeight = viewport.w * 0.5;
    var size = 16 / viewport.w, scale = new Vector2(size * invAspect, size);
    var screenPosition = new Vector3(1, 1, 0), screenPositionPixels = new Vector2(1, 1);
    var validArea = new Box2();
    validArea.min.set(0, 0);
    validArea.max.set(viewport.z - 16, viewport.w - 16);
    if (program === undefined) {
        init();
    }
    gl.useProgram(program);
    state.initAttributes();
    state.enableAttribute(attributes.vertex);
    state.enableAttribute(attributes.uv);
    state.disableUnusedAttributes();
    gl.uniform1i(uniforms.occlusionMap, 0);
    gl.uniform1i(uniforms.map, 1);
    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
    gl.vertexAttribPointer(attributes.vertex, 2, gl.FLOAT, false, 2 * 8, 0);
    gl.vertexAttribPointer(attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, elementBuffer);
    state.disable(gl.CULL_FACE);
    state.setDepthWrite(false);
    for (var i = 0, l = flares.length; i < l; i++) {
        size = 16 / viewport.w;
        scale.set(size * invAspect, size);
        var flare = flares[i];
        tempPosition.set(flare.matrixWorld.elements[12], flare.matrixWorld.elements[13], flare.matrixWorld.elements[14]);
        tempPosition.applyMatrix4(camera.matrixWorldInverse);
        tempPosition.applyProjection(camera.projectionMatrix);
        screenPosition.copy(tempPosition);
        screenPositionPixels.x = viewport.x + screenPosition.x * halfViewportWidth + halfViewportWidth - 8;
        screenPositionPixels.y = viewport.y + screenPosition.y * halfViewportHeight + halfViewportHeight - 8;
        if (validArea.containsPoint(screenPositionPixels) === true) {
            state.activeTexture(gl.TEXTURE0);
            state.bindTexture(gl.TEXTURE_2D, null);
            state.activeTexture(gl.TEXTURE1);
            state.bindTexture(gl.TEXTURE_2D, tempTexture);
            gl.copyTexImage2D(gl.TEXTURE_2D, 0, gl.RGB, screenPositionPixels.x, screenPositionPixels.y, 16, 16, 0);
            gl.uniform1i(uniforms.renderType, 0);
            gl.uniform2f(uniforms.scale, scale.x, scale.y);
            gl.uniform3f(uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z);
            state.disable(gl.BLEND);
            state.enable(gl.DEPTH_TEST);
            gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
            state.activeTexture(gl.TEXTURE0);
            state.bindTexture(gl.TEXTURE_2D, occlusionTexture);
            gl.copyTexImage2D(gl.TEXTURE_2D, 0, gl.RGBA, screenPositionPixels.x, screenPositionPixels.y, 16, 16, 0);
            gl.uniform1i(uniforms.renderType, 1);
            state.disable(gl.DEPTH_TEST);
            state.activeTexture(gl.TEXTURE1);
            state.bindTexture(gl.TEXTURE_2D, tempTexture);
            gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
            flare.positionScreen.copy(screenPosition);
            if (flare.customUpdateCallback) {
                flare.customUpdateCallback(flare);
            } else {
                flare.updateLensFlares();
            }
            gl.uniform1i(uniforms.renderType, 2);
            state.enable(gl.BLEND);
            for (var j = 0, jl = flare.lensFlares.length; j < jl; j++) {
                var sprite = flare.lensFlares[j];
                if (sprite.opacity > 0.001 && sprite.scale > 0.001) {
                    screenPosition.x = sprite.x;
                    screenPosition.y = sprite.y;
                    screenPosition.z = sprite.z;
                    size = sprite.size * sprite.scale / viewport.w;
                    scale.x = size * invAspect;
                    scale.y = size;
                    gl.uniform3f(uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z);
                    gl.uniform2f(uniforms.scale, scale.x, scale.y);
                    gl.uniform1f(uniforms.rotation, sprite.rotation);
                    gl.uniform1f(uniforms.opacity, sprite.opacity);
                    gl.uniform3f(uniforms.color, sprite.color.r, sprite.color.g, sprite.color.b);
                    state.setBlending(sprite.blending, sprite.blendEquation, sprite.blendSrc, sprite.blendDst);
                    renderer.setTexture2D(sprite.texture, 1);
                    gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
                }
            }
        }
    }
    state.enable(gl.CULL_FACE);
    state.enable(gl.DEPTH_TEST);
    state.setDepthWrite(true);
    renderer.resetGLState();
};});
    CubeTexture = ($__.fs.CubeTexture_15 = function CubeTexture(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) {
var vvv_return, vvv_switch, vvv_tmp0;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
images = arguments[0], mapping = arguments[1], wrapS = arguments[2], wrapT = arguments[3], magFilter = arguments[4], minFilter = arguments[5], format = arguments[6], type = arguments[7], anisotropy = arguments[8], encoding = arguments[9];
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    images = (images !== undefined, []);
    mapping = (mapping !== undefined, CubeReflectionMapping);
    vvv_tmp0 = this, (Texture, $__.fs.Texture_7).call(vvv_tmp0, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding, 1, true, $__.uid);
    this.flipY = false;
    return;
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
images = images !== undefined ? images : [];
mapping = mapping !== undefined ? mapping : CubeReflectionMapping;
Texture.call(this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
this.flipY = false;});
    UniformContainer = ($__.fs.UniformContainer_16 = function UniformContainer() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.seq = [];
this.map = {};});
    flatten = ($__.fs.flatten_17 = function flatten(array, nBlocks, blockSize) {
var vvv_return, vvv_switch, firstElem, n, r;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
array = arguments[0], nBlocks = arguments[1], blockSize = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
firstElem = array[0];
if (firstElem <= 0 || firstElem > 0)
    return array;
n = nBlocks * blockSize;
r = arrayCacheF32[n];
if (r === undefined) {
    r = new Float32Array(n);
    arrayCacheF32[n] = r;
}
if (nBlocks !== 0) {
    firstElem.toArray(r, 0);
    for (var i = 1, offset = 0; i !== nBlocks; ++i) {
        offset += blockSize;
        array[i].toArray(r, offset);
    }
}
return r;});
    allocTexUnits = ($__.fs.allocTexUnits_18 = function allocTexUnits(renderer, n) {
var vvv_return, vvv_switch, r;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
renderer = arguments[0], n = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
r = arrayCacheI32[n];
if (r === undefined) {
    r = new Int32Array(n);
    arrayCacheI32[n] = r;
}
for (var i = 0; i !== n; ++i)
    r[i] = renderer.allocTextureUnit();
return r;});
    setValue1f = ($__.fs.setValue1f_19 = function setValue1f(gl, v) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
gl = arguments[0], v = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
gl.uniform1f(this.addr, v);});
    setValue1i = ($__.fs.setValue1i_20 = function setValue1i(gl, v) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
gl = arguments[0], v = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
gl.uniform1i(this.addr, v);});
    setValue2fv = ($__.fs.setValue2fv_21 = function setValue2fv(gl, v) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
gl = arguments[0], v = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (v.x === undefined)
    gl.uniform2fv(this.addr, v);
else
    gl.uniform2f(this.addr, v.x, v.y);});
    setValue3fv = ($__.fs.setValue3fv_22 = function setValue3fv(gl, v) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
gl = arguments[0], v = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (v.x !== undefined)
    gl.uniform3f(this.addr, v.x, v.y, v.z);
else if (v.r !== undefined)
    gl.uniform3f(this.addr, v.r, v.g, v.b);
else
    gl.uniform3fv(this.addr, v);});
    setValue4fv = ($__.fs.setValue4fv_23 = function setValue4fv(gl, v) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
gl = arguments[0], v = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (v.x === undefined)
    gl.uniform4fv(this.addr, v);
else
    gl.uniform4f(this.addr, v.x, v.y, v.z, v.w);});
    setValue2fm = ($__.fs.setValue2fm_24 = function setValue2fm(gl, v) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
gl = arguments[0], v = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
gl.uniformMatrix2fv(this.addr, false, v.elements || v);});
    setValue3fm = ($__.fs.setValue3fm_25 = function setValue3fm(gl, v) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
gl = arguments[0], v = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
gl.uniformMatrix3fv(this.addr, false, v.elements || v);});
    setValue4fm = ($__.fs.setValue4fm_26 = function setValue4fm(gl, v) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
gl = arguments[0], v = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
gl.uniformMatrix4fv(this.addr, false, v.elements || v);});
    setValueT1 = ($__.fs.setValueT1_27 = function setValueT1(gl, v, renderer) {
var vvv_return, vvv_switch, unit;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
gl = arguments[0], v = arguments[1], renderer = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
unit = renderer.allocTextureUnit();
gl.uniform1i(this.addr, unit);
renderer.setTexture2D(v || emptyTexture, unit);});
    setValueT6 = ($__.fs.setValueT6_28 = function setValueT6(gl, v, renderer) {
var vvv_return, vvv_switch, unit;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
gl = arguments[0], v = arguments[1], renderer = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
unit = renderer.allocTextureUnit();
gl.uniform1i(this.addr, unit);
renderer.setTextureCube(v || emptyCubeTexture, unit);});
    setValue2iv = ($__.fs.setValue2iv_29 = function setValue2iv(gl, v) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
gl = arguments[0], v = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
gl.uniform2iv(this.addr, v);});
    setValue3iv = ($__.fs.setValue3iv_30 = function setValue3iv(gl, v) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
gl = arguments[0], v = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
gl.uniform3iv(this.addr, v);});
    setValue4iv = ($__.fs.setValue4iv_31 = function setValue4iv(gl, v) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
gl = arguments[0], v = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
gl.uniform4iv(this.addr, v);});
    getSingularSetter = ($__.fs.getSingularSetter_32 = function getSingularSetter(type) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
type = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
switch (type) {
case 5126:
    return setValue1f;
case 35664:
    return setValue2fv;
case 35665:
    return setValue3fv;
case 35666:
    return setValue4fv;
case 35674:
    return setValue2fm;
case 35675:
    return setValue3fm;
case 35676:
    return setValue4fm;
case 35678:
    return setValueT1;
case 35680:
    return setValueT6;
case 5124:
case 35670:
    return setValue1i;
case 35667:
case 35671:
    return setValue2iv;
case 35668:
case 35672:
    return setValue3iv;
case 35669:
case 35673:
    return setValue4iv;
}});
    setValue1fv = ($__.fs.setValue1fv_33 = function setValue1fv(gl, v) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
gl = arguments[0], v = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
gl.uniform1fv(this.addr, v);});
    setValue1iv = ($__.fs.setValue1iv_34 = function setValue1iv(gl, v) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
gl = arguments[0], v = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
gl.uniform1iv(this.addr, v);});
    setValueV2a = ($__.fs.setValueV2a_35 = function setValueV2a(gl, v) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
gl = arguments[0], v = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
gl.uniform2fv(this.addr, flatten(v, this.size, 2));});
    setValueV3a = ($__.fs.setValueV3a_36 = function setValueV3a(gl, v) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
gl = arguments[0], v = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
gl.uniform3fv(this.addr, flatten(v, this.size, 3));});
    setValueV4a = ($__.fs.setValueV4a_37 = function setValueV4a(gl, v) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
gl = arguments[0], v = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
gl.uniform4fv(this.addr, flatten(v, this.size, 4));});
    setValueM2a = ($__.fs.setValueM2a_38 = function setValueM2a(gl, v) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
gl = arguments[0], v = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
gl.uniformMatrix2fv(this.addr, false, flatten(v, this.size, 4));});
    setValueM3a = ($__.fs.setValueM3a_39 = function setValueM3a(gl, v) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
gl = arguments[0], v = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
gl.uniformMatrix3fv(this.addr, false, flatten(v, this.size, 9));});
    setValueM4a = ($__.fs.setValueM4a_40 = function setValueM4a(gl, v) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
gl = arguments[0], v = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
gl.uniformMatrix4fv(this.addr, false, flatten(v, this.size, 16));});
    setValueT1a = ($__.fs.setValueT1a_41 = function setValueT1a(gl, v, renderer) {
var vvv_return, vvv_switch, n, units;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
gl = arguments[0], v = arguments[1], renderer = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
n = v.length;
units = allocTexUnits(renderer, n);
gl.uniform1iv(this.addr, units);
for (var i = 0; i !== n; ++i) {
    renderer.setTexture2D(v[i] || emptyTexture, units[i]);
}});
    setValueT6a = ($__.fs.setValueT6a_42 = function setValueT6a(gl, v, renderer) {
var vvv_return, vvv_switch, n, units;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
gl = arguments[0], v = arguments[1], renderer = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
n = v.length;
units = allocTexUnits(renderer, n);
gl.uniform1iv(this.addr, units);
for (var i = 0; i !== n; ++i) {
    renderer.setTextureCube(v[i] || emptyCubeTexture, units[i]);
}});
    getPureArraySetter = ($__.fs.getPureArraySetter_43 = function getPureArraySetter(type) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
type = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
switch (type) {
case 5126:
    return setValue1fv;
case 35664:
    return setValueV2a;
case 35665:
    return setValueV3a;
case 35666:
    return setValueV4a;
case 35674:
    return setValueM2a;
case 35675:
    return setValueM3a;
case 35676:
    return setValueM4a;
case 35678:
    return setValueT1a;
case 35680:
    return setValueT6a;
case 5124:
case 35670:
    return setValue1iv;
case 35667:
case 35671:
    return setValue2iv;
case 35668:
case 35672:
    return setValue3iv;
case 35669:
case 35673:
    return setValue4iv;
}});
    SingleUniform = ($__.fs.SingleUniform_44 = function SingleUniform(id, activeInfo, addr) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
id = arguments[0], activeInfo = arguments[1], addr = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.id = id;
this.addr = addr;
this.setValue = getSingularSetter(activeInfo.type);});
    PureArrayUniform = ($__.fs.PureArrayUniform_45 = function PureArrayUniform(id, activeInfo, addr) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
id = arguments[0], activeInfo = arguments[1], addr = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.id = id;
this.addr = addr;
this.size = activeInfo.size;
this.setValue = getPureArraySetter(activeInfo.type);});
    StructuredUniform = ($__.fs.StructuredUniform_46 = function StructuredUniform(id) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
id = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.id = id;
UniformContainer.call(this);});
    addUniform = ($__.fs.addUniform_47 = function addUniform(container, uniformObject) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
container = arguments[0], uniformObject = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
container.seq.push(uniformObject);
container.map[uniformObject.id] = uniformObject;});
    parseUniform = ($__.fs.parseUniform_48 = function parseUniform(activeInfo, addr, container) {
var vvv_return, vvv_switch, path, pathLength, match, matchEnd, id, idIsIndex, subscript, map, next;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
activeInfo = arguments[0], addr = arguments[1], container = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
path = activeInfo.name;
pathLength = path.length;
RePathPart.lastIndex = 0;
for (;;) {
    match = RePathPart.exec(path);
    matchEnd = RePathPart.lastIndex;
    id = match[1];
    idIsIndex = match[2] === ']';
    subscript = match[3];
    if (idIsIndex)
        id = id | 0;
    if (subscript === undefined || subscript === '[' && matchEnd + 2 === pathLength) {
        addUniform(container, subscript === undefined ? new SingleUniform(id, activeInfo, addr) : new PureArrayUniform(id, activeInfo, addr));
        break;
    } else {
        map = container.map;
        next = map[id];
        if (next === undefined) {
            next = new StructuredUniform(id);
            addUniform(container, next);
        }
        container = next;
    }
}});
    WebGLUniforms = ($__.fs.WebGLUniforms_49 = function WebGLUniforms(gl, program, renderer) {
var vvv_return, vvv_switch, n, info, path, addr;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
gl = arguments[0], program = arguments[1], renderer = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
UniformContainer.call(this);
this.renderer = renderer;
n = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
for (var i = 0; i !== n; ++i) {
    info = gl.getActiveUniform(program, i);
    path = info.name;
    addr = gl.getUniformLocation(program, path);
    parseUniform(info, addr, this);
}});
    WebGLTextures = ($__.fs.WebGLTextures_50 = function WebGLTextures(_gl, extensions, state, properties, capabilities, paramThreeToGL, info) {
var vvv_return, vvv_switch, _infoMemory, _isWebGL2, clampToMaxSize, isPowerOfTwo, makePowerOfTwo, textureNeedsPowerOfTwo, filterFallback, onTextureDispose, onRenderTargetDispose, deallocateTexture, deallocateRenderTarget, setTexture2D, setTextureCube, setTextureCubeDynamic, setTextureParameters, uploadTexture, setupFrameBufferTexture, setupRenderBufferStorage, setupDepthTexture, setupDepthRenderbuffer, setupRenderTarget, updateRenderTargetMipmap;
clampToMaxSize = function clampToMaxSize(image, maxSize) {
    if (image.width > maxSize || image.height > maxSize) {
        var scale = maxSize / Math.max(image.width, image.height);
        var canvas = document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');
        canvas.width = Math.floor(image.width * scale);
        canvas.height = Math.floor(image.height * scale);
        var context = canvas.getContext('2d');
        context.drawImage(image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height);
        console.warn('THREE.WebGLRenderer: image is too big (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image);
        return canvas;
    }
    return image;
};
isPowerOfTwo = function isPowerOfTwo(image) {
    return exports.Math.isPowerOfTwo(image.width) && exports.Math.isPowerOfTwo(image.height);
};
makePowerOfTwo = function makePowerOfTwo(image) {
    if (image instanceof HTMLImageElement || image instanceof HTMLCanvasElement) {
        var canvas = document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');
        canvas.width = exports.Math.nearestPowerOfTwo(image.width);
        canvas.height = exports.Math.nearestPowerOfTwo(image.height);
        var context = canvas.getContext('2d');
        context.drawImage(image, 0, 0, canvas.width, canvas.height);
        console.warn('THREE.WebGLRenderer: image is not power of two (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image);
        return canvas;
    }
    return image;
};
textureNeedsPowerOfTwo = function textureNeedsPowerOfTwo(texture) {
    if (texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping)
        return true;
    if (texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter)
        return true;
    return false;
};
filterFallback = function filterFallback(f) {
    if (f === NearestFilter || f === NearestMipMapNearestFilter || f === NearestMipMapLinearFilter) {
        return _gl.NEAREST;
    }
    return _gl.LINEAR;
};
onTextureDispose = function onTextureDispose(event) {
    var texture = event.target;
    texture.removeEventListener('dispose', onTextureDispose);
    deallocateTexture(texture);
    _infoMemory.textures--;
};
onRenderTargetDispose = function onRenderTargetDispose(event) {
    var renderTarget = event.target;
    renderTarget.removeEventListener('dispose', onRenderTargetDispose);
    deallocateRenderTarget(renderTarget);
    _infoMemory.textures--;
};
deallocateTexture = function deallocateTexture(texture) {
    var textureProperties = properties.get(texture);
    if (texture.image && textureProperties.__image__webglTextureCube) {
        _gl.deleteTexture(textureProperties.__image__webglTextureCube);
    } else {
        if (textureProperties.__webglInit === undefined)
            return;
        _gl.deleteTexture(textureProperties.__webglTexture);
    }
    properties.delete(texture);
};
deallocateRenderTarget = function deallocateRenderTarget(renderTarget) {
    var renderTargetProperties = properties.get(renderTarget);
    var textureProperties = properties.get(renderTarget.texture);
    if (!renderTarget)
        return;
    if (textureProperties.__webglTexture !== undefined) {
        _gl.deleteTexture(textureProperties.__webglTexture);
    }
    if (renderTarget.depthTexture) {
        renderTarget.depthTexture.dispose();
    }
    if (renderTarget && renderTarget.isWebGLRenderTargetCube) {
        for (var i = 0; i < 6; i++) {
            _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i]);
            if (renderTargetProperties.__webglDepthbuffer)
                _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer[i]);
        }
    } else {
        _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer);
        if (renderTargetProperties.__webglDepthbuffer)
            _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer);
    }
    properties.delete(renderTarget.texture);
    properties.delete(renderTarget);
};
setTexture2D = function setTexture2D(texture, slot) {
    var textureProperties = properties.get(texture);
    if (texture.version > 0 && textureProperties.__version !== texture.version) {
        var image = texture.image;
        if (image === undefined) {
            console.warn('THREE.WebGLRenderer: Texture marked for update but image is undefined', texture);
        } else if (image.complete === false) {
            console.warn('THREE.WebGLRenderer: Texture marked for update but image is incomplete', texture);
        } else {
            uploadTexture(textureProperties, texture, slot);
            return;
        }
    }
    state.activeTexture(_gl.TEXTURE0 + slot);
    state.bindTexture(_gl.TEXTURE_2D, textureProperties.__webglTexture);
};
setTextureCube = function setTextureCube(texture, slot) {
    var textureProperties = properties.get(texture);
    if (texture.image.length === 6) {
        if (texture.version > 0 && textureProperties.__version !== texture.version) {
            if (!textureProperties.__image__webglTextureCube) {
                texture.addEventListener('dispose', onTextureDispose);
                textureProperties.__image__webglTextureCube = _gl.createTexture();
                _infoMemory.textures++;
            }
            state.activeTexture(_gl.TEXTURE0 + slot);
            state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube);
            _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);
            var isCompressed = texture && texture.isCompressedTexture;
            var isDataTexture = texture.image[0] && texture.image[0].isDataTexture;
            var cubeImage = [];
            for (var i = 0; i < 6; i++) {
                if (!isCompressed && !isDataTexture) {
                    cubeImage[i] = clampToMaxSize(texture.image[i], capabilities.maxCubemapSize);
                } else {
                    cubeImage[i] = isDataTexture ? texture.image[i].image : texture.image[i];
                }
            }
            var image = cubeImage[0], isPowerOfTwoImage = isPowerOfTwo(image), glFormat = paramThreeToGL(texture.format), glType = paramThreeToGL(texture.type);
            setTextureParameters(_gl.TEXTURE_CUBE_MAP, texture, isPowerOfTwoImage);
            for (var i = 0; i < 6; i++) {
                if (!isCompressed) {
                    if (isDataTexture) {
                        state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, cubeImage[i].width, cubeImage[i].height, 0, glFormat, glType, cubeImage[i].data);
                    } else {
                        state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, glFormat, glType, cubeImage[i]);
                    }
                } else {
                    var mipmap, mipmaps = cubeImage[i].mipmaps;
                    for (var j = 0, jl = mipmaps.length; j < jl; j++) {
                        mipmap = mipmaps[j];
                        if (texture.format !== RGBAFormat && texture.format !== RGBFormat) {
                            if (state.getCompressedTextureFormats().indexOf(glFormat) > -1) {
                                state.compressedTexImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, mipmap.data);
                            } else {
                                console.warn('THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()');
                            }
                        } else {
                            state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
                        }
                    }
                }
            }
            if (texture.generateMipmaps && isPowerOfTwoImage) {
                _gl.generateMipmap(_gl.TEXTURE_CUBE_MAP);
            }
            textureProperties.__version = texture.version;
            if (texture.onUpdate)
                texture.onUpdate(texture);
        } else {
            state.activeTexture(_gl.TEXTURE0 + slot);
            state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube);
        }
    }
};
setTextureCubeDynamic = function setTextureCubeDynamic(texture, slot) {
    state.activeTexture(_gl.TEXTURE0 + slot);
    state.bindTexture(_gl.TEXTURE_CUBE_MAP, properties.get(texture).__webglTexture);
};
setTextureParameters = function setTextureParameters(textureType, texture, isPowerOfTwoImage) {
    var extension;
    if (isPowerOfTwoImage) {
        _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, paramThreeToGL(texture.wrapS));
        _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, paramThreeToGL(texture.wrapT));
        _gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, paramThreeToGL(texture.magFilter));
        _gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, paramThreeToGL(texture.minFilter));
    } else {
        _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE);
        _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE);
        if (texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping) {
            console.warn('THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.', texture);
        }
        _gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, filterFallback(texture.magFilter));
        _gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, filterFallback(texture.minFilter));
        if (texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter) {
            console.warn('THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.', texture);
        }
    }
    extension = extensions.get('EXT_texture_filter_anisotropic');
    if (extension) {
        if (texture.type === FloatType && extensions.get('OES_texture_float_linear') === null)
            return;
        if (texture.type === HalfFloatType && extensions.get('OES_texture_half_float_linear') === null)
            return;
        if (texture.anisotropy > 1 || properties.get(texture).__currentAnisotropy) {
            _gl.texParameterf(textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(texture.anisotropy, capabilities.getMaxAnisotropy()));
            properties.get(texture).__currentAnisotropy = texture.anisotropy;
        }
    }
};
uploadTexture = function uploadTexture(textureProperties, texture, slot) {
    if (textureProperties.__webglInit === undefined) {
        textureProperties.__webglInit = true;
        texture.addEventListener('dispose', onTextureDispose);
        textureProperties.__webglTexture = _gl.createTexture();
        _infoMemory.textures++;
    }
    state.activeTexture(_gl.TEXTURE0 + slot);
    state.bindTexture(_gl.TEXTURE_2D, textureProperties.__webglTexture);
    _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);
    _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha);
    _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, texture.unpackAlignment);
    var image = clampToMaxSize(texture.image, capabilities.maxTextureSize);
    if (textureNeedsPowerOfTwo(texture) && isPowerOfTwo(image) === false) {
        image = makePowerOfTwo(image);
    }
    var isPowerOfTwoImage = isPowerOfTwo(image), glFormat = paramThreeToGL(texture.format), glType = paramThreeToGL(texture.type);
    setTextureParameters(_gl.TEXTURE_2D, texture, isPowerOfTwoImage);
    var mipmap, mipmaps = texture.mipmaps;
    if (texture && texture.isDepthTexture) {
        var internalFormat = _gl.DEPTH_COMPONENT;
        if (texture.type === FloatType) {
            if (!_isWebGL2)
                throw new Error('Float Depth Texture only supported in WebGL2.0');
            internalFormat = _gl.DEPTH_COMPONENT32F;
        } else if (_isWebGL2) {
            internalFormat = _gl.DEPTH_COMPONENT16;
        }
        if (texture.format === DepthStencilFormat) {
            internalFormat = _gl.DEPTH_STENCIL;
        }
        state.texImage2D(_gl.TEXTURE_2D, 0, internalFormat, image.width, image.height, 0, glFormat, glType, null);
    } else if (texture && texture.isDataTexture) {
        if (mipmaps.length > 0 && isPowerOfTwoImage) {
            for (var i = 0, il = mipmaps.length; i < il; i++) {
                mipmap = mipmaps[i];
                state.texImage2D(_gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
            }
            texture.generateMipmaps = false;
        } else {
            state.texImage2D(_gl.TEXTURE_2D, 0, glFormat, image.width, image.height, 0, glFormat, glType, image.data);
        }
    } else if (texture && texture.isCompressedTexture) {
        for (var i = 0, il = mipmaps.length; i < il; i++) {
            mipmap = mipmaps[i];
            if (texture.format !== RGBAFormat && texture.format !== RGBFormat) {
                if (state.getCompressedTextureFormats().indexOf(glFormat) > -1) {
                    state.compressedTexImage2D(_gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, mipmap.data);
                } else {
                    console.warn('THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()');
                }
            } else {
                state.texImage2D(_gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
            }
        }
    } else {
        if (mipmaps.length > 0 && isPowerOfTwoImage) {
            for (var i = 0, il = mipmaps.length; i < il; i++) {
                mipmap = mipmaps[i];
                state.texImage2D(_gl.TEXTURE_2D, i, glFormat, glFormat, glType, mipmap);
            }
            texture.generateMipmaps = false;
        } else {
            state.texImage2D(_gl.TEXTURE_2D, 0, glFormat, glFormat, glType, image);
        }
    }
    if (texture.generateMipmaps && isPowerOfTwoImage)
        _gl.generateMipmap(_gl.TEXTURE_2D);
    textureProperties.__version = texture.version;
    if (texture.onUpdate)
        texture.onUpdate(texture);
};
setupFrameBufferTexture = function setupFrameBufferTexture(framebuffer, renderTarget, attachment, textureTarget) {
    var glFormat = paramThreeToGL(renderTarget.texture.format);
    var glType = paramThreeToGL(renderTarget.texture.type);
    state.texImage2D(textureTarget, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null);
    _gl.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
    _gl.framebufferTexture2D(_gl.FRAMEBUFFER, attachment, textureTarget, properties.get(renderTarget.texture).__webglTexture, 0);
    _gl.bindFramebuffer(_gl.FRAMEBUFFER, null);
};
setupRenderBufferStorage = function setupRenderBufferStorage(renderbuffer, renderTarget) {
    _gl.bindRenderbuffer(_gl.RENDERBUFFER, renderbuffer);
    if (renderTarget.depthBuffer && !renderTarget.stencilBuffer) {
        _gl.renderbufferStorage(_gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height);
        _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer);
    } else if (renderTarget.depthBuffer && renderTarget.stencilBuffer) {
        _gl.renderbufferStorage(_gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height);
        _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer);
    } else {
        _gl.renderbufferStorage(_gl.RENDERBUFFER, _gl.RGBA4, renderTarget.width, renderTarget.height);
    }
    _gl.bindRenderbuffer(_gl.RENDERBUFFER, null);
};
setupDepthTexture = function setupDepthTexture(framebuffer, renderTarget) {
    var isCube = renderTarget && renderTarget.isWebGLRenderTargetCube;
    if (isCube)
        throw new Error('Depth Texture with cube render targets is not supported!');
    _gl.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
    if (!(renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture)) {
        throw new Error('renderTarget.depthTexture must be an instance of THREE.DepthTexture');
    }
    if (!properties.get(renderTarget.depthTexture).__webglTexture || renderTarget.depthTexture.image.width !== renderTarget.width || renderTarget.depthTexture.image.height !== renderTarget.height) {
        renderTarget.depthTexture.image.width = renderTarget.width;
        renderTarget.depthTexture.image.height = renderTarget.height;
        renderTarget.depthTexture.needsUpdate = true;
    }
    setTexture2D(renderTarget.depthTexture, 0);
    var webglDepthTexture = properties.get(renderTarget.depthTexture).__webglTexture;
    if (renderTarget.depthTexture.format === DepthFormat) {
        _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0);
    } else if (renderTarget.depthTexture.format === DepthStencilFormat) {
        _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0);
    } else {
        throw new Error('Unknown depthTexture format');
    }
};
setupDepthRenderbuffer = function setupDepthRenderbuffer(renderTarget) {
    var renderTargetProperties = properties.get(renderTarget);
    var isCube = renderTarget && renderTarget.isWebGLRenderTargetCube;
    if (renderTarget.depthTexture) {
        if (isCube)
            throw new Error('target.depthTexture not supported in Cube render targets');
        setupDepthTexture(renderTargetProperties.__webglFramebuffer, renderTarget);
    } else {
        if (isCube) {
            renderTargetProperties.__webglDepthbuffer = [];
            for (var i = 0; i < 6; i++) {
                _gl.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[i]);
                renderTargetProperties.__webglDepthbuffer[i] = _gl.createRenderbuffer();
                setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer[i], renderTarget);
            }
        } else {
            _gl.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);
            renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
            setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer, renderTarget);
        }
    }
    _gl.bindFramebuffer(_gl.FRAMEBUFFER, null);
};
setupRenderTarget = function setupRenderTarget(renderTarget) {
    var renderTargetProperties = properties.get(renderTarget);
    var textureProperties = properties.get(renderTarget.texture);
    renderTarget.addEventListener('dispose', onRenderTargetDispose);
    textureProperties.__webglTexture = _gl.createTexture();
    _infoMemory.textures++;
    var isCube = renderTarget && renderTarget.isWebGLRenderTargetCube;
    var isTargetPowerOfTwo = isPowerOfTwo(renderTarget);
    if (isCube) {
        renderTargetProperties.__webglFramebuffer = [];
        for (var i = 0; i < 6; i++) {
            renderTargetProperties.__webglFramebuffer[i] = _gl.createFramebuffer();
        }
    } else {
        renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();
    }
    if (isCube) {
        state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture);
        setTextureParameters(_gl.TEXTURE_CUBE_MAP, renderTarget.texture, isTargetPowerOfTwo);
        for (var i = 0; i < 6; i++) {
            setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i], renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i);
        }
        if (renderTarget.texture.generateMipmaps && isTargetPowerOfTwo)
            _gl.generateMipmap(_gl.TEXTURE_CUBE_MAP);
        state.bindTexture(_gl.TEXTURE_CUBE_MAP, null);
    } else {
        state.bindTexture(_gl.TEXTURE_2D, textureProperties.__webglTexture);
        setTextureParameters(_gl.TEXTURE_2D, renderTarget.texture, isTargetPowerOfTwo);
        setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D);
        if (renderTarget.texture.generateMipmaps && isTargetPowerOfTwo)
            _gl.generateMipmap(_gl.TEXTURE_2D);
        state.bindTexture(_gl.TEXTURE_2D, null);
    }
    if (renderTarget.depthBuffer) {
        setupDepthRenderbuffer(renderTarget);
    }
};
updateRenderTargetMipmap = function updateRenderTargetMipmap(renderTarget) {
    var texture = renderTarget.texture;
    if (texture.generateMipmaps && isPowerOfTwo(renderTarget) && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter) {
        var target = renderTarget && renderTarget.isWebGLRenderTargetCube ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D;
        var webglTexture = properties.get(texture).__webglTexture;
        state.bindTexture(target, webglTexture);
        _gl.generateMipmap(target);
        state.bindTexture(target, null);
    }
};
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
_gl = arguments[0], extensions = arguments[1], state = arguments[2], properties = arguments[3], capabilities = arguments[4], paramThreeToGL = arguments[5], info = arguments[6];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
_infoMemory = info.memory;
_isWebGL2 = typeof WebGL2RenderingContext !== 'undefined' && _gl instanceof WebGL2RenderingContext;
this.setTexture2D = setTexture2D;
this.setTextureCube = setTextureCube;
this.setTextureCubeDynamic = setTextureCubeDynamic;
this.setupRenderTarget = setupRenderTarget;
this.updateRenderTargetMipmap = updateRenderTargetMipmap;});
    Vector4 = ($__.fs.Vector4_51 = function Vector4(x, y, z, w) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
x = arguments[0], y = arguments[1], z = arguments[2], w = arguments[3];
switch (vvv_switch) {
case 0:
case 1:
case 2:
case 3:
case 4:
case 5:
case 6:
case 7:
case 8:
case 9:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(0 <= vvv_switch && vvv_switch <= 9);
    this.x = (x, 0);
    this.y = (y, 0);
    this.z = z;
    this.w = (w !== undefined, w);
    return;
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.x = x || 0;
this.y = y || 0;
this.z = z || 0;
this.w = w !== undefined ? w : 1;});
    WebGLState = ($__.fs.WebGLState_52 = function WebGLState(gl, extensions, paramThreeToGL) {
var vvv_return, vvv_switch, ColorBuffer, DepthBuffer, StencilBuffer, colorBuffer, depthBuffer, stencilBuffer, maxVertexAttributes, newAttributes, enabledAttributes, attributeDivisors, capabilities, compressedTextureFormats, currentBlending, currentBlendEquation, currentBlendSrc, currentBlendDst, currentBlendEquationAlpha, currentBlendSrcAlpha, currentBlendDstAlpha, currentPremultipledAlpha, currentFlipSided, currentCullFace, currentLineWidth, currentPolygonOffsetFactor, currentPolygonOffsetUnits, currentScissorTest, maxTextures, currentTextureSlot, currentBoundTextures, currentScissor, currentViewport, createTexture, emptyTextures, init, initAttributes, enableAttribute, enableAttributeAndDivisor, disableUnusedAttributes, enable, disable, getCompressedTextureFormats, setBlending, setColorWrite, setDepthTest, setDepthWrite, setDepthFunc, setStencilTest, setStencilWrite, setStencilFunc, setStencilOp, setFlipSided, setCullFace, setLineWidth, setPolygonOffset, getScissorTest, setScissorTest, activeTexture, bindTexture, compressedTexImage2D, texImage2D, clearColor, clearDepth, clearStencil, scissor, viewport, reset;
ColorBuffer = function ColorBuffer() {
    var locked = false;
    var color = new Vector4();
    var currentColorMask = null;
    var currentColorClear = new Vector4();
    return {
        setMask: function (colorMask) {
            if (currentColorMask !== colorMask && !locked) {
                gl.colorMask(colorMask, colorMask, colorMask, colorMask);
                currentColorMask = colorMask;
            }
        },
        setLocked: function (lock) {
            locked = lock;
        },
        setClear: function (r, g, b, a) {
            color.set(r, g, b, a);
            if (currentColorClear.equals(color) === false) {
                gl.clearColor(r, g, b, a);
                currentColorClear.copy(color);
            }
        },
        reset: function () {
            locked = false;
            currentColorMask = null;
            currentColorClear.set(0, 0, 0, 1);
        }
    };
};
DepthBuffer = function DepthBuffer() {
    var locked = false;
    var currentDepthMask = null;
    var currentDepthFunc = null;
    var currentDepthClear = null;
    return {
        setTest: function (depthTest) {
            if (depthTest) {
                enable(gl.DEPTH_TEST);
            } else {
                disable(gl.DEPTH_TEST);
            }
        },
        setMask: function (depthMask) {
            if (currentDepthMask !== depthMask && !locked) {
                gl.depthMask(depthMask);
                currentDepthMask = depthMask;
            }
        },
        setFunc: function (depthFunc) {
            if (currentDepthFunc !== depthFunc) {
                if (depthFunc) {
                    switch (depthFunc) {
                    case NeverDepth:
                        gl.depthFunc(gl.NEVER);
                        break;
                    case AlwaysDepth:
                        gl.depthFunc(gl.ALWAYS);
                        break;
                    case LessDepth:
                        gl.depthFunc(gl.LESS);
                        break;
                    case LessEqualDepth:
                        gl.depthFunc(gl.LEQUAL);
                        break;
                    case EqualDepth:
                        gl.depthFunc(gl.EQUAL);
                        break;
                    case GreaterEqualDepth:
                        gl.depthFunc(gl.GEQUAL);
                        break;
                    case GreaterDepth:
                        gl.depthFunc(gl.GREATER);
                        break;
                    case NotEqualDepth:
                        gl.depthFunc(gl.NOTEQUAL);
                        break;
                    default:
                        gl.depthFunc(gl.LEQUAL);
                    }
                } else {
                    gl.depthFunc(gl.LEQUAL);
                }
                currentDepthFunc = depthFunc;
            }
        },
        setLocked: function (lock) {
            locked = lock;
        },
        setClear: function (depth) {
            if (currentDepthClear !== depth) {
                gl.clearDepth(depth);
                currentDepthClear = depth;
            }
        },
        reset: function () {
            locked = false;
            currentDepthMask = null;
            currentDepthFunc = null;
            currentDepthClear = null;
        }
    };
};
StencilBuffer = function StencilBuffer() {
    var locked = false;
    var currentStencilMask = null;
    var currentStencilFunc = null;
    var currentStencilRef = null;
    var currentStencilFuncMask = null;
    var currentStencilFail = null;
    var currentStencilZFail = null;
    var currentStencilZPass = null;
    var currentStencilClear = null;
    return {
        setTest: function (stencilTest) {
            if (stencilTest) {
                enable(gl.STENCIL_TEST);
            } else {
                disable(gl.STENCIL_TEST);
            }
        },
        setMask: function (stencilMask) {
            if (currentStencilMask !== stencilMask && !locked) {
                gl.stencilMask(stencilMask);
                currentStencilMask = stencilMask;
            }
        },
        setFunc: function (stencilFunc, stencilRef, stencilMask) {
            if (currentStencilFunc !== stencilFunc || currentStencilRef !== stencilRef || currentStencilFuncMask !== stencilMask) {
                gl.stencilFunc(stencilFunc, stencilRef, stencilMask);
                currentStencilFunc = stencilFunc;
                currentStencilRef = stencilRef;
                currentStencilFuncMask = stencilMask;
            }
        },
        setOp: function (stencilFail, stencilZFail, stencilZPass) {
            if (currentStencilFail !== stencilFail || currentStencilZFail !== stencilZFail || currentStencilZPass !== stencilZPass) {
                gl.stencilOp(stencilFail, stencilZFail, stencilZPass);
                currentStencilFail = stencilFail;
                currentStencilZFail = stencilZFail;
                currentStencilZPass = stencilZPass;
            }
        },
        setLocked: function (lock) {
            locked = lock;
        },
        setClear: function (stencil) {
            if (currentStencilClear !== stencil) {
                gl.clearStencil(stencil);
                currentStencilClear = stencil;
            }
        },
        reset: function () {
            locked = false;
            currentStencilMask = null;
            currentStencilFunc = null;
            currentStencilRef = null;
            currentStencilFuncMask = null;
            currentStencilFail = null;
            currentStencilZFail = null;
            currentStencilZPass = null;
            currentStencilClear = null;
        }
    };
};
createTexture = function createTexture(type, target, count) {
    var data = new Uint8Array(4);
    var texture = gl.createTexture();
    gl.bindTexture(type, texture);
    gl.texParameteri(type, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(type, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    for (var i = 0; i < count; i++) {
        gl.texImage2D(target + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);
    }
    return texture;
};
init = function init() {
    clearColor(0, 0, 0, 1);
    clearDepth(1);
    clearStencil(0);
    enable(gl.DEPTH_TEST);
    setDepthFunc(LessEqualDepth);
    setFlipSided(false);
    setCullFace(CullFaceBack);
    enable(gl.CULL_FACE);
    enable(gl.BLEND);
    setBlending(NormalBlending);
};
initAttributes = function initAttributes() {
    for (var i = 0, l = newAttributes.length; i < l; i++) {
        newAttributes[i] = 0;
    }
};
enableAttribute = function enableAttribute(attribute) {
    newAttributes[attribute] = 1;
    if (enabledAttributes[attribute] === 0) {
        gl.enableVertexAttribArray(attribute);
        enabledAttributes[attribute] = 1;
    }
    if (attributeDivisors[attribute] !== 0) {
        var extension = extensions.get('ANGLE_instanced_arrays');
        extension.vertexAttribDivisorANGLE(attribute, 0);
        attributeDivisors[attribute] = 0;
    }
};
enableAttributeAndDivisor = function enableAttributeAndDivisor(attribute, meshPerAttribute, extension) {
    newAttributes[attribute] = 1;
    if (enabledAttributes[attribute] === 0) {
        gl.enableVertexAttribArray(attribute);
        enabledAttributes[attribute] = 1;
    }
    if (attributeDivisors[attribute] !== meshPerAttribute) {
        extension.vertexAttribDivisorANGLE(attribute, meshPerAttribute);
        attributeDivisors[attribute] = meshPerAttribute;
    }
};
disableUnusedAttributes = function disableUnusedAttributes() {
    for (var i = 0, l = enabledAttributes.length; i !== l; ++i) {
        if (enabledAttributes[i] !== newAttributes[i]) {
            gl.disableVertexAttribArray(i);
            enabledAttributes[i] = 0;
        }
    }
};
enable = function enable(id) {
    if (capabilities[id] !== true) {
        gl.enable(id);
        capabilities[id] = true;
    }
};
disable = function disable(id) {
    if (capabilities[id] !== false) {
        gl.disable(id);
        capabilities[id] = false;
    }
};
getCompressedTextureFormats = function getCompressedTextureFormats() {
    if (compressedTextureFormats === null) {
        compressedTextureFormats = [];
        if (extensions.get('WEBGL_compressed_texture_pvrtc') || extensions.get('WEBGL_compressed_texture_s3tc') || extensions.get('WEBGL_compressed_texture_etc1')) {
            var formats = gl.getParameter(gl.COMPRESSED_TEXTURE_FORMATS);
            for (var i = 0; i < formats.length; i++) {
                compressedTextureFormats.push(formats[i]);
            }
        }
    }
    return compressedTextureFormats;
};
setBlending = function setBlending(blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha) {
    if (blending !== NoBlending) {
        enable(gl.BLEND);
    } else {
        disable(gl.BLEND);
        currentBlending = blending;
        return;
    }
    if (blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha) {
        if (blending === AdditiveBlending) {
            if (premultipliedAlpha) {
                gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
                gl.blendFuncSeparate(gl.ONE, gl.ONE, gl.ONE, gl.ONE);
            } else {
                gl.blendEquation(gl.FUNC_ADD);
                gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
            }
        } else if (blending === SubtractiveBlending) {
            if (premultipliedAlpha) {
                gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
                gl.blendFuncSeparate(gl.ZERO, gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ONE_MINUS_SRC_ALPHA);
            } else {
                gl.blendEquation(gl.FUNC_ADD);
                gl.blendFunc(gl.ZERO, gl.ONE_MINUS_SRC_COLOR);
            }
        } else if (blending === MultiplyBlending) {
            if (premultipliedAlpha) {
                gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
                gl.blendFuncSeparate(gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA);
            } else {
                gl.blendEquation(gl.FUNC_ADD);
                gl.blendFunc(gl.ZERO, gl.SRC_COLOR);
            }
        } else {
            if (premultipliedAlpha) {
                gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
                gl.blendFuncSeparate(gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
            } else {
                gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
                gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
            }
        }
        currentBlending = blending;
        currentPremultipledAlpha = premultipliedAlpha;
    }
    if (blending === CustomBlending) {
        blendEquationAlpha = blendEquationAlpha || blendEquation;
        blendSrcAlpha = blendSrcAlpha || blendSrc;
        blendDstAlpha = blendDstAlpha || blendDst;
        if (blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha) {
            gl.blendEquationSeparate(paramThreeToGL(blendEquation), paramThreeToGL(blendEquationAlpha));
            currentBlendEquation = blendEquation;
            currentBlendEquationAlpha = blendEquationAlpha;
        }
        if (blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha) {
            gl.blendFuncSeparate(paramThreeToGL(blendSrc), paramThreeToGL(blendDst), paramThreeToGL(blendSrcAlpha), paramThreeToGL(blendDstAlpha));
            currentBlendSrc = blendSrc;
            currentBlendDst = blendDst;
            currentBlendSrcAlpha = blendSrcAlpha;
            currentBlendDstAlpha = blendDstAlpha;
        }
    } else {
        currentBlendEquation = null;
        currentBlendSrc = null;
        currentBlendDst = null;
        currentBlendEquationAlpha = null;
        currentBlendSrcAlpha = null;
        currentBlendDstAlpha = null;
    }
};
setColorWrite = function setColorWrite(colorWrite) {
    colorBuffer.setMask(colorWrite);
};
setDepthTest = function setDepthTest(depthTest) {
    depthBuffer.setTest(depthTest);
};
setDepthWrite = function setDepthWrite(depthWrite) {
    depthBuffer.setMask(depthWrite);
};
setDepthFunc = function setDepthFunc(depthFunc) {
    depthBuffer.setFunc(depthFunc);
};
setStencilTest = function setStencilTest(stencilTest) {
    stencilBuffer.setTest(stencilTest);
};
setStencilWrite = function setStencilWrite(stencilWrite) {
    stencilBuffer.setMask(stencilWrite);
};
setStencilFunc = function setStencilFunc(stencilFunc, stencilRef, stencilMask) {
    stencilBuffer.setFunc(stencilFunc, stencilRef, stencilMask);
};
setStencilOp = function setStencilOp(stencilFail, stencilZFail, stencilZPass) {
    stencilBuffer.setOp(stencilFail, stencilZFail, stencilZPass);
};
setFlipSided = function setFlipSided(flipSided) {
    if (currentFlipSided !== flipSided) {
        if (flipSided) {
            gl.frontFace(gl.CW);
        } else {
            gl.frontFace(gl.CCW);
        }
        currentFlipSided = flipSided;
    }
};
setCullFace = function setCullFace(cullFace) {
    if (cullFace !== CullFaceNone) {
        enable(gl.CULL_FACE);
        if (cullFace !== currentCullFace) {
            if (cullFace === CullFaceBack) {
                gl.cullFace(gl.BACK);
            } else if (cullFace === CullFaceFront) {
                gl.cullFace(gl.FRONT);
            } else {
                gl.cullFace(gl.FRONT_AND_BACK);
            }
        }
    } else {
        disable(gl.CULL_FACE);
    }
    currentCullFace = cullFace;
};
setLineWidth = function setLineWidth(width) {
    if (width !== currentLineWidth) {
        gl.lineWidth(width);
        currentLineWidth = width;
    }
};
setPolygonOffset = function setPolygonOffset(polygonOffset, factor, units) {
    if (polygonOffset) {
        enable(gl.POLYGON_OFFSET_FILL);
        if (currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units) {
            gl.polygonOffset(factor, units);
            currentPolygonOffsetFactor = factor;
            currentPolygonOffsetUnits = units;
        }
    } else {
        disable(gl.POLYGON_OFFSET_FILL);
    }
};
getScissorTest = function getScissorTest() {
    return currentScissorTest;
};
setScissorTest = function setScissorTest(scissorTest) {
    currentScissorTest = scissorTest;
    if (scissorTest) {
        enable(gl.SCISSOR_TEST);
    } else {
        disable(gl.SCISSOR_TEST);
    }
};
activeTexture = function activeTexture(webglSlot) {
    if (webglSlot === undefined)
        webglSlot = gl.TEXTURE0 + maxTextures - 1;
    if (currentTextureSlot !== webglSlot) {
        gl.activeTexture(webglSlot);
        currentTextureSlot = webglSlot;
    }
};
bindTexture = function bindTexture(webglType, webglTexture) {
    if (currentTextureSlot === null) {
        activeTexture();
    }
    var boundTexture = currentBoundTextures[currentTextureSlot];
    if (boundTexture === undefined) {
        boundTexture = {
            type: undefined,
            texture: undefined
        };
        currentBoundTextures[currentTextureSlot] = boundTexture;
    }
    if (boundTexture.type !== webglType || boundTexture.texture !== webglTexture) {
        gl.bindTexture(webglType, webglTexture || emptyTextures[webglType]);
        boundTexture.type = webglType;
        boundTexture.texture = webglTexture;
    }
};
compressedTexImage2D = function compressedTexImage2D() {
    try {
        gl.compressedTexImage2D.apply(gl, arguments);
    } catch (error) {
        console.error(error);
    }
};
texImage2D = function texImage2D() {
    try {
        gl.texImage2D.apply(gl, arguments);
    } catch (error) {
        console.error(error);
    }
};
clearColor = function clearColor(r, g, b, a) {
    colorBuffer.setClear(r, g, b, a);
};
clearDepth = function clearDepth(depth) {
    depthBuffer.setClear(depth);
};
clearStencil = function clearStencil(stencil) {
    stencilBuffer.setClear(stencil);
};
scissor = function scissor(scissor) {
    if (currentScissor.equals(scissor) === false) {
        gl.scissor(scissor.x, scissor.y, scissor.z, scissor.w);
        currentScissor.copy(scissor);
    }
};
viewport = function viewport(viewport) {
    if (currentViewport.equals(viewport) === false) {
        gl.viewport(viewport.x, viewport.y, viewport.z, viewport.w);
        currentViewport.copy(viewport);
    }
};
reset = function reset() {
    for (var i = 0; i < enabledAttributes.length; i++) {
        if (enabledAttributes[i] === 1) {
            gl.disableVertexAttribArray(i);
            enabledAttributes[i] = 0;
        }
    }
    capabilities = {};
    compressedTextureFormats = null;
    currentTextureSlot = null;
    currentBoundTextures = {};
    currentBlending = null;
    currentFlipSided = null;
    currentCullFace = null;
    colorBuffer.reset();
    depthBuffer.reset();
    stencilBuffer.reset();
};
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
gl = arguments[0], extensions = arguments[1], paramThreeToGL = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
colorBuffer = new ColorBuffer();
depthBuffer = new DepthBuffer();
stencilBuffer = new StencilBuffer();
maxVertexAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
newAttributes = new Uint8Array(maxVertexAttributes);
enabledAttributes = new Uint8Array(maxVertexAttributes);
attributeDivisors = new Uint8Array(maxVertexAttributes);
capabilities = {};
compressedTextureFormats = null;
currentBlending = null;
currentBlendEquation = null;
currentBlendSrc = null;
currentBlendDst = null;
currentBlendEquationAlpha = null;
currentBlendSrcAlpha = null;
currentBlendDstAlpha = null;
currentPremultipledAlpha = false;
currentFlipSided = null;
currentCullFace = null;
currentLineWidth = null;
currentPolygonOffsetFactor = null;
currentPolygonOffsetUnits = null;
currentScissorTest = null;
maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
currentTextureSlot = null;
currentBoundTextures = {};
currentScissor = new Vector4();
currentViewport = new Vector4();
emptyTextures = {};
emptyTextures[gl.TEXTURE_2D] = createTexture(gl.TEXTURE_2D, gl.TEXTURE_2D, 1);
emptyTextures[gl.TEXTURE_CUBE_MAP] = createTexture(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_CUBE_MAP_POSITIVE_X, 6);
return {
    buffers: {
        color: colorBuffer,
        depth: depthBuffer,
        stencil: stencilBuffer
    },
    init: init,
    initAttributes: initAttributes,
    enableAttribute: enableAttribute,
    enableAttributeAndDivisor: enableAttributeAndDivisor,
    disableUnusedAttributes: disableUnusedAttributes,
    enable: enable,
    disable: disable,
    getCompressedTextureFormats: getCompressedTextureFormats,
    setBlending: setBlending,
    setColorWrite: setColorWrite,
    setDepthTest: setDepthTest,
    setDepthWrite: setDepthWrite,
    setDepthFunc: setDepthFunc,
    setStencilTest: setStencilTest,
    setStencilWrite: setStencilWrite,
    setStencilFunc: setStencilFunc,
    setStencilOp: setStencilOp,
    setFlipSided: setFlipSided,
    setCullFace: setCullFace,
    setLineWidth: setLineWidth,
    setPolygonOffset: setPolygonOffset,
    getScissorTest: getScissorTest,
    setScissorTest: setScissorTest,
    activeTexture: activeTexture,
    bindTexture: bindTexture,
    compressedTexImage2D: compressedTexImage2D,
    texImage2D: texImage2D,
    clearColor: clearColor,
    clearDepth: clearDepth,
    clearStencil: clearStencil,
    scissor: scissor,
    viewport: viewport,
    reset: reset
};});
    WebGLRenderTarget = ($__.fs.WebGLRenderTarget_53 = function WebGLRenderTarget(width, height, options) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
width = arguments[0], height = arguments[1], options = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.uuid = exports.Math.generateUUID();
this.width = width;
this.height = height;
this.scissor = new Vector4(0, 0, width, height);
this.scissorTest = false;
this.viewport = new Vector4(0, 0, width, height);
options = options || {};
if (options.minFilter === undefined)
    options.minFilter = LinearFilter;
this.texture = new Texture(undefined, undefined, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding);
this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;
this.depthTexture = options.depthTexture !== undefined ? options.depthTexture : null;});
    Material = ($__.fs.Material_54 = function Material() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
Object.defineProperty(this, 'id', {
    value: MaterialIdCount()
});
this.uuid = exports.Math.generateUUID();
this.name = '';
this.type = 'Material';
this.fog = true;
this.lights = true;
this.blending = NormalBlending;
this.side = FrontSide;
this.shading = SmoothShading;
this.vertexColors = NoColors;
this.opacity = 1;
this.transparent = false;
this.blendSrc = SrcAlphaFactor;
this.blendDst = OneMinusSrcAlphaFactor;
this.blendEquation = AddEquation;
this.blendSrcAlpha = null;
this.blendDstAlpha = null;
this.blendEquationAlpha = null;
this.depthFunc = LessEqualDepth;
this.depthTest = true;
this.depthWrite = true;
this.clippingPlanes = null;
this.clipShadows = false;
this.colorWrite = true;
this.precision = null;
this.polygonOffset = false;
this.polygonOffsetFactor = 0;
this.polygonOffsetUnits = 0;
this.alphaTest = 0;
this.premultipliedAlpha = false;
this.overdraw = 0;
this.visible = true;
this._needsUpdate = true;});
    MaterialIdCount = ($__.fs.MaterialIdCount_55 = function MaterialIdCount() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return count$1++;});
    ShaderMaterial = ($__.fs.ShaderMaterial_56 = function ShaderMaterial(parameters) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
parameters = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
Material.call(this);
this.type = 'ShaderMaterial';
this.defines = {};
this.uniforms = {};
this.vertexShader = 'void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}';
this.fragmentShader = 'void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}';
this.linewidth = 1;
this.wireframe = false;
this.wireframeLinewidth = 1;
this.fog = false;
this.lights = false;
this.clipping = false;
this.skinning = false;
this.morphTargets = false;
this.morphNormals = false;
this.extensions = {
    derivatives: false,
    fragDepth: false,
    drawBuffers: false,
    shaderTextureLOD: false
};
this.defaultAttributeValues = {
    'color': [
        1,
        1,
        1
    ],
    'uv': [
        0,
        0
    ],
    'uv2': [
        0,
        0
    ]
};
this.index0AttributeName = undefined;
if (parameters !== undefined) {
    if (parameters.attributes !== undefined) {
        console.error('THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.');
    }
    this.setValues(parameters);
}});
    Color = ($__.fs.Color_57 = function Color(r, g, b) {
var vvv_return, vvv_switch, vvv_tmp0;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
r = arguments[0], g = arguments[1], b = arguments[2];
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    g === undefined, b === undefined;
    return vvv_tmp0 = this, 'set', $__.fs.J$__v494107025_806_603.call(vvv_tmp0, r, 0, true, $__.uid);
case 1:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 1);
    g === undefined, b === undefined;
    return vvv_tmp0 = this, 'set', $__.fs.J$__v494107025_806_603.call(vvv_tmp0, r, 1, true, $__.uid);
case 2:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 2);
    g === undefined, b === undefined;
    return vvv_tmp0 = this, 'set', $__.fs.J$__v494107025_806_603.call(vvv_tmp0, r, 2, true, $__.uid);
case 3:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 3);
    g === undefined;
    return vvv_tmp0 = this, 'setRGB', $__.fs.J$__v494107025_812_606.call(vvv_tmp0, r, g, b, 0, true, $__.uid);
case 4:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 4);
    g === undefined;
    return vvv_tmp0 = this, 'setRGB', $__.fs.J$__v494107025_812_606.call(vvv_tmp0, r, g, b, 1, true, $__.uid);
case 5:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 5);
    g === undefined, b === undefined;
    return vvv_tmp0 = this, 'set', $__.fs.J$__v494107025_806_603.call(vvv_tmp0, r, 3, true, $__.uid);
case 6:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 6);
    g === undefined;
    return vvv_tmp0 = this, 'setRGB', $__.fs.J$__v494107025_812_606.call(vvv_tmp0, r, g, b, 2, true, $__.uid);
case 7:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 7);
    g === undefined;
    return vvv_tmp0 = this, 'setRGB', $__.fs.J$__v494107025_812_606.call(vvv_tmp0, r, g, b, 3, true, $__.uid);
case 8:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 8);
    g === undefined;
    return vvv_tmp0 = this, 'setRGB', $__.fs.J$__v494107025_812_606.call(vvv_tmp0, r, g, b, 4, true, $__.uid);
case 9:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 9);
    g === undefined, b === undefined;
    return vvv_tmp0 = this, 'set', $__.fs.J$__v494107025_806_603.call(vvv_tmp0, r, 4, true, $__.uid);
case 10:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 10);
    g === undefined, b === undefined;
    return vvv_tmp0 = this, 'set', $__.fs.J$__v494107025_806_603.call(vvv_tmp0, r, 5, true, $__.uid);
case 11:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 11);
    g === undefined;
    return vvv_tmp0 = this, 'setRGB', $__.fs.J$__v494107025_812_606.call(vvv_tmp0, r, g, b, 5, true, $__.uid);
case 12:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 12);
    g === undefined;
    return vvv_tmp0 = this, 'setRGB', $__.fs.J$__v494107025_812_606.call(vvv_tmp0, r, g, b, 6, true, $__.uid);
case 13:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 13);
    g === undefined;
    return vvv_tmp0 = this, 'setRGB', $__.fs.J$__v494107025_812_606.call(vvv_tmp0, r, g, b, 7, true, $__.uid);
case 14:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 14);
    g === undefined;
    return vvv_tmp0 = this, 'setRGB', $__.fs.J$__v494107025_812_606.call(vvv_tmp0, r, g, b, 8, true, $__.uid);
case 15:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 15);
    g === undefined, b === undefined;
    return vvv_tmp0 = this, 'set', $__.fs.J$__v494107025_806_603.call(vvv_tmp0, r, 6, true, $__.uid);
case 16:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 16);
    g === undefined;
    return vvv_tmp0 = this, 'setRGB', $__.fs.J$__v494107025_812_606.call(vvv_tmp0, r, g, b, 9, true, $__.uid);
case 17:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 17);
    g === undefined;
    return vvv_tmp0 = this, 'setRGB', $__.fs.J$__v494107025_812_606.call(vvv_tmp0, r, g, b, 10, true, $__.uid);
case 18:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 18);
    g === undefined;
    return vvv_tmp0 = this, 'setRGB', $__.fs.J$__v494107025_812_606.call(vvv_tmp0, r, g, b, 11, true, $__.uid);
case 19:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 19);
    g === undefined;
    return vvv_tmp0 = this, 'setRGB', $__.fs.J$__v494107025_812_606.call(vvv_tmp0, r, g, b, 12, true, $__.uid);
case 20:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 20);
    g === undefined;
    return vvv_tmp0 = this, 'setRGB', $__.fs.J$__v494107025_812_606.call(vvv_tmp0, r, g, b, 13, true, $__.uid);
case 21:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 21);
    g === undefined;
    return vvv_tmp0 = this, 'setRGB', $__.fs.J$__v494107025_812_606.call(vvv_tmp0, r, g, b, 14, true, $__.uid);
case 22:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 22);
    g === undefined;
    return vvv_tmp0 = this, 'setRGB', $__.fs.J$__v494107025_812_606.call(vvv_tmp0, r, g, b, 15, true, $__.uid);
case 23:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 23);
    g === undefined;
    return vvv_tmp0 = this, 'setRGB', $__.fs.J$__v494107025_812_606.call(vvv_tmp0, r, g, b, 16, true, $__.uid);
case 24:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 24);
    g === undefined;
    return vvv_tmp0 = this, 'setRGB', $__.fs.J$__v494107025_812_606.call(vvv_tmp0, r, g, b, 17, true, $__.uid);
case 25:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 25);
    g === undefined;
    return vvv_tmp0 = this, 'setRGB', $__.fs.J$__v494107025_812_606.call(vvv_tmp0, r, g, b, 18, true, $__.uid);
case 26:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 26);
    g === undefined;
    return vvv_tmp0 = this, 'setRGB', $__.fs.J$__v494107025_812_606.call(vvv_tmp0, r, g, b, 19, true, $__.uid);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (g === undefined && b === undefined) {
    return this.set(r);
}
return this.setRGB(r, g, b);});
    MeshDepthMaterial = ($__.fs.MeshDepthMaterial_58 = function MeshDepthMaterial(parameters) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
parameters = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
Material.call(this);
this.type = 'MeshDepthMaterial';
this.depthPacking = BasicDepthPacking;
this.skinning = false;
this.morphTargets = false;
this.map = null;
this.alphaMap = null;
this.displacementMap = null;
this.displacementScale = 1;
this.displacementBias = 0;
this.wireframe = false;
this.wireframeLinewidth = 1;
this.fog = false;
this.lights = false;
this.setValues(parameters);});
    Box3 = ($__.fs.Box3_59 = function Box3(min, max) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
min = arguments[0], max = arguments[1];
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    this.min = (min !== undefined, new (Vector3, $__.fs.Vector3_11)(+Infinity, +Infinity, +Infinity, 13, true, $__.uid));
    this.max = (max !== undefined, new (Vector3, $__.fs.Vector3_11)(-Infinity, -Infinity, -Infinity, 14, true, $__.uid));
    return;
case 1:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 1);
    this.min = (min !== undefined, new (Vector3, $__.fs.Vector3_11)(+Infinity, +Infinity, +Infinity, 34, true, $__.uid));
    this.max = (max !== undefined, new (Vector3, $__.fs.Vector3_11)(-Infinity, -Infinity, -Infinity, 35, true, $__.uid));
    return;
case 2:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 2);
    this.min = (min !== undefined, new (Vector3, $__.fs.Vector3_11)(+Infinity, +Infinity, +Infinity, 97, true, $__.uid));
    this.max = (max !== undefined, new (Vector3, $__.fs.Vector3_11)(-Infinity, -Infinity, -Infinity, 98, true, $__.uid));
    return;
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.min = min !== undefined ? min : new Vector3(+Infinity, +Infinity, +Infinity);
this.max = max !== undefined ? max : new Vector3(-Infinity, -Infinity, -Infinity);});
    Sphere = ($__.fs.Sphere_60 = function Sphere(center, radius) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
center = arguments[0], radius = arguments[1];
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    this.center = (center !== undefined, new (Vector3, $__.fs.Vector3_11)(19, true, $__.uid));
    this.radius = (radius !== undefined, 0);
    return;
case 1:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 1);
    this.center = (center !== undefined, new (Vector3, $__.fs.Vector3_11)(20, true, $__.uid));
    this.radius = (radius !== undefined, 0);
    return;
case 2:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 2);
    this.center = (center !== undefined, new (Vector3, $__.fs.Vector3_11)(59, true, $__.uid));
    this.radius = (radius !== undefined, 0);
    return;
case 3:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 3);
    this.center = (center !== undefined, new (Vector3, $__.fs.Vector3_11)(75, true, $__.uid));
    this.radius = (radius !== undefined, 0);
    return;
case 4:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 4);
    this.center = (center !== undefined, new (Vector3, $__.fs.Vector3_11)(78, true, $__.uid));
    this.radius = (radius !== undefined, 0);
    return;
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.center = center !== undefined ? center : new Vector3();
this.radius = radius !== undefined ? radius : 0;});
    Matrix3 = ($__.fs.Matrix3_61 = function Matrix3() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
switch (vvv_switch) {
case 0:
case 1:
case 2:
case 3:
case 4:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(0 <= vvv_switch && vvv_switch <= 4);
    this.elements = new Float32Array([
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1
    ]);
    (arguments.length, 0) > 0;
    return;
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.elements = new Float32Array([
    1,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    1
]);
if (arguments.length > 0) {
    console.error('THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.');
}});
    Plane = ($__.fs.Plane_62 = function Plane(normal, constant) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
normal = arguments[0], constant = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.normal = normal !== undefined ? normal : new Vector3(1, 0, 0);
this.constant = constant !== undefined ? constant : 0;});
    Frustum = ($__.fs.Frustum_63 = function Frustum(p0, p1, p2, p3, p4, p5) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
p0 = arguments[0], p1 = arguments[1], p2 = arguments[2], p3 = arguments[3], p4 = arguments[4], p5 = arguments[5];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.planes = [
    p0 !== undefined ? p0 : new Plane(),
    p1 !== undefined ? p1 : new Plane(),
    p2 !== undefined ? p2 : new Plane(),
    p3 !== undefined ? p3 : new Plane(),
    p4 !== undefined ? p4 : new Plane(),
    p5 !== undefined ? p5 : new Plane()
];});
    WebGLShadowMap = ($__.fs.WebGLShadowMap_64 = function WebGLShadowMap(_renderer, _lights, _objects, capabilities) {
var vvv_return, vvv_switch, _gl, _state, _frustum, _projScreenMatrix, _lightShadows, _shadowMapSize, _maxShadowMapSize, _lookTarget, _lightPositionWorld, _renderList, _MorphingFlag, _SkinningFlag, _NumberOfMaterialVariants, _depthMaterials, _distanceMaterials, _materialCache, cubeDirections, cubeUps, cube2DViewPorts, depthMaterialTemplate, distanceShader, distanceUniforms, useMorphing, useSkinning, depthMaterial, distanceMaterial, scope, getDepthMaterial, projectObject;
getDepthMaterial = function getDepthMaterial(object, material, isPointLight, lightPositionWorld) {
    var geometry = object.geometry;
    var result = null;
    var materialVariants = _depthMaterials;
    var customMaterial = object.customDepthMaterial;
    if (isPointLight) {
        materialVariants = _distanceMaterials;
        customMaterial = object.customDistanceMaterial;
    }
    if (!customMaterial) {
        var useMorphing = false;
        if (material.morphTargets) {
            if (geometry && geometry.isBufferGeometry) {
                useMorphing = geometry.morphAttributes && geometry.morphAttributes.position && geometry.morphAttributes.position.length > 0;
            } else if (geometry && geometry.isGeometry) {
                useMorphing = geometry.morphTargets && geometry.morphTargets.length > 0;
            }
        }
        var useSkinning = object.isSkinnedMesh && material.skinning;
        var variantIndex = 0;
        if (useMorphing)
            variantIndex |= _MorphingFlag;
        if (useSkinning)
            variantIndex |= _SkinningFlag;
        result = materialVariants[variantIndex];
    } else {
        result = customMaterial;
    }
    if (_renderer.localClippingEnabled && material.clipShadows === true && material.clippingPlanes.length !== 0) {
        var keyA = result.uuid, keyB = material.uuid;
        var materialsForVariant = _materialCache[keyA];
        if (materialsForVariant === undefined) {
            materialsForVariant = {};
            _materialCache[keyA] = materialsForVariant;
        }
        var cachedMaterial = materialsForVariant[keyB];
        if (cachedMaterial === undefined) {
            cachedMaterial = result.clone();
            materialsForVariant[keyB] = cachedMaterial;
        }
        result = cachedMaterial;
    }
    result.visible = material.visible;
    result.wireframe = material.wireframe;
    var side = material.side;
    if (scope.renderSingleSided && side == DoubleSide) {
        side = FrontSide;
    }
    if (scope.renderReverseSided) {
        if (side === FrontSide)
            side = BackSide;
        else if (side === BackSide)
            side = FrontSide;
    }
    result.side = side;
    result.clipShadows = material.clipShadows;
    result.clippingPlanes = material.clippingPlanes;
    result.wireframeLinewidth = material.wireframeLinewidth;
    result.linewidth = material.linewidth;
    if (isPointLight && result.uniforms.lightPos !== undefined) {
        result.uniforms.lightPos.value.copy(lightPositionWorld);
    }
    return result;
};
projectObject = function projectObject(object, camera, shadowCamera) {
    if (object.visible === false)
        return;
    var visible = (object.layers.mask & camera.layers.mask) !== 0;
    if (visible && (object.isMesh || object.isLine || object.isPoints)) {
        if (object.castShadow && (object.frustumCulled === false || _frustum.intersectsObject(object) === true)) {
            var material = object.material;
            if (material.visible === true) {
                object.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse, object.matrixWorld);
                _renderList.push(object);
            }
        }
    }
    var children = object.children;
    for (var i = 0, l = children.length; i < l; i++) {
        projectObject(children[i], camera, shadowCamera);
    }
};
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
_renderer = arguments[0], _lights = arguments[1], _objects = arguments[2], capabilities = arguments[3];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
_gl = _renderer.context;
_state = _renderer.state;
_frustum = new Frustum();
_projScreenMatrix = new Matrix4();
_lightShadows = _lights.shadows;
_shadowMapSize = new Vector2();
_maxShadowMapSize = new Vector2(capabilities.maxTextureSize, capabilities.maxTextureSize);
_lookTarget = new Vector3();
_lightPositionWorld = new Vector3();
_renderList = [];
_MorphingFlag = 1;
_SkinningFlag = 2;
_NumberOfMaterialVariants = (_MorphingFlag | _SkinningFlag) + 1;
_depthMaterials = new Array(_NumberOfMaterialVariants);
_distanceMaterials = new Array(_NumberOfMaterialVariants);
_materialCache = {};
cubeDirections = [
    new Vector3(1, 0, 0),
    new Vector3(-1, 0, 0),
    new Vector3(0, 0, 1),
    new Vector3(0, 0, -1),
    new Vector3(0, 1, 0),
    new Vector3(0, -1, 0)
];
cubeUps = [
    new Vector3(0, 1, 0),
    new Vector3(0, 1, 0),
    new Vector3(0, 1, 0),
    new Vector3(0, 1, 0),
    new Vector3(0, 0, 1),
    new Vector3(0, 0, -1)
];
cube2DViewPorts = [
    new Vector4(),
    new Vector4(),
    new Vector4(),
    new Vector4(),
    new Vector4(),
    new Vector4()
];
depthMaterialTemplate = new MeshDepthMaterial();
depthMaterialTemplate.depthPacking = RGBADepthPacking;
depthMaterialTemplate.clipping = true;
distanceShader = ShaderLib['distanceRGBA'];
distanceUniforms = exports.UniformsUtils.clone(distanceShader.uniforms);
for (var i = 0; i !== _NumberOfMaterialVariants; ++i) {
    useMorphing = (i & _MorphingFlag) !== 0;
    useSkinning = (i & _SkinningFlag) !== 0;
    depthMaterial = depthMaterialTemplate.clone();
    depthMaterial.morphTargets = useMorphing;
    depthMaterial.skinning = useSkinning;
    _depthMaterials[i] = depthMaterial;
    distanceMaterial = new ShaderMaterial({
        defines: {
            'USE_SHADOWMAP': ''
        },
        uniforms: distanceUniforms,
        vertexShader: distanceShader.vertexShader,
        fragmentShader: distanceShader.fragmentShader,
        morphTargets: useMorphing,
        skinning: useSkinning,
        clipping: true
    });
    _distanceMaterials[i] = distanceMaterial;
}
scope = this;
this.enabled = false;
this.autoUpdate = true;
this.needsUpdate = false;
this.type = PCFShadowMap;
this.renderReverseSided = true;
this.renderSingleSided = true;
this.render = function (scene, camera) {
    if (scope.enabled === false)
        return;
    if (scope.autoUpdate === false && scope.needsUpdate === false)
        return;
    if (_lightShadows.length === 0)
        return;
    _state.clearColor(1, 1, 1, 1);
    _state.disable(_gl.BLEND);
    _state.setDepthTest(true);
    _state.setScissorTest(false);
    var faceCount, isPointLight;
    for (var i = 0, il = _lightShadows.length; i < il; i++) {
        var light = _lightShadows[i];
        var shadow = light.shadow;
        if (shadow === undefined) {
            console.warn('THREE.WebGLShadowMap:', light, 'has no shadow.');
            continue;
        }
        var shadowCamera = shadow.camera;
        _shadowMapSize.copy(shadow.mapSize);
        _shadowMapSize.min(_maxShadowMapSize);
        if (light && light.isPointLight) {
            faceCount = 6;
            isPointLight = true;
            var vpWidth = _shadowMapSize.x;
            var vpHeight = _shadowMapSize.y;
            cube2DViewPorts[0].set(vpWidth * 2, vpHeight, vpWidth, vpHeight);
            cube2DViewPorts[1].set(0, vpHeight, vpWidth, vpHeight);
            cube2DViewPorts[2].set(vpWidth * 3, vpHeight, vpWidth, vpHeight);
            cube2DViewPorts[3].set(vpWidth, vpHeight, vpWidth, vpHeight);
            cube2DViewPorts[4].set(vpWidth * 3, 0, vpWidth, vpHeight);
            cube2DViewPorts[5].set(vpWidth, 0, vpWidth, vpHeight);
            _shadowMapSize.x *= 4;
            _shadowMapSize.y *= 2;
        } else {
            faceCount = 1;
            isPointLight = false;
        }
        if (shadow.map === null) {
            var pars = {
                minFilter: NearestFilter,
                magFilter: NearestFilter,
                format: RGBAFormat
            };
            shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
            shadowCamera.updateProjectionMatrix();
        }
        if (shadow && shadow.isSpotLightShadow) {
            shadow.update(light);
        }
        var shadowMap = shadow.map;
        var shadowMatrix = shadow.matrix;
        _lightPositionWorld.setFromMatrixPosition(light.matrixWorld);
        shadowCamera.position.copy(_lightPositionWorld);
        _renderer.setRenderTarget(shadowMap);
        _renderer.clear();
        for (var face = 0; face < faceCount; face++) {
            if (isPointLight) {
                _lookTarget.copy(shadowCamera.position);
                _lookTarget.add(cubeDirections[face]);
                shadowCamera.up.copy(cubeUps[face]);
                shadowCamera.lookAt(_lookTarget);
                var vpDimensions = cube2DViewPorts[face];
                _state.viewport(vpDimensions);
            } else {
                _lookTarget.setFromMatrixPosition(light.target.matrixWorld);
                shadowCamera.lookAt(_lookTarget);
            }
            shadowCamera.updateMatrixWorld();
            shadowCamera.matrixWorldInverse.getInverse(shadowCamera.matrixWorld);
            shadowMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);
            shadowMatrix.multiply(shadowCamera.projectionMatrix);
            shadowMatrix.multiply(shadowCamera.matrixWorldInverse);
            _projScreenMatrix.multiplyMatrices(shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse);
            _frustum.setFromMatrix(_projScreenMatrix);
            _renderList.length = 0;
            projectObject(scene, camera, shadowCamera);
            for (var j = 0, jl = _renderList.length; j < jl; j++) {
                var object = _renderList[j];
                var geometry = _objects.update(object);
                var material = object.material;
                if (material && material.isMultiMaterial) {
                    var groups = geometry.groups;
                    var materials = material.materials;
                    for (var k = 0, kl = groups.length; k < kl; k++) {
                        var group = groups[k];
                        var groupMaterial = materials[group.materialIndex];
                        if (groupMaterial.visible === true) {
                            var depthMaterial = getDepthMaterial(object, groupMaterial, isPointLight, _lightPositionWorld);
                            _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, group);
                        }
                    }
                } else {
                    var depthMaterial = getDepthMaterial(object, material, isPointLight, _lightPositionWorld);
                    _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, null);
                }
            }
        }
    }
    var clearColor = _renderer.getClearColor(), clearAlpha = _renderer.getClearAlpha();
    _renderer.setClearColor(clearColor, clearAlpha);
    scope.needsUpdate = false;
};});
    addLineNumbers = ($__.fs.addLineNumbers_65 = function addLineNumbers(string) {
var vvv_return, vvv_switch, lines;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
string = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
lines = string.split('\n');
for (var i = 0; i < lines.length; i++) {
    lines[i] = i + 1 + ': ' + lines[i];
}
return lines.join('\n');});
    WebGLShader = ($__.fs.WebGLShader_66 = function WebGLShader(gl, type, string) {
var vvv_return, vvv_switch, shader;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
gl = arguments[0], type = arguments[1], string = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
shader = gl.createShader(type);
gl.shaderSource(shader, string);
gl.compileShader(shader);
if (gl.getShaderParameter(shader, gl.COMPILE_STATUS) === false) {
    console.error('THREE.WebGLShader: Shader couldn\'t compile.');
}
if (gl.getShaderInfoLog(shader) !== '') {
    console.warn('THREE.WebGLShader: gl.getShaderInfoLog()', type === gl.VERTEX_SHADER ? 'vertex' : 'fragment', gl.getShaderInfoLog(shader), addLineNumbers(string));
}
return shader;});
    WebGLProperties = ($__.fs.WebGLProperties_67 = function WebGLProperties() {
var vvv_return, vvv_switch, properties;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
properties = {};
return {
    get: function (object) {
        var uuid = object.uuid;
        var map = properties[uuid];
        if (map === undefined) {
            map = {};
            properties[uuid] = map;
        }
        return map;
    },
    delete: function (object) {
        delete properties[object.uuid];
    },
    clear: function () {
        properties = {};
    }
};});
    getEncodingComponents = ($__.fs.getEncodingComponents_68 = function getEncodingComponents(encoding) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
encoding = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
switch (encoding) {
case LinearEncoding:
    return [
        'Linear',
        '( value )'
    ];
case sRGBEncoding:
    return [
        'sRGB',
        '( value )'
    ];
case RGBEEncoding:
    return [
        'RGBE',
        '( value )'
    ];
case RGBM7Encoding:
    return [
        'RGBM',
        '( value, 7.0 )'
    ];
case RGBM16Encoding:
    return [
        'RGBM',
        '( value, 16.0 )'
    ];
case RGBDEncoding:
    return [
        'RGBD',
        '( value, 256.0 )'
    ];
case GammaEncoding:
    return [
        'Gamma',
        '( value, float( GAMMA_FACTOR ) )'
    ];
default:
    throw new Error('unsupported encoding: ' + encoding);
}});
    getTexelDecodingFunction = ($__.fs.getTexelDecodingFunction_69 = function getTexelDecodingFunction(functionName, encoding) {
var vvv_return, vvv_switch, components;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
functionName = arguments[0], encoding = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
components = getEncodingComponents(encoding);
return 'vec4 ' + functionName + '( vec4 value ) { return ' + components[0] + 'ToLinear' + components[1] + '; }';});
    getTexelEncodingFunction = ($__.fs.getTexelEncodingFunction_70 = function getTexelEncodingFunction(functionName, encoding) {
var vvv_return, vvv_switch, components;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
functionName = arguments[0], encoding = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
components = getEncodingComponents(encoding);
return 'vec4 ' + functionName + '( vec4 value ) { return LinearTo' + components[0] + components[1] + '; }';});
    getToneMappingFunction = ($__.fs.getToneMappingFunction_71 = function getToneMappingFunction(functionName, toneMapping) {
var vvv_return, vvv_switch, toneMappingName;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
functionName = arguments[0], toneMapping = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
switch (toneMapping) {
case LinearToneMapping:
    toneMappingName = 'Linear';
    break;
case ReinhardToneMapping:
    toneMappingName = 'Reinhard';
    break;
case Uncharted2ToneMapping:
    toneMappingName = 'Uncharted2';
    break;
case CineonToneMapping:
    toneMappingName = 'OptimizedCineon';
    break;
default:
    throw new Error('unsupported toneMapping: ' + toneMapping);
}
return 'vec3 ' + functionName + '( vec3 color ) { return ' + toneMappingName + 'ToneMapping( color ); }';});
    generateExtensions = ($__.fs.generateExtensions_72 = function generateExtensions(extensions, parameters, rendererExtensions) {
var vvv_return, vvv_switch, chunks;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
extensions = arguments[0], parameters = arguments[1], rendererExtensions = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
extensions = extensions || {};
chunks = [
    extensions.derivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.normalMap || parameters.flatShading ? '#extension GL_OES_standard_derivatives : enable' : '',
    (extensions.fragDepth || parameters.logarithmicDepthBuffer) && rendererExtensions.get('EXT_frag_depth') ? '#extension GL_EXT_frag_depth : enable' : '',
    extensions.drawBuffers && rendererExtensions.get('WEBGL_draw_buffers') ? '#extension GL_EXT_draw_buffers : require' : '',
    (extensions.shaderTextureLOD || parameters.envMap) && rendererExtensions.get('EXT_shader_texture_lod') ? '#extension GL_EXT_shader_texture_lod : enable' : ''
];
return chunks.filter(filterEmptyLine).join('\n');});
    generateDefines = ($__.fs.generateDefines_73 = function generateDefines(defines) {
var vvv_return, vvv_switch, chunks, value;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
defines = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
chunks = [];
for (var name in defines) {
    value = defines[name];
    if (value === false)
        continue;
    chunks.push('#define ' + name + ' ' + value);
}
return chunks.join('\n');});
    fetchAttributeLocations = ($__.fs.fetchAttributeLocations_74 = function fetchAttributeLocations(gl, program, identifiers) {
var vvv_return, vvv_switch, attributes, n, info, name;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
gl = arguments[0], program = arguments[1], identifiers = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
attributes = {};
n = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
for (var i = 0; i < n; i++) {
    info = gl.getActiveAttrib(program, i);
    name = info.name;
    attributes[name] = gl.getAttribLocation(program, name);
}
return attributes;});
    filterEmptyLine = ($__.fs.filterEmptyLine_75 = function filterEmptyLine(string) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
string = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return string !== '';});
    replaceLightNums = ($__.fs.replaceLightNums_76 = function replaceLightNums(string, parameters) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
string = arguments[0], parameters = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return string.replace(/NUM_DIR_LIGHTS/g, parameters.numDirLights).replace(/NUM_SPOT_LIGHTS/g, parameters.numSpotLights).replace(/NUM_POINT_LIGHTS/g, parameters.numPointLights).replace(/NUM_HEMI_LIGHTS/g, parameters.numHemiLights);});
    parseIncludes = ($__.fs.parseIncludes_77 = function parseIncludes(string) {
var vvv_return, vvv_switch, pattern, replace;
replace = function replace(match, include) {
    var replace = ShaderChunk[include];
    if (replace === undefined) {
        throw new Error('Can not resolve #include <' + include + '>');
    }
    return parseIncludes(replace);
};
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
string = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
pattern = /#include +<([\w\d.]+)>/g;
return string.replace(pattern, replace);});
    unrollLoops = ($__.fs.unrollLoops_78 = function unrollLoops(string) {
var vvv_return, vvv_switch, pattern, replace;
replace = function replace(match, start, end, snippet) {
    var unroll = '';
    for (var i = parseInt(start); i < parseInt(end); i++) {
        unroll += snippet.replace(/\[ i \]/g, '[ ' + i + ' ]');
    }
    return unroll;
};
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
string = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
pattern = /for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;
return string.replace(pattern, replace);});
    WebGLProgram = ($__.fs.WebGLProgram_79 = function WebGLProgram(renderer, code, material, parameters) {
var vvv_return, vvv_switch, gl, extensions, defines, vertexShader, fragmentShader, shadowMapTypeDefine, envMapTypeDefine, envMapModeDefine, envMapBlendingDefine, gammaFactorDefine, customExtensions, customDefines, program, prefixVertex, prefixFragment, vertexGlsl, fragmentGlsl, glVertexShader, glFragmentShader, programLog, vertexLog, fragmentLog, runnable, haveDiagnostics, cachedUniforms, cachedAttributes;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
renderer = arguments[0], code = arguments[1], material = arguments[2], parameters = arguments[3];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
gl = renderer.context;
extensions = material.extensions;
defines = material.defines;
vertexShader = material.__webglShader.vertexShader;
fragmentShader = material.__webglShader.fragmentShader;
shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';
if (parameters.shadowMapType === PCFShadowMap) {
    shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';
} else if (parameters.shadowMapType === PCFSoftShadowMap) {
    shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';
}
envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
envMapModeDefine = 'ENVMAP_MODE_REFLECTION';
envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
if (parameters.envMap) {
    switch (material.envMap.mapping) {
    case CubeReflectionMapping:
    case CubeRefractionMapping:
        envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
        break;
    case CubeUVReflectionMapping:
    case CubeUVRefractionMapping:
        envMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';
        break;
    case EquirectangularReflectionMapping:
    case EquirectangularRefractionMapping:
        envMapTypeDefine = 'ENVMAP_TYPE_EQUIREC';
        break;
    case SphericalReflectionMapping:
        envMapTypeDefine = 'ENVMAP_TYPE_SPHERE';
        break;
    }
    switch (material.envMap.mapping) {
    case CubeRefractionMapping:
    case EquirectangularRefractionMapping:
        envMapModeDefine = 'ENVMAP_MODE_REFRACTION';
        break;
    }
    switch (material.combine) {
    case MultiplyOperation:
        envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
        break;
    case MixOperation:
        envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';
        break;
    case AddOperation:
        envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';
        break;
    }
}
gammaFactorDefine = renderer.gammaFactor > 0 ? renderer.gammaFactor : 1;
customExtensions = generateExtensions(extensions, parameters, renderer.extensions);
customDefines = generateDefines(defines);
program = gl.createProgram();
if (material.isRawShaderMaterial) {
    prefixVertex = [
        customDefines,
        '\n'
    ].filter(filterEmptyLine).join('\n');
    prefixFragment = [
        customExtensions,
        customDefines,
        '\n'
    ].filter(filterEmptyLine).join('\n');
} else {
    prefixVertex = [
        'precision ' + parameters.precision + ' float;',
        'precision ' + parameters.precision + ' int;',
        '#define SHADER_NAME ' + material.__webglShader.name,
        customDefines,
        parameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',
        '#define GAMMA_FACTOR ' + gammaFactorDefine,
        '#define MAX_BONES ' + parameters.maxBones,
        parameters.map ? '#define USE_MAP' : '',
        parameters.envMap ? '#define USE_ENVMAP' : '',
        parameters.envMap ? '#define ' + envMapModeDefine : '',
        parameters.lightMap ? '#define USE_LIGHTMAP' : '',
        parameters.aoMap ? '#define USE_AOMAP' : '',
        parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
        parameters.bumpMap ? '#define USE_BUMPMAP' : '',
        parameters.normalMap ? '#define USE_NORMALMAP' : '',
        parameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '',
        parameters.specularMap ? '#define USE_SPECULARMAP' : '',
        parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
        parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
        parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
        parameters.vertexColors ? '#define USE_COLOR' : '',
        parameters.flatShading ? '#define FLAT_SHADED' : '',
        parameters.skinning ? '#define USE_SKINNING' : '',
        parameters.useVertexTexture ? '#define BONE_TEXTURE' : '',
        parameters.morphTargets ? '#define USE_MORPHTARGETS' : '',
        parameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '',
        parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
        parameters.flipSided ? '#define FLIP_SIDED' : '',
        '#define NUM_CLIPPING_PLANES ' + parameters.numClippingPlanes,
        parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
        parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',
        parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',
        parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
        parameters.logarithmicDepthBuffer && renderer.extensions.get('EXT_frag_depth') ? '#define USE_LOGDEPTHBUF_EXT' : '',
        'uniform mat4 modelMatrix;',
        'uniform mat4 modelViewMatrix;',
        'uniform mat4 projectionMatrix;',
        'uniform mat4 viewMatrix;',
        'uniform mat3 normalMatrix;',
        'uniform vec3 cameraPosition;',
        'attribute vec3 position;',
        'attribute vec3 normal;',
        'attribute vec2 uv;',
        '#ifdef USE_COLOR',
        '\tattribute vec3 color;',
        '#endif',
        '#ifdef USE_MORPHTARGETS',
        '\tattribute vec3 morphTarget0;',
        '\tattribute vec3 morphTarget1;',
        '\tattribute vec3 morphTarget2;',
        '\tattribute vec3 morphTarget3;',
        '\t#ifdef USE_MORPHNORMALS',
        '\t\tattribute vec3 morphNormal0;',
        '\t\tattribute vec3 morphNormal1;',
        '\t\tattribute vec3 morphNormal2;',
        '\t\tattribute vec3 morphNormal3;',
        '\t#else',
        '\t\tattribute vec3 morphTarget4;',
        '\t\tattribute vec3 morphTarget5;',
        '\t\tattribute vec3 morphTarget6;',
        '\t\tattribute vec3 morphTarget7;',
        '\t#endif',
        '#endif',
        '#ifdef USE_SKINNING',
        '\tattribute vec4 skinIndex;',
        '\tattribute vec4 skinWeight;',
        '#endif',
        '\n'
    ].filter(filterEmptyLine).join('\n');
    prefixFragment = [
        customExtensions,
        'precision ' + parameters.precision + ' float;',
        'precision ' + parameters.precision + ' int;',
        '#define SHADER_NAME ' + material.__webglShader.name,
        customDefines,
        parameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest : '',
        '#define GAMMA_FACTOR ' + gammaFactorDefine,
        parameters.useFog && parameters.fog ? '#define USE_FOG' : '',
        parameters.useFog && parameters.fogExp ? '#define FOG_EXP2' : '',
        parameters.map ? '#define USE_MAP' : '',
        parameters.envMap ? '#define USE_ENVMAP' : '',
        parameters.envMap ? '#define ' + envMapTypeDefine : '',
        parameters.envMap ? '#define ' + envMapModeDefine : '',
        parameters.envMap ? '#define ' + envMapBlendingDefine : '',
        parameters.lightMap ? '#define USE_LIGHTMAP' : '',
        parameters.aoMap ? '#define USE_AOMAP' : '',
        parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
        parameters.bumpMap ? '#define USE_BUMPMAP' : '',
        parameters.normalMap ? '#define USE_NORMALMAP' : '',
        parameters.specularMap ? '#define USE_SPECULARMAP' : '',
        parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
        parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
        parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
        parameters.vertexColors ? '#define USE_COLOR' : '',
        parameters.flatShading ? '#define FLAT_SHADED' : '',
        parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
        parameters.flipSided ? '#define FLIP_SIDED' : '',
        '#define NUM_CLIPPING_PLANES ' + parameters.numClippingPlanes,
        parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
        parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',
        parameters.premultipliedAlpha ? '#define PREMULTIPLIED_ALPHA' : '',
        parameters.physicallyCorrectLights ? '#define PHYSICALLY_CORRECT_LIGHTS' : '',
        parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
        parameters.logarithmicDepthBuffer && renderer.extensions.get('EXT_frag_depth') ? '#define USE_LOGDEPTHBUF_EXT' : '',
        parameters.envMap && renderer.extensions.get('EXT_shader_texture_lod') ? '#define TEXTURE_LOD_EXT' : '',
        'uniform mat4 viewMatrix;',
        'uniform vec3 cameraPosition;',
        parameters.toneMapping !== NoToneMapping ? '#define TONE_MAPPING' : '',
        parameters.toneMapping !== NoToneMapping ? ShaderChunk['tonemapping_pars_fragment'] : '',
        parameters.toneMapping !== NoToneMapping ? getToneMappingFunction('toneMapping', parameters.toneMapping) : '',
        parameters.outputEncoding || parameters.mapEncoding || parameters.envMapEncoding || parameters.emissiveMapEncoding ? ShaderChunk['encodings_pars_fragment'] : '',
        parameters.mapEncoding ? getTexelDecodingFunction('mapTexelToLinear', parameters.mapEncoding) : '',
        parameters.envMapEncoding ? getTexelDecodingFunction('envMapTexelToLinear', parameters.envMapEncoding) : '',
        parameters.emissiveMapEncoding ? getTexelDecodingFunction('emissiveMapTexelToLinear', parameters.emissiveMapEncoding) : '',
        parameters.outputEncoding ? getTexelEncodingFunction('linearToOutputTexel', parameters.outputEncoding) : '',
        parameters.depthPacking ? '#define DEPTH_PACKING ' + material.depthPacking : '',
        '\n'
    ].filter(filterEmptyLine).join('\n');
}
vertexShader = parseIncludes(vertexShader, parameters);
vertexShader = replaceLightNums(vertexShader, parameters);
fragmentShader = parseIncludes(fragmentShader, parameters);
fragmentShader = replaceLightNums(fragmentShader, parameters);
if (!material.isShaderMaterial) {
    vertexShader = unrollLoops(vertexShader);
    fragmentShader = unrollLoops(fragmentShader);
}
vertexGlsl = prefixVertex + vertexShader;
fragmentGlsl = prefixFragment + fragmentShader;
glVertexShader = WebGLShader(gl, gl.VERTEX_SHADER, vertexGlsl);
glFragmentShader = WebGLShader(gl, gl.FRAGMENT_SHADER, fragmentGlsl);
gl.attachShader(program, glVertexShader);
gl.attachShader(program, glFragmentShader);
if (material.index0AttributeName !== undefined) {
    gl.bindAttribLocation(program, 0, material.index0AttributeName);
} else if (parameters.morphTargets === true) {
    gl.bindAttribLocation(program, 0, 'position');
}
gl.linkProgram(program);
programLog = gl.getProgramInfoLog(program);
vertexLog = gl.getShaderInfoLog(glVertexShader);
fragmentLog = gl.getShaderInfoLog(glFragmentShader);
runnable = true;
haveDiagnostics = true;
if (gl.getProgramParameter(program, gl.LINK_STATUS) === false) {
    runnable = false;
    console.error('THREE.WebGLProgram: shader error: ', gl.getError(), 'gl.VALIDATE_STATUS', gl.getProgramParameter(program, gl.VALIDATE_STATUS), 'gl.getProgramInfoLog', programLog, vertexLog, fragmentLog);
} else if (programLog !== '') {
    console.warn('THREE.WebGLProgram: gl.getProgramInfoLog()', programLog);
} else if (vertexLog === '' || fragmentLog === '') {
    haveDiagnostics = false;
}
if (haveDiagnostics) {
    this.diagnostics = {
        runnable: runnable,
        material: material,
        programLog: programLog,
        vertexShader: {
            log: vertexLog,
            prefix: prefixVertex
        },
        fragmentShader: {
            log: fragmentLog,
            prefix: prefixFragment
        }
    };
}
gl.deleteShader(glVertexShader);
gl.deleteShader(glFragmentShader);
this.getUniforms = function () {
    if (cachedUniforms === undefined) {
        cachedUniforms = new WebGLUniforms(gl, program, renderer);
    }
    return cachedUniforms;
};
this.getAttributes = function () {
    if (cachedAttributes === undefined) {
        cachedAttributes = fetchAttributeLocations(gl, program);
    }
    return cachedAttributes;
};
this.destroy = function () {
    gl.deleteProgram(program);
    this.program = undefined;
};
Object.defineProperties(this, {
    uniforms: {
        get: function () {
            console.warn('THREE.WebGLProgram: .uniforms is now .getUniforms().');
            return this.getUniforms();
        }
    },
    attributes: {
        get: function () {
            console.warn('THREE.WebGLProgram: .attributes is now .getAttributes().');
            return this.getAttributes();
        }
    }
});
this.id = programIdCount++;
this.code = code;
this.usedTimes = 1;
this.program = program;
this.vertexShader = glVertexShader;
this.fragmentShader = glFragmentShader;
return this;});
    WebGLPrograms = ($__.fs.WebGLPrograms_80 = function WebGLPrograms(renderer, capabilities) {
var vvv_return, vvv_switch, programs, shaderIDs, parameterNames, allocateBones, getTextureEncodingFromMap;
allocateBones = function allocateBones(object) {
    if (capabilities.floatVertexTextures && object && object.skeleton && object.skeleton.useVertexTexture) {
        return 1024;
    } else {
        var nVertexUniforms = capabilities.maxVertexUniforms;
        var nVertexMatrices = Math.floor((nVertexUniforms - 20) / 4);
        var maxBones = nVertexMatrices;
        if (object !== undefined && (object && object.isSkinnedMesh)) {
            maxBones = Math.min(object.skeleton.bones.length, maxBones);
            if (maxBones < object.skeleton.bones.length) {
                console.warn('WebGLRenderer: too many bones - ' + object.skeleton.bones.length + ', this GPU supports just ' + maxBones + ' (try OpenGL instead of ANGLE)');
            }
        }
        return maxBones;
    }
};
getTextureEncodingFromMap = function getTextureEncodingFromMap(map, gammaOverrideLinear) {
    var encoding;
    if (!map) {
        encoding = LinearEncoding;
    } else if (map && map.isTexture) {
        encoding = map.encoding;
    } else if (map && map.isWebGLRenderTarget) {
        console.warn('THREE.WebGLPrograms.getTextureEncodingFromMap: don\'t use render targets as textures. Use their .texture property instead.');
        encoding = map.texture.encoding;
    }
    if (encoding === LinearEncoding && gammaOverrideLinear) {
        encoding = GammaEncoding;
    }
    return encoding;
};
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
renderer = arguments[0], capabilities = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
programs = [];
shaderIDs = {
    MeshDepthMaterial: 'depth',
    MeshNormalMaterial: 'normal',
    MeshBasicMaterial: 'basic',
    MeshLambertMaterial: 'lambert',
    MeshPhongMaterial: 'phong',
    MeshStandardMaterial: 'physical',
    MeshPhysicalMaterial: 'physical',
    LineBasicMaterial: 'basic',
    LineDashedMaterial: 'dashed',
    PointsMaterial: 'points'
};
parameterNames = [
    'precision',
    'supportsVertexTextures',
    'map',
    'mapEncoding',
    'envMap',
    'envMapMode',
    'envMapEncoding',
    'lightMap',
    'aoMap',
    'emissiveMap',
    'emissiveMapEncoding',
    'bumpMap',
    'normalMap',
    'displacementMap',
    'specularMap',
    'roughnessMap',
    'metalnessMap',
    'alphaMap',
    'combine',
    'vertexColors',
    'fog',
    'useFog',
    'fogExp',
    'flatShading',
    'sizeAttenuation',
    'logarithmicDepthBuffer',
    'skinning',
    'maxBones',
    'useVertexTexture',
    'morphTargets',
    'morphNormals',
    'maxMorphTargets',
    'maxMorphNormals',
    'premultipliedAlpha',
    'numDirLights',
    'numPointLights',
    'numSpotLights',
    'numHemiLights',
    'shadowMapEnabled',
    'shadowMapType',
    'toneMapping',
    'physicallyCorrectLights',
    'alphaTest',
    'doubleSided',
    'flipSided',
    'numClippingPlanes',
    'depthPacking'
];
this.getParameters = function (material, lights, fog, nClipPlanes, object) {
    var shaderID = shaderIDs[material.type];
    var maxBones = allocateBones(object);
    var precision = renderer.getPrecision();
    if (material.precision !== null) {
        precision = capabilities.getMaxPrecision(material.precision);
        if (precision !== material.precision) {
            console.warn('THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.');
        }
    }
    var currentRenderTarget = renderer.getCurrentRenderTarget();
    var parameters = {
        shaderID: shaderID,
        precision: precision,
        supportsVertexTextures: capabilities.vertexTextures,
        outputEncoding: getTextureEncodingFromMap(!currentRenderTarget ? null : currentRenderTarget.texture, renderer.gammaOutput),
        map: !!material.map,
        mapEncoding: getTextureEncodingFromMap(material.map, renderer.gammaInput),
        envMap: !!material.envMap,
        envMapMode: material.envMap && material.envMap.mapping,
        envMapEncoding: getTextureEncodingFromMap(material.envMap, renderer.gammaInput),
        envMapCubeUV: !!material.envMap && (material.envMap.mapping === CubeUVReflectionMapping || material.envMap.mapping === CubeUVRefractionMapping),
        lightMap: !!material.lightMap,
        aoMap: !!material.aoMap,
        emissiveMap: !!material.emissiveMap,
        emissiveMapEncoding: getTextureEncodingFromMap(material.emissiveMap, renderer.gammaInput),
        bumpMap: !!material.bumpMap,
        normalMap: !!material.normalMap,
        displacementMap: !!material.displacementMap,
        roughnessMap: !!material.roughnessMap,
        metalnessMap: !!material.metalnessMap,
        specularMap: !!material.specularMap,
        alphaMap: !!material.alphaMap,
        combine: material.combine,
        vertexColors: material.vertexColors,
        fog: !!fog,
        useFog: material.fog,
        fogExp: fog && fog.isFogExp2,
        flatShading: material.shading === FlatShading,
        sizeAttenuation: material.sizeAttenuation,
        logarithmicDepthBuffer: capabilities.logarithmicDepthBuffer,
        skinning: material.skinning,
        maxBones: maxBones,
        useVertexTexture: capabilities.floatVertexTextures && object && object.skeleton && object.skeleton.useVertexTexture,
        morphTargets: material.morphTargets,
        morphNormals: material.morphNormals,
        maxMorphTargets: renderer.maxMorphTargets,
        maxMorphNormals: renderer.maxMorphNormals,
        numDirLights: lights.directional.length,
        numPointLights: lights.point.length,
        numSpotLights: lights.spot.length,
        numHemiLights: lights.hemi.length,
        numClippingPlanes: nClipPlanes,
        shadowMapEnabled: renderer.shadowMap.enabled && object.receiveShadow && lights.shadows.length > 0,
        shadowMapType: renderer.shadowMap.type,
        toneMapping: renderer.toneMapping,
        physicallyCorrectLights: renderer.physicallyCorrectLights,
        premultipliedAlpha: material.premultipliedAlpha,
        alphaTest: material.alphaTest,
        doubleSided: material.side === DoubleSide,
        flipSided: material.side === BackSide,
        depthPacking: material.depthPacking !== undefined ? material.depthPacking : false
    };
    return parameters;
};
this.getProgramCode = function (material, parameters) {
    var array = [];
    if (parameters.shaderID) {
        array.push(parameters.shaderID);
    } else {
        array.push(material.fragmentShader);
        array.push(material.vertexShader);
    }
    if (material.defines !== undefined) {
        for (var name in material.defines) {
            array.push(name);
            array.push(material.defines[name]);
        }
    }
    for (var i = 0; i < parameterNames.length; i++) {
        array.push(parameters[parameterNames[i]]);
    }
    return array.join();
};
this.acquireProgram = function (material, parameters, code) {
    var program;
    for (var p = 0, pl = programs.length; p < pl; p++) {
        var programInfo = programs[p];
        if (programInfo.code === code) {
            program = programInfo;
            ++program.usedTimes;
            break;
        }
    }
    if (program === undefined) {
        program = new WebGLProgram(renderer, code, material, parameters);
        programs.push(program);
    }
    return program;
};
this.releaseProgram = function (program) {
    if (--program.usedTimes === 0) {
        var i = programs.indexOf(program);
        programs[i] = programs[programs.length - 1];
        programs.pop();
        program.destroy();
    }
};
this.programs = programs;});
    BufferAttribute = ($__.fs.BufferAttribute_81 = function BufferAttribute(array, itemSize, normalized) {
var vvv_return, vvv_switch, vvv_tmp0;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
array = arguments[0], itemSize = arguments[1], normalized = arguments[2];
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    Array['isArray'](array);
    this.uuid = (vvv_tmp0 = ((exports, $__.os.oid0).Math, $__.os.oid3), 'generateUUID', $__.fs.generateUUID_286.call(vvv_tmp0, 4, true, $__.uid));
    this.array = array;
    this.itemSize = itemSize;
    this.normalized = normalized === true;
    this.dynamic = false;
    this.updateRange = $__.os.oid534 = {
        'offset': 0,
        'count': -1
    };
    this.version = 0;
    return;
case 1:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 1);
    Array['isArray'](array);
    this.uuid = (vvv_tmp0 = ((exports, $__.os.oid0).Math, $__.os.oid3), 'generateUUID', $__.fs.generateUUID_286.call(vvv_tmp0, 6, true, $__.uid));
    this.array = array;
    this.itemSize = itemSize;
    this.normalized = normalized === true;
    this.dynamic = false;
    this.updateRange = $__.os.oid540 = {
        'offset': 0,
        'count': -1
    };
    this.version = 0;
    return;
case 2:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 2);
    Array['isArray'](array);
    this.uuid = (vvv_tmp0 = ((exports, $__.os.oid0).Math, $__.os.oid3), 'generateUUID', $__.fs.generateUUID_286.call(vvv_tmp0, 7, true, $__.uid));
    this.array = array;
    this.itemSize = itemSize;
    this.normalized = normalized === true;
    this.dynamic = false;
    this.updateRange = $__.os.oid541 = {
        'offset': 0,
        'count': -1
    };
    this.version = 0;
    return;
case 3:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 3);
    Array['isArray'](array);
    this.uuid = (vvv_tmp0 = ((exports, $__.os.oid0).Math, $__.os.oid3), 'generateUUID', $__.fs.generateUUID_286.call(vvv_tmp0, 8, true, $__.uid));
    this.array = array;
    this.itemSize = itemSize;
    this.normalized = normalized === true;
    this.dynamic = false;
    this.updateRange = $__.os.oid542 = {
        'offset': 0,
        'count': -1
    };
    this.version = 0;
    return;
case 4:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 4);
    Array['isArray'](array);
    this.uuid = (vvv_tmp0 = ((exports, $__.os.oid0).Math, $__.os.oid3), 'generateUUID', $__.fs.generateUUID_286.call(vvv_tmp0, 9, true, $__.uid));
    this.array = array;
    this.itemSize = itemSize;
    this.normalized = normalized === true;
    this.dynamic = false;
    this.updateRange = $__.os.oid543 = {
        'offset': 0,
        'count': -1
    };
    this.version = 0;
    return;
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (Array.isArray(array)) {
    throw new TypeError('THREE.BufferAttribute: array should be a Typed Array.');
}
this.uuid = exports.Math.generateUUID();
this.array = array;
this.itemSize = itemSize;
this.normalized = normalized === true;
this.dynamic = false;
this.updateRange = {
    offset: 0,
    count: -1
};
this.version = 0;});
    Int8Attribute = ($__.fs.Int8Attribute_82 = function Int8Attribute(array, itemSize) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
array = arguments[0], itemSize = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return new BufferAttribute(new Int8Array(array), itemSize);});
    Uint8Attribute = ($__.fs.Uint8Attribute_83 = function Uint8Attribute(array, itemSize) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
array = arguments[0], itemSize = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return new BufferAttribute(new Uint8Array(array), itemSize);});
    Uint8ClampedAttribute = ($__.fs.Uint8ClampedAttribute_84 = function Uint8ClampedAttribute(array, itemSize) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
array = arguments[0], itemSize = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return new BufferAttribute(new Uint8ClampedArray(array), itemSize);});
    Int16Attribute = ($__.fs.Int16Attribute_85 = function Int16Attribute(array, itemSize) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
array = arguments[0], itemSize = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return new BufferAttribute(new Int16Array(array), itemSize);});
    Uint16Attribute = ($__.fs.Uint16Attribute_86 = function Uint16Attribute(array, itemSize) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
array = arguments[0], itemSize = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return new BufferAttribute(new Uint16Array(array), itemSize);});
    Int32Attribute = ($__.fs.Int32Attribute_87 = function Int32Attribute(array, itemSize) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
array = arguments[0], itemSize = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return new BufferAttribute(new Int32Array(array), itemSize);});
    Uint32Attribute = ($__.fs.Uint32Attribute_88 = function Uint32Attribute(array, itemSize) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
array = arguments[0], itemSize = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return new BufferAttribute(new Uint32Array(array), itemSize);});
    Float32Attribute = ($__.fs.Float32Attribute_89 = function Float32Attribute(array, itemSize) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
array = arguments[0], itemSize = arguments[1];
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    return new (BufferAttribute, $__.fs.BufferAttribute_81)(new Float32Array(array), itemSize, 0, true, $__.uid);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return new BufferAttribute(new Float32Array(array), itemSize);});
    Float64Attribute = ($__.fs.Float64Attribute_90 = function Float64Attribute(array, itemSize) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
array = arguments[0], itemSize = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return new BufferAttribute(new Float64Array(array), itemSize);});
    DynamicBufferAttribute = ($__.fs.DynamicBufferAttribute_91 = function DynamicBufferAttribute(array, itemSize) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
array = arguments[0], itemSize = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
console.warn('THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead.');
return new BufferAttribute(array, itemSize).setDynamic(true);});
    Face3 = ($__.fs.Face3_92 = function Face3(a, b, c, normal, color, materialIndex) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
a = arguments[0], b = arguments[1], c = arguments[2], normal = arguments[3], color = arguments[4], materialIndex = arguments[5];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.a = a;
this.b = b;
this.c = c;
this.normal = normal && normal.isVector3 ? normal : new Vector3();
this.vertexNormals = Array.isArray(normal) ? normal : [];
this.color = color && color.isColor ? color : new Color();
this.vertexColors = Array.isArray(color) ? color : [];
this.materialIndex = materialIndex !== undefined ? materialIndex : 0;});
    Euler = ($__.fs.Euler_93 = function Euler(x, y, z, order) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
x = arguments[0], y = arguments[1], z = arguments[2], order = arguments[3];
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    this._x = (x, 0);
    this._y = (y, 0);
    this._z = (z, 0);
    this._order = (order, TAJS_restrictToType(Euler.DefaultOrder, 'string'));
    return;
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this._x = x || 0;
this._y = y || 0;
this._z = z || 0;
this._order = order || Euler.DefaultOrder;});
    Layers = ($__.fs.Layers_94 = function Layers() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    this.mask = 1;
    return;
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.mask = 1;});
    Object3D = ($__.fs.Object3D_95 = function Object3D() {
var vvv_return, vvv_switch, vvv_tmp0, vvv_tmp1, vvv_tmp2, vvv_tmp3, position, rotation, quaternion, scale, onRotationChange, onQuaternionChange;
onRotationChange = function onRotationChange() {
    quaternion.setFromEuler(rotation, false);
};
onQuaternionChange = function onQuaternionChange() {
    rotation.setFromQuaternion(quaternion, undefined, false);
};
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    onRotationChange = ($__.fs.onRotationChange_1450 = function onRotationChange() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
quaternion.setFromEuler(rotation, false);});
    onQuaternionChange = ($__.fs.onQuaternionChange_1451 = function onQuaternionChange() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
rotation.setFromQuaternion(quaternion, undefined, false);});
    Object['defineProperty'](this, 'id', $__.os.oid521 = {
        'value': (Object3DIdCount, $__.fs.Object3DIdCount_96)(0, true, $__.uid)
    });
    this.uuid = (vvv_tmp0 = ((exports, $__.os.oid0).Math, $__.os.oid3), 'generateUUID', $__.fs.generateUUID_286.call(vvv_tmp0, 2, true, $__.uid));
    this.name = '';
    this.type = 'Object3D';
    this.parent = null;
    this.children = [];
    this.up = (vvv_tmp1 = TAJS_restrictToType(Object3D.DefaultUp, 'object'), 'clone', $__.fs.J$__v494107025_349_444.call(vvv_tmp1, 0, true, $__.uid));
    position = new (Vector3, $__.fs.Vector3_11)(95, true, $__.uid);
    rotation = new (Euler, $__.fs.Euler_93)(0, true, $__.uid);
    quaternion = new (Quaternion, $__.fs.Quaternion_10)(7, true, $__.uid);
    scale = new (Vector3, $__.fs.Vector3_11)(1, 1, 1, 96, true, $__.uid);
    vvv_tmp2 = rotation, 'onChange', $__.fs.J$__v494107025_1221_776.call(vvv_tmp2, (onRotationChange, $__.fs.onRotationChange_1450), 0, true, $__.uid);
    vvv_tmp3 = quaternion, 'onChange', $__.fs.J$__v494107025_326_425.call(vvv_tmp3, (onQuaternionChange, $__.fs.onQuaternionChange_1451), 0, true, $__.uid);
    Object['defineProperties'](this, $__.os.oid528 = {
        'position': $__.os.oid522 = {
            'enumerable': true,
            'value': position
        },
        'rotation': $__.os.oid523 = {
            'enumerable': true,
            'value': rotation
        },
        'quaternion': $__.os.oid524 = {
            'enumerable': true,
            'value': quaternion
        },
        'scale': $__.os.oid525 = {
            'enumerable': true,
            'value': scale
        },
        'modelViewMatrix': $__.os.oid526 = {
            'value': new (Matrix4, $__.fs.Matrix4_9)(10, true, $__.uid)
        },
        'normalMatrix': $__.os.oid527 = {
            'value': new (Matrix3, $__.fs.Matrix3_61)(3, true, $__.uid)
        }
    });
    this.matrix = new (Matrix4, $__.fs.Matrix4_9)(11, true, $__.uid);
    this.matrixWorld = new (Matrix4, $__.fs.Matrix4_9)(12, true, $__.uid);
    this.matrixAutoUpdate = (Object3D.DefaultMatrixAutoUpdate, true);
    this.matrixWorldNeedsUpdate = false;
    this.layers = new (Layers, $__.fs.Layers_94)(0, true, $__.uid);
    this.visible = true;
    this.castShadow = false;
    this.receiveShadow = false;
    this.frustumCulled = true;
    this.renderOrder = 0;
    this.userData = $__.os.oid529 = {};
    return;
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
Object.defineProperty(this, 'id', {
    value: Object3DIdCount()
});
this.uuid = exports.Math.generateUUID();
this.name = '';
this.type = 'Object3D';
this.parent = null;
this.children = [];
this.up = Object3D.DefaultUp.clone();
position = new Vector3();
rotation = new Euler();
quaternion = new Quaternion();
scale = new Vector3(1, 1, 1);
rotation.onChange(onRotationChange);
quaternion.onChange(onQuaternionChange);
Object.defineProperties(this, {
    position: {
        enumerable: true,
        value: position
    },
    rotation: {
        enumerable: true,
        value: rotation
    },
    quaternion: {
        enumerable: true,
        value: quaternion
    },
    scale: {
        enumerable: true,
        value: scale
    },
    modelViewMatrix: {
        value: new Matrix4()
    },
    normalMatrix: {
        value: new Matrix3()
    }
});
this.matrix = new Matrix4();
this.matrixWorld = new Matrix4();
this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;
this.matrixWorldNeedsUpdate = false;
this.layers = new Layers();
this.visible = true;
this.castShadow = false;
this.receiveShadow = false;
this.frustumCulled = true;
this.renderOrder = 0;
this.userData = {};}, $__.fs.Object3D_95);
    Object3DIdCount = ($__.fs.Object3DIdCount_96 = function Object3DIdCount() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    return (count$3 = +count$3 + 1) - 1;
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return count$3++;});
    Geometry = ($__.fs.Geometry_97 = function Geometry() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
Object.defineProperty(this, 'id', {
    value: GeometryIdCount()
});
this.uuid = exports.Math.generateUUID();
this.name = '';
this.type = 'Geometry';
this.vertices = [];
this.colors = [];
this.faces = [];
this.faceVertexUvs = [[]];
this.morphTargets = [];
this.morphNormals = [];
this.skinWeights = [];
this.skinIndices = [];
this.lineDistances = [];
this.boundingBox = null;
this.boundingSphere = null;
this.elementsNeedUpdate = false;
this.verticesNeedUpdate = false;
this.uvsNeedUpdate = false;
this.normalsNeedUpdate = false;
this.colorsNeedUpdate = false;
this.lineDistancesNeedUpdate = false;
this.groupsNeedUpdate = false;});
    GeometryIdCount = ($__.fs.GeometryIdCount_98 = function GeometryIdCount() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
switch (vvv_switch) {
case 0:
case 1:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(0 <= vvv_switch && vvv_switch <= 1);
    return (count$2 = +count$2 + 1) - 1;
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return count$2++;});
    DirectGeometry = ($__.fs.DirectGeometry_99 = function DirectGeometry() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
Object.defineProperty(this, 'id', {
    value: GeometryIdCount()
});
this.uuid = exports.Math.generateUUID();
this.name = '';
this.type = 'DirectGeometry';
this.indices = [];
this.vertices = [];
this.normals = [];
this.colors = [];
this.uvs = [];
this.uvs2 = [];
this.groups = [];
this.morphTargets = {};
this.skinWeights = [];
this.skinIndices = [];
this.boundingBox = null;
this.boundingSphere = null;
this.verticesNeedUpdate = false;
this.normalsNeedUpdate = false;
this.colorsNeedUpdate = false;
this.uvsNeedUpdate = false;
this.groupsNeedUpdate = false;});
    BufferGeometry = ($__.fs.BufferGeometry_100 = function BufferGeometry() {
var vvv_return, vvv_switch, vvv_tmp0;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    Object['defineProperty'](this, 'id', $__.os.oid530 = {
        'value': (GeometryIdCount, $__.fs.GeometryIdCount_98)(0, true, $__.uid)
    });
    this.uuid = (vvv_tmp0 = ((exports, $__.os.oid0).Math, $__.os.oid3), 'generateUUID', $__.fs.generateUUID_286.call(vvv_tmp0, 3, true, $__.uid));
    this.name = '';
    this.type = 'BufferGeometry';
    this.index = null;
    this.attributes = $__.os.oid531 = {};
    this.morphAttributes = $__.os.oid532 = {};
    this.groups = [];
    this.boundingBox = null;
    this.boundingSphere = null;
    this.drawRange = $__.os.oid533 = {
        'start': 0,
        'count': Infinity
    };
    return;
case 1:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 1);
    Object['defineProperty'](this, 'id', $__.os.oid535 = {
        'value': (GeometryIdCount, $__.fs.GeometryIdCount_98)(1, true, $__.uid)
    });
    this.uuid = (vvv_tmp0 = ((exports, $__.os.oid0).Math, $__.os.oid3), 'generateUUID', $__.fs.generateUUID_286.call(vvv_tmp0, 5, true, $__.uid));
    this.name = '';
    this.type = 'BufferGeometry';
    this.index = null;
    this.attributes = $__.os.oid536 = {};
    this.morphAttributes = $__.os.oid537 = {};
    this.groups = [];
    this.boundingBox = null;
    this.boundingSphere = null;
    this.drawRange = $__.os.oid538 = {
        'start': 0,
        'count': Infinity
    };
    return;
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
Object.defineProperty(this, 'id', {
    value: GeometryIdCount()
});
this.uuid = exports.Math.generateUUID();
this.name = '';
this.type = 'BufferGeometry';
this.index = null;
this.attributes = {};
this.morphAttributes = {};
this.groups = [];
this.boundingBox = null;
this.boundingSphere = null;
this.drawRange = {
    start: 0,
    count: Infinity
};}, $__.fs.BufferGeometry_100);
    WebGLGeometries = ($__.fs.WebGLGeometries_101 = function WebGLGeometries(gl, properties, info) {
var vvv_return, vvv_switch, geometries, onGeometryDispose, getAttributeBuffer, deleteAttribute, deleteAttributes, removeAttributeBuffer;
onGeometryDispose = function onGeometryDispose(event) {
    var geometry = event.target;
    var buffergeometry = geometries[geometry.id];
    if (buffergeometry.index !== null) {
        deleteAttribute(buffergeometry.index);
    }
    deleteAttributes(buffergeometry.attributes);
    geometry.removeEventListener('dispose', onGeometryDispose);
    delete geometries[geometry.id];
    var property = properties.get(geometry);
    if (property.wireframe) {
        deleteAttribute(property.wireframe);
    }
    properties.delete(geometry);
    var bufferproperty = properties.get(buffergeometry);
    if (bufferproperty.wireframe) {
        deleteAttribute(bufferproperty.wireframe);
    }
    properties.delete(buffergeometry);
    info.memory.geometries--;
};
getAttributeBuffer = function getAttributeBuffer(attribute) {
    if (attribute.isInterleavedBufferAttribute) {
        return properties.get(attribute.data).__webglBuffer;
    }
    return properties.get(attribute).__webglBuffer;
};
deleteAttribute = function deleteAttribute(attribute) {
    var buffer = getAttributeBuffer(attribute);
    if (buffer !== undefined) {
        gl.deleteBuffer(buffer);
        removeAttributeBuffer(attribute);
    }
};
deleteAttributes = function deleteAttributes(attributes) {
    for (var name in attributes) {
        deleteAttribute(attributes[name]);
    }
};
removeAttributeBuffer = function removeAttributeBuffer(attribute) {
    if (attribute.isInterleavedBufferAttribute) {
        properties.delete(attribute.data);
    } else {
        properties.delete(attribute);
    }
};
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
gl = arguments[0], properties = arguments[1], info = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
geometries = {};
return {
    get: function (object) {
        var geometry = object.geometry;
        if (geometries[geometry.id] !== undefined) {
            return geometries[geometry.id];
        }
        geometry.addEventListener('dispose', onGeometryDispose);
        var buffergeometry;
        if (geometry.isBufferGeometry) {
            buffergeometry = geometry;
        } else if (geometry.isGeometry) {
            if (geometry._bufferGeometry === undefined) {
                geometry._bufferGeometry = new BufferGeometry().setFromObject(object);
            }
            buffergeometry = geometry._bufferGeometry;
        }
        geometries[geometry.id] = buffergeometry;
        info.memory.geometries++;
        return buffergeometry;
    }
};});
    WebGLObjects = ($__.fs.WebGLObjects_102 = function WebGLObjects(gl, properties, info) {
var vvv_return, vvv_switch, geometries, update, updateAttribute, createBuffer, updateBuffer, getAttributeBuffer, getWireframeAttribute, checkEdge;
update = function update(object) {
    var geometry = geometries.get(object);
    if (object.geometry.isGeometry) {
        geometry.updateFromObject(object);
    }
    var index = geometry.index;
    var attributes = geometry.attributes;
    if (index !== null) {
        updateAttribute(index, gl.ELEMENT_ARRAY_BUFFER);
    }
    for (var name in attributes) {
        updateAttribute(attributes[name], gl.ARRAY_BUFFER);
    }
    var morphAttributes = geometry.morphAttributes;
    for (var name in morphAttributes) {
        var array = morphAttributes[name];
        for (var i = 0, l = array.length; i < l; i++) {
            updateAttribute(array[i], gl.ARRAY_BUFFER);
        }
    }
    return geometry;
};
updateAttribute = function updateAttribute(attribute, bufferType) {
    var data = attribute.isInterleavedBufferAttribute ? attribute.data : attribute;
    var attributeProperties = properties.get(data);
    if (attributeProperties.__webglBuffer === undefined) {
        createBuffer(attributeProperties, data, bufferType);
    } else if (attributeProperties.version !== data.version) {
        updateBuffer(attributeProperties, data, bufferType);
    }
};
createBuffer = function createBuffer(attributeProperties, data, bufferType) {
    attributeProperties.__webglBuffer = gl.createBuffer();
    gl.bindBuffer(bufferType, attributeProperties.__webglBuffer);
    var usage = data.dynamic ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;
    gl.bufferData(bufferType, data.array, usage);
    attributeProperties.version = data.version;
};
updateBuffer = function updateBuffer(attributeProperties, data, bufferType) {
    gl.bindBuffer(bufferType, attributeProperties.__webglBuffer);
    if (data.dynamic === false || data.updateRange.count === -1) {
        gl.bufferSubData(bufferType, 0, data.array);
    } else if (data.updateRange.count === 0) {
        console.error('THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.');
    } else {
        gl.bufferSubData(bufferType, data.updateRange.offset * data.array.BYTES_PER_ELEMENT, data.array.subarray(data.updateRange.offset, data.updateRange.offset + data.updateRange.count));
        data.updateRange.count = 0;
    }
    attributeProperties.version = data.version;
};
getAttributeBuffer = function getAttributeBuffer(attribute) {
    if (attribute.isInterleavedBufferAttribute) {
        return properties.get(attribute.data).__webglBuffer;
    }
    return properties.get(attribute).__webglBuffer;
};
getWireframeAttribute = function getWireframeAttribute(geometry) {
    var property = properties.get(geometry);
    if (property.wireframe !== undefined) {
        return property.wireframe;
    }
    var indices = [];
    var index = geometry.index;
    var attributes = geometry.attributes;
    var position = attributes.position;
    if (index !== null) {
        var edges = {};
        var array = index.array;
        for (var i = 0, l = array.length; i < l; i += 3) {
            var a = array[i + 0];
            var b = array[i + 1];
            var c = array[i + 2];
            if (checkEdge(edges, a, b))
                indices.push(a, b);
            if (checkEdge(edges, b, c))
                indices.push(b, c);
            if (checkEdge(edges, c, a))
                indices.push(c, a);
        }
    } else {
        var array = attributes.position.array;
        for (var i = 0, l = array.length / 3 - 1; i < l; i += 3) {
            var a = i + 0;
            var b = i + 1;
            var c = i + 2;
            indices.push(a, b, b, c, c, a);
        }
    }
    var TypeArray = position.count > 65535 ? Uint32Array : Uint16Array;
    var attribute = new BufferAttribute(new TypeArray(indices), 1);
    updateAttribute(attribute, gl.ELEMENT_ARRAY_BUFFER);
    property.wireframe = attribute;
    return attribute;
};
checkEdge = function checkEdge(edges, a, b) {
    if (a > b) {
        var tmp = a;
        a = b;
        b = tmp;
    }
    var list = edges[a];
    if (list === undefined) {
        edges[a] = [b];
        return true;
    } else if (list.indexOf(b) === -1) {
        list.push(b);
        return true;
    }
    return false;
};
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
gl = arguments[0], properties = arguments[1], info = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
geometries = new WebGLGeometries(gl, properties, info);
return {
    getAttributeBuffer: getAttributeBuffer,
    getWireframeAttribute: getWireframeAttribute,
    update: update
};});
    WebGLLights = ($__.fs.WebGLLights_103 = function WebGLLights() {
var vvv_return, vvv_switch, lights;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
lights = {};
return {
    get: function (light) {
        if (lights[light.id] !== undefined) {
            return lights[light.id];
        }
        var uniforms;
        switch (light.type) {
        case 'DirectionalLight':
            uniforms = {
                direction: new Vector3(),
                color: new Color(),
                shadow: false,
                shadowBias: 0,
                shadowRadius: 1,
                shadowMapSize: new Vector2()
            };
            break;
        case 'SpotLight':
            uniforms = {
                position: new Vector3(),
                direction: new Vector3(),
                color: new Color(),
                distance: 0,
                coneCos: 0,
                penumbraCos: 0,
                decay: 0,
                shadow: false,
                shadowBias: 0,
                shadowRadius: 1,
                shadowMapSize: new Vector2()
            };
            break;
        case 'PointLight':
            uniforms = {
                position: new Vector3(),
                color: new Color(),
                distance: 0,
                decay: 0,
                shadow: false,
                shadowBias: 0,
                shadowRadius: 1,
                shadowMapSize: new Vector2()
            };
            break;
        case 'HemisphereLight':
            uniforms = {
                direction: new Vector3(),
                skyColor: new Color(),
                groundColor: new Color()
            };
            break;
        }
        lights[light.id] = uniforms;
        return uniforms;
    }
};});
    WebGLCapabilities = ($__.fs.WebGLCapabilities_104 = function WebGLCapabilities(gl, extensions, parameters) {
var vvv_return, vvv_switch, maxAnisotropy, getMaxAnisotropy, getMaxPrecision, precision, maxPrecision, logarithmicDepthBuffer, maxTextures, maxVertexTextures, maxTextureSize, maxCubemapSize, maxAttributes, maxVertexUniforms, maxVaryings, maxFragmentUniforms, vertexTextures, floatFragmentTextures, floatVertexTextures;
getMaxAnisotropy = function getMaxAnisotropy() {
    if (maxAnisotropy !== undefined)
        return maxAnisotropy;
    var extension = extensions.get('EXT_texture_filter_anisotropic');
    if (extension !== null) {
        maxAnisotropy = gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else {
        maxAnisotropy = 0;
    }
    return maxAnisotropy;
};
getMaxPrecision = function getMaxPrecision(precision) {
    if (precision === 'highp') {
        if (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT).precision > 0 && gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT).precision > 0) {
            return 'highp';
        }
        precision = 'mediump';
    }
    if (precision === 'mediump') {
        if (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_FLOAT).precision > 0 && gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT).precision > 0) {
            return 'mediump';
        }
    }
    return 'lowp';
};
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
gl = arguments[0], extensions = arguments[1], parameters = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
precision = parameters.precision !== undefined ? parameters.precision : 'highp';
maxPrecision = getMaxPrecision(precision);
if (maxPrecision !== precision) {
    console.warn('THREE.WebGLRenderer:', precision, 'not supported, using', maxPrecision, 'instead.');
    precision = maxPrecision;
}
logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true && !!extensions.get('EXT_frag_depth');
maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
maxVertexTextures = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
maxCubemapSize = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);
maxAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
maxVertexUniforms = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);
maxVaryings = gl.getParameter(gl.MAX_VARYING_VECTORS);
maxFragmentUniforms = gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS);
vertexTextures = maxVertexTextures > 0;
floatFragmentTextures = !!extensions.get('OES_texture_float');
floatVertexTextures = vertexTextures && floatFragmentTextures;
return {
    getMaxAnisotropy: getMaxAnisotropy,
    getMaxPrecision: getMaxPrecision,
    precision: precision,
    logarithmicDepthBuffer: logarithmicDepthBuffer,
    maxTextures: maxTextures,
    maxVertexTextures: maxVertexTextures,
    maxTextureSize: maxTextureSize,
    maxCubemapSize: maxCubemapSize,
    maxAttributes: maxAttributes,
    maxVertexUniforms: maxVertexUniforms,
    maxVaryings: maxVaryings,
    maxFragmentUniforms: maxFragmentUniforms,
    vertexTextures: vertexTextures,
    floatFragmentTextures: floatFragmentTextures,
    floatVertexTextures: floatVertexTextures
};});
    WebGLExtensions = ($__.fs.WebGLExtensions_105 = function WebGLExtensions(gl) {
var vvv_return, vvv_switch, extensions;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
gl = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
extensions = {};
return {
    get: function (name) {
        if (extensions[name] !== undefined) {
            return extensions[name];
        }
        var extension;
        switch (name) {
        case 'WEBGL_depth_texture':
            extension = gl.getExtension('WEBGL_depth_texture') || gl.getExtension('MOZ_WEBGL_depth_texture') || gl.getExtension('WEBKIT_WEBGL_depth_texture');
            break;
        case 'EXT_texture_filter_anisotropic':
            extension = gl.getExtension('EXT_texture_filter_anisotropic') || gl.getExtension('MOZ_EXT_texture_filter_anisotropic') || gl.getExtension('WEBKIT_EXT_texture_filter_anisotropic');
            break;
        case 'WEBGL_compressed_texture_s3tc':
            extension = gl.getExtension('WEBGL_compressed_texture_s3tc') || gl.getExtension('MOZ_WEBGL_compressed_texture_s3tc') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc');
            break;
        case 'WEBGL_compressed_texture_pvrtc':
            extension = gl.getExtension('WEBGL_compressed_texture_pvrtc') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc');
            break;
        case 'WEBGL_compressed_texture_etc1':
            extension = gl.getExtension('WEBGL_compressed_texture_etc1');
            break;
        default:
            extension = gl.getExtension(name);
        }
        if (extension === null) {
            console.warn('THREE.WebGLRenderer: ' + name + ' extension not supported.');
        }
        extensions[name] = extension;
        return extension;
    }
};});
    WebGLIndexedBufferRenderer = ($__.fs.WebGLIndexedBufferRenderer_106 = function WebGLIndexedBufferRenderer(gl, extensions, infoRender) {
var vvv_return, vvv_switch, mode, setMode, type, size, setIndex, render, renderInstances;
setMode = function setMode(value) {
    mode = value;
};
setIndex = function setIndex(index) {
    if (index.array instanceof Uint32Array && extensions.get('OES_element_index_uint')) {
        type = gl.UNSIGNED_INT;
        size = 4;
    } else {
        type = gl.UNSIGNED_SHORT;
        size = 2;
    }
};
render = function render(start, count) {
    gl.drawElements(mode, count, type, start * size);
    infoRender.calls++;
    infoRender.vertices += count;
    if (mode === gl.TRIANGLES)
        infoRender.faces += count / 3;
};
renderInstances = function renderInstances(geometry, start, count) {
    var extension = extensions.get('ANGLE_instanced_arrays');
    if (extension === null) {
        console.error('THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');
        return;
    }
    extension.drawElementsInstancedANGLE(mode, count, type, start * size, geometry.maxInstancedCount);
    infoRender.calls++;
    infoRender.vertices += count * geometry.maxInstancedCount;
    if (mode === gl.TRIANGLES)
        infoRender.faces += geometry.maxInstancedCount * count / 3;
};
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
gl = arguments[0], extensions = arguments[1], infoRender = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return {
    setMode: setMode,
    setIndex: setIndex,
    render: render,
    renderInstances: renderInstances
};});
    WebGLClipping = ($__.fs.WebGLClipping_107 = function WebGLClipping() {
var vvv_return, vvv_switch, scope, globalState, numGlobalPlanes, localClippingEnabled, renderingShadows, plane, viewNormalMatrix, uniform, resetGlobalState, projectPlanes;
resetGlobalState = function resetGlobalState() {
    if (uniform.value !== globalState) {
        uniform.value = globalState;
        uniform.needsUpdate = numGlobalPlanes > 0;
    }
    scope.numPlanes = numGlobalPlanes;
};
projectPlanes = function projectPlanes(planes, camera, dstOffset, skipTransform) {
    var nPlanes = planes !== null ? planes.length : 0, dstArray = null;
    if (nPlanes !== 0) {
        dstArray = uniform.value;
        if (skipTransform !== true || dstArray === null) {
            var flatSize = dstOffset + nPlanes * 4, viewMatrix = camera.matrixWorldInverse;
            viewNormalMatrix.getNormalMatrix(viewMatrix);
            if (dstArray === null || dstArray.length < flatSize) {
                dstArray = new Float32Array(flatSize);
            }
            for (var i = 0, i4 = dstOffset; i !== nPlanes; ++i, i4 += 4) {
                plane.copy(planes[i]).applyMatrix4(viewMatrix, viewNormalMatrix);
                plane.normal.toArray(dstArray, i4);
                dstArray[i4 + 3] = plane.constant;
            }
        }
        uniform.value = dstArray;
        uniform.needsUpdate = true;
    }
    scope.numPlanes = nPlanes;
    return dstArray;
};
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
scope = this;
globalState = null;
numGlobalPlanes = 0;
localClippingEnabled = false;
renderingShadows = false;
plane = new Plane();
viewNormalMatrix = new Matrix3();
uniform = {
    value: null,
    needsUpdate: false
};
this.uniform = uniform;
this.numPlanes = 0;
this.init = function (planes, enableLocalClipping, camera) {
    var enabled = planes.length !== 0 || enableLocalClipping || numGlobalPlanes !== 0 || localClippingEnabled;
    localClippingEnabled = enableLocalClipping;
    globalState = projectPlanes(planes, camera, 0);
    numGlobalPlanes = planes.length;
    return enabled;
};
this.beginShadows = function () {
    renderingShadows = true;
    projectPlanes(null);
};
this.endShadows = function () {
    renderingShadows = false;
    resetGlobalState();
};
this.setState = function (planes, clipShadows, camera, cache, fromCache) {
    if (!localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && !clipShadows) {
        if (renderingShadows) {
            projectPlanes(null);
        } else {
            resetGlobalState();
        }
    } else {
        var nGlobal = renderingShadows ? 0 : numGlobalPlanes, lGlobal = nGlobal * 4, dstArray = cache.clippingState || null;
        uniform.value = dstArray;
        dstArray = projectPlanes(planes, camera, lGlobal, fromCache);
        for (var i = 0; i !== lGlobal; ++i) {
            dstArray[i] = globalState[i];
        }
        cache.clippingState = dstArray;
        this.numPlanes += nGlobal;
    }
};});
    WebGLBufferRenderer = ($__.fs.WebGLBufferRenderer_108 = function WebGLBufferRenderer(gl, extensions, infoRender) {
var vvv_return, vvv_switch, mode, setMode, render, renderInstances;
setMode = function setMode(value) {
    mode = value;
};
render = function render(start, count) {
    gl.drawArrays(mode, start, count);
    infoRender.calls++;
    infoRender.vertices += count;
    if (mode === gl.TRIANGLES)
        infoRender.faces += count / 3;
};
renderInstances = function renderInstances(geometry) {
    var extension = extensions.get('ANGLE_instanced_arrays');
    if (extension === null) {
        console.error('THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');
        return;
    }
    var position = geometry.attributes.position;
    var count = 0;
    if (position && position.isInterleavedBufferAttribute) {
        count = position.data.count;
        extension.drawArraysInstancedANGLE(mode, 0, count, geometry.maxInstancedCount);
    } else {
        count = position.count;
        extension.drawArraysInstancedANGLE(mode, 0, count, geometry.maxInstancedCount);
    }
    infoRender.calls++;
    infoRender.vertices += count * geometry.maxInstancedCount;
    if (mode === gl.TRIANGLES)
        infoRender.faces += geometry.maxInstancedCount * count / 3;
};
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
gl = arguments[0], extensions = arguments[1], infoRender = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return {
    setMode: setMode,
    render: render,
    renderInstances: renderInstances
};});
    WebGLRenderTargetCube = ($__.fs.WebGLRenderTargetCube_109 = function WebGLRenderTargetCube(width, height, options) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
width = arguments[0], height = arguments[1], options = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
WebGLRenderTarget.call(this, width, height, options);
this.activeCubeFace = 0;
this.activeMipMapLevel = 0;});
    BoxBufferGeometry = ($__.fs.BoxBufferGeometry_110 = function BoxBufferGeometry(width, height, depth, widthSegments, heightSegments, depthSegments) {
var vvv_return, vvv_switch, scope, vertexCount, indexCount, indices, vertices, normals, uvs, vertexBufferOffset, uvBufferOffset, indexBufferOffset, numberOfVertices, groupStart, calculateVertexCount, calculateIndexCount, buildPlane;
calculateVertexCount = function calculateVertexCount(w, h, d) {
    var vertices = 0;
    vertices += (w + 1) * (h + 1) * 2;
    vertices += (w + 1) * (d + 1) * 2;
    vertices += (d + 1) * (h + 1) * 2;
    return vertices;
};
calculateIndexCount = function calculateIndexCount(w, h, d) {
    var index = 0;
    index += w * h * 2;
    index += w * d * 2;
    index += d * h * 2;
    return index * 6;
};
buildPlane = function buildPlane(u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex) {
    var segmentWidth = width / gridX;
    var segmentHeight = height / gridY;
    var widthHalf = width / 2;
    var heightHalf = height / 2;
    var depthHalf = depth / 2;
    var gridX1 = gridX + 1;
    var gridY1 = gridY + 1;
    var vertexCounter = 0;
    var groupCount = 0;
    var vector = new Vector3();
    for (var iy = 0; iy < gridY1; iy++) {
        var y = iy * segmentHeight - heightHalf;
        for (var ix = 0; ix < gridX1; ix++) {
            var x = ix * segmentWidth - widthHalf;
            vector[u] = x * udir;
            vector[v] = y * vdir;
            vector[w] = depthHalf;
            vertices[vertexBufferOffset] = vector.x;
            vertices[vertexBufferOffset + 1] = vector.y;
            vertices[vertexBufferOffset + 2] = vector.z;
            vector[u] = 0;
            vector[v] = 0;
            vector[w] = depth > 0 ? 1 : -1;
            normals[vertexBufferOffset] = vector.x;
            normals[vertexBufferOffset + 1] = vector.y;
            normals[vertexBufferOffset + 2] = vector.z;
            uvs[uvBufferOffset] = ix / gridX;
            uvs[uvBufferOffset + 1] = 1 - iy / gridY;
            vertexBufferOffset += 3;
            uvBufferOffset += 2;
            vertexCounter += 1;
        }
    }
    for (iy = 0; iy < gridY; iy++) {
        for (ix = 0; ix < gridX; ix++) {
            var a = numberOfVertices + ix + gridX1 * iy;
            var b = numberOfVertices + ix + gridX1 * (iy + 1);
            var c = numberOfVertices + (ix + 1) + gridX1 * (iy + 1);
            var d = numberOfVertices + (ix + 1) + gridX1 * iy;
            indices[indexBufferOffset] = a;
            indices[indexBufferOffset + 1] = b;
            indices[indexBufferOffset + 2] = d;
            indices[indexBufferOffset + 3] = b;
            indices[indexBufferOffset + 4] = c;
            indices[indexBufferOffset + 5] = d;
            indexBufferOffset += 6;
            groupCount += 6;
        }
    }
    scope.addGroup(groupStart, groupCount, materialIndex);
    groupStart += groupCount;
    numberOfVertices += vertexCounter;
};
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
width = arguments[0], height = arguments[1], depth = arguments[2], widthSegments = arguments[3], heightSegments = arguments[4], depthSegments = arguments[5];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
BufferGeometry.call(this);
this.type = 'BoxBufferGeometry';
this.parameters = {
    width: width,
    height: height,
    depth: depth,
    widthSegments: widthSegments,
    heightSegments: heightSegments,
    depthSegments: depthSegments
};
scope = this;
widthSegments = Math.floor(widthSegments) || 1;
heightSegments = Math.floor(heightSegments) || 1;
depthSegments = Math.floor(depthSegments) || 1;
vertexCount = calculateVertexCount(widthSegments, heightSegments, depthSegments);
indexCount = calculateIndexCount(widthSegments, heightSegments, depthSegments);
indices = new (indexCount > 65535 ? Uint32Array : Uint16Array)(indexCount);
vertices = new Float32Array(vertexCount * 3);
normals = new Float32Array(vertexCount * 3);
uvs = new Float32Array(vertexCount * 2);
vertexBufferOffset = 0;
uvBufferOffset = 0;
indexBufferOffset = 0;
numberOfVertices = 0;
groupStart = 0;
buildPlane('z', 'y', 'x', -1, -1, depth, height, width, depthSegments, heightSegments, 0);
buildPlane('z', 'y', 'x', 1, -1, depth, height, -width, depthSegments, heightSegments, 1);
buildPlane('x', 'z', 'y', 1, 1, width, depth, height, widthSegments, depthSegments, 2);
buildPlane('x', 'z', 'y', 1, -1, width, depth, -height, widthSegments, depthSegments, 3);
buildPlane('x', 'y', 'z', 1, -1, width, height, depth, widthSegments, heightSegments, 4);
buildPlane('x', 'y', 'z', -1, -1, width, height, -depth, widthSegments, heightSegments, 5);
this.setIndex(new BufferAttribute(indices, 1));
this.addAttribute('position', new BufferAttribute(vertices, 3));
this.addAttribute('normal', new BufferAttribute(normals, 3));
this.addAttribute('uv', new BufferAttribute(uvs, 2));});
    Ray = ($__.fs.Ray_111 = function Ray(origin, direction) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
origin = arguments[0], direction = arguments[1];
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    this.origin = (origin !== undefined, new (Vector3, $__.fs.Vector3_11)(57, true, $__.uid));
    this.direction = (direction !== undefined, new (Vector3, $__.fs.Vector3_11)(58, true, $__.uid));
    return;
case 1:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 1);
    this.origin = (origin !== undefined, new (Vector3, $__.fs.Vector3_11)(73, true, $__.uid));
    this.direction = (direction !== undefined, new (Vector3, $__.fs.Vector3_11)(74, true, $__.uid));
    return;
case 2:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 2);
    this.origin = (origin !== undefined, new (Vector3, $__.fs.Vector3_11)(76, true, $__.uid));
    this.direction = (direction !== undefined, new (Vector3, $__.fs.Vector3_11)(77, true, $__.uid));
    return;
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.origin = origin !== undefined ? origin : new Vector3();
this.direction = direction !== undefined ? direction : new Vector3();});
    Line3 = ($__.fs.Line3_112 = function Line3(start, end) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
start = arguments[0], end = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.start = start !== undefined ? start : new Vector3();
this.end = end !== undefined ? end : new Vector3();});
    Triangle = ($__.fs.Triangle_113 = function Triangle(a, b, c) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
a = arguments[0], b = arguments[1], c = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.a = a !== undefined ? a : new Vector3();
this.b = b !== undefined ? b : new Vector3();
this.c = c !== undefined ? c : new Vector3();});
    MeshBasicMaterial = ($__.fs.MeshBasicMaterial_114 = function MeshBasicMaterial(parameters) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
parameters = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
Material.call(this);
this.type = 'MeshBasicMaterial';
this.color = new Color(16777215);
this.map = null;
this.aoMap = null;
this.aoMapIntensity = 1;
this.specularMap = null;
this.alphaMap = null;
this.envMap = null;
this.combine = MultiplyOperation;
this.reflectivity = 1;
this.refractionRatio = 0.98;
this.wireframe = false;
this.wireframeLinewidth = 1;
this.wireframeLinecap = 'round';
this.wireframeLinejoin = 'round';
this.skinning = false;
this.morphTargets = false;
this.lights = false;
this.setValues(parameters);});
    Mesh = ($__.fs.Mesh_115 = function Mesh(geometry, material) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
geometry = arguments[0], material = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
Object3D.call(this);
this.type = 'Mesh';
this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
this.material = material !== undefined ? material : new MeshBasicMaterial({
    color: Math.random() * 16777215
});
this.drawMode = TrianglesDrawMode;
this.updateMorphTargets();});
    PlaneBufferGeometry = ($__.fs.PlaneBufferGeometry_116 = function PlaneBufferGeometry(width, height, widthSegments, heightSegments) {
var vvv_return, vvv_switch, width_half, height_half, gridX, gridY, gridX1, gridY1, segment_width, segment_height, vertices, normals, uvs, offset, offset2, y, x, indices, a, b, c, d;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
width = arguments[0], height = arguments[1], widthSegments = arguments[2], heightSegments = arguments[3];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
BufferGeometry.call(this);
this.type = 'PlaneBufferGeometry';
this.parameters = {
    width: width,
    height: height,
    widthSegments: widthSegments,
    heightSegments: heightSegments
};
width_half = width / 2;
height_half = height / 2;
gridX = Math.floor(widthSegments) || 1;
gridY = Math.floor(heightSegments) || 1;
gridX1 = gridX + 1;
gridY1 = gridY + 1;
segment_width = width / gridX;
segment_height = height / gridY;
vertices = new Float32Array(gridX1 * gridY1 * 3);
normals = new Float32Array(gridX1 * gridY1 * 3);
uvs = new Float32Array(gridX1 * gridY1 * 2);
offset = 0;
offset2 = 0;
for (var iy = 0; iy < gridY1; iy++) {
    y = iy * segment_height - height_half;
    for (var ix = 0; ix < gridX1; ix++) {
        x = ix * segment_width - width_half;
        vertices[offset] = x;
        vertices[offset + 1] = -y;
        normals[offset + 2] = 1;
        uvs[offset2] = ix / gridX;
        uvs[offset2 + 1] = 1 - iy / gridY;
        offset += 3;
        offset2 += 2;
    }
}
offset = 0;
indices = new (vertices.length / 3 > 65535 ? Uint32Array : Uint16Array)(gridX * gridY * 6);
for (var iy = 0; iy < gridY; iy++) {
    for (var ix = 0; ix < gridX; ix++) {
        a = ix + gridX1 * iy;
        b = ix + gridX1 * (iy + 1);
        c = ix + 1 + gridX1 * (iy + 1);
        d = ix + 1 + gridX1 * iy;
        indices[offset] = a;
        indices[offset + 1] = b;
        indices[offset + 2] = d;
        indices[offset + 3] = b;
        indices[offset + 4] = c;
        indices[offset + 5] = d;
        offset += 6;
    }
}
this.setIndex(new BufferAttribute(indices, 1));
this.addAttribute('position', new BufferAttribute(vertices, 3));
this.addAttribute('normal', new BufferAttribute(normals, 3));
this.addAttribute('uv', new BufferAttribute(uvs, 2));});
    Camera = ($__.fs.Camera_117 = function Camera() {
var vvv_return, vvv_switch, vvv_tmp0;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    vvv_tmp0 = this, (Object3D, $__.fs.Object3D_95).call(vvv_tmp0, 0, true, $__.uid);
    this.type = 'Camera';
    this.matrixWorldInverse = new (Matrix4, $__.fs.Matrix4_9)(13, true, $__.uid);
    this.projectionMatrix = new (Matrix4, $__.fs.Matrix4_9)(14, true, $__.uid);
    return;
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
Object3D.call(this);
this.type = 'Camera';
this.matrixWorldInverse = new Matrix4();
this.projectionMatrix = new Matrix4();});
    PerspectiveCamera = ($__.fs.PerspectiveCamera_118 = function PerspectiveCamera(fov, aspect, near, far) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
fov = arguments[0], aspect = arguments[1], near = arguments[2], far = arguments[3];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
Camera.call(this);
this.type = 'PerspectiveCamera';
this.fov = fov !== undefined ? fov : 50;
this.zoom = 1;
this.near = near !== undefined ? near : 0.1;
this.far = far !== undefined ? far : 2000;
this.focus = 10;
this.aspect = aspect !== undefined ? aspect : 1;
this.view = null;
this.filmGauge = 35;
this.filmOffset = 0;
this.updateProjectionMatrix();});
    OrthographicCamera = ($__.fs.OrthographicCamera_119 = function OrthographicCamera(left, right, top, bottom, near, far) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
left = arguments[0], right = arguments[1], top = arguments[2], bottom = arguments[3], near = arguments[4], far = arguments[5];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
Camera.call(this);
this.type = 'OrthographicCamera';
this.zoom = 1;
this.view = null;
this.left = left;
this.right = right;
this.top = top;
this.bottom = bottom;
this.near = near !== undefined ? near : 0.1;
this.far = far !== undefined ? far : 2000;
this.updateProjectionMatrix();});
    WebGLRenderer = ($__.fs.WebGLRenderer_120 = function WebGLRenderer(parameters) {
var vvv_return, vvv_switch, _canvas, _context, _alpha, _depth, _stencil, _antialias, _premultipliedAlpha, _preserveDrawingBuffer, lights, opaqueObjects, opaqueObjectsLastIndex, transparentObjects, transparentObjectsLastIndex, morphInfluences, sprites, lensFlares, _this, _currentProgram, _currentRenderTarget, _currentFramebuffer, _currentMaterialId, _currentGeometryProgram, _currentCamera, _currentScissor, _currentScissorTest, _currentViewport, _usedTextureUnits, _clearColor, _clearAlpha, _width, _height, _pixelRatio, _scissor, _scissorTest, _viewport, _frustum, _clipping, _clippingEnabled, _localClippingEnabled, _sphere, _projScreenMatrix, _vector3, _lights, _infoRender, _gl, attributes, extensions, capabilities, state, properties, textures, objects, programCache, lightCache, bufferRenderer, indexedBufferRenderer, backgroundCamera, backgroundCamera2, backgroundPlaneMesh, backgroundBoxShader, backgroundBoxMesh, getTargetPixelRatio, glClearColor, setDefaultGLState, resetGLState, shadowMap, spritePlugin, lensFlarePlugin, onContextLost, onMaterialDispose, deallocateMaterial, releaseMaterialProgramReference, setupVertexAttributes, absNumericalSort, painterSortStable, reversePainterSortStable, pushRenderItem, isObjectViewable, isSpriteViewable, isSphereViewable, projectObject, renderObjects, initMaterial, setMaterial, setProgram, refreshUniformsCommon, refreshUniformsLine, refreshUniformsDash, refreshUniformsPoints, refreshUniformsFog, refreshUniformsLambert, refreshUniformsPhong, refreshUniformsStandard, refreshUniformsPhysical, markUniformsLightsNeedsUpdate, setupShadows, setupLights, allocTextureUnit, paramThreeToGL;
getTargetPixelRatio = function getTargetPixelRatio() {
    return _currentRenderTarget === null ? _pixelRatio : 1;
};
glClearColor = function glClearColor(r, g, b, a) {
    if (_premultipliedAlpha === true) {
        r *= a;
        g *= a;
        b *= a;
    }
    state.clearColor(r, g, b, a);
};
setDefaultGLState = function setDefaultGLState() {
    state.init();
    state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio));
    state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio));
    glClearColor(_clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha);
};
resetGLState = function resetGLState() {
    _currentProgram = null;
    _currentCamera = null;
    _currentGeometryProgram = '';
    _currentMaterialId = -1;
    state.reset();
};
onContextLost = function onContextLost(event) {
    event.preventDefault();
    resetGLState();
    setDefaultGLState();
    properties.clear();
};
onMaterialDispose = function onMaterialDispose(event) {
    var material = event.target;
    material.removeEventListener('dispose', onMaterialDispose);
    deallocateMaterial(material);
};
deallocateMaterial = function deallocateMaterial(material) {
    releaseMaterialProgramReference(material);
    properties.delete(material);
};
releaseMaterialProgramReference = function releaseMaterialProgramReference(material) {
    var programInfo = properties.get(material).program;
    material.program = undefined;
    if (programInfo !== undefined) {
        programCache.releaseProgram(programInfo);
    }
};
setupVertexAttributes = function setupVertexAttributes(material, program, geometry, startIndex) {
    var extension;
    if (geometry && geometry.isInstancedBufferGeometry) {
        extension = extensions.get('ANGLE_instanced_arrays');
        if (extension === null) {
            console.error('THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');
            return;
        }
    }
    if (startIndex === undefined)
        startIndex = 0;
    state.initAttributes();
    var geometryAttributes = geometry.attributes;
    var programAttributes = program.getAttributes();
    var materialDefaultAttributeValues = material.defaultAttributeValues;
    for (var name in programAttributes) {
        var programAttribute = programAttributes[name];
        if (programAttribute >= 0) {
            var geometryAttribute = geometryAttributes[name];
            if (geometryAttribute !== undefined) {
                var type = _gl.FLOAT;
                var array = geometryAttribute.array;
                var normalized = geometryAttribute.normalized;
                if (array instanceof Float32Array) {
                    type = _gl.FLOAT;
                } else if (array instanceof Float64Array) {
                    console.warn('Unsupported data buffer format: Float64Array');
                } else if (array instanceof Uint16Array) {
                    type = _gl.UNSIGNED_SHORT;
                } else if (array instanceof Int16Array) {
                    type = _gl.SHORT;
                } else if (array instanceof Uint32Array) {
                    type = _gl.UNSIGNED_INT;
                } else if (array instanceof Int32Array) {
                    type = _gl.INT;
                } else if (array instanceof Int8Array) {
                    type = _gl.BYTE;
                } else if (array instanceof Uint8Array) {
                    type = _gl.UNSIGNED_BYTE;
                }
                var size = geometryAttribute.itemSize;
                var buffer = objects.getAttributeBuffer(geometryAttribute);
                if (geometryAttribute && geometryAttribute.isInterleavedBufferAttribute) {
                    var data = geometryAttribute.data;
                    var stride = data.stride;
                    var offset = geometryAttribute.offset;
                    if (data && data.isInstancedInterleavedBuffer) {
                        state.enableAttributeAndDivisor(programAttribute, data.meshPerAttribute, extension);
                        if (geometry.maxInstancedCount === undefined) {
                            geometry.maxInstancedCount = data.meshPerAttribute * data.count;
                        }
                    } else {
                        state.enableAttribute(programAttribute);
                    }
                    _gl.bindBuffer(_gl.ARRAY_BUFFER, buffer);
                    _gl.vertexAttribPointer(programAttribute, size, type, normalized, stride * data.array.BYTES_PER_ELEMENT, (startIndex * stride + offset) * data.array.BYTES_PER_ELEMENT);
                } else {
                    if (geometryAttribute && geometryAttribute.isInstancedBufferAttribute) {
                        state.enableAttributeAndDivisor(programAttribute, geometryAttribute.meshPerAttribute, extension);
                        if (geometry.maxInstancedCount === undefined) {
                            geometry.maxInstancedCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;
                        }
                    } else {
                        state.enableAttribute(programAttribute);
                    }
                    _gl.bindBuffer(_gl.ARRAY_BUFFER, buffer);
                    _gl.vertexAttribPointer(programAttribute, size, type, normalized, 0, startIndex * size * geometryAttribute.array.BYTES_PER_ELEMENT);
                }
            } else if (materialDefaultAttributeValues !== undefined) {
                var value = materialDefaultAttributeValues[name];
                if (value !== undefined) {
                    switch (value.length) {
                    case 2:
                        _gl.vertexAttrib2fv(programAttribute, value);
                        break;
                    case 3:
                        _gl.vertexAttrib3fv(programAttribute, value);
                        break;
                    case 4:
                        _gl.vertexAttrib4fv(programAttribute, value);
                        break;
                    default:
                        _gl.vertexAttrib1fv(programAttribute, value);
                    }
                }
            }
        }
    }
    state.disableUnusedAttributes();
};
absNumericalSort = function absNumericalSort(a, b) {
    return Math.abs(b[0]) - Math.abs(a[0]);
};
painterSortStable = function painterSortStable(a, b) {
    if (a.object.renderOrder !== b.object.renderOrder) {
        return a.object.renderOrder - b.object.renderOrder;
    } else if (a.material.program && b.material.program && a.material.program !== b.material.program) {
        return a.material.program.id - b.material.program.id;
    } else if (a.material.id !== b.material.id) {
        return a.material.id - b.material.id;
    } else if (a.z !== b.z) {
        return a.z - b.z;
    } else {
        return a.id - b.id;
    }
};
reversePainterSortStable = function reversePainterSortStable(a, b) {
    if (a.object.renderOrder !== b.object.renderOrder) {
        return a.object.renderOrder - b.object.renderOrder;
    }
    if (a.z !== b.z) {
        return b.z - a.z;
    } else {
        return a.id - b.id;
    }
};
pushRenderItem = function pushRenderItem(object, geometry, material, z, group) {
    var array, index;
    if (material.transparent) {
        array = transparentObjects;
        index = ++transparentObjectsLastIndex;
    } else {
        array = opaqueObjects;
        index = ++opaqueObjectsLastIndex;
    }
    var renderItem = array[index];
    if (renderItem !== undefined) {
        renderItem.id = object.id;
        renderItem.object = object;
        renderItem.geometry = geometry;
        renderItem.material = material;
        renderItem.z = _vector3.z;
        renderItem.group = group;
    } else {
        renderItem = {
            id: object.id,
            object: object,
            geometry: geometry,
            material: material,
            z: _vector3.z,
            group: group
        };
        array.push(renderItem);
    }
};
isObjectViewable = function isObjectViewable(object) {
    var geometry = object.geometry;
    if (geometry.boundingSphere === null)
        geometry.computeBoundingSphere();
    _sphere.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld);
    return isSphereViewable(_sphere);
};
isSpriteViewable = function isSpriteViewable(sprite) {
    _sphere.center.set(0, 0, 0);
    _sphere.radius = 0.7071067811865476;
    _sphere.applyMatrix4(sprite.matrixWorld);
    return isSphereViewable(_sphere);
};
isSphereViewable = function isSphereViewable(sphere) {
    if (!_frustum.intersectsSphere(sphere))
        return false;
    var numPlanes = _clipping.numPlanes;
    if (numPlanes === 0)
        return true;
    var planes = _this.clippingPlanes, center = sphere.center, negRad = -sphere.radius, i = 0;
    do {
        if (planes[i].distanceToPoint(center) < negRad)
            return false;
    } while (++i !== numPlanes);
    return true;
};
projectObject = function projectObject(object, camera) {
    if (object.visible === false)
        return;
    var visible = (object.layers.mask & camera.layers.mask) !== 0;
    if (visible) {
        if (object.isLight) {
            lights.push(object);
        } else if (object.isSprite) {
            if (object.frustumCulled === false || isSpriteViewable(object) === true) {
                sprites.push(object);
            }
        } else if (object.isLensFlare) {
            lensFlares.push(object);
        } else if (object.isImmediateRenderObject) {
            if (_this.sortObjects === true) {
                _vector3.setFromMatrixPosition(object.matrixWorld);
                _vector3.applyProjection(_projScreenMatrix);
            }
            pushRenderItem(object, null, object.material, _vector3.z, null);
        } else if (object.isMesh || object.isLine || object.isPoints) {
            if (object.isSkinnedMesh) {
                object.skeleton.update();
            }
            if (object.frustumCulled === false || isObjectViewable(object) === true) {
                var material = object.material;
                if (material.visible === true) {
                    if (_this.sortObjects === true) {
                        _vector3.setFromMatrixPosition(object.matrixWorld);
                        _vector3.applyProjection(_projScreenMatrix);
                    }
                    var geometry = objects.update(object);
                    if (material.isMultiMaterial) {
                        var groups = geometry.groups;
                        var materials = material.materials;
                        for (var i = 0, l = groups.length; i < l; i++) {
                            var group = groups[i];
                            var groupMaterial = materials[group.materialIndex];
                            if (groupMaterial.visible === true) {
                                pushRenderItem(object, geometry, groupMaterial, _vector3.z, group);
                            }
                        }
                    } else {
                        pushRenderItem(object, geometry, material, _vector3.z, null);
                    }
                }
            }
        }
    }
    var children = object.children;
    for (var i = 0, l = children.length; i < l; i++) {
        projectObject(children[i], camera);
    }
};
renderObjects = function renderObjects(renderList, camera, fog, overrideMaterial) {
    for (var i = 0, l = renderList.length; i < l; i++) {
        var renderItem = renderList[i];
        var object = renderItem.object;
        var geometry = renderItem.geometry;
        var material = overrideMaterial === undefined ? renderItem.material : overrideMaterial;
        var group = renderItem.group;
        object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);
        object.normalMatrix.getNormalMatrix(object.modelViewMatrix);
        if (object.isImmediateRenderObject) {
            setMaterial(material);
            var program = setProgram(camera, fog, material, object);
            _currentGeometryProgram = '';
            object.render(function (object) {
                _this.renderBufferImmediate(object, program, material);
            });
        } else {
            _this.renderBufferDirect(camera, fog, geometry, material, object, group);
        }
    }
};
initMaterial = function initMaterial(material, fog, object) {
    var materialProperties = properties.get(material);
    var parameters = programCache.getParameters(material, _lights, fog, _clipping.numPlanes, object);
    var code = programCache.getProgramCode(material, parameters);
    var program = materialProperties.program;
    var programChange = true;
    if (program === undefined) {
        material.addEventListener('dispose', onMaterialDispose);
    } else if (program.code !== code) {
        releaseMaterialProgramReference(material);
    } else if (parameters.shaderID !== undefined) {
        return;
    } else {
        programChange = false;
    }
    if (programChange) {
        if (parameters.shaderID) {
            var shader = ShaderLib[parameters.shaderID];
            materialProperties.__webglShader = {
                name: material.type,
                uniforms: exports.UniformsUtils.clone(shader.uniforms),
                vertexShader: shader.vertexShader,
                fragmentShader: shader.fragmentShader
            };
        } else {
            materialProperties.__webglShader = {
                name: material.type,
                uniforms: material.uniforms,
                vertexShader: material.vertexShader,
                fragmentShader: material.fragmentShader
            };
        }
        material.__webglShader = materialProperties.__webglShader;
        program = programCache.acquireProgram(material, parameters, code);
        materialProperties.program = program;
        material.program = program;
    }
    var attributes = program.getAttributes();
    if (material.morphTargets) {
        material.numSupportedMorphTargets = 0;
        for (var i = 0; i < _this.maxMorphTargets; i++) {
            if (attributes['morphTarget' + i] >= 0) {
                material.numSupportedMorphTargets++;
            }
        }
    }
    if (material.morphNormals) {
        material.numSupportedMorphNormals = 0;
        for (var i = 0; i < _this.maxMorphNormals; i++) {
            if (attributes['morphNormal' + i] >= 0) {
                material.numSupportedMorphNormals++;
            }
        }
    }
    var uniforms = materialProperties.__webglShader.uniforms;
    if (!material.isShaderMaterial && !material.isRawShaderMaterial | material.clipping === true) {
        materialProperties.numClippingPlanes = _clipping.numPlanes;
        uniforms.clippingPlanes = _clipping.uniform;
    }
    materialProperties.fog = fog;
    materialProperties.lightsHash = _lights.hash;
    if (material.lights) {
        uniforms.ambientLightColor.value = _lights.ambient;
        uniforms.directionalLights.value = _lights.directional;
        uniforms.spotLights.value = _lights.spot;
        uniforms.pointLights.value = _lights.point;
        uniforms.hemisphereLights.value = _lights.hemi;
        uniforms.directionalShadowMap.value = _lights.directionalShadowMap;
        uniforms.directionalShadowMatrix.value = _lights.directionalShadowMatrix;
        uniforms.spotShadowMap.value = _lights.spotShadowMap;
        uniforms.spotShadowMatrix.value = _lights.spotShadowMatrix;
        uniforms.pointShadowMap.value = _lights.pointShadowMap;
        uniforms.pointShadowMatrix.value = _lights.pointShadowMatrix;
    }
    var progUniforms = materialProperties.program.getUniforms(), uniformsList = WebGLUniforms.seqWithValue(progUniforms.seq, uniforms);
    materialProperties.uniformsList = uniformsList;
    materialProperties.dynamicUniforms = WebGLUniforms.splitDynamic(uniformsList, uniforms);
};
setMaterial = function setMaterial(material) {
    material.side === DoubleSide ? state.disable(_gl.CULL_FACE) : state.enable(_gl.CULL_FACE);
    state.setFlipSided(material.side === BackSide);
    material.transparent === true ? state.setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha) : state.setBlending(NoBlending);
    state.setDepthFunc(material.depthFunc);
    state.setDepthTest(material.depthTest);
    state.setDepthWrite(material.depthWrite);
    state.setColorWrite(material.colorWrite);
    state.setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits);
};
setProgram = function setProgram(camera, fog, material, object) {
    _usedTextureUnits = 0;
    var materialProperties = properties.get(material);
    if (_clippingEnabled) {
        if (_localClippingEnabled || camera !== _currentCamera) {
            var useCache = camera === _currentCamera && material.id === _currentMaterialId;
            _clipping.setState(material.clippingPlanes, material.clipShadows, camera, materialProperties, useCache);
        }
    }
    if (material.needsUpdate === false) {
        if (materialProperties.program === undefined) {
            material.needsUpdate = true;
        } else if (material.fog && materialProperties.fog !== fog) {
            material.needsUpdate = true;
        } else if (material.lights && materialProperties.lightsHash !== _lights.hash) {
            material.needsUpdate = true;
        } else if (materialProperties.numClippingPlanes !== undefined && materialProperties.numClippingPlanes !== _clipping.numPlanes) {
            material.needsUpdate = true;
        }
    }
    if (material.needsUpdate) {
        initMaterial(material, fog, object);
        material.needsUpdate = false;
    }
    var refreshProgram = false;
    var refreshMaterial = false;
    var refreshLights = false;
    var program = materialProperties.program, p_uniforms = program.getUniforms(), m_uniforms = materialProperties.__webglShader.uniforms;
    if (program.id !== _currentProgram) {
        _gl.useProgram(program.program);
        _currentProgram = program.id;
        refreshProgram = true;
        refreshMaterial = true;
        refreshLights = true;
    }
    if (material.id !== _currentMaterialId) {
        _currentMaterialId = material.id;
        refreshMaterial = true;
    }
    if (refreshProgram || camera !== _currentCamera) {
        p_uniforms.set(_gl, camera, 'projectionMatrix');
        if (capabilities.logarithmicDepthBuffer) {
            p_uniforms.setValue(_gl, 'logDepthBufFC', 2 / (Math.log(camera.far + 1) / Math.LN2));
        }
        if (camera !== _currentCamera) {
            _currentCamera = camera;
            refreshMaterial = true;
            refreshLights = true;
        }
        if (material.isShaderMaterial || material.isMeshPhongMaterial || material.isMeshStandardMaterial || material.envMap) {
            var uCamPos = p_uniforms.map.cameraPosition;
            if (uCamPos !== undefined) {
                uCamPos.setValue(_gl, _vector3.setFromMatrixPosition(camera.matrixWorld));
            }
        }
        if (material.isMeshPhongMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial || material.skinning) {
            p_uniforms.setValue(_gl, 'viewMatrix', camera.matrixWorldInverse);
        }
        p_uniforms.set(_gl, _this, 'toneMappingExposure');
        p_uniforms.set(_gl, _this, 'toneMappingWhitePoint');
    }
    if (material.skinning) {
        p_uniforms.setOptional(_gl, object, 'bindMatrix');
        p_uniforms.setOptional(_gl, object, 'bindMatrixInverse');
        var skeleton = object.skeleton;
        if (skeleton) {
            if (capabilities.floatVertexTextures && skeleton.useVertexTexture) {
                p_uniforms.set(_gl, skeleton, 'boneTexture');
                p_uniforms.set(_gl, skeleton, 'boneTextureWidth');
                p_uniforms.set(_gl, skeleton, 'boneTextureHeight');
            } else {
                p_uniforms.setOptional(_gl, skeleton, 'boneMatrices');
            }
        }
    }
    if (refreshMaterial) {
        if (material.lights) {
            markUniformsLightsNeedsUpdate(m_uniforms, refreshLights);
        }
        if (fog && material.fog) {
            refreshUniformsFog(m_uniforms, fog);
        }
        if (material.isMeshBasicMaterial || material.isMeshLambertMaterial || material.isMeshPhongMaterial || material.isMeshStandardMaterial || material.isMeshDepthMaterial) {
            refreshUniformsCommon(m_uniforms, material);
        }
        if (material.isLineBasicMaterial) {
            refreshUniformsLine(m_uniforms, material);
        } else if (material.isLineDashedMaterial) {
            refreshUniformsLine(m_uniforms, material);
            refreshUniformsDash(m_uniforms, material);
        } else if (material.isPointsMaterial) {
            refreshUniformsPoints(m_uniforms, material);
        } else if (material.isMeshLambertMaterial) {
            refreshUniformsLambert(m_uniforms, material);
        } else if (material.isMeshPhongMaterial) {
            refreshUniformsPhong(m_uniforms, material);
        } else if (material.isMeshPhysicalMaterial) {
            refreshUniformsPhysical(m_uniforms, material);
        } else if (material.isMeshStandardMaterial) {
            refreshUniformsStandard(m_uniforms, material);
        } else if (material.isMeshDepthMaterial) {
            if (material.displacementMap) {
                m_uniforms.displacementMap.value = material.displacementMap;
                m_uniforms.displacementScale.value = material.displacementScale;
                m_uniforms.displacementBias.value = material.displacementBias;
            }
        } else if (material.isMeshNormalMaterial) {
            m_uniforms.opacity.value = material.opacity;
        }
        WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, _this);
    }
    p_uniforms.set(_gl, object, 'modelViewMatrix');
    p_uniforms.set(_gl, object, 'normalMatrix');
    p_uniforms.setValue(_gl, 'modelMatrix', object.matrixWorld);
    var dynUniforms = materialProperties.dynamicUniforms;
    if (dynUniforms !== null) {
        WebGLUniforms.evalDynamic(dynUniforms, m_uniforms, object, camera);
        WebGLUniforms.upload(_gl, dynUniforms, m_uniforms, _this);
    }
    return program;
};
refreshUniformsCommon = function refreshUniformsCommon(uniforms, material) {
    uniforms.opacity.value = material.opacity;
    uniforms.diffuse.value = material.color;
    if (material.emissive) {
        uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity);
    }
    uniforms.map.value = material.map;
    uniforms.specularMap.value = material.specularMap;
    uniforms.alphaMap.value = material.alphaMap;
    if (material.aoMap) {
        uniforms.aoMap.value = material.aoMap;
        uniforms.aoMapIntensity.value = material.aoMapIntensity;
    }
    var uvScaleMap;
    if (material.map) {
        uvScaleMap = material.map;
    } else if (material.specularMap) {
        uvScaleMap = material.specularMap;
    } else if (material.displacementMap) {
        uvScaleMap = material.displacementMap;
    } else if (material.normalMap) {
        uvScaleMap = material.normalMap;
    } else if (material.bumpMap) {
        uvScaleMap = material.bumpMap;
    } else if (material.roughnessMap) {
        uvScaleMap = material.roughnessMap;
    } else if (material.metalnessMap) {
        uvScaleMap = material.metalnessMap;
    } else if (material.alphaMap) {
        uvScaleMap = material.alphaMap;
    } else if (material.emissiveMap) {
        uvScaleMap = material.emissiveMap;
    }
    if (uvScaleMap !== undefined) {
        if (uvScaleMap.isWebGLRenderTarget) {
            uvScaleMap = uvScaleMap.texture;
        }
        var offset = uvScaleMap.offset;
        var repeat = uvScaleMap.repeat;
        uniforms.offsetRepeat.value.set(offset.x, offset.y, repeat.x, repeat.y);
    }
    uniforms.envMap.value = material.envMap;
    uniforms.flipEnvMap.value = !(material.envMap && material.envMap.isCubeTexture) ? 1 : -1;
    uniforms.reflectivity.value = material.reflectivity;
    uniforms.refractionRatio.value = material.refractionRatio;
};
refreshUniformsLine = function refreshUniformsLine(uniforms, material) {
    uniforms.diffuse.value = material.color;
    uniforms.opacity.value = material.opacity;
};
refreshUniformsDash = function refreshUniformsDash(uniforms, material) {
    uniforms.dashSize.value = material.dashSize;
    uniforms.totalSize.value = material.dashSize + material.gapSize;
    uniforms.scale.value = material.scale;
};
refreshUniformsPoints = function refreshUniformsPoints(uniforms, material) {
    uniforms.diffuse.value = material.color;
    uniforms.opacity.value = material.opacity;
    uniforms.size.value = material.size * _pixelRatio;
    uniforms.scale.value = _canvas.clientHeight * 0.5;
    uniforms.map.value = material.map;
    if (material.map !== null) {
        var offset = material.map.offset;
        var repeat = material.map.repeat;
        uniforms.offsetRepeat.value.set(offset.x, offset.y, repeat.x, repeat.y);
    }
};
refreshUniformsFog = function refreshUniformsFog(uniforms, fog) {
    uniforms.fogColor.value = fog.color;
    if (fog.isFog) {
        uniforms.fogNear.value = fog.near;
        uniforms.fogFar.value = fog.far;
    } else if (fog.isFogExp2) {
        uniforms.fogDensity.value = fog.density;
    }
};
refreshUniformsLambert = function refreshUniformsLambert(uniforms, material) {
    if (material.lightMap) {
        uniforms.lightMap.value = material.lightMap;
        uniforms.lightMapIntensity.value = material.lightMapIntensity;
    }
    if (material.emissiveMap) {
        uniforms.emissiveMap.value = material.emissiveMap;
    }
};
refreshUniformsPhong = function refreshUniformsPhong(uniforms, material) {
    uniforms.specular.value = material.specular;
    uniforms.shininess.value = Math.max(material.shininess, 0.0001);
    if (material.lightMap) {
        uniforms.lightMap.value = material.lightMap;
        uniforms.lightMapIntensity.value = material.lightMapIntensity;
    }
    if (material.emissiveMap) {
        uniforms.emissiveMap.value = material.emissiveMap;
    }
    if (material.bumpMap) {
        uniforms.bumpMap.value = material.bumpMap;
        uniforms.bumpScale.value = material.bumpScale;
    }
    if (material.normalMap) {
        uniforms.normalMap.value = material.normalMap;
        uniforms.normalScale.value.copy(material.normalScale);
    }
    if (material.displacementMap) {
        uniforms.displacementMap.value = material.displacementMap;
        uniforms.displacementScale.value = material.displacementScale;
        uniforms.displacementBias.value = material.displacementBias;
    }
};
refreshUniformsStandard = function refreshUniformsStandard(uniforms, material) {
    uniforms.roughness.value = material.roughness;
    uniforms.metalness.value = material.metalness;
    if (material.roughnessMap) {
        uniforms.roughnessMap.value = material.roughnessMap;
    }
    if (material.metalnessMap) {
        uniforms.metalnessMap.value = material.metalnessMap;
    }
    if (material.lightMap) {
        uniforms.lightMap.value = material.lightMap;
        uniforms.lightMapIntensity.value = material.lightMapIntensity;
    }
    if (material.emissiveMap) {
        uniforms.emissiveMap.value = material.emissiveMap;
    }
    if (material.bumpMap) {
        uniforms.bumpMap.value = material.bumpMap;
        uniforms.bumpScale.value = material.bumpScale;
    }
    if (material.normalMap) {
        uniforms.normalMap.value = material.normalMap;
        uniforms.normalScale.value.copy(material.normalScale);
    }
    if (material.displacementMap) {
        uniforms.displacementMap.value = material.displacementMap;
        uniforms.displacementScale.value = material.displacementScale;
        uniforms.displacementBias.value = material.displacementBias;
    }
    if (material.envMap) {
        uniforms.envMapIntensity.value = material.envMapIntensity;
    }
};
refreshUniformsPhysical = function refreshUniformsPhysical(uniforms, material) {
    uniforms.clearCoat.value = material.clearCoat;
    uniforms.clearCoatRoughness.value = material.clearCoatRoughness;
    refreshUniformsStandard(uniforms, material);
};
markUniformsLightsNeedsUpdate = function markUniformsLightsNeedsUpdate(uniforms, value) {
    uniforms.ambientLightColor.needsUpdate = value;
    uniforms.directionalLights.needsUpdate = value;
    uniforms.pointLights.needsUpdate = value;
    uniforms.spotLights.needsUpdate = value;
    uniforms.hemisphereLights.needsUpdate = value;
};
setupShadows = function setupShadows(lights) {
    var lightShadowsLength = 0;
    for (var i = 0, l = lights.length; i < l; i++) {
        var light = lights[i];
        if (light.castShadow) {
            _lights.shadows[lightShadowsLength++] = light;
        }
    }
    _lights.shadows.length = lightShadowsLength;
};
setupLights = function setupLights(lights, camera) {
    var l, ll, light, r = 0, g = 0, b = 0, color, intensity, distance, shadowMap, viewMatrix = camera.matrixWorldInverse, directionalLength = 0, pointLength = 0, spotLength = 0, hemiLength = 0;
    for (l = 0, ll = lights.length; l < ll; l++) {
        light = lights[l];
        color = light.color;
        intensity = light.intensity;
        distance = light.distance;
        shadowMap = light.shadow && light.shadow.map ? light.shadow.map.texture : null;
        if (light.isAmbientLight) {
            r += color.r * intensity;
            g += color.g * intensity;
            b += color.b * intensity;
        } else if (light.isDirectionalLight) {
            var uniforms = lightCache.get(light);
            uniforms.color.copy(light.color).multiplyScalar(light.intensity);
            uniforms.direction.setFromMatrixPosition(light.matrixWorld);
            _vector3.setFromMatrixPosition(light.target.matrixWorld);
            uniforms.direction.sub(_vector3);
            uniforms.direction.transformDirection(viewMatrix);
            uniforms.shadow = light.castShadow;
            if (light.castShadow) {
                uniforms.shadowBias = light.shadow.bias;
                uniforms.shadowRadius = light.shadow.radius;
                uniforms.shadowMapSize = light.shadow.mapSize;
            }
            _lights.directionalShadowMap[directionalLength] = shadowMap;
            _lights.directionalShadowMatrix[directionalLength] = light.shadow.matrix;
            _lights.directional[directionalLength++] = uniforms;
        } else if (light.isSpotLight) {
            var uniforms = lightCache.get(light);
            uniforms.position.setFromMatrixPosition(light.matrixWorld);
            uniforms.position.applyMatrix4(viewMatrix);
            uniforms.color.copy(color).multiplyScalar(intensity);
            uniforms.distance = distance;
            uniforms.direction.setFromMatrixPosition(light.matrixWorld);
            _vector3.setFromMatrixPosition(light.target.matrixWorld);
            uniforms.direction.sub(_vector3);
            uniforms.direction.transformDirection(viewMatrix);
            uniforms.coneCos = Math.cos(light.angle);
            uniforms.penumbraCos = Math.cos(light.angle * (1 - light.penumbra));
            uniforms.decay = light.distance === 0 ? 0 : light.decay;
            uniforms.shadow = light.castShadow;
            if (light.castShadow) {
                uniforms.shadowBias = light.shadow.bias;
                uniforms.shadowRadius = light.shadow.radius;
                uniforms.shadowMapSize = light.shadow.mapSize;
            }
            _lights.spotShadowMap[spotLength] = shadowMap;
            _lights.spotShadowMatrix[spotLength] = light.shadow.matrix;
            _lights.spot[spotLength++] = uniforms;
        } else if (light.isPointLight) {
            var uniforms = lightCache.get(light);
            uniforms.position.setFromMatrixPosition(light.matrixWorld);
            uniforms.position.applyMatrix4(viewMatrix);
            uniforms.color.copy(light.color).multiplyScalar(light.intensity);
            uniforms.distance = light.distance;
            uniforms.decay = light.distance === 0 ? 0 : light.decay;
            uniforms.shadow = light.castShadow;
            if (light.castShadow) {
                uniforms.shadowBias = light.shadow.bias;
                uniforms.shadowRadius = light.shadow.radius;
                uniforms.shadowMapSize = light.shadow.mapSize;
            }
            _lights.pointShadowMap[pointLength] = shadowMap;
            if (_lights.pointShadowMatrix[pointLength] === undefined) {
                _lights.pointShadowMatrix[pointLength] = new Matrix4();
            }
            _vector3.setFromMatrixPosition(light.matrixWorld).negate();
            _lights.pointShadowMatrix[pointLength].identity().setPosition(_vector3);
            _lights.point[pointLength++] = uniforms;
        } else if (light.isHemisphereLight) {
            var uniforms = lightCache.get(light);
            uniforms.direction.setFromMatrixPosition(light.matrixWorld);
            uniforms.direction.transformDirection(viewMatrix);
            uniforms.direction.normalize();
            uniforms.skyColor.copy(light.color).multiplyScalar(intensity);
            uniforms.groundColor.copy(light.groundColor).multiplyScalar(intensity);
            _lights.hemi[hemiLength++] = uniforms;
        }
    }
    _lights.ambient[0] = r;
    _lights.ambient[1] = g;
    _lights.ambient[2] = b;
    _lights.directional.length = directionalLength;
    _lights.spot.length = spotLength;
    _lights.point.length = pointLength;
    _lights.hemi.length = hemiLength;
    _lights.hash = directionalLength + ',' + pointLength + ',' + spotLength + ',' + hemiLength + ',' + _lights.shadows.length;
};
allocTextureUnit = function allocTextureUnit() {
    var textureUnit = _usedTextureUnits;
    if (textureUnit >= capabilities.maxTextures) {
        console.warn('WebGLRenderer: trying to use ' + textureUnit + ' texture units while this GPU supports only ' + capabilities.maxTextures);
    }
    _usedTextureUnits += 1;
    return textureUnit;
};
paramThreeToGL = function paramThreeToGL(p) {
    var extension;
    if (p === RepeatWrapping)
        return _gl.REPEAT;
    if (p === ClampToEdgeWrapping)
        return _gl.CLAMP_TO_EDGE;
    if (p === MirroredRepeatWrapping)
        return _gl.MIRRORED_REPEAT;
    if (p === NearestFilter)
        return _gl.NEAREST;
    if (p === NearestMipMapNearestFilter)
        return _gl.NEAREST_MIPMAP_NEAREST;
    if (p === NearestMipMapLinearFilter)
        return _gl.NEAREST_MIPMAP_LINEAR;
    if (p === LinearFilter)
        return _gl.LINEAR;
    if (p === LinearMipMapNearestFilter)
        return _gl.LINEAR_MIPMAP_NEAREST;
    if (p === LinearMipMapLinearFilter)
        return _gl.LINEAR_MIPMAP_LINEAR;
    if (p === UnsignedByteType)
        return _gl.UNSIGNED_BYTE;
    if (p === UnsignedShort4444Type)
        return _gl.UNSIGNED_SHORT_4_4_4_4;
    if (p === UnsignedShort5551Type)
        return _gl.UNSIGNED_SHORT_5_5_5_1;
    if (p === UnsignedShort565Type)
        return _gl.UNSIGNED_SHORT_5_6_5;
    if (p === ByteType)
        return _gl.BYTE;
    if (p === ShortType)
        return _gl.SHORT;
    if (p === UnsignedShortType)
        return _gl.UNSIGNED_SHORT;
    if (p === IntType)
        return _gl.INT;
    if (p === UnsignedIntType)
        return _gl.UNSIGNED_INT;
    if (p === FloatType)
        return _gl.FLOAT;
    extension = extensions.get('OES_texture_half_float');
    if (extension !== null) {
        if (p === HalfFloatType)
            return extension.HALF_FLOAT_OES;
    }
    if (p === AlphaFormat)
        return _gl.ALPHA;
    if (p === RGBFormat)
        return _gl.RGB;
    if (p === RGBAFormat)
        return _gl.RGBA;
    if (p === LuminanceFormat)
        return _gl.LUMINANCE;
    if (p === LuminanceAlphaFormat)
        return _gl.LUMINANCE_ALPHA;
    if (p === DepthFormat)
        return _gl.DEPTH_COMPONENT;
    if (p === DepthStencilFormat)
        return _gl.DEPTH_STENCIL;
    if (p === AddEquation)
        return _gl.FUNC_ADD;
    if (p === SubtractEquation)
        return _gl.FUNC_SUBTRACT;
    if (p === ReverseSubtractEquation)
        return _gl.FUNC_REVERSE_SUBTRACT;
    if (p === ZeroFactor)
        return _gl.ZERO;
    if (p === OneFactor)
        return _gl.ONE;
    if (p === SrcColorFactor)
        return _gl.SRC_COLOR;
    if (p === OneMinusSrcColorFactor)
        return _gl.ONE_MINUS_SRC_COLOR;
    if (p === SrcAlphaFactor)
        return _gl.SRC_ALPHA;
    if (p === OneMinusSrcAlphaFactor)
        return _gl.ONE_MINUS_SRC_ALPHA;
    if (p === DstAlphaFactor)
        return _gl.DST_ALPHA;
    if (p === OneMinusDstAlphaFactor)
        return _gl.ONE_MINUS_DST_ALPHA;
    if (p === DstColorFactor)
        return _gl.DST_COLOR;
    if (p === OneMinusDstColorFactor)
        return _gl.ONE_MINUS_DST_COLOR;
    if (p === SrcAlphaSaturateFactor)
        return _gl.SRC_ALPHA_SATURATE;
    extension = extensions.get('WEBGL_compressed_texture_s3tc');
    if (extension !== null) {
        if (p === RGB_S3TC_DXT1_Format)
            return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
        if (p === RGBA_S3TC_DXT1_Format)
            return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
        if (p === RGBA_S3TC_DXT3_Format)
            return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        if (p === RGBA_S3TC_DXT5_Format)
            return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;
    }
    extension = extensions.get('WEBGL_compressed_texture_pvrtc');
    if (extension !== null) {
        if (p === RGB_PVRTC_4BPPV1_Format)
            return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (p === RGB_PVRTC_2BPPV1_Format)
            return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (p === RGBA_PVRTC_4BPPV1_Format)
            return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (p === RGBA_PVRTC_2BPPV1_Format)
            return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
    }
    extension = extensions.get('WEBGL_compressed_texture_etc1');
    if (extension !== null) {
        if (p === RGB_ETC1_Format)
            return extension.COMPRESSED_RGB_ETC1_WEBGL;
    }
    extension = extensions.get('EXT_blend_minmax');
    if (extension !== null) {
        if (p === MinEquation)
            return extension.MIN_EXT;
        if (p === MaxEquation)
            return extension.MAX_EXT;
    }
    extension = extensions.get('WEBGL_depth_texture');
    if (extension !== null) {
        if (p === UnsignedInt248Type)
            return extension.UNSIGNED_INT_24_8_WEBGL;
    }
    return 0;
};
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
parameters = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
console.log('THREE.WebGLRenderer', REVISION);
parameters = parameters || {};
_canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');
_context = parameters.context !== undefined ? parameters.context : null;
_alpha = parameters.alpha !== undefined ? parameters.alpha : false;
_depth = parameters.depth !== undefined ? parameters.depth : true;
_stencil = parameters.stencil !== undefined ? parameters.stencil : true;
_antialias = parameters.antialias !== undefined ? parameters.antialias : false;
_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true;
_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false;
lights = [];
opaqueObjects = [];
opaqueObjectsLastIndex = -1;
transparentObjects = [];
transparentObjectsLastIndex = -1;
morphInfluences = new Float32Array(8);
sprites = [];
lensFlares = [];
this.domElement = _canvas;
this.context = null;
this.autoClear = true;
this.autoClearColor = true;
this.autoClearDepth = true;
this.autoClearStencil = true;
this.sortObjects = true;
this.clippingPlanes = [];
this.localClippingEnabled = false;
this.gammaFactor = 2;
this.gammaInput = false;
this.gammaOutput = false;
this.physicallyCorrectLights = false;
this.toneMapping = LinearToneMapping;
this.toneMappingExposure = 1;
this.toneMappingWhitePoint = 1;
this.maxMorphTargets = 8;
this.maxMorphNormals = 4;
_this = this;
_currentProgram = null;
_currentRenderTarget = null;
_currentFramebuffer = null;
_currentMaterialId = -1;
_currentGeometryProgram = '';
_currentCamera = null;
_currentScissor = new Vector4();
_currentScissorTest = null;
_currentViewport = new Vector4();
_usedTextureUnits = 0;
_clearColor = new Color(0);
_clearAlpha = 0;
_width = _canvas.width;
_height = _canvas.height;
_pixelRatio = 1;
_scissor = new Vector4(0, 0, _width, _height);
_scissorTest = false;
_viewport = new Vector4(0, 0, _width, _height);
_frustum = new Frustum();
_clipping = new WebGLClipping();
_clippingEnabled = false;
_localClippingEnabled = false;
_sphere = new Sphere();
_projScreenMatrix = new Matrix4();
_vector3 = new Vector3();
_lights = {
    hash: '',
    ambient: [
        0,
        0,
        0
    ],
    directional: [],
    directionalShadowMap: [],
    directionalShadowMatrix: [],
    spot: [],
    spotShadowMap: [],
    spotShadowMatrix: [],
    point: [],
    pointShadowMap: [],
    pointShadowMatrix: [],
    hemi: [],
    shadows: []
};
_infoRender = {
    calls: 0,
    vertices: 0,
    faces: 0,
    points: 0
};
this.info = {
    render: _infoRender,
    memory: {
        geometries: 0,
        textures: 0
    },
    programs: null
};
try {
    attributes = {
        alpha: _alpha,
        depth: _depth,
        stencil: _stencil,
        antialias: _antialias,
        premultipliedAlpha: _premultipliedAlpha,
        preserveDrawingBuffer: _preserveDrawingBuffer
    };
    _gl = _context || _canvas.getContext('webgl', attributes) || _canvas.getContext('experimental-webgl', attributes);
    if (_gl === null) {
        if (_canvas.getContext('webgl') !== null) {
            throw 'Error creating WebGL context with your selected attributes.';
        } else {
            throw 'Error creating WebGL context.';
        }
    }
    if (_gl.getShaderPrecisionFormat === undefined) {
        _gl.getShaderPrecisionFormat = function () {
            return {
                'rangeMin': 1,
                'rangeMax': 1,
                'precision': 1
            };
        };
    }
    _canvas.addEventListener('webglcontextlost', onContextLost, false);
} catch (error) {
    console.error('THREE.WebGLRenderer: ' + error);
}
extensions = new WebGLExtensions(_gl);
extensions.get('WEBGL_depth_texture');
extensions.get('OES_texture_float');
extensions.get('OES_texture_float_linear');
extensions.get('OES_texture_half_float');
extensions.get('OES_texture_half_float_linear');
extensions.get('OES_standard_derivatives');
extensions.get('ANGLE_instanced_arrays');
if (extensions.get('OES_element_index_uint')) {
    BufferGeometry.MaxIndex = 4294967296;
}
capabilities = new WebGLCapabilities(_gl, extensions, parameters);
state = new WebGLState(_gl, extensions, paramThreeToGL);
properties = new WebGLProperties();
textures = new WebGLTextures(_gl, extensions, state, properties, capabilities, paramThreeToGL, this.info);
objects = new WebGLObjects(_gl, properties, this.info);
programCache = new WebGLPrograms(this, capabilities);
lightCache = new WebGLLights();
this.info.programs = programCache.programs;
bufferRenderer = new WebGLBufferRenderer(_gl, extensions, _infoRender);
indexedBufferRenderer = new WebGLIndexedBufferRenderer(_gl, extensions, _infoRender);
backgroundCamera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);
backgroundCamera2 = new PerspectiveCamera();
backgroundPlaneMesh = new Mesh(new PlaneBufferGeometry(2, 2), new MeshBasicMaterial({
    depthTest: false,
    depthWrite: false,
    fog: false
}));
backgroundBoxShader = ShaderLib['cube'];
backgroundBoxMesh = new Mesh(new BoxBufferGeometry(5, 5, 5), new ShaderMaterial({
    uniforms: backgroundBoxShader.uniforms,
    vertexShader: backgroundBoxShader.vertexShader,
    fragmentShader: backgroundBoxShader.fragmentShader,
    side: BackSide,
    depthTest: false,
    depthWrite: false,
    fog: false
}));
setDefaultGLState();
this.context = _gl;
this.capabilities = capabilities;
this.extensions = extensions;
this.properties = properties;
this.state = state;
shadowMap = new WebGLShadowMap(this, _lights, objects, capabilities);
this.shadowMap = shadowMap;
spritePlugin = new SpritePlugin(this, sprites);
lensFlarePlugin = new LensFlarePlugin(this, lensFlares);
this.getContext = function () {
    return _gl;
};
this.getContextAttributes = function () {
    return _gl.getContextAttributes();
};
this.forceContextLoss = function () {
    extensions.get('WEBGL_lose_context').loseContext();
};
this.getMaxAnisotropy = function () {
    return capabilities.getMaxAnisotropy();
};
this.getPrecision = function () {
    return capabilities.precision;
};
this.getPixelRatio = function () {
    return _pixelRatio;
};
this.setPixelRatio = function (value) {
    if (value === undefined)
        return;
    _pixelRatio = value;
    this.setSize(_viewport.z, _viewport.w, false);
};
this.getSize = function () {
    return {
        width: _width,
        height: _height
    };
};
this.setSize = function (width, height, updateStyle) {
    _width = width;
    _height = height;
    _canvas.width = width * _pixelRatio;
    _canvas.height = height * _pixelRatio;
    if (updateStyle !== false) {
        _canvas.style.width = width + 'px';
        _canvas.style.height = height + 'px';
    }
    this.setViewport(0, 0, width, height);
};
this.setViewport = function (x, y, width, height) {
    state.viewport(_viewport.set(x, y, width, height));
};
this.setScissor = function (x, y, width, height) {
    state.scissor(_scissor.set(x, y, width, height));
};
this.setScissorTest = function (boolean) {
    state.setScissorTest(_scissorTest = boolean);
};
this.getClearColor = function () {
    return _clearColor;
};
this.setClearColor = function (color, alpha) {
    _clearColor.set(color);
    _clearAlpha = alpha !== undefined ? alpha : 1;
    glClearColor(_clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha);
};
this.getClearAlpha = function () {
    return _clearAlpha;
};
this.setClearAlpha = function (alpha) {
    _clearAlpha = alpha;
    glClearColor(_clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha);
};
this.clear = function (color, depth, stencil) {
    var bits = 0;
    if (color === undefined || color)
        bits |= _gl.COLOR_BUFFER_BIT;
    if (depth === undefined || depth)
        bits |= _gl.DEPTH_BUFFER_BIT;
    if (stencil === undefined || stencil)
        bits |= _gl.STENCIL_BUFFER_BIT;
    _gl.clear(bits);
};
this.clearColor = function () {
    this.clear(true, false, false);
};
this.clearDepth = function () {
    this.clear(false, true, false);
};
this.clearStencil = function () {
    this.clear(false, false, true);
};
this.clearTarget = function (renderTarget, color, depth, stencil) {
    this.setRenderTarget(renderTarget);
    this.clear(color, depth, stencil);
};
this.resetGLState = resetGLState;
this.dispose = function () {
    transparentObjects = [];
    transparentObjectsLastIndex = -1;
    opaqueObjects = [];
    opaqueObjectsLastIndex = -1;
    _canvas.removeEventListener('webglcontextlost', onContextLost, false);
};
this.renderBufferImmediate = function (object, program, material) {
    state.initAttributes();
    var buffers = properties.get(object);
    if (object.hasPositions && !buffers.position)
        buffers.position = _gl.createBuffer();
    if (object.hasNormals && !buffers.normal)
        buffers.normal = _gl.createBuffer();
    if (object.hasUvs && !buffers.uv)
        buffers.uv = _gl.createBuffer();
    if (object.hasColors && !buffers.color)
        buffers.color = _gl.createBuffer();
    var attributes = program.getAttributes();
    if (object.hasPositions) {
        _gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.position);
        _gl.bufferData(_gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW);
        state.enableAttribute(attributes.position);
        _gl.vertexAttribPointer(attributes.position, 3, _gl.FLOAT, false, 0, 0);
    }
    if (object.hasNormals) {
        _gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.normal);
        if (!material.isMeshPhongMaterial && !material.isMeshStandardMaterial && material.shading === FlatShading) {
            for (var i = 0, l = object.count * 3; i < l; i += 9) {
                var array = object.normalArray;
                var nx = (array[i + 0] + array[i + 3] + array[i + 6]) / 3;
                var ny = (array[i + 1] + array[i + 4] + array[i + 7]) / 3;
                var nz = (array[i + 2] + array[i + 5] + array[i + 8]) / 3;
                array[i + 0] = nx;
                array[i + 1] = ny;
                array[i + 2] = nz;
                array[i + 3] = nx;
                array[i + 4] = ny;
                array[i + 5] = nz;
                array[i + 6] = nx;
                array[i + 7] = ny;
                array[i + 8] = nz;
            }
        }
        _gl.bufferData(_gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW);
        state.enableAttribute(attributes.normal);
        _gl.vertexAttribPointer(attributes.normal, 3, _gl.FLOAT, false, 0, 0);
    }
    if (object.hasUvs && material.map) {
        _gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.uv);
        _gl.bufferData(_gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW);
        state.enableAttribute(attributes.uv);
        _gl.vertexAttribPointer(attributes.uv, 2, _gl.FLOAT, false, 0, 0);
    }
    if (object.hasColors && material.vertexColors !== NoColors) {
        _gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.color);
        _gl.bufferData(_gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW);
        state.enableAttribute(attributes.color);
        _gl.vertexAttribPointer(attributes.color, 3, _gl.FLOAT, false, 0, 0);
    }
    state.disableUnusedAttributes();
    _gl.drawArrays(_gl.TRIANGLES, 0, object.count);
    object.count = 0;
};
this.renderBufferDirect = function (camera, fog, geometry, material, object, group) {
    setMaterial(material);
    var program = setProgram(camera, fog, material, object);
    var updateBuffers = false;
    var geometryProgram = geometry.id + '_' + program.id + '_' + material.wireframe;
    if (geometryProgram !== _currentGeometryProgram) {
        _currentGeometryProgram = geometryProgram;
        updateBuffers = true;
    }
    var morphTargetInfluences = object.morphTargetInfluences;
    if (morphTargetInfluences !== undefined) {
        var activeInfluences = [];
        for (var i = 0, l = morphTargetInfluences.length; i < l; i++) {
            var influence = morphTargetInfluences[i];
            activeInfluences.push([
                influence,
                i
            ]);
        }
        activeInfluences.sort(absNumericalSort);
        if (activeInfluences.length > 8) {
            activeInfluences.length = 8;
        }
        var morphAttributes = geometry.morphAttributes;
        for (var i = 0, l = activeInfluences.length; i < l; i++) {
            var influence = activeInfluences[i];
            morphInfluences[i] = influence[0];
            if (influence[0] !== 0) {
                var index = influence[1];
                if (material.morphTargets === true && morphAttributes.position)
                    geometry.addAttribute('morphTarget' + i, morphAttributes.position[index]);
                if (material.morphNormals === true && morphAttributes.normal)
                    geometry.addAttribute('morphNormal' + i, morphAttributes.normal[index]);
            } else {
                if (material.morphTargets === true)
                    geometry.removeAttribute('morphTarget' + i);
                if (material.morphNormals === true)
                    geometry.removeAttribute('morphNormal' + i);
            }
        }
        program.getUniforms().setValue(_gl, 'morphTargetInfluences', morphInfluences);
        updateBuffers = true;
    }
    var index = geometry.index;
    var position = geometry.attributes.position;
    if (material.wireframe === true) {
        index = objects.getWireframeAttribute(geometry);
    }
    var renderer;
    if (index !== null) {
        renderer = indexedBufferRenderer;
        renderer.setIndex(index);
    } else {
        renderer = bufferRenderer;
    }
    if (updateBuffers) {
        setupVertexAttributes(material, program, geometry);
        if (index !== null) {
            _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, objects.getAttributeBuffer(index));
        }
    }
    var dataStart = 0;
    var dataCount = Infinity;
    if (index !== null) {
        dataCount = index.count;
    } else if (position !== undefined) {
        dataCount = position.count;
    }
    var rangeStart = geometry.drawRange.start;
    var rangeCount = geometry.drawRange.count;
    var groupStart = group !== null ? group.start : 0;
    var groupCount = group !== null ? group.count : Infinity;
    var drawStart = Math.max(dataStart, rangeStart, groupStart);
    var drawEnd = Math.min(dataStart + dataCount, rangeStart + rangeCount, groupStart + groupCount) - 1;
    var drawCount = Math.max(0, drawEnd - drawStart + 1);
    if (object.isMesh) {
        if (material.wireframe === true) {
            state.setLineWidth(material.wireframeLinewidth * getTargetPixelRatio());
            renderer.setMode(_gl.LINES);
        } else {
            switch (object.drawMode) {
            case TrianglesDrawMode:
                renderer.setMode(_gl.TRIANGLES);
                break;
            case TriangleStripDrawMode:
                renderer.setMode(_gl.TRIANGLE_STRIP);
                break;
            case TriangleFanDrawMode:
                renderer.setMode(_gl.TRIANGLE_FAN);
                break;
            }
        }
    } else if (object.isLine) {
        var lineWidth = material.linewidth;
        if (lineWidth === undefined)
            lineWidth = 1;
        state.setLineWidth(lineWidth * getTargetPixelRatio());
        if (object.isLineSegments) {
            renderer.setMode(_gl.LINES);
        } else {
            renderer.setMode(_gl.LINE_STRIP);
        }
    } else if (object.isPoints) {
        renderer.setMode(_gl.POINTS);
    }
    if (geometry && geometry.isInstancedBufferGeometry) {
        if (geometry.maxInstancedCount > 0) {
            renderer.renderInstances(geometry, drawStart, drawCount);
        }
    } else {
        renderer.render(drawStart, drawCount);
    }
};
this.render = function (scene, camera, renderTarget, forceClear) {
    if ((camera && camera.isCamera) === false) {
        console.error('THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.');
        return;
    }
    var fog = scene.fog;
    _currentGeometryProgram = '';
    _currentMaterialId = -1;
    _currentCamera = null;
    if (scene.autoUpdate === true)
        scene.updateMatrixWorld();
    if (camera.parent === null)
        camera.updateMatrixWorld();
    camera.matrixWorldInverse.getInverse(camera.matrixWorld);
    _projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
    _frustum.setFromMatrix(_projScreenMatrix);
    lights.length = 0;
    opaqueObjectsLastIndex = -1;
    transparentObjectsLastIndex = -1;
    sprites.length = 0;
    lensFlares.length = 0;
    _localClippingEnabled = this.localClippingEnabled;
    _clippingEnabled = _clipping.init(this.clippingPlanes, _localClippingEnabled, camera);
    projectObject(scene, camera);
    opaqueObjects.length = opaqueObjectsLastIndex + 1;
    transparentObjects.length = transparentObjectsLastIndex + 1;
    if (_this.sortObjects === true) {
        opaqueObjects.sort(painterSortStable);
        transparentObjects.sort(reversePainterSortStable);
    }
    if (_clippingEnabled)
        _clipping.beginShadows();
    setupShadows(lights);
    shadowMap.render(scene, camera);
    setupLights(lights, camera);
    if (_clippingEnabled)
        _clipping.endShadows();
    _infoRender.calls = 0;
    _infoRender.vertices = 0;
    _infoRender.faces = 0;
    _infoRender.points = 0;
    if (renderTarget === undefined) {
        renderTarget = null;
    }
    this.setRenderTarget(renderTarget);
    var background = scene.background;
    if (background === null) {
        glClearColor(_clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha);
    } else if (background && background.isColor) {
        glClearColor(background.r, background.g, background.b, 1);
        forceClear = true;
    }
    if (this.autoClear || forceClear) {
        this.clear(this.autoClearColor, this.autoClearDepth, this.autoClearStencil);
    }
    if (background && background.isCubeTexture) {
        backgroundCamera2.projectionMatrix.copy(camera.projectionMatrix);
        backgroundCamera2.matrixWorld.extractRotation(camera.matrixWorld);
        backgroundCamera2.matrixWorldInverse.getInverse(backgroundCamera2.matrixWorld);
        backgroundBoxMesh.material.uniforms['tCube'].value = background;
        backgroundBoxMesh.modelViewMatrix.multiplyMatrices(backgroundCamera2.matrixWorldInverse, backgroundBoxMesh.matrixWorld);
        objects.update(backgroundBoxMesh);
        _this.renderBufferDirect(backgroundCamera2, null, backgroundBoxMesh.geometry, backgroundBoxMesh.material, backgroundBoxMesh, null);
    } else if (background && background.isTexture) {
        backgroundPlaneMesh.material.map = background;
        objects.update(backgroundPlaneMesh);
        _this.renderBufferDirect(backgroundCamera, null, backgroundPlaneMesh.geometry, backgroundPlaneMesh.material, backgroundPlaneMesh, null);
    }
    if (scene.overrideMaterial) {
        var overrideMaterial = scene.overrideMaterial;
        renderObjects(opaqueObjects, camera, fog, overrideMaterial);
        renderObjects(transparentObjects, camera, fog, overrideMaterial);
    } else {
        state.setBlending(NoBlending);
        renderObjects(opaqueObjects, camera, fog);
        renderObjects(transparentObjects, camera, fog);
    }
    spritePlugin.render(scene, camera);
    lensFlarePlugin.render(scene, camera, _currentViewport);
    if (renderTarget) {
        textures.updateRenderTargetMipmap(renderTarget);
    }
    state.setDepthTest(true);
    state.setDepthWrite(true);
    state.setColorWrite(true);
};
this.setFaceCulling = function (cullFace, frontFaceDirection) {
    state.setCullFace(cullFace);
    state.setFlipSided(frontFaceDirection === FrontFaceDirectionCW);
};
this.allocTextureUnit = allocTextureUnit;
this.setTexture2D = function () {
    var warned = false;
    return function setTexture2D(texture, slot) {
        if (texture && texture.isWebGLRenderTarget) {
            if (!warned) {
                console.warn('THREE.WebGLRenderer.setTexture2D: don\'t use render targets as textures. Use their .texture property instead.');
                warned = true;
            }
            texture = texture.texture;
        }
        textures.setTexture2D(texture, slot);
    };
}();
this.setTexture = function () {
    var warned = false;
    return function setTexture(texture, slot) {
        if (!warned) {
            console.warn('THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead.');
            warned = true;
        }
        textures.setTexture2D(texture, slot);
    };
}();
this.setTextureCube = function () {
    var warned = false;
    return function setTextureCube(texture, slot) {
        if (texture && texture.isWebGLRenderTargetCube) {
            if (!warned) {
                console.warn('THREE.WebGLRenderer.setTextureCube: don\'t use cube render targets as textures. Use their .texture property instead.');
                warned = true;
            }
            texture = texture.texture;
        }
        if (texture && texture.isCubeTexture || Array.isArray(texture.image) && texture.image.length === 6) {
            textures.setTextureCube(texture, slot);
        } else {
            textures.setTextureCubeDynamic(texture, slot);
        }
    };
}();
this.getCurrentRenderTarget = function () {
    return _currentRenderTarget;
};
this.setRenderTarget = function (renderTarget) {
    _currentRenderTarget = renderTarget;
    if (renderTarget && properties.get(renderTarget).__webglFramebuffer === undefined) {
        textures.setupRenderTarget(renderTarget);
    }
    var isCube = renderTarget && renderTarget.isWebGLRenderTargetCube;
    var framebuffer;
    if (renderTarget) {
        var renderTargetProperties = properties.get(renderTarget);
        if (isCube) {
            framebuffer = renderTargetProperties.__webglFramebuffer[renderTarget.activeCubeFace];
        } else {
            framebuffer = renderTargetProperties.__webglFramebuffer;
        }
        _currentScissor.copy(renderTarget.scissor);
        _currentScissorTest = renderTarget.scissorTest;
        _currentViewport.copy(renderTarget.viewport);
    } else {
        framebuffer = null;
        _currentScissor.copy(_scissor).multiplyScalar(_pixelRatio);
        _currentScissorTest = _scissorTest;
        _currentViewport.copy(_viewport).multiplyScalar(_pixelRatio);
    }
    if (_currentFramebuffer !== framebuffer) {
        _gl.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
        _currentFramebuffer = framebuffer;
    }
    state.scissor(_currentScissor);
    state.setScissorTest(_currentScissorTest);
    state.viewport(_currentViewport);
    if (isCube) {
        var textureProperties = properties.get(renderTarget.texture);
        _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + renderTarget.activeCubeFace, textureProperties.__webglTexture, renderTarget.activeMipMapLevel);
    }
};
this.readRenderTargetPixels = function (renderTarget, x, y, width, height, buffer) {
    if ((renderTarget && renderTarget.isWebGLRenderTarget) === false) {
        console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.');
        return;
    }
    var framebuffer = properties.get(renderTarget).__webglFramebuffer;
    if (framebuffer) {
        var restore = false;
        if (framebuffer !== _currentFramebuffer) {
            _gl.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
            restore = true;
        }
        try {
            var texture = renderTarget.texture;
            var textureFormat = texture.format;
            var textureType = texture.type;
            if (textureFormat !== RGBAFormat && paramThreeToGL(textureFormat) !== _gl.getParameter(_gl.IMPLEMENTATION_COLOR_READ_FORMAT)) {
                console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.');
                return;
            }
            if (textureType !== UnsignedByteType && paramThreeToGL(textureType) !== _gl.getParameter(_gl.IMPLEMENTATION_COLOR_READ_TYPE) && !(textureType === FloatType && (extensions.get('OES_texture_float') || extensions.get('WEBGL_color_buffer_float'))) && !(textureType === HalfFloatType && extensions.get('EXT_color_buffer_half_float'))) {
                console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.');
                return;
            }
            if (_gl.checkFramebufferStatus(_gl.FRAMEBUFFER) === _gl.FRAMEBUFFER_COMPLETE) {
                if (x >= 0 && x <= renderTarget.width - width && (y >= 0 && y <= renderTarget.height - height)) {
                    _gl.readPixels(x, y, width, height, paramThreeToGL(textureFormat), paramThreeToGL(textureType), buffer);
                }
            } else {
                console.error('THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.');
            }
        } finally {
            if (restore) {
                _gl.bindFramebuffer(_gl.FRAMEBUFFER, _currentFramebuffer);
            }
        }
    }
};});
    FogExp2 = ($__.fs.FogExp2_121 = function FogExp2(color, density) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
color = arguments[0], density = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.name = '';
this.color = new Color(color);
this.density = density !== undefined ? density : 0.00025;});
    Fog = ($__.fs.Fog_122 = function Fog(color, near, far) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
color = arguments[0], near = arguments[1], far = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.name = '';
this.color = new Color(color);
this.near = near !== undefined ? near : 1;
this.far = far !== undefined ? far : 1000;});
    Scene = ($__.fs.Scene_123 = function Scene() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
Object3D.call(this);
this.type = 'Scene';
this.background = null;
this.fog = null;
this.overrideMaterial = null;
this.autoUpdate = true;});
    LensFlare = ($__.fs.LensFlare_124 = function LensFlare(texture, size, distance, blending, color) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
texture = arguments[0], size = arguments[1], distance = arguments[2], blending = arguments[3], color = arguments[4];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
Object3D.call(this);
this.lensFlares = [];
this.positionScreen = new Vector3();
this.customUpdateCallback = undefined;
if (texture !== undefined) {
    this.add(texture, size, distance, blending, color);
}});
    SpriteMaterial = ($__.fs.SpriteMaterial_125 = function SpriteMaterial(parameters) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
parameters = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
Material.call(this);
this.type = 'SpriteMaterial';
this.color = new Color(16777215);
this.map = null;
this.rotation = 0;
this.fog = false;
this.lights = false;
this.setValues(parameters);});
    Sprite = ($__.fs.Sprite_126 = function Sprite(material) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
material = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
Object3D.call(this);
this.type = 'Sprite';
this.material = material !== undefined ? material : new SpriteMaterial();});
    LOD = ($__.fs.LOD_127 = function LOD() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
Object3D.call(this);
this.type = 'LOD';
Object.defineProperties(this, {
    levels: {
        enumerable: true,
        value: []
    }
});});
    DataTexture = ($__.fs.DataTexture_128 = function DataTexture(data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
data = arguments[0], width = arguments[1], height = arguments[2], format = arguments[3], type = arguments[4], mapping = arguments[5], wrapS = arguments[6], wrapT = arguments[7], magFilter = arguments[8], minFilter = arguments[9], anisotropy = arguments[10], encoding = arguments[11];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
this.image = {
    data: data,
    width: width,
    height: height
};
this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;
this.flipY = false;
this.generateMipmaps = false;});
    Skeleton = ($__.fs.Skeleton_129 = function Skeleton(bones, boneInverses, useVertexTexture) {
var vvv_return, vvv_switch, size;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
bones = arguments[0], boneInverses = arguments[1], useVertexTexture = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.useVertexTexture = useVertexTexture !== undefined ? useVertexTexture : true;
this.identityMatrix = new Matrix4();
bones = bones || [];
this.bones = bones.slice(0);
if (this.useVertexTexture) {
    size = Math.sqrt(this.bones.length * 4);
    size = exports.Math.nextPowerOfTwo(Math.ceil(size));
    size = Math.max(size, 4);
    this.boneTextureWidth = size;
    this.boneTextureHeight = size;
    this.boneMatrices = new Float32Array(this.boneTextureWidth * this.boneTextureHeight * 4);
    this.boneTexture = new DataTexture(this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, RGBAFormat, FloatType);
} else {
    this.boneMatrices = new Float32Array(16 * this.bones.length);
}
if (boneInverses === undefined) {
    this.calculateInverses();
} else {
    if (this.bones.length === boneInverses.length) {
        this.boneInverses = boneInverses.slice(0);
    } else {
        console.warn('THREE.Skeleton bonInverses is the wrong length.');
        this.boneInverses = [];
        for (var b = 0, bl = this.bones.length; b < bl; b++) {
            this.boneInverses.push(new Matrix4());
        }
    }
}});
    Bone = ($__.fs.Bone_130 = function Bone(skin) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
skin = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
Object3D.call(this);
this.type = 'Bone';
this.skin = skin;});
    SkinnedMesh = ($__.fs.SkinnedMesh_131 = function SkinnedMesh(geometry, material, useVertexTexture) {
var vvv_return, vvv_switch, bones, bone, gbone;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
geometry = arguments[0], material = arguments[1], useVertexTexture = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
Mesh.call(this, geometry, material);
this.type = 'SkinnedMesh';
this.bindMode = 'attached';
this.bindMatrix = new Matrix4();
this.bindMatrixInverse = new Matrix4();
bones = [];
if (this.geometry && this.geometry.bones !== undefined) {
    for (var b = 0, bl = this.geometry.bones.length; b < bl; ++b) {
        gbone = this.geometry.bones[b];
        bone = new Bone(this);
        bones.push(bone);
        bone.name = gbone.name;
        bone.position.fromArray(gbone.pos);
        bone.quaternion.fromArray(gbone.rotq);
        if (gbone.scl !== undefined)
            bone.scale.fromArray(gbone.scl);
    }
    for (var b = 0, bl = this.geometry.bones.length; b < bl; ++b) {
        gbone = this.geometry.bones[b];
        if (gbone.parent !== -1 && gbone.parent !== null && bones[gbone.parent] !== undefined) {
            bones[gbone.parent].add(bones[b]);
        } else {
            this.add(bones[b]);
        }
    }
}
this.normalizeSkinWeights();
this.updateMatrixWorld(true);
this.bind(new Skeleton(bones, undefined, useVertexTexture), this.matrixWorld);});
    LineBasicMaterial = ($__.fs.LineBasicMaterial_132 = function LineBasicMaterial(parameters) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
parameters = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
Material.call(this);
this.type = 'LineBasicMaterial';
this.color = new Color(16777215);
this.linewidth = 1;
this.linecap = 'round';
this.linejoin = 'round';
this.lights = false;
this.setValues(parameters);});
    Line = ($__.fs.Line_133 = function Line(geometry, material, mode) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
geometry = arguments[0], material = arguments[1], mode = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (mode === 1) {
    console.warn('THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead.');
    return new LineSegments(geometry, material);
}
Object3D.call(this);
this.type = 'Line';
this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
this.material = material !== undefined ? material : new LineBasicMaterial({
    color: Math.random() * 16777215
});});
    LineSegments = ($__.fs.LineSegments_134 = function LineSegments(geometry, material) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
geometry = arguments[0], material = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
Line.call(this, geometry, material);
this.type = 'LineSegments';});
    PointsMaterial = ($__.fs.PointsMaterial_135 = function PointsMaterial(parameters) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
parameters = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
Material.call(this);
this.type = 'PointsMaterial';
this.color = new Color(16777215);
this.map = null;
this.size = 1;
this.sizeAttenuation = true;
this.lights = false;
this.setValues(parameters);});
    Points = ($__.fs.Points_136 = function Points(geometry, material) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
geometry = arguments[0], material = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
Object3D.call(this);
this.type = 'Points';
this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
this.material = material !== undefined ? material : new PointsMaterial({
    color: Math.random() * 16777215
});});
    Group = ($__.fs.Group_137 = function Group() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
Object3D.call(this);
this.type = 'Group';});
    VideoTexture = ($__.fs.VideoTexture_138 = function VideoTexture(video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
var vvv_return, vvv_switch, scope, update;
update = function update() {
    requestAnimationFrame(update);
    if (video.readyState >= video.HAVE_CURRENT_DATA) {
        scope.needsUpdate = true;
    }
};
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
video = arguments[0], mapping = arguments[1], wrapS = arguments[2], wrapT = arguments[3], magFilter = arguments[4], minFilter = arguments[5], format = arguments[6], type = arguments[7], anisotropy = arguments[8];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
Texture.call(this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
this.generateMipmaps = false;
scope = this;
update();});
    CompressedTexture = ($__.fs.CompressedTexture_139 = function CompressedTexture(mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
mipmaps = arguments[0], width = arguments[1], height = arguments[2], format = arguments[3], type = arguments[4], mapping = arguments[5], wrapS = arguments[6], wrapT = arguments[7], magFilter = arguments[8], minFilter = arguments[9], anisotropy = arguments[10], encoding = arguments[11];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
this.image = {
    width: width,
    height: height
};
this.mipmaps = mipmaps;
this.flipY = false;
this.generateMipmaps = false;});
    CanvasTexture = ($__.fs.CanvasTexture_140 = function CanvasTexture(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
canvas = arguments[0], mapping = arguments[1], wrapS = arguments[2], wrapT = arguments[3], magFilter = arguments[4], minFilter = arguments[5], format = arguments[6], type = arguments[7], anisotropy = arguments[8];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
Texture.call(this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
this.needsUpdate = true;});
    DepthTexture = ($__.fs.DepthTexture_141 = function DepthTexture(width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
width = arguments[0], height = arguments[1], type = arguments[2], mapping = arguments[3], wrapS = arguments[4], wrapT = arguments[5], magFilter = arguments[6], minFilter = arguments[7], anisotropy = arguments[8], format = arguments[9];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
format = format !== undefined ? format : DepthFormat;
if (format !== DepthFormat && format !== DepthStencilFormat) {
    throw new Error('DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat');
}
Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
this.image = {
    width: width,
    height: height
};
this.type = type !== undefined ? type : UnsignedShortType;
this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;
this.flipY = false;
this.generateMipmaps = false;});
    ShadowMaterial = ($__.fs.ShadowMaterial_142 = function ShadowMaterial() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
ShaderMaterial.call(this, {
    uniforms: exports.UniformsUtils.merge([
        UniformsLib['lights'],
        {
            opacity: {
                value: 1
            }
        }
    ]),
    vertexShader: ShaderChunk['shadow_vert'],
    fragmentShader: ShaderChunk['shadow_frag']
});
this.lights = true;
this.transparent = true;
Object.defineProperties(this, {
    opacity: {
        enumerable: true,
        get: function () {
            return this.uniforms.opacity.value;
        },
        set: function (value) {
            this.uniforms.opacity.value = value;
        }
    }
});});
    RawShaderMaterial = ($__.fs.RawShaderMaterial_143 = function RawShaderMaterial(parameters) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
parameters = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
ShaderMaterial.call(this, parameters);
this.type = 'RawShaderMaterial';});
    MultiMaterial = ($__.fs.MultiMaterial_144 = function MultiMaterial(materials) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
materials = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.uuid = exports.Math.generateUUID();
this.type = 'MultiMaterial';
this.materials = materials instanceof Array ? materials : [];
this.visible = true;});
    MeshStandardMaterial = ($__.fs.MeshStandardMaterial_145 = function MeshStandardMaterial(parameters) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
parameters = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
Material.call(this);
this.defines = {
    'STANDARD': ''
};
this.type = 'MeshStandardMaterial';
this.color = new Color(16777215);
this.roughness = 0.5;
this.metalness = 0.5;
this.map = null;
this.lightMap = null;
this.lightMapIntensity = 1;
this.aoMap = null;
this.aoMapIntensity = 1;
this.emissive = new Color(0);
this.emissiveIntensity = 1;
this.emissiveMap = null;
this.bumpMap = null;
this.bumpScale = 1;
this.normalMap = null;
this.normalScale = new Vector2(1, 1);
this.displacementMap = null;
this.displacementScale = 1;
this.displacementBias = 0;
this.roughnessMap = null;
this.metalnessMap = null;
this.alphaMap = null;
this.envMap = null;
this.envMapIntensity = 1;
this.refractionRatio = 0.98;
this.wireframe = false;
this.wireframeLinewidth = 1;
this.wireframeLinecap = 'round';
this.wireframeLinejoin = 'round';
this.skinning = false;
this.morphTargets = false;
this.morphNormals = false;
this.setValues(parameters);});
    MeshPhysicalMaterial = ($__.fs.MeshPhysicalMaterial_146 = function MeshPhysicalMaterial(parameters) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
parameters = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
MeshStandardMaterial.call(this);
this.defines = {
    'PHYSICAL': ''
};
this.type = 'MeshPhysicalMaterial';
this.reflectivity = 0.5;
this.clearCoat = 0;
this.clearCoatRoughness = 0;
this.setValues(parameters);});
    MeshPhongMaterial = ($__.fs.MeshPhongMaterial_147 = function MeshPhongMaterial(parameters) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
parameters = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
Material.call(this);
this.type = 'MeshPhongMaterial';
this.color = new Color(16777215);
this.specular = new Color(1118481);
this.shininess = 30;
this.map = null;
this.lightMap = null;
this.lightMapIntensity = 1;
this.aoMap = null;
this.aoMapIntensity = 1;
this.emissive = new Color(0);
this.emissiveIntensity = 1;
this.emissiveMap = null;
this.bumpMap = null;
this.bumpScale = 1;
this.normalMap = null;
this.normalScale = new Vector2(1, 1);
this.displacementMap = null;
this.displacementScale = 1;
this.displacementBias = 0;
this.specularMap = null;
this.alphaMap = null;
this.envMap = null;
this.combine = MultiplyOperation;
this.reflectivity = 1;
this.refractionRatio = 0.98;
this.wireframe = false;
this.wireframeLinewidth = 1;
this.wireframeLinecap = 'round';
this.wireframeLinejoin = 'round';
this.skinning = false;
this.morphTargets = false;
this.morphNormals = false;
this.setValues(parameters);});
    MeshNormalMaterial = ($__.fs.MeshNormalMaterial_148 = function MeshNormalMaterial(parameters) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
parameters = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
Material.call(this, parameters);
this.type = 'MeshNormalMaterial';
this.wireframe = false;
this.wireframeLinewidth = 1;
this.fog = false;
this.lights = false;
this.morphTargets = false;
this.setValues(parameters);});
    MeshLambertMaterial = ($__.fs.MeshLambertMaterial_149 = function MeshLambertMaterial(parameters) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
parameters = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
Material.call(this);
this.type = 'MeshLambertMaterial';
this.color = new Color(16777215);
this.map = null;
this.lightMap = null;
this.lightMapIntensity = 1;
this.aoMap = null;
this.aoMapIntensity = 1;
this.emissive = new Color(0);
this.emissiveIntensity = 1;
this.emissiveMap = null;
this.specularMap = null;
this.alphaMap = null;
this.envMap = null;
this.combine = MultiplyOperation;
this.reflectivity = 1;
this.refractionRatio = 0.98;
this.wireframe = false;
this.wireframeLinewidth = 1;
this.wireframeLinecap = 'round';
this.wireframeLinejoin = 'round';
this.skinning = false;
this.morphTargets = false;
this.morphNormals = false;
this.setValues(parameters);});
    LineDashedMaterial = ($__.fs.LineDashedMaterial_150 = function LineDashedMaterial(parameters) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
parameters = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
Material.call(this);
this.type = 'LineDashedMaterial';
this.color = new Color(16777215);
this.linewidth = 1;
this.scale = 1;
this.dashSize = 3;
this.gapSize = 1;
this.lights = false;
this.setValues(parameters);});
    LoadingManager = ($__.fs.LoadingManager_151 = function LoadingManager(onLoad, onProgress, onError) {
var vvv_return, vvv_switch, scope, isLoading, itemsLoaded, itemsTotal;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
onLoad = arguments[0], onProgress = arguments[1], onError = arguments[2];
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    scope = this;
    isLoading = false;
    itemsLoaded = 0;
    itemsTotal = 0;
    this.onStart = undefined;
    this.onLoad = onLoad;
    this.onProgress = onProgress;
    this.onError = onError;
    this.itemStart = ($__.fs.J$__v494107025_1934_1057 = function J$__v494107025_1934(url) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
url = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
itemsTotal++;
if (isLoading === false) {
    if (scope.onStart !== undefined) {
        scope.onStart(url, itemsLoaded, itemsTotal);
    }
}
isLoading = true;});
    this.itemEnd = ($__.fs.J$__v494107025_1936_1058 = function J$__v494107025_1936(url) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
url = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
itemsLoaded++;
if (scope.onProgress !== undefined) {
    scope.onProgress(url, itemsLoaded, itemsTotal);
}
if (itemsLoaded === itemsTotal) {
    isLoading = false;
    if (scope.onLoad !== undefined) {
        scope.onLoad();
    }
}});
    this.itemError = ($__.fs.J$__v494107025_1938_1059 = function J$__v494107025_1938(url) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
url = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (scope.onError !== undefined) {
    scope.onError(url);
}});
    return;
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
scope = this;
isLoading = false;
itemsLoaded = 0;
itemsTotal = 0;
this.onStart = undefined;
this.onLoad = onLoad;
this.onProgress = onProgress;
this.onError = onError;
this.itemStart = function (url) {
    itemsTotal++;
    if (isLoading === false) {
        if (scope.onStart !== undefined) {
            scope.onStart(url, itemsLoaded, itemsTotal);
        }
    }
    isLoading = true;
};
this.itemEnd = function (url) {
    itemsLoaded++;
    if (scope.onProgress !== undefined) {
        scope.onProgress(url, itemsLoaded, itemsTotal);
    }
    if (itemsLoaded === itemsTotal) {
        isLoading = false;
        if (scope.onLoad !== undefined) {
            scope.onLoad();
        }
    }
};
this.itemError = function (url) {
    if (scope.onError !== undefined) {
        scope.onError(url);
    }
};});
    XHRLoader = ($__.fs.XHRLoader_152 = function XHRLoader(manager) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
manager = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.manager = manager !== undefined ? manager : exports.DefaultLoadingManager;});
    CompressedTextureLoader = ($__.fs.CompressedTextureLoader_153 = function CompressedTextureLoader(manager) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
manager = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.manager = manager !== undefined ? manager : exports.DefaultLoadingManager;
this._parser = null;});
    BinaryTextureLoader = ($__.fs.BinaryTextureLoader_154 = function BinaryTextureLoader(manager) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
manager = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.manager = manager !== undefined ? manager : exports.DefaultLoadingManager;
this._parser = null;});
    ImageLoader = ($__.fs.ImageLoader_155 = function ImageLoader(manager) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
manager = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.manager = manager !== undefined ? manager : exports.DefaultLoadingManager;});
    CubeTextureLoader = ($__.fs.CubeTextureLoader_156 = function CubeTextureLoader(manager) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
manager = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.manager = manager !== undefined ? manager : exports.DefaultLoadingManager;});
    TextureLoader = ($__.fs.TextureLoader_157 = function TextureLoader(manager) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
manager = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.manager = manager !== undefined ? manager : exports.DefaultLoadingManager;});
    Light = ($__.fs.Light_158 = function Light(color, intensity) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
color = arguments[0], intensity = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
Object3D.call(this);
this.type = 'Light';
this.color = new Color(color);
this.intensity = intensity !== undefined ? intensity : 1;
this.receiveShadow = undefined;});
    HemisphereLight = ($__.fs.HemisphereLight_159 = function HemisphereLight(skyColor, groundColor, intensity) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
skyColor = arguments[0], groundColor = arguments[1], intensity = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
Light.call(this, skyColor, intensity);
this.type = 'HemisphereLight';
this.castShadow = undefined;
this.position.copy(Object3D.DefaultUp);
this.updateMatrix();
this.groundColor = new Color(groundColor);});
    LightShadow = ($__.fs.LightShadow_160 = function LightShadow(camera) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
camera = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.camera = camera;
this.bias = 0;
this.radius = 1;
this.mapSize = new Vector2(512, 512);
this.map = null;
this.matrix = new Matrix4();});
    SpotLightShadow = ($__.fs.SpotLightShadow_161 = function SpotLightShadow() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
LightShadow.call(this, new PerspectiveCamera(50, 1, 0.5, 500));});
    SpotLight = ($__.fs.SpotLight_162 = function SpotLight(color, intensity, distance, angle, penumbra, decay) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
color = arguments[0], intensity = arguments[1], distance = arguments[2], angle = arguments[3], penumbra = arguments[4], decay = arguments[5];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
Light.call(this, color, intensity);
this.type = 'SpotLight';
this.position.copy(Object3D.DefaultUp);
this.updateMatrix();
this.target = new Object3D();
Object.defineProperty(this, 'power', {
    get: function () {
        return this.intensity * Math.PI;
    },
    set: function (power) {
        this.intensity = power / Math.PI;
    }
});
this.distance = distance !== undefined ? distance : 0;
this.angle = angle !== undefined ? angle : Math.PI / 3;
this.penumbra = penumbra !== undefined ? penumbra : 0;
this.decay = decay !== undefined ? decay : 1;
this.shadow = new SpotLightShadow();});
    PointLight = ($__.fs.PointLight_163 = function PointLight(color, intensity, distance, decay) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
color = arguments[0], intensity = arguments[1], distance = arguments[2], decay = arguments[3];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
Light.call(this, color, intensity);
this.type = 'PointLight';
Object.defineProperty(this, 'power', {
    get: function () {
        return this.intensity * 4 * Math.PI;
    },
    set: function (power) {
        this.intensity = power / (4 * Math.PI);
    }
});
this.distance = distance !== undefined ? distance : 0;
this.decay = decay !== undefined ? decay : 1;
this.shadow = new LightShadow(new PerspectiveCamera(90, 1, 0.5, 500));});
    DirectionalLightShadow = ($__.fs.DirectionalLightShadow_164 = function DirectionalLightShadow(light) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
light = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
LightShadow.call(this, new OrthographicCamera(-5, 5, 5, -5, 0.5, 500));});
    DirectionalLight = ($__.fs.DirectionalLight_165 = function DirectionalLight(color, intensity) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
color = arguments[0], intensity = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
Light.call(this, color, intensity);
this.type = 'DirectionalLight';
this.position.copy(Object3D.DefaultUp);
this.updateMatrix();
this.target = new Object3D();
this.shadow = new DirectionalLightShadow();});
    AmbientLight = ($__.fs.AmbientLight_166 = function AmbientLight(color, intensity) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
color = arguments[0], intensity = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
Light.call(this, color, intensity);
this.type = 'AmbientLight';
this.castShadow = undefined;});
    Interpolant = ($__.fs.Interpolant_167 = function Interpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
parameterPositions = arguments[0], sampleValues = arguments[1], sampleSize = arguments[2], resultBuffer = arguments[3];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.parameterPositions = parameterPositions;
this._cachedIndex = 0;
this.resultBuffer = resultBuffer !== undefined ? resultBuffer : new sampleValues.constructor(sampleSize);
this.sampleValues = sampleValues;
this.valueSize = sampleSize;});
    CubicInterpolant = ($__.fs.CubicInterpolant_168 = function CubicInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
parameterPositions = arguments[0], sampleValues = arguments[1], sampleSize = arguments[2], resultBuffer = arguments[3];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
this._weightPrev = -0;
this._offsetPrev = -0;
this._weightNext = -0;
this._offsetNext = -0;});
    LinearInterpolant = ($__.fs.LinearInterpolant_169 = function LinearInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
parameterPositions = arguments[0], sampleValues = arguments[1], sampleSize = arguments[2], resultBuffer = arguments[3];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);});
    DiscreteInterpolant = ($__.fs.DiscreteInterpolant_170 = function DiscreteInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
parameterPositions = arguments[0], sampleValues = arguments[1], sampleSize = arguments[2], resultBuffer = arguments[3];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);});
    KeyframeTrackConstructor = ($__.fs.KeyframeTrackConstructor_171 = function KeyframeTrackConstructor(name, times, values, interpolation) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
name = arguments[0], times = arguments[1], values = arguments[2], interpolation = arguments[3];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (name === undefined)
    throw new Error('track name is undefined');
if (times === undefined || times.length === 0) {
    throw new Error('no keyframes in track named ' + name);
}
this.name = name;
this.times = exports.AnimationUtils.convertArray(times, this.TimeBufferType);
this.values = exports.AnimationUtils.convertArray(values, this.ValueBufferType);
this.setInterpolation(interpolation || this.DefaultInterpolation);
this.validate();
this.optimize();});
    VectorKeyframeTrack = ($__.fs.VectorKeyframeTrack_172 = function VectorKeyframeTrack(name, times, values, interpolation) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
name = arguments[0], times = arguments[1], values = arguments[2], interpolation = arguments[3];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
KeyframeTrackConstructor.call(this, name, times, values, interpolation);});
    QuaternionLinearInterpolant = ($__.fs.QuaternionLinearInterpolant_173 = function QuaternionLinearInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
parameterPositions = arguments[0], sampleValues = arguments[1], sampleSize = arguments[2], resultBuffer = arguments[3];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);});
    QuaternionKeyframeTrack = ($__.fs.QuaternionKeyframeTrack_174 = function QuaternionKeyframeTrack(name, times, values, interpolation) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
name = arguments[0], times = arguments[1], values = arguments[2], interpolation = arguments[3];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
KeyframeTrackConstructor.call(this, name, times, values, interpolation);});
    NumberKeyframeTrack = ($__.fs.NumberKeyframeTrack_175 = function NumberKeyframeTrack(name, times, values, interpolation) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
name = arguments[0], times = arguments[1], values = arguments[2], interpolation = arguments[3];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
KeyframeTrackConstructor.call(this, name, times, values, interpolation);});
    StringKeyframeTrack = ($__.fs.StringKeyframeTrack_176 = function StringKeyframeTrack(name, times, values, interpolation) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
name = arguments[0], times = arguments[1], values = arguments[2], interpolation = arguments[3];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
KeyframeTrackConstructor.call(this, name, times, values, interpolation);});
    BooleanKeyframeTrack = ($__.fs.BooleanKeyframeTrack_177 = function BooleanKeyframeTrack(name, times, values) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
name = arguments[0], times = arguments[1], values = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
KeyframeTrackConstructor.call(this, name, times, values);});
    ColorKeyframeTrack = ($__.fs.ColorKeyframeTrack_178 = function ColorKeyframeTrack(name, times, values, interpolation) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
name = arguments[0], times = arguments[1], values = arguments[2], interpolation = arguments[3];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
KeyframeTrackConstructor.call(this, name, times, values, interpolation);});
    KeyframeTrack = ($__.fs.KeyframeTrack_179 = function KeyframeTrack(name, times, values, interpolation) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
name = arguments[0], times = arguments[1], values = arguments[2], interpolation = arguments[3];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
KeyframeTrackConstructor.apply(this, arguments);}, $__.fs.KeyframeTrack_179_2 = $__.fs.KeyframeTrack_179, $__.fs.KeyframeTrack_179);
    AnimationClip = ($__.fs.AnimationClip_180 = function AnimationClip(name, duration, tracks) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
name = arguments[0], duration = arguments[1], tracks = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.name = name;
this.tracks = tracks;
this.duration = duration !== undefined ? duration : -1;
this.uuid = exports.Math.generateUUID();
if (this.duration < 0) {
    this.resetDuration();
}
this.trim();
this.optimize();}, $__.fs.AnimationClip_180_3 = $__.fs.AnimationClip_180, $__.fs.AnimationClip_180);
    MaterialLoader = ($__.fs.MaterialLoader_181 = function MaterialLoader(manager) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
manager = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.manager = manager !== undefined ? manager : exports.DefaultLoadingManager;
this.textures = {};});
    BufferGeometryLoader = ($__.fs.BufferGeometryLoader_182 = function BufferGeometryLoader(manager) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
manager = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.manager = manager !== undefined ? manager : exports.DefaultLoadingManager;});
    Loader = ($__.fs.Loader_183 = function Loader() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.onLoadStart = function () {
};
this.onLoadProgress = function () {
};
this.onLoadComplete = function () {
};});
    JSONLoader = ($__.fs.JSONLoader_184 = function JSONLoader(manager) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
manager = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (typeof manager === 'boolean') {
    console.warn('THREE.JSONLoader: showStatus parameter has been removed from constructor.');
    manager = undefined;
}
this.manager = manager !== undefined ? manager : exports.DefaultLoadingManager;
this.withCredentials = false;});
    ObjectLoader = ($__.fs.ObjectLoader_185 = function ObjectLoader(manager) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
manager = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.manager = manager !== undefined ? manager : exports.DefaultLoadingManager;
this.texturePath = '';});
    Curve = ($__.fs.Curve_186 = function Curve() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');});
    LineCurve = ($__.fs.LineCurve_187 = function LineCurve(v1, v2) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
v1 = arguments[0], v2 = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.v1 = v1;
this.v2 = v2;});
    CurvePath = ($__.fs.CurvePath_188 = function CurvePath() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.curves = [];
this.autoClose = false;});
    EllipseCurve = ($__.fs.EllipseCurve_189 = function EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
aX = arguments[0], aY = arguments[1], xRadius = arguments[2], yRadius = arguments[3], aStartAngle = arguments[4], aEndAngle = arguments[5], aClockwise = arguments[6], aRotation = arguments[7];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.aX = aX;
this.aY = aY;
this.xRadius = xRadius;
this.yRadius = yRadius;
this.aStartAngle = aStartAngle;
this.aEndAngle = aEndAngle;
this.aClockwise = aClockwise;
this.aRotation = aRotation || 0;});
    SplineCurve = ($__.fs.SplineCurve_190 = function SplineCurve(points) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
points = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.points = points === undefined ? [] : points;});
    CubicBezierCurve = ($__.fs.CubicBezierCurve_191 = function CubicBezierCurve(v0, v1, v2, v3) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
v0 = arguments[0], v1 = arguments[1], v2 = arguments[2], v3 = arguments[3];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.v0 = v0;
this.v1 = v1;
this.v2 = v2;
this.v3 = v3;});
    QuadraticBezierCurve = ($__.fs.QuadraticBezierCurve_192 = function QuadraticBezierCurve(v0, v1, v2) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
v0 = arguments[0], v1 = arguments[1], v2 = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.v0 = v0;
this.v1 = v1;
this.v2 = v2;});
    TubeGeometry = ($__.fs.TubeGeometry_193 = function TubeGeometry(path, segments, radius, radialSegments, closed, taper) {
var vvv_return, vvv_switch, grid, scope, tangent, normal, binormal, numpoints, u, v, r, cx, cy, pos, pos2, i, j, ip, jp, a, b, c, d, uva, uvb, uvc, uvd, frames, tangents, normals, binormals, vert;
vert = function vert(x, y, z) {
    return scope.vertices.push(new Vector3(x, y, z)) - 1;
};
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
path = arguments[0], segments = arguments[1], radius = arguments[2], radialSegments = arguments[3], closed = arguments[4], taper = arguments[5];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
Geometry.call(this);
this.type = 'TubeGeometry';
this.parameters = {
    path: path,
    segments: segments,
    radius: radius,
    radialSegments: radialSegments,
    closed: closed,
    taper: taper
};
segments = segments || 64;
radius = radius || 1;
radialSegments = radialSegments || 8;
closed = closed || false;
taper = taper || TubeGeometry.NoTaper;
grid = [];
scope = this;
numpoints = segments + 1;
pos2 = new Vector3();
frames = new TubeGeometry.FrenetFrames(path, segments, closed);
tangents = frames.tangents;
normals = frames.normals;
binormals = frames.binormals;
this.tangents = tangents;
this.normals = normals;
this.binormals = binormals;
for (i = 0; i < numpoints; i++) {
    grid[i] = [];
    u = i / (numpoints - 1);
    pos = path.getPointAt(u);
    tangent = tangents[i];
    normal = normals[i];
    binormal = binormals[i];
    r = radius * taper(u);
    for (j = 0; j < radialSegments; j++) {
        v = j / radialSegments * 2 * Math.PI;
        cx = -r * Math.cos(v);
        cy = r * Math.sin(v);
        pos2.copy(pos);
        pos2.x += cx * normal.x + cy * binormal.x;
        pos2.y += cx * normal.y + cy * binormal.y;
        pos2.z += cx * normal.z + cy * binormal.z;
        grid[i][j] = vert(pos2.x, pos2.y, pos2.z);
    }
}
for (i = 0; i < segments; i++) {
    for (j = 0; j < radialSegments; j++) {
        ip = closed ? (i + 1) % segments : i + 1;
        jp = (j + 1) % radialSegments;
        a = grid[i][j];
        b = grid[ip][j];
        c = grid[ip][jp];
        d = grid[i][jp];
        uva = new Vector2(i / segments, j / radialSegments);
        uvb = new Vector2((i + 1) / segments, j / radialSegments);
        uvc = new Vector2((i + 1) / segments, (j + 1) / radialSegments);
        uvd = new Vector2(i / segments, (j + 1) / radialSegments);
        this.faces.push(new Face3(a, b, d));
        this.faceVertexUvs[0].push([
            uva,
            uvb,
            uvd
        ]);
        this.faces.push(new Face3(b, c, d));
        this.faceVertexUvs[0].push([
            uvb.clone(),
            uvc,
            uvd.clone()
        ]);
    }
}
this.computeFaceNormals();
this.computeVertexNormals();});
    ExtrudeGeometry = ($__.fs.ExtrudeGeometry_194 = function ExtrudeGeometry(shapes, options) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
shapes = arguments[0], options = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (typeof shapes === 'undefined') {
    shapes = [];
    return;
}
Geometry.call(this);
this.type = 'ExtrudeGeometry';
shapes = Array.isArray(shapes) ? shapes : [shapes];
this.addShapeList(shapes, options);
this.computeFaceNormals();});
    ShapeGeometry = ($__.fs.ShapeGeometry_195 = function ShapeGeometry(shapes, options) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
shapes = arguments[0], options = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
Geometry.call(this);
this.type = 'ShapeGeometry';
if (Array.isArray(shapes) === false)
    shapes = [shapes];
this.addShapeList(shapes, options);
this.computeFaceNormals();});
    Shape = ($__.fs.Shape_196 = function Shape() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
Path.apply(this, arguments);
this.holes = [];});
    Path = ($__.fs.Path_197 = function Path(points) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
points = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
CurvePath.call(this);
this.currentPoint = new Vector2();
if (points) {
    this.fromPoints(points);
}});
    ShapePath = ($__.fs.ShapePath_198 = function ShapePath() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.subPaths = [];
this.currentPath = null;});
    Font = ($__.fs.Font_199 = function Font(data) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
data = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.data = data;});
    FontLoader = ($__.fs.FontLoader_200 = function FontLoader(manager) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
manager = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.manager = manager !== undefined ? manager : exports.DefaultLoadingManager;});
    getAudioContext = ($__.fs.getAudioContext_201 = function getAudioContext() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (context === undefined) {
    context = new (window.AudioContext || window.webkitAudioContext)();
}
return context;});
    AudioLoader = ($__.fs.AudioLoader_202 = function AudioLoader(manager) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
manager = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.manager = manager !== undefined ? manager : exports.DefaultLoadingManager;});
    StereoCamera = ($__.fs.StereoCamera_203 = function StereoCamera() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.type = 'StereoCamera';
this.aspect = 1;
this.eyeSep = 0.064;
this.cameraL = new PerspectiveCamera();
this.cameraL.layers.enable(1);
this.cameraL.matrixAutoUpdate = false;
this.cameraR = new PerspectiveCamera();
this.cameraR.layers.enable(2);
this.cameraR.matrixAutoUpdate = false;});
    CubeCamera = ($__.fs.CubeCamera_204 = function CubeCamera(near, far, cubeResolution) {
var vvv_return, vvv_switch, fov, aspect, cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ, options;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
near = arguments[0], far = arguments[1], cubeResolution = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
Object3D.call(this);
this.type = 'CubeCamera';
fov = 90;
aspect = 1;
cameraPX = new PerspectiveCamera(fov, aspect, near, far);
cameraPX.up.set(0, -1, 0);
cameraPX.lookAt(new Vector3(1, 0, 0));
this.add(cameraPX);
cameraNX = new PerspectiveCamera(fov, aspect, near, far);
cameraNX.up.set(0, -1, 0);
cameraNX.lookAt(new Vector3(-1, 0, 0));
this.add(cameraNX);
cameraPY = new PerspectiveCamera(fov, aspect, near, far);
cameraPY.up.set(0, 0, 1);
cameraPY.lookAt(new Vector3(0, 1, 0));
this.add(cameraPY);
cameraNY = new PerspectiveCamera(fov, aspect, near, far);
cameraNY.up.set(0, 0, -1);
cameraNY.lookAt(new Vector3(0, -1, 0));
this.add(cameraNY);
cameraPZ = new PerspectiveCamera(fov, aspect, near, far);
cameraPZ.up.set(0, -1, 0);
cameraPZ.lookAt(new Vector3(0, 0, 1));
this.add(cameraPZ);
cameraNZ = new PerspectiveCamera(fov, aspect, near, far);
cameraNZ.up.set(0, -1, 0);
cameraNZ.lookAt(new Vector3(0, 0, -1));
this.add(cameraNZ);
options = {
    format: RGBFormat,
    magFilter: LinearFilter,
    minFilter: LinearFilter
};
this.renderTarget = new WebGLRenderTargetCube(cubeResolution, cubeResolution, options);
this.updateCubeMap = function (renderer, scene) {
    if (this.parent === null)
        this.updateMatrixWorld();
    var renderTarget = this.renderTarget;
    var generateMipmaps = renderTarget.texture.generateMipmaps;
    renderTarget.texture.generateMipmaps = false;
    renderTarget.activeCubeFace = 0;
    renderer.render(scene, cameraPX, renderTarget);
    renderTarget.activeCubeFace = 1;
    renderer.render(scene, cameraNX, renderTarget);
    renderTarget.activeCubeFace = 2;
    renderer.render(scene, cameraPY, renderTarget);
    renderTarget.activeCubeFace = 3;
    renderer.render(scene, cameraNY, renderTarget);
    renderTarget.activeCubeFace = 4;
    renderer.render(scene, cameraPZ, renderTarget);
    renderTarget.texture.generateMipmaps = generateMipmaps;
    renderTarget.activeCubeFace = 5;
    renderer.render(scene, cameraNZ, renderTarget);
    renderer.setRenderTarget(null);
};});
    AudioListener = ($__.fs.AudioListener_205 = function AudioListener() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
Object3D.call(this);
this.type = 'AudioListener';
this.context = getAudioContext();
this.gain = this.context.createGain();
this.gain.connect(this.context.destination);
this.filter = null;});
    Audio = ($__.fs.Audio_206 = function Audio(listener) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
listener = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
Object3D.call(this);
this.type = 'Audio';
this.context = listener.context;
this.source = this.context.createBufferSource();
this.source.onended = this.onEnded.bind(this);
this.gain = this.context.createGain();
this.gain.connect(listener.getInput());
this.autoplay = false;
this.startTime = 0;
this.playbackRate = 1;
this.isPlaying = false;
this.hasPlaybackControl = true;
this.sourceType = 'empty';
this.filters = [];});
    PositionalAudio = ($__.fs.PositionalAudio_207 = function PositionalAudio(listener) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
listener = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
Audio.call(this, listener);
this.panner = this.context.createPanner();
this.panner.connect(this.gain);});
    AudioAnalyser = ($__.fs.AudioAnalyser_208 = function AudioAnalyser(audio, fftSize) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
audio = arguments[0], fftSize = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.analyser = audio.context.createAnalyser();
this.analyser.fftSize = fftSize !== undefined ? fftSize : 2048;
this.data = new Uint8Array(this.analyser.frequencyBinCount);
audio.getOutput().connect(this.analyser);});
    PropertyMixer = ($__.fs.PropertyMixer_209 = function PropertyMixer(binding, typeName, valueSize) {
var vvv_return, vvv_switch, bufferType, mixFunction;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
binding = arguments[0], typeName = arguments[1], valueSize = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.binding = binding;
this.valueSize = valueSize;
bufferType = Float64Array;
switch (typeName) {
case 'quaternion':
    mixFunction = this._slerp;
    break;
case 'string':
case 'bool':
    bufferType = Array, mixFunction = this._select;
    break;
default:
    mixFunction = this._lerp;
}
this.buffer = new bufferType(valueSize * 4);
this._mixBufferRegion = mixFunction;
this.cumulativeWeight = 0;
this.useCount = 0;
this.referenceCount = 0;});
    PropertyBinding = ($__.fs.PropertyBinding_210 = function PropertyBinding(rootNode, path, parsedPath) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
rootNode = arguments[0], path = arguments[1], parsedPath = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.path = path;
this.parsedPath = parsedPath || PropertyBinding.parseTrackName(path);
this.node = PropertyBinding.findNode(rootNode, this.parsedPath.nodeName) || rootNode;
this.rootNode = rootNode;});
    AnimationObjectGroup = ($__.fs.AnimationObjectGroup_211 = function AnimationObjectGroup(var_args) {
var vvv_return, vvv_switch, indices, scope;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
var_args = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.uuid = exports.Math.generateUUID();
this._objects = Array.prototype.slice.call(arguments);
this.nCachedObjects_ = 0;
indices = {};
this._indicesByUUID = indices;
for (var i = 0, n = arguments.length; i !== n; ++i) {
    indices[arguments[i].uuid] = i;
}
this._paths = [];
this._parsedPaths = [];
this._bindings = [];
this._bindingsIndicesByPath = {};
scope = this;
this.stats = {
    objects: {
        get total() {
            return scope._objects.length;
        },
        get inUse() {
            return this.total - scope.nCachedObjects_;
        }
    },
    get bindingsPerObject() {
        return scope._bindings.length;
    }
};});
    AnimationAction = ($__.fs.AnimationAction_212 = function AnimationAction(mixer, clip, localRoot) {
var vvv_return, vvv_switch, tracks, nTracks, interpolants, interpolantSettings, interpolant;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
mixer = arguments[0], clip = arguments[1], localRoot = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this._mixer = mixer;
this._clip = clip;
this._localRoot = localRoot || null;
tracks = clip.tracks;
nTracks = tracks.length;
interpolants = new Array(nTracks);
interpolantSettings = {
    endingStart: ZeroCurvatureEnding,
    endingEnd: ZeroCurvatureEnding
};
for (var i = 0; i !== nTracks; ++i) {
    interpolant = tracks[i].createInterpolant(null);
    interpolants[i] = interpolant;
    interpolant.settings = interpolantSettings;
}
this._interpolantSettings = interpolantSettings;
this._interpolants = interpolants;
this._propertyBindings = new Array(nTracks);
this._cacheIndex = null;
this._byClipCacheIndex = null;
this._timeScaleInterpolant = null;
this._weightInterpolant = null;
this.loop = LoopRepeat;
this._loopCount = -1;
this._startTime = null;
this.time = 0;
this.timeScale = 1;
this._effectiveTimeScale = 1;
this.weight = 1;
this._effectiveWeight = 1;
this.repetitions = Infinity;
this.paused = false;
this.enabled = true;
this.clampWhenFinished = false;
this.zeroSlopeAtStart = true;
this.zeroSlopeAtEnd = true;});
    AnimationMixer = ($__.fs.AnimationMixer_213 = function AnimationMixer(root) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
root = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this._root = root;
this._initMemoryManager();
this._accuIndex = 0;
this.time = 0;
this.timeScale = 1;});
    Uniform = ($__.fs.Uniform_214 = function Uniform(value) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
value = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (typeof value === 'string') {
    console.warn('THREE.Uniform: Type parameter is no longer needed.');
    value = arguments[1];
}
this.value = value;
this.dynamic = false;});
    InstancedBufferGeometry = ($__.fs.InstancedBufferGeometry_215 = function InstancedBufferGeometry() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
BufferGeometry.call(this);
this.type = 'InstancedBufferGeometry';
this.maxInstancedCount = undefined;});
    InterleavedBufferAttribute = ($__.fs.InterleavedBufferAttribute_216 = function InterleavedBufferAttribute(interleavedBuffer, itemSize, offset, normalized) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
interleavedBuffer = arguments[0], itemSize = arguments[1], offset = arguments[2], normalized = arguments[3];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.uuid = exports.Math.generateUUID();
this.data = interleavedBuffer;
this.itemSize = itemSize;
this.offset = offset;
this.normalized = normalized === true;});
    InterleavedBuffer = ($__.fs.InterleavedBuffer_217 = function InterleavedBuffer(array, stride) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
array = arguments[0], stride = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.uuid = exports.Math.generateUUID();
this.array = array;
this.stride = stride;
this.dynamic = false;
this.updateRange = {
    offset: 0,
    count: -1
};
this.version = 0;});
    InstancedInterleavedBuffer = ($__.fs.InstancedInterleavedBuffer_218 = function InstancedInterleavedBuffer(array, stride, meshPerAttribute) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
array = arguments[0], stride = arguments[1], meshPerAttribute = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
InterleavedBuffer.call(this, array, stride);
this.meshPerAttribute = meshPerAttribute || 1;});
    InstancedBufferAttribute = ($__.fs.InstancedBufferAttribute_219 = function InstancedBufferAttribute(array, itemSize, meshPerAttribute) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
array = arguments[0], itemSize = arguments[1], meshPerAttribute = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
BufferAttribute.call(this, array, itemSize);
this.meshPerAttribute = meshPerAttribute || 1;});
    Raycaster = ($__.fs.Raycaster_220 = function Raycaster(origin, direction, near, far) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
origin = arguments[0], direction = arguments[1], near = arguments[2], far = arguments[3];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.ray = new Ray(origin, direction);
this.near = near || 0;
this.far = far || Infinity;
this.params = {
    Mesh: {},
    Line: {},
    LOD: {},
    Points: {
        threshold: 1
    },
    Sprite: {}
};
Object.defineProperties(this.params, {
    PointCloud: {
        get: function () {
            console.warn('THREE.Raycaster: params.PointCloud has been renamed to params.Points.');
            return this.Points;
        }
    }
});});
    ascSort = ($__.fs.ascSort_221 = function ascSort(a, b) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
a = arguments[0], b = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return a.distance - b.distance;});
    intersectObject = ($__.fs.intersectObject_222 = function intersectObject(object, raycaster, intersects, recursive) {
var vvv_return, vvv_switch, children;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
object = arguments[0], raycaster = arguments[1], intersects = arguments[2], recursive = arguments[3];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (object.visible === false)
    return;
object.raycast(raycaster, intersects);
if (recursive === true) {
    children = object.children;
    for (var i = 0, l = children.length; i < l; i++) {
        intersectObject(children[i], raycaster, intersects, true);
    }
}});
    Clock = ($__.fs.Clock_223 = function Clock(autoStart) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
autoStart = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.autoStart = autoStart !== undefined ? autoStart : true;
this.startTime = 0;
this.oldTime = 0;
this.elapsedTime = 0;
this.running = false;});
    Spline = ($__.fs.Spline_224 = function Spline(points) {
var vvv_return, vvv_switch, c, v3, point, intPoint, weight, w2, w3, pa, pb, pc, pd, interpolate;
interpolate = function interpolate(p0, p1, p2, p3, t, t2, t3) {
    var v0 = (p2 - p0) * 0.5, v1 = (p3 - p1) * 0.5;
    return (2 * (p1 - p2) + v0 + v1) * t3 + (-3 * (p1 - p2) - 2 * v0 - v1) * t2 + v0 * t + p1;
};
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
points = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.points = points;
c = [];
v3 = {
    x: 0,
    y: 0,
    z: 0
};
this.initFromArray = function (a) {
    this.points = [];
    for (var i = 0; i < a.length; i++) {
        this.points[i] = {
            x: a[i][0],
            y: a[i][1],
            z: a[i][2]
        };
    }
};
this.getPoint = function (k) {
    point = (this.points.length - 1) * k;
    intPoint = Math.floor(point);
    weight = point - intPoint;
    c[0] = intPoint === 0 ? intPoint : intPoint - 1;
    c[1] = intPoint;
    c[2] = intPoint > this.points.length - 2 ? this.points.length - 1 : intPoint + 1;
    c[3] = intPoint > this.points.length - 3 ? this.points.length - 1 : intPoint + 2;
    pa = this.points[c[0]];
    pb = this.points[c[1]];
    pc = this.points[c[2]];
    pd = this.points[c[3]];
    w2 = weight * weight;
    w3 = weight * w2;
    v3.x = interpolate(pa.x, pb.x, pc.x, pd.x, weight, w2, w3);
    v3.y = interpolate(pa.y, pb.y, pc.y, pd.y, weight, w2, w3);
    v3.z = interpolate(pa.z, pb.z, pc.z, pd.z, weight, w2, w3);
    return v3;
};
this.getControlPointsArray = function () {
    var i, p, l = this.points.length, coords = [];
    for (i = 0; i < l; i++) {
        p = this.points[i];
        coords[i] = [
            p.x,
            p.y,
            p.z
        ];
    }
    return coords;
};
this.getLength = function (nSubDivisions) {
    var i, index, nSamples, position, point = 0, intPoint = 0, oldIntPoint = 0, oldPosition = new Vector3(), tmpVec = new Vector3(), chunkLengths = [], totalLength = 0;
    chunkLengths[0] = 0;
    if (!nSubDivisions)
        nSubDivisions = 100;
    nSamples = this.points.length * nSubDivisions;
    oldPosition.copy(this.points[0]);
    for (i = 1; i < nSamples; i++) {
        index = i / nSamples;
        position = this.getPoint(index);
        tmpVec.copy(position);
        totalLength += tmpVec.distanceTo(oldPosition);
        oldPosition.copy(position);
        point = (this.points.length - 1) * index;
        intPoint = Math.floor(point);
        if (intPoint !== oldIntPoint) {
            chunkLengths[intPoint] = totalLength;
            oldIntPoint = intPoint;
        }
    }
    chunkLengths[chunkLengths.length] = totalLength;
    return {
        chunks: chunkLengths,
        total: totalLength
    };
};
this.reparametrizeByArcLength = function (samplingCoef) {
    var i, j, index, indexCurrent, indexNext, realDistance, sampling, position, newpoints = [], tmpVec = new Vector3(), sl = this.getLength();
    newpoints.push(tmpVec.copy(this.points[0]).clone());
    for (i = 1; i < this.points.length; i++) {
        realDistance = sl.chunks[i] - sl.chunks[i - 1];
        sampling = Math.ceil(samplingCoef * realDistance / sl.total);
        indexCurrent = (i - 1) / (this.points.length - 1);
        indexNext = i / (this.points.length - 1);
        for (j = 1; j < sampling - 1; j++) {
            index = indexCurrent + j * (1 / sampling) * (indexNext - indexCurrent);
            position = this.getPoint(index);
            newpoints.push(tmpVec.copy(position).clone());
        }
        newpoints.push(tmpVec.copy(this.points[i]).clone());
    }
    this.points = newpoints;
};});
    Spherical = ($__.fs.Spherical_225 = function Spherical(radius, phi, theta) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
radius = arguments[0], phi = arguments[1], theta = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.radius = radius !== undefined ? radius : 1;
this.phi = phi !== undefined ? phi : 0;
this.theta = theta !== undefined ? theta : 0;
return this;});
    MorphBlendMesh = ($__.fs.MorphBlendMesh_226 = function MorphBlendMesh(geometry, material) {
var vvv_return, vvv_switch, numFrames, name, startFrame, endFrame, fps;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
geometry = arguments[0], material = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
Mesh.call(this, geometry, material);
this.animationsMap = {};
this.animationsList = [];
numFrames = this.geometry.morphTargets.length;
name = '__default';
startFrame = 0;
endFrame = numFrames - 1;
fps = numFrames / 1;
this.createAnimation(name, startFrame, endFrame, fps);
this.setAnimationWeight(name, 1);});
    ImmediateRenderObject = ($__.fs.ImmediateRenderObject_227 = function ImmediateRenderObject(material) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
material = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
Object3D.call(this);
this.material = material;
this.render = function (renderCallback) {
};});
    WireframeGeometry = ($__.fs.WireframeGeometry_228 = function WireframeGeometry(geometry) {
var vvv_return, vvv_switch, edge, hash, sortFunction, keys, vertices, faces, numEdges, edges, face, key, coords, vertex, index, indices, groups, group, start, count, index2, numTris, index1;
sortFunction = function sortFunction(a, b) {
    return a - b;
};
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
geometry = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
BufferGeometry.call(this);
edge = [
    0,
    0
];
hash = {};
keys = [
    'a',
    'b',
    'c'
];
if (geometry && geometry.isGeometry) {
    vertices = geometry.vertices;
    faces = geometry.faces;
    numEdges = 0;
    edges = new Uint32Array(6 * faces.length);
    for (var i = 0, l = faces.length; i < l; i++) {
        face = faces[i];
        for (var j = 0; j < 3; j++) {
            edge[0] = face[keys[j]];
            edge[1] = face[keys[(j + 1) % 3]];
            edge.sort(sortFunction);
            key = edge.toString();
            if (hash[key] === undefined) {
                edges[2 * numEdges] = edge[0];
                edges[2 * numEdges + 1] = edge[1];
                hash[key] = true;
                numEdges++;
            }
        }
    }
    coords = new Float32Array(numEdges * 2 * 3);
    for (var i = 0, l = numEdges; i < l; i++) {
        for (var j = 0; j < 2; j++) {
            vertex = vertices[edges[2 * i + j]];
            index = 6 * i + 3 * j;
            coords[index + 0] = vertex.x;
            coords[index + 1] = vertex.y;
            coords[index + 2] = vertex.z;
        }
    }
    this.addAttribute('position', new BufferAttribute(coords, 3));
} else if (geometry && geometry.isBufferGeometry) {
    if (geometry.index !== null) {
        indices = geometry.index.array;
        vertices = geometry.attributes.position;
        groups = geometry.groups;
        numEdges = 0;
        if (groups.length === 0) {
            geometry.addGroup(0, indices.length);
        }
        edges = new Uint32Array(2 * indices.length);
        for (var o = 0, ol = groups.length; o < ol; ++o) {
            group = groups[o];
            start = group.start;
            count = group.count;
            for (var i = start, il = start + count; i < il; i += 3) {
                for (var j = 0; j < 3; j++) {
                    edge[0] = indices[i + j];
                    edge[1] = indices[i + (j + 1) % 3];
                    edge.sort(sortFunction);
                    key = edge.toString();
                    if (hash[key] === undefined) {
                        edges[2 * numEdges] = edge[0];
                        edges[2 * numEdges + 1] = edge[1];
                        hash[key] = true;
                        numEdges++;
                    }
                }
            }
        }
        coords = new Float32Array(numEdges * 2 * 3);
        for (var i = 0, l = numEdges; i < l; i++) {
            for (var j = 0; j < 2; j++) {
                index = 6 * i + 3 * j;
                index2 = edges[2 * i + j];
                coords[index + 0] = vertices.getX(index2);
                coords[index + 1] = vertices.getY(index2);
                coords[index + 2] = vertices.getZ(index2);
            }
        }
        this.addAttribute('position', new BufferAttribute(coords, 3));
    } else {
        vertices = geometry.attributes.position.array;
        numEdges = vertices.length / 3;
        numTris = numEdges / 3;
        coords = new Float32Array(numEdges * 2 * 3);
        for (var i = 0, l = numTris; i < l; i++) {
            for (var j = 0; j < 3; j++) {
                index = 18 * i + 6 * j;
                index1 = 9 * i + 3 * j;
                coords[index + 0] = vertices[index1];
                coords[index + 1] = vertices[index1 + 1];
                coords[index + 2] = vertices[index1 + 2];
                index2 = 9 * i + 3 * ((j + 1) % 3);
                coords[index + 3] = vertices[index2];
                coords[index + 4] = vertices[index2 + 1];
                coords[index + 5] = vertices[index2 + 2];
            }
        }
        this.addAttribute('position', new BufferAttribute(coords, 3));
    }
}});
    WireframeHelper = ($__.fs.WireframeHelper_229 = function WireframeHelper(object, hex) {
var vvv_return, vvv_switch, color;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
object = arguments[0], hex = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
color = hex !== undefined ? hex : 16777215;
LineSegments.call(this, new WireframeGeometry(object.geometry), new LineBasicMaterial({
    color: color
}));
this.matrix = object.matrixWorld;
this.matrixAutoUpdate = false;});
    VertexNormalsHelper = ($__.fs.VertexNormalsHelper_230 = function VertexNormalsHelper(object, size, hex, linewidth) {
var vvv_return, vvv_switch, color, width, nNormals, objGeometry, geometry, positions;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
object = arguments[0], size = arguments[1], hex = arguments[2], linewidth = arguments[3];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.object = object;
this.size = size !== undefined ? size : 1;
color = hex !== undefined ? hex : 16711680;
width = linewidth !== undefined ? linewidth : 1;
nNormals = 0;
objGeometry = this.object.geometry;
if (objGeometry && objGeometry.isGeometry) {
    nNormals = objGeometry.faces.length * 3;
} else if (objGeometry && objGeometry.isBufferGeometry) {
    nNormals = objGeometry.attributes.normal.count;
}
geometry = new BufferGeometry();
positions = new Float32Attribute(nNormals * 2 * 3, 3);
geometry.addAttribute('position', positions);
LineSegments.call(this, geometry, new LineBasicMaterial({
    color: color,
    linewidth: width
}));
this.matrixAutoUpdate = false;
this.update();});
    SpotLightHelper = ($__.fs.SpotLightHelper_231 = function SpotLightHelper(light) {
var vvv_return, vvv_switch, geometry, positions, p1, p2, material;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
light = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
Object3D.call(this);
this.light = light;
this.light.updateMatrixWorld();
this.matrix = light.matrixWorld;
this.matrixAutoUpdate = false;
geometry = new BufferGeometry();
positions = [
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    1,
    0,
    1,
    0,
    0,
    0,
    -1,
    0,
    1,
    0,
    0,
    0,
    0,
    1,
    1,
    0,
    0,
    0,
    0,
    -1,
    1
];
for (var i = 0, j = 1, l = 32; i < l; i++, j++) {
    p1 = i / l * Math.PI * 2;
    p2 = j / l * Math.PI * 2;
    positions.push(Math.cos(p1), Math.sin(p1), 1, Math.cos(p2), Math.sin(p2), 1);
}
geometry.addAttribute('position', new Float32Attribute(positions, 3));
material = new LineBasicMaterial({
    fog: false
});
this.cone = new LineSegments(geometry, material);
this.add(this.cone);
this.update();});
    SkeletonHelper = ($__.fs.SkeletonHelper_232 = function SkeletonHelper(object) {
var vvv_return, vvv_switch, geometry, bone, material;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
object = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.bones = this.getBoneList(object);
geometry = new Geometry();
for (var i = 0; i < this.bones.length; i++) {
    bone = this.bones[i];
    if (bone.parent && bone.parent.isBone) {
        geometry.vertices.push(new Vector3());
        geometry.vertices.push(new Vector3());
        geometry.colors.push(new Color(0, 0, 1));
        geometry.colors.push(new Color(0, 1, 0));
    }
}
geometry.dynamic = true;
material = new LineBasicMaterial({
    vertexColors: VertexColors,
    depthTest: false,
    depthWrite: false,
    transparent: true
});
LineSegments.call(this, geometry, material);
this.root = object;
this.matrix = object.matrixWorld;
this.matrixAutoUpdate = false;
this.update();});
    SphereBufferGeometry = ($__.fs.SphereBufferGeometry_233 = function SphereBufferGeometry(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength) {
var vvv_return, vvv_switch, thetaEnd, vertexCount, positions, normals, uvs, index, vertices, normal, verticesRow, v, u, px, py, pz, indices, v1, v2, v3, v4;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
radius = arguments[0], widthSegments = arguments[1], heightSegments = arguments[2], phiStart = arguments[3], phiLength = arguments[4], thetaStart = arguments[5], thetaLength = arguments[6];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
BufferGeometry.call(this);
this.type = 'SphereBufferGeometry';
this.parameters = {
    radius: radius,
    widthSegments: widthSegments,
    heightSegments: heightSegments,
    phiStart: phiStart,
    phiLength: phiLength,
    thetaStart: thetaStart,
    thetaLength: thetaLength
};
radius = radius || 50;
widthSegments = Math.max(3, Math.floor(widthSegments) || 8);
heightSegments = Math.max(2, Math.floor(heightSegments) || 6);
phiStart = phiStart !== undefined ? phiStart : 0;
phiLength = phiLength !== undefined ? phiLength : Math.PI * 2;
thetaStart = thetaStart !== undefined ? thetaStart : 0;
thetaLength = thetaLength !== undefined ? thetaLength : Math.PI;
thetaEnd = thetaStart + thetaLength;
vertexCount = (widthSegments + 1) * (heightSegments + 1);
positions = new BufferAttribute(new Float32Array(vertexCount * 3), 3);
normals = new BufferAttribute(new Float32Array(vertexCount * 3), 3);
uvs = new BufferAttribute(new Float32Array(vertexCount * 2), 2);
index = 0;
vertices = [];
normal = new Vector3();
for (var y = 0; y <= heightSegments; y++) {
    verticesRow = [];
    v = y / heightSegments;
    for (var x = 0; x <= widthSegments; x++) {
        u = x / widthSegments;
        px = -radius * Math.cos(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
        py = radius * Math.cos(thetaStart + v * thetaLength);
        pz = radius * Math.sin(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
        normal.set(px, py, pz).normalize();
        positions.setXYZ(index, px, py, pz);
        normals.setXYZ(index, normal.x, normal.y, normal.z);
        uvs.setXY(index, u, 1 - v);
        verticesRow.push(index);
        index++;
    }
    vertices.push(verticesRow);
}
indices = [];
for (var y = 0; y < heightSegments; y++) {
    for (var x = 0; x < widthSegments; x++) {
        v1 = vertices[y][x + 1];
        v2 = vertices[y][x];
        v3 = vertices[y + 1][x];
        v4 = vertices[y + 1][x + 1];
        if (y !== 0 || thetaStart > 0)
            indices.push(v1, v2, v4);
        if (y !== heightSegments - 1 || thetaEnd < Math.PI)
            indices.push(v2, v3, v4);
    }
}
this.setIndex(new (positions.count > 65535 ? Uint32Attribute : Uint16Attribute)(indices, 1));
this.addAttribute('position', positions);
this.addAttribute('normal', normals);
this.addAttribute('uv', uvs);
this.boundingSphere = new Sphere(new Vector3(), radius);});
    PointLightHelper = ($__.fs.PointLightHelper_234 = function PointLightHelper(light, sphereSize) {
var vvv_return, vvv_switch, geometry, material;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
light = arguments[0], sphereSize = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.light = light;
this.light.updateMatrixWorld();
geometry = new SphereBufferGeometry(sphereSize, 4, 2);
material = new MeshBasicMaterial({
    wireframe: true,
    fog: false
});
material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
Mesh.call(this, geometry, material);
this.matrix = this.light.matrixWorld;
this.matrixAutoUpdate = false;});
    SphereGeometry = ($__.fs.SphereGeometry_235 = function SphereGeometry(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
radius = arguments[0], widthSegments = arguments[1], heightSegments = arguments[2], phiStart = arguments[3], phiLength = arguments[4], thetaStart = arguments[5], thetaLength = arguments[6];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
Geometry.call(this);
this.type = 'SphereGeometry';
this.parameters = {
    radius: radius,
    widthSegments: widthSegments,
    heightSegments: heightSegments,
    phiStart: phiStart,
    phiLength: phiLength,
    thetaStart: thetaStart,
    thetaLength: thetaLength
};
this.fromBufferGeometry(new SphereBufferGeometry(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength));});
    HemisphereLightHelper = ($__.fs.HemisphereLightHelper_236 = function HemisphereLightHelper(light, sphereSize) {
var vvv_return, vvv_switch, geometry, material;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
light = arguments[0], sphereSize = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
Object3D.call(this);
this.light = light;
this.light.updateMatrixWorld();
this.matrix = light.matrixWorld;
this.matrixAutoUpdate = false;
this.colors = [
    new Color(),
    new Color()
];
geometry = new SphereGeometry(sphereSize, 4, 2);
geometry.rotateX(-Math.PI / 2);
for (var i = 0, il = 8; i < il; i++) {
    geometry.faces[i].color = this.colors[i < 4 ? 0 : 1];
}
material = new MeshBasicMaterial({
    vertexColors: FaceColors,
    wireframe: true
});
this.lightSphere = new Mesh(geometry, material);
this.add(this.lightSphere);
this.update();});
    GridHelper = ($__.fs.GridHelper_237 = function GridHelper(size, divisions, color1, color2) {
var vvv_return, vvv_switch, center, step, vertices, colors, color, geometry, material;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
size = arguments[0], divisions = arguments[1], color1 = arguments[2], color2 = arguments[3];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
divisions = divisions || 1;
color1 = new Color(color1 !== undefined ? color1 : 4473924);
color2 = new Color(color2 !== undefined ? color2 : 8947848);
center = divisions / 2;
step = size * 2 / divisions;
vertices = [];
colors = [];
for (var i = 0, j = 0, k = -size; i <= divisions; i++, k += step) {
    vertices.push(-size, 0, k, size, 0, k);
    vertices.push(k, 0, -size, k, 0, size);
    color = i === center ? color1 : color2;
    color.toArray(colors, j);
    j += 3;
    color.toArray(colors, j);
    j += 3;
    color.toArray(colors, j);
    j += 3;
    color.toArray(colors, j);
    j += 3;
}
geometry = new BufferGeometry();
geometry.addAttribute('position', new Float32Attribute(vertices, 3));
geometry.addAttribute('color', new Float32Attribute(colors, 3));
material = new LineBasicMaterial({
    vertexColors: VertexColors
});
LineSegments.call(this, geometry, material);});
    FaceNormalsHelper = ($__.fs.FaceNormalsHelper_238 = function FaceNormalsHelper(object, size, hex, linewidth) {
var vvv_return, vvv_switch, color, width, nNormals, objGeometry, geometry, positions;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
object = arguments[0], size = arguments[1], hex = arguments[2], linewidth = arguments[3];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.object = object;
this.size = size !== undefined ? size : 1;
color = hex !== undefined ? hex : 16776960;
width = linewidth !== undefined ? linewidth : 1;
nNormals = 0;
objGeometry = this.object.geometry;
if (objGeometry && objGeometry.isGeometry) {
    nNormals = objGeometry.faces.length;
} else {
    console.warn('THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.');
}
geometry = new BufferGeometry();
positions = new Float32Attribute(nNormals * 2 * 3, 3);
geometry.addAttribute('position', positions);
LineSegments.call(this, geometry, new LineBasicMaterial({
    color: color,
    linewidth: width
}));
this.matrixAutoUpdate = false;
this.update();});
    EdgesGeometry = ($__.fs.EdgesGeometry_239 = function EdgesGeometry(geometry, thresholdAngle) {
var vvv_return, vvv_switch, thresholdDot, edge, hash, sortFunction, keys, geometry2, vertices, faces, face, key, coords, h, vertex;
sortFunction = function sortFunction(a, b) {
    return a - b;
};
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
geometry = arguments[0], thresholdAngle = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
BufferGeometry.call(this);
thresholdAngle = thresholdAngle !== undefined ? thresholdAngle : 1;
thresholdDot = Math.cos(exports.Math.DEG2RAD * thresholdAngle);
edge = [
    0,
    0
];
hash = {};
keys = [
    'a',
    'b',
    'c'
];
if (geometry && geometry.isBufferGeometry) {
    geometry2 = new Geometry();
    geometry2.fromBufferGeometry(geometry);
} else {
    geometry2 = geometry.clone();
}
geometry2.mergeVertices();
geometry2.computeFaceNormals();
vertices = geometry2.vertices;
faces = geometry2.faces;
for (var i = 0, l = faces.length; i < l; i++) {
    face = faces[i];
    for (var j = 0; j < 3; j++) {
        edge[0] = face[keys[j]];
        edge[1] = face[keys[(j + 1) % 3]];
        edge.sort(sortFunction);
        key = edge.toString();
        if (hash[key] === undefined) {
            hash[key] = {
                vert1: edge[0],
                vert2: edge[1],
                face1: i,
                face2: undefined
            };
        } else {
            hash[key].face2 = i;
        }
    }
}
coords = [];
for (var key in hash) {
    h = hash[key];
    if (h.face2 === undefined || faces[h.face1].normal.dot(faces[h.face2].normal) <= thresholdDot) {
        vertex = vertices[h.vert1];
        coords.push(vertex.x);
        coords.push(vertex.y);
        coords.push(vertex.z);
        vertex = vertices[h.vert2];
        coords.push(vertex.x);
        coords.push(vertex.y);
        coords.push(vertex.z);
    }
}
this.addAttribute('position', new BufferAttribute(new Float32Array(coords), 3));});
    EdgesHelper = ($__.fs.EdgesHelper_240 = function EdgesHelper(object, hex, thresholdAngle) {
var vvv_return, vvv_switch, color;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
object = arguments[0], hex = arguments[1], thresholdAngle = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
color = hex !== undefined ? hex : 16777215;
LineSegments.call(this, new EdgesGeometry(object.geometry, thresholdAngle), new LineBasicMaterial({
    color: color
}));
this.matrix = object.matrixWorld;
this.matrixAutoUpdate = false;});
    DirectionalLightHelper = ($__.fs.DirectionalLightHelper_241 = function DirectionalLightHelper(light, size) {
var vvv_return, vvv_switch, geometry, material;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
light = arguments[0], size = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
Object3D.call(this);
this.light = light;
this.light.updateMatrixWorld();
this.matrix = light.matrixWorld;
this.matrixAutoUpdate = false;
if (size === undefined)
    size = 1;
geometry = new BufferGeometry();
geometry.addAttribute('position', new Float32Attribute([
    -size,
    size,
    0,
    size,
    size,
    0,
    size,
    -size,
    0,
    -size,
    -size,
    0,
    -size,
    size,
    0
], 3));
material = new LineBasicMaterial({
    fog: false
});
this.add(new Line(geometry, material));
geometry = new BufferGeometry();
geometry.addAttribute('position', new Float32Attribute([
    0,
    0,
    0,
    0,
    0,
    1
], 3));
this.add(new Line(geometry, material));
this.update();});
    CameraHelper = ($__.fs.CameraHelper_242 = function CameraHelper(camera) {
var vvv_return, vvv_switch, geometry, material, pointMap, hexFrustum, hexCone, hexUp, hexTarget, hexCross, addLine, addPoint;
addLine = function addLine(a, b, hex) {
    addPoint(a, hex);
    addPoint(b, hex);
};
addPoint = function addPoint(id, hex) {
    geometry.vertices.push(new Vector3());
    geometry.colors.push(new Color(hex));
    if (pointMap[id] === undefined) {
        pointMap[id] = [];
    }
    pointMap[id].push(geometry.vertices.length - 1);
};
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
camera = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
geometry = new Geometry();
material = new LineBasicMaterial({
    color: 16777215,
    vertexColors: FaceColors
});
pointMap = {};
hexFrustum = 16755200;
hexCone = 16711680;
hexUp = 43775;
hexTarget = 16777215;
hexCross = 3355443;
addLine('n1', 'n2', hexFrustum);
addLine('n2', 'n4', hexFrustum);
addLine('n4', 'n3', hexFrustum);
addLine('n3', 'n1', hexFrustum);
addLine('f1', 'f2', hexFrustum);
addLine('f2', 'f4', hexFrustum);
addLine('f4', 'f3', hexFrustum);
addLine('f3', 'f1', hexFrustum);
addLine('n1', 'f1', hexFrustum);
addLine('n2', 'f2', hexFrustum);
addLine('n3', 'f3', hexFrustum);
addLine('n4', 'f4', hexFrustum);
addLine('p', 'n1', hexCone);
addLine('p', 'n2', hexCone);
addLine('p', 'n3', hexCone);
addLine('p', 'n4', hexCone);
addLine('u1', 'u2', hexUp);
addLine('u2', 'u3', hexUp);
addLine('u3', 'u1', hexUp);
addLine('c', 't', hexTarget);
addLine('p', 'c', hexCross);
addLine('cn1', 'cn2', hexCross);
addLine('cn3', 'cn4', hexCross);
addLine('cf1', 'cf2', hexCross);
addLine('cf3', 'cf4', hexCross);
LineSegments.call(this, geometry, material);
this.camera = camera;
if (this.camera.updateProjectionMatrix)
    this.camera.updateProjectionMatrix();
this.matrix = camera.matrixWorld;
this.matrixAutoUpdate = false;
this.pointMap = pointMap;
this.update();});
    BoxGeometry = ($__.fs.BoxGeometry_243 = function BoxGeometry(width, height, depth, widthSegments, heightSegments, depthSegments) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
width = arguments[0], height = arguments[1], depth = arguments[2], widthSegments = arguments[3], heightSegments = arguments[4], depthSegments = arguments[5];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
Geometry.call(this);
this.type = 'BoxGeometry';
this.parameters = {
    width: width,
    height: height,
    depth: depth,
    widthSegments: widthSegments,
    heightSegments: heightSegments,
    depthSegments: depthSegments
};
this.fromBufferGeometry(new BoxBufferGeometry(width, height, depth, widthSegments, heightSegments, depthSegments));
this.mergeVertices();});
    BoundingBoxHelper = ($__.fs.BoundingBoxHelper_244 = function BoundingBoxHelper(object, hex) {
var vvv_return, vvv_switch, color;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
object = arguments[0], hex = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
color = hex !== undefined ? hex : 8947848;
this.object = object;
this.box = new Box3();
Mesh.call(this, new BoxGeometry(1, 1, 1), new MeshBasicMaterial({
    color: color,
    wireframe: true
}));});
    BoxHelper = ($__.fs.BoxHelper_245 = function BoxHelper(object, color) {
var vvv_return, vvv_switch, indices, positions, geometry;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
object = arguments[0], color = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (color === undefined)
    color = 16776960;
indices = new Uint16Array([
    0,
    1,
    1,
    2,
    2,
    3,
    3,
    0,
    4,
    5,
    5,
    6,
    6,
    7,
    7,
    4,
    0,
    4,
    1,
    5,
    2,
    6,
    3,
    7
]);
positions = new Float32Array(8 * 3);
geometry = new BufferGeometry();
geometry.setIndex(new BufferAttribute(indices, 1));
geometry.addAttribute('position', new BufferAttribute(positions, 3));
LineSegments.call(this, geometry, new LineBasicMaterial({
    color: color
}));
if (object !== undefined) {
    this.update(object);
}});
    CylinderBufferGeometry = ($__.fs.CylinderBufferGeometry_246 = function CylinderBufferGeometry(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
var vvv_return, vvv_switch, vvv_tmp0, vvv_tmp1, vvv_tmp2, vvv_tmp3, vvv_tmp4, scope, nbCap, vertexCount, indexCount, indices, vertices, normals, uvs, index, indexOffset, indexArray, halfHeight, groupStart, calculateVertexCount, calculateIndexCount, generateTorso, generateCap;
calculateVertexCount = function calculateVertexCount() {
    var count = (radialSegments + 1) * (heightSegments + 1);
    if (openEnded === false) {
        count += (radialSegments + 1) * nbCap + radialSegments * nbCap;
    }
    return count;
};
calculateIndexCount = function calculateIndexCount() {
    var count = radialSegments * heightSegments * 2 * 3;
    if (openEnded === false) {
        count += radialSegments * nbCap * 3;
    }
    return count;
};
generateTorso = function generateTorso() {
    var x, y;
    var normal = new Vector3();
    var vertex = new Vector3();
    var groupCount = 0;
    var tanTheta = (radiusBottom - radiusTop) / height;
    for (y = 0; y <= heightSegments; y++) {
        var indexRow = [];
        var v = y / heightSegments;
        var radius = v * (radiusBottom - radiusTop) + radiusTop;
        for (x = 0; x <= radialSegments; x++) {
            var u = x / radialSegments;
            vertex.x = radius * Math.sin(u * thetaLength + thetaStart);
            vertex.y = -v * height + halfHeight;
            vertex.z = radius * Math.cos(u * thetaLength + thetaStart);
            vertices.setXYZ(index, vertex.x, vertex.y, vertex.z);
            normal.copy(vertex);
            if (radiusTop === 0 && y === 0 || radiusBottom === 0 && y === heightSegments) {
                normal.x = Math.sin(u * thetaLength + thetaStart);
                normal.z = Math.cos(u * thetaLength + thetaStart);
            }
            normal.setY(Math.sqrt(normal.x * normal.x + normal.z * normal.z) * tanTheta).normalize();
            normals.setXYZ(index, normal.x, normal.y, normal.z);
            uvs.setXY(index, u, 1 - v);
            indexRow.push(index);
            index++;
        }
        indexArray.push(indexRow);
    }
    for (x = 0; x < radialSegments; x++) {
        for (y = 0; y < heightSegments; y++) {
            var i1 = indexArray[y][x];
            var i2 = indexArray[y + 1][x];
            var i3 = indexArray[y + 1][x + 1];
            var i4 = indexArray[y][x + 1];
            indices.setX(indexOffset, i1);
            indexOffset++;
            indices.setX(indexOffset, i2);
            indexOffset++;
            indices.setX(indexOffset, i4);
            indexOffset++;
            indices.setX(indexOffset, i2);
            indexOffset++;
            indices.setX(indexOffset, i3);
            indexOffset++;
            indices.setX(indexOffset, i4);
            indexOffset++;
            groupCount += 6;
        }
    }
    scope.addGroup(groupStart, groupCount, 0);
    groupStart += groupCount;
};
generateCap = function generateCap(top) {
    var x, centerIndexStart, centerIndexEnd;
    var uv = new Vector2();
    var vertex = new Vector3();
    var groupCount = 0;
    var radius = top === true ? radiusTop : radiusBottom;
    var sign = top === true ? 1 : -1;
    centerIndexStart = index;
    for (x = 1; x <= radialSegments; x++) {
        vertices.setXYZ(index, 0, halfHeight * sign, 0);
        normals.setXYZ(index, 0, sign, 0);
        uv.x = 0.5;
        uv.y = 0.5;
        uvs.setXY(index, uv.x, uv.y);
        index++;
    }
    centerIndexEnd = index;
    for (x = 0; x <= radialSegments; x++) {
        var u = x / radialSegments;
        var theta = u * thetaLength + thetaStart;
        var cosTheta = Math.cos(theta);
        var sinTheta = Math.sin(theta);
        vertex.x = radius * sinTheta;
        vertex.y = halfHeight * sign;
        vertex.z = radius * cosTheta;
        vertices.setXYZ(index, vertex.x, vertex.y, vertex.z);
        normals.setXYZ(index, 0, sign, 0);
        uv.x = cosTheta * 0.5 + 0.5;
        uv.y = sinTheta * 0.5 * sign + 0.5;
        uvs.setXY(index, uv.x, uv.y);
        index++;
    }
    for (x = 0; x < radialSegments; x++) {
        var c = centerIndexStart + x;
        var i = centerIndexEnd + x;
        if (top === true) {
            indices.setX(indexOffset, i);
            indexOffset++;
            indices.setX(indexOffset, i + 1);
            indexOffset++;
            indices.setX(indexOffset, c);
            indexOffset++;
        } else {
            indices.setX(indexOffset, i + 1);
            indexOffset++;
            indices.setX(indexOffset, i);
            indexOffset++;
            indices.setX(indexOffset, c);
            indexOffset++;
        }
        groupCount += 3;
    }
    scope.addGroup(groupStart, groupCount, top === true ? 1 : 2);
    groupStart += groupCount;
};
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
radiusTop = arguments[0], radiusBottom = arguments[1], height = arguments[2], radialSegments = arguments[3], heightSegments = arguments[4], openEnded = arguments[5], thetaStart = arguments[6], thetaLength = arguments[7];
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    calculateVertexCount = ($__.fs.calculateVertexCount_1456 = function calculateVertexCount() {
var vvv_return, vvv_switch, count;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    count = (radialSegments + 1) * (heightSegments + 1);
    openEnded === false;
    count = count + ((radialSegments + 1) * nbCap + radialSegments * nbCap);
    return count;
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
count = (radialSegments + 1) * (heightSegments + 1);
if (openEnded === false) {
    count += (radialSegments + 1) * nbCap + radialSegments * nbCap;
}
return count;});
    calculateIndexCount = ($__.fs.calculateIndexCount_1457 = function calculateIndexCount() {
var vvv_return, vvv_switch, count;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    count = radialSegments * heightSegments * 2 * 3;
    openEnded === false;
    count = count + radialSegments * nbCap * 3;
    return count;
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
count = radialSegments * heightSegments * 2 * 3;
if (openEnded === false) {
    count += radialSegments * nbCap * 3;
}
return count;});
    generateTorso = ($__.fs.generateTorso_1458 = function generateTorso() {
var vvv_return, vvv_switch, vvv_tmp0, vvv_tmp1, vvv_tmp2, vvv_tmp3, vvv_tmp4, vvv_tmp5, vvv_tmp6, vvv_tmp7, vvv_tmp8, vvv_tmp9, vvv_tmp10, vvv_tmp11, vvv_tmp12, vvv_tmp13, vvv_tmp14, vvv_tmp15, vvv_tmp16, vvv_tmp17, vvv_tmp18, vvv_tmp19, vvv_tmp20, vvv_tmp21, vvv_tmp22, vvv_tmp23, vvv_tmp24, vvv_tmp25, vvv_tmp26, vvv_tmp27, vvv_tmp28, vvv_tmp29, vvv_tmp30, vvv_tmp31, vvv_tmp32, vvv_tmp33, vvv_tmp34, vvv_tmp35, vvv_tmp36, vvv_tmp37, vvv_tmp38, vvv_tmp39, vvv_tmp40, vvv_tmp41, vvv_tmp42, vvv_tmp43, vvv_tmp44, vvv_tmp45, vvv_tmp46, vvv_tmp47, vvv_tmp48, vvv_tmp49, vvv_tmp50, vvv_tmp51, vvv_tmp52, vvv_tmp53, vvv_tmp54, vvv_tmp55, vvv_tmp56, vvv_tmp57, vvv_tmp58, vvv_tmp59, vvv_tmp60, vvv_tmp61, vvv_tmp62, vvv_tmp63, vvv_tmp64, vvv_tmp65, vvv_tmp66, vvv_tmp67, vvv_tmp68, vvv_tmp69, vvv_tmp70, vvv_tmp71, vvv_tmp72, vvv_tmp73, vvv_tmp74, vvv_tmp75, vvv_tmp76, vvv_tmp77, vvv_tmp78, vvv_tmp79, vvv_tmp80, vvv_tmp81, vvv_tmp82, vvv_tmp83, vvv_tmp84, vvv_tmp85, vvv_tmp86, vvv_tmp87, vvv_tmp88, vvv_tmp89, vvv_tmp90, vvv_tmp91, vvv_tmp92, vvv_tmp93, vvv_tmp94, vvv_tmp95, vvv_tmp96, vvv_tmp97, vvv_tmp98, vvv_tmp99, vvv_tmp100, vvv_tmp101, vvv_tmp102, x, y, normal, vertex, groupCount, tanTheta, indexRow, v, radius, u, i1, i2, i3, i4;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    normal = new (Vector3, $__.fs.Vector3_11)(99, true, $__.uid);
    vertex = new (Vector3, $__.fs.Vector3_11)(100, true, $__.uid);
    groupCount = 0;
    tanTheta = (radiusBottom - radiusTop) / height;
    y = 0;
    y <= heightSegments;
    indexRow = [];
    v = y / heightSegments;
    radius = v * (radiusBottom - radiusTop) + radiusTop;
    x = 0;
    x <= radialSegments;
    u = x / radialSegments;
    vertex.x = radius * Math['sin'](u * thetaLength + thetaStart);
    vertex.y = -v * height + halfHeight;
    vertex.z = radius * Math['cos'](u * thetaLength + thetaStart);
    vvv_tmp0 = vertices, 'setXYZ', $__.fs.J$__v494107025_1159_756.call(vvv_tmp0, index, (vertex.x, 0), (vertex.y, 0.5), (vertex.z, 0), 0, true, $__.uid);
    vvv_tmp1 = normal, 'copy', $__.fs.J$__v494107025_351_445.call(vvv_tmp1, vertex, 0, true, $__.uid);
    radiusTop === 0, y === 0;
    normal.x = Math['sin'](u * thetaLength + thetaStart);
    normal.z = Math['cos'](u * thetaLength + thetaStart);
    vvv_tmp3 = (vvv_tmp2 = normal, 'setY', $__.fs.J$__v494107025_341_440.call(vvv_tmp2, Math['sqrt']((normal.x, 0) * (normal.x, 0) + (normal.z, 1) * (normal.z, 1)) * tanTheta, 0, true, $__.uid)), 'normalize', $__.fs.J$__v494107025_428_486.call(vvv_tmp3, 0, true, $__.uid);
    vvv_tmp4 = normals, 'setXYZ', $__.fs.J$__v494107025_1159_756.call(vvv_tmp4, index, (normal.x, 0), (normal.y, 0.4472135954999579), (normal.z, 0.8944271909999159), 1, true, $__.uid);
    vvv_tmp5 = uvs, 'setXY', $__.fs.J$__v494107025_1157_755.call(vvv_tmp5, index, u, 1 - v, 0, true, $__.uid);
    indexRow['push'](index);
    (index = +index + 1) - 1;
    (x = +x + 1) - 1;
    x <= radialSegments;
    u = x / radialSegments;
    vertex.x = radius * Math['sin'](u * thetaLength + thetaStart);
    vertex.y = -v * height + halfHeight;
    vertex.z = radius * Math['cos'](u * thetaLength + thetaStart);
    vvv_tmp6 = vertices, 'setXYZ', $__.fs.J$__v494107025_1159_756.call(vvv_tmp6, index, (vertex.x, 0), (vertex.y, 0.5), (vertex.z, 0), 2, true, $__.uid);
    vvv_tmp7 = normal, 'copy', $__.fs.J$__v494107025_351_445.call(vvv_tmp7, vertex, 1, true, $__.uid);
    radiusTop === 0, y === 0;
    normal.x = Math['sin'](u * thetaLength + thetaStart);
    normal.z = Math['cos'](u * thetaLength + thetaStart);
    vvv_tmp9 = (vvv_tmp8 = normal, 'setY', $__.fs.J$__v494107025_341_440.call(vvv_tmp8, Math['sqrt']((normal.x, 0.9510565162951535) * (normal.x, 0.9510565162951535) + (normal.z, 0.30901699437494745) * (normal.z, 0.30901699437494745)) * tanTheta, 1, true, $__.uid)), 'normalize', $__.fs.J$__v494107025_428_486.call(vvv_tmp9, 1, true, $__.uid);
    vvv_tmp10 = normals, 'setXYZ', $__.fs.J$__v494107025_1159_756.call(vvv_tmp10, index, (normal.x, 0.85065080835204), (normal.y, 0.4472135954999579), (normal.z, 0.27639320225002106), 3, true, $__.uid);
    vvv_tmp11 = uvs, 'setXY', $__.fs.J$__v494107025_1157_755.call(vvv_tmp11, index, u, 1 - v, 1, true, $__.uid);
    indexRow['push'](index);
    (index = +index + 1) - 1;
    (x = +x + 1) - 1;
    x <= radialSegments;
    u = x / radialSegments;
    vertex.x = radius * Math['sin'](u * thetaLength + thetaStart);
    vertex.y = -v * height + halfHeight;
    vertex.z = radius * Math['cos'](u * thetaLength + thetaStart);
    vvv_tmp12 = vertices, 'setXYZ', $__.fs.J$__v494107025_1159_756.call(vvv_tmp12, index, (vertex.x, 0), (vertex.y, 0.5), (vertex.z, 0), 4, true, $__.uid);
    vvv_tmp13 = normal, 'copy', $__.fs.J$__v494107025_351_445.call(vvv_tmp13, vertex, 2, true, $__.uid);
    radiusTop === 0, y === 0;
    normal.x = Math['sin'](u * thetaLength + thetaStart);
    normal.z = Math['cos'](u * thetaLength + thetaStart);
    vvv_tmp15 = (vvv_tmp14 = normal, 'setY', $__.fs.J$__v494107025_341_440.call(vvv_tmp14, Math['sqrt']((normal.x, 0.5877852522924732) * (normal.x, 0.5877852522924732) + (normal.z, -0.8090169943749473) * (normal.z, -0.8090169943749473)) * tanTheta, 2, true, $__.uid)), 'normalize', $__.fs.J$__v494107025_428_486.call(vvv_tmp15, 2, true, $__.uid);
    vvv_tmp16 = normals, 'setXYZ', $__.fs.J$__v494107025_1159_756.call(vvv_tmp16, index, (normal.x, 0.5257311121191337), (normal.y, 0.4472135954999579), (normal.z, -0.7236067977499788), 5, true, $__.uid);
    vvv_tmp17 = uvs, 'setXY', $__.fs.J$__v494107025_1157_755.call(vvv_tmp17, index, u, 1 - v, 2, true, $__.uid);
    indexRow['push'](index);
    (index = +index + 1) - 1;
    (x = +x + 1) - 1;
    x <= radialSegments;
    u = x / radialSegments;
    vertex.x = radius * Math['sin'](u * thetaLength + thetaStart);
    vertex.y = -v * height + halfHeight;
    vertex.z = radius * Math['cos'](u * thetaLength + thetaStart);
    vvv_tmp18 = vertices, 'setXYZ', $__.fs.J$__v494107025_1159_756.call(vvv_tmp18, index, (vertex.x, 0), (vertex.y, 0.5), (vertex.z, 0), 6, true, $__.uid);
    vvv_tmp19 = normal, 'copy', $__.fs.J$__v494107025_351_445.call(vvv_tmp19, vertex, 3, true, $__.uid);
    radiusTop === 0, y === 0;
    normal.x = Math['sin'](u * thetaLength + thetaStart);
    normal.z = Math['cos'](u * thetaLength + thetaStart);
    vvv_tmp21 = (vvv_tmp20 = normal, 'setY', $__.fs.J$__v494107025_341_440.call(vvv_tmp20, Math['sqrt']((normal.x, -0.587785252292473) * (normal.x, -0.587785252292473) + (normal.z, -0.8090169943749475) * (normal.z, -0.8090169943749475)) * tanTheta, 3, true, $__.uid)), 'normalize', $__.fs.J$__v494107025_428_486.call(vvv_tmp21, 3, true, $__.uid);
    vvv_tmp22 = normals, 'setXYZ', $__.fs.J$__v494107025_1159_756.call(vvv_tmp22, index, (normal.x, -0.5257311121191336), (normal.y, 0.4472135954999579), (normal.z, -0.723606797749979), 7, true, $__.uid);
    vvv_tmp23 = uvs, 'setXY', $__.fs.J$__v494107025_1157_755.call(vvv_tmp23, index, u, 1 - v, 3, true, $__.uid);
    indexRow['push'](index);
    (index = +index + 1) - 1;
    (x = +x + 1) - 1;
    x <= radialSegments;
    u = x / radialSegments;
    vertex.x = radius * Math['sin'](u * thetaLength + thetaStart);
    vertex.y = -v * height + halfHeight;
    vertex.z = radius * Math['cos'](u * thetaLength + thetaStart);
    vvv_tmp24 = vertices, 'setXYZ', $__.fs.J$__v494107025_1159_756.call(vvv_tmp24, index, (vertex.x, 0), (vertex.y, 0.5), (vertex.z, 0), 8, true, $__.uid);
    vvv_tmp25 = normal, 'copy', $__.fs.J$__v494107025_351_445.call(vvv_tmp25, vertex, 4, true, $__.uid);
    radiusTop === 0, y === 0;
    normal.x = Math['sin'](u * thetaLength + thetaStart);
    normal.z = Math['cos'](u * thetaLength + thetaStart);
    vvv_tmp27 = (vvv_tmp26 = normal, 'setY', $__.fs.J$__v494107025_341_440.call(vvv_tmp26, Math['sqrt']((normal.x, -0.9510565162951536) * (normal.x, -0.9510565162951536) + (normal.z, 0.30901699437494723) * (normal.z, 0.30901699437494723)) * tanTheta, 4, true, $__.uid)), 'normalize', $__.fs.J$__v494107025_428_486.call(vvv_tmp27, 4, true, $__.uid);
    vvv_tmp28 = normals, 'setXYZ', $__.fs.J$__v494107025_1159_756.call(vvv_tmp28, index, (normal.x, -0.85065080835204), (normal.y, 0.4472135954999579), (normal.z, 0.27639320225002084), 9, true, $__.uid);
    vvv_tmp29 = uvs, 'setXY', $__.fs.J$__v494107025_1157_755.call(vvv_tmp29, index, u, 1 - v, 4, true, $__.uid);
    indexRow['push'](index);
    (index = +index + 1) - 1;
    (x = +x + 1) - 1;
    x <= radialSegments;
    u = x / radialSegments;
    vertex.x = radius * Math['sin'](u * thetaLength + thetaStart);
    vertex.y = -v * height + halfHeight;
    vertex.z = radius * Math['cos'](u * thetaLength + thetaStart);
    vvv_tmp30 = vertices, 'setXYZ', $__.fs.J$__v494107025_1159_756.call(vvv_tmp30, index, (vertex.x, 0), (vertex.y, 0.5), (vertex.z, 0), 10, true, $__.uid);
    vvv_tmp31 = normal, 'copy', $__.fs.J$__v494107025_351_445.call(vvv_tmp31, vertex, 5, true, $__.uid);
    radiusTop === 0, y === 0;
    normal.x = Math['sin'](u * thetaLength + thetaStart);
    normal.z = Math['cos'](u * thetaLength + thetaStart);
    vvv_tmp33 = (vvv_tmp32 = normal, 'setY', $__.fs.J$__v494107025_341_440.call(vvv_tmp32, Math['sqrt']((normal.x, -2.4492935982947064e-16) * (normal.x, -2.4492935982947064e-16) + (normal.z, 1) * (normal.z, 1)) * tanTheta, 5, true, $__.uid)), 'normalize', $__.fs.J$__v494107025_428_486.call(vvv_tmp33, 5, true, $__.uid);
    vvv_tmp34 = normals, 'setXYZ', $__.fs.J$__v494107025_1159_756.call(vvv_tmp34, index, (normal.x, -2.1907147930568105e-16), (normal.y, 0.4472135954999579), (normal.z, 0.8944271909999159), 11, true, $__.uid);
    vvv_tmp35 = uvs, 'setXY', $__.fs.J$__v494107025_1157_755.call(vvv_tmp35, index, u, 1 - v, 5, true, $__.uid);
    indexRow['push'](index);
    (index = +index + 1) - 1;
    (x = +x + 1) - 1;
    x <= radialSegments;
    indexArray['push'](indexRow);
    (y = +y + 1) - 1;
    y <= heightSegments;
    indexRow = [];
    v = y / heightSegments;
    radius = v * (radiusBottom - radiusTop) + radiusTop;
    x = 0;
    x <= radialSegments;
    u = x / radialSegments;
    vertex.x = radius * Math['sin'](u * thetaLength + thetaStart);
    vertex.y = -v * height + halfHeight;
    vertex.z = radius * Math['cos'](u * thetaLength + thetaStart);
    vvv_tmp36 = vertices, 'setXYZ', $__.fs.J$__v494107025_1159_756.call(vvv_tmp36, index, (vertex.x, 0), (vertex.y, -0.5), (vertex.z, 0.5), 12, true, $__.uid);
    vvv_tmp37 = normal, 'copy', $__.fs.J$__v494107025_351_445.call(vvv_tmp37, vertex, 6, true, $__.uid);
    (radiusTop === 0, y === 0), radiusBottom === 0;
    vvv_tmp39 = (vvv_tmp38 = normal, 'setY', $__.fs.J$__v494107025_341_440.call(vvv_tmp38, Math['sqrt']((normal.x, 0) * (normal.x, 0) + (normal.z, 0.5) * (normal.z, 0.5)) * tanTheta, 6, true, $__.uid)), 'normalize', $__.fs.J$__v494107025_428_486.call(vvv_tmp39, 6, true, $__.uid);
    vvv_tmp40 = normals, 'setXYZ', $__.fs.J$__v494107025_1159_756.call(vvv_tmp40, index, (normal.x, 0), (normal.y, 0.4472135954999579), (normal.z, 0.8944271909999159), 13, true, $__.uid);
    vvv_tmp41 = uvs, 'setXY', $__.fs.J$__v494107025_1157_755.call(vvv_tmp41, index, u, 1 - v, 6, true, $__.uid);
    indexRow['push'](index);
    (index = +index + 1) - 1;
    (x = +x + 1) - 1;
    x <= radialSegments;
    u = x / radialSegments;
    vertex.x = radius * Math['sin'](u * thetaLength + thetaStart);
    vertex.y = -v * height + halfHeight;
    vertex.z = radius * Math['cos'](u * thetaLength + thetaStart);
    vvv_tmp42 = vertices, 'setXYZ', $__.fs.J$__v494107025_1159_756.call(vvv_tmp42, index, (vertex.x, 0.47552825814757677), (vertex.y, -0.5), (vertex.z, 0.15450849718747373), 14, true, $__.uid);
    vvv_tmp43 = normal, 'copy', $__.fs.J$__v494107025_351_445.call(vvv_tmp43, vertex, 7, true, $__.uid);
    (radiusTop === 0, y === 0), radiusBottom === 0;
    vvv_tmp45 = (vvv_tmp44 = normal, 'setY', $__.fs.J$__v494107025_341_440.call(vvv_tmp44, Math['sqrt']((normal.x, 0.47552825814757677) * (normal.x, 0.47552825814757677) + (normal.z, 0.15450849718747373) * (normal.z, 0.15450849718747373)) * tanTheta, 7, true, $__.uid)), 'normalize', $__.fs.J$__v494107025_428_486.call(vvv_tmp45, 7, true, $__.uid);
    vvv_tmp46 = normals, 'setXYZ', $__.fs.J$__v494107025_1159_756.call(vvv_tmp46, index, (normal.x, 0.85065080835204), (normal.y, 0.4472135954999579), (normal.z, 0.27639320225002106), 15, true, $__.uid);
    vvv_tmp47 = uvs, 'setXY', $__.fs.J$__v494107025_1157_755.call(vvv_tmp47, index, u, 1 - v, 7, true, $__.uid);
    indexRow['push'](index);
    (index = +index + 1) - 1;
    (x = +x + 1) - 1;
    x <= radialSegments;
    u = x / radialSegments;
    vertex.x = radius * Math['sin'](u * thetaLength + thetaStart);
    vertex.y = -v * height + halfHeight;
    vertex.z = radius * Math['cos'](u * thetaLength + thetaStart);
    vvv_tmp48 = vertices, 'setXYZ', $__.fs.J$__v494107025_1159_756.call(vvv_tmp48, index, (vertex.x, 0.2938926261462366), (vertex.y, -0.5), (vertex.z, -0.40450849718747367), 16, true, $__.uid);
    vvv_tmp49 = normal, 'copy', $__.fs.J$__v494107025_351_445.call(vvv_tmp49, vertex, 8, true, $__.uid);
    (radiusTop === 0, y === 0), radiusBottom === 0;
    vvv_tmp51 = (vvv_tmp50 = normal, 'setY', $__.fs.J$__v494107025_341_440.call(vvv_tmp50, Math['sqrt']((normal.x, 0.2938926261462366) * (normal.x, 0.2938926261462366) + (normal.z, -0.40450849718747367) * (normal.z, -0.40450849718747367)) * tanTheta, 8, true, $__.uid)), 'normalize', $__.fs.J$__v494107025_428_486.call(vvv_tmp51, 8, true, $__.uid);
    vvv_tmp52 = normals, 'setXYZ', $__.fs.J$__v494107025_1159_756.call(vvv_tmp52, index, (normal.x, 0.5257311121191337), (normal.y, 0.4472135954999579), (normal.z, -0.7236067977499788), 17, true, $__.uid);
    vvv_tmp53 = uvs, 'setXY', $__.fs.J$__v494107025_1157_755.call(vvv_tmp53, index, u, 1 - v, 8, true, $__.uid);
    indexRow['push'](index);
    (index = +index + 1) - 1;
    (x = +x + 1) - 1;
    x <= radialSegments;
    u = x / radialSegments;
    vertex.x = radius * Math['sin'](u * thetaLength + thetaStart);
    vertex.y = -v * height + halfHeight;
    vertex.z = radius * Math['cos'](u * thetaLength + thetaStart);
    vvv_tmp54 = vertices, 'setXYZ', $__.fs.J$__v494107025_1159_756.call(vvv_tmp54, index, (vertex.x, -0.2938926261462365), (vertex.y, -0.5), (vertex.z, -0.4045084971874737), 18, true, $__.uid);
    vvv_tmp55 = normal, 'copy', $__.fs.J$__v494107025_351_445.call(vvv_tmp55, vertex, 9, true, $__.uid);
    (radiusTop === 0, y === 0), radiusBottom === 0;
    vvv_tmp57 = (vvv_tmp56 = normal, 'setY', $__.fs.J$__v494107025_341_440.call(vvv_tmp56, Math['sqrt']((normal.x, -0.2938926261462365) * (normal.x, -0.2938926261462365) + (normal.z, -0.4045084971874737) * (normal.z, -0.4045084971874737)) * tanTheta, 9, true, $__.uid)), 'normalize', $__.fs.J$__v494107025_428_486.call(vvv_tmp57, 9, true, $__.uid);
    vvv_tmp58 = normals, 'setXYZ', $__.fs.J$__v494107025_1159_756.call(vvv_tmp58, index, (normal.x, -0.5257311121191336), (normal.y, 0.4472135954999579), (normal.z, -0.723606797749979), 19, true, $__.uid);
    vvv_tmp59 = uvs, 'setXY', $__.fs.J$__v494107025_1157_755.call(vvv_tmp59, index, u, 1 - v, 9, true, $__.uid);
    indexRow['push'](index);
    (index = +index + 1) - 1;
    (x = +x + 1) - 1;
    x <= radialSegments;
    u = x / radialSegments;
    vertex.x = radius * Math['sin'](u * thetaLength + thetaStart);
    vertex.y = -v * height + halfHeight;
    vertex.z = radius * Math['cos'](u * thetaLength + thetaStart);
    vvv_tmp60 = vertices, 'setXYZ', $__.fs.J$__v494107025_1159_756.call(vvv_tmp60, index, (vertex.x, -0.4755282581475768), (vertex.y, -0.5), (vertex.z, 0.15450849718747361), 20, true, $__.uid);
    vvv_tmp61 = normal, 'copy', $__.fs.J$__v494107025_351_445.call(vvv_tmp61, vertex, 10, true, $__.uid);
    (radiusTop === 0, y === 0), radiusBottom === 0;
    vvv_tmp63 = (vvv_tmp62 = normal, 'setY', $__.fs.J$__v494107025_341_440.call(vvv_tmp62, Math['sqrt']((normal.x, -0.4755282581475768) * (normal.x, -0.4755282581475768) + (normal.z, 0.15450849718747361) * (normal.z, 0.15450849718747361)) * tanTheta, 10, true, $__.uid)), 'normalize', $__.fs.J$__v494107025_428_486.call(vvv_tmp63, 10, true, $__.uid);
    vvv_tmp64 = normals, 'setXYZ', $__.fs.J$__v494107025_1159_756.call(vvv_tmp64, index, (normal.x, -0.85065080835204), (normal.y, 0.4472135954999579), (normal.z, 0.27639320225002084), 21, true, $__.uid);
    vvv_tmp65 = uvs, 'setXY', $__.fs.J$__v494107025_1157_755.call(vvv_tmp65, index, u, 1 - v, 10, true, $__.uid);
    indexRow['push'](index);
    (index = +index + 1) - 1;
    (x = +x + 1) - 1;
    x <= radialSegments;
    u = x / radialSegments;
    vertex.x = radius * Math['sin'](u * thetaLength + thetaStart);
    vertex.y = -v * height + halfHeight;
    vertex.z = radius * Math['cos'](u * thetaLength + thetaStart);
    vvv_tmp66 = vertices, 'setXYZ', $__.fs.J$__v494107025_1159_756.call(vvv_tmp66, index, (vertex.x, -1.2246467991473532e-16), (vertex.y, -0.5), (vertex.z, 0.5), 22, true, $__.uid);
    vvv_tmp67 = normal, 'copy', $__.fs.J$__v494107025_351_445.call(vvv_tmp67, vertex, 11, true, $__.uid);
    (radiusTop === 0, y === 0), radiusBottom === 0;
    vvv_tmp69 = (vvv_tmp68 = normal, 'setY', $__.fs.J$__v494107025_341_440.call(vvv_tmp68, Math['sqrt']((normal.x, -1.2246467991473532e-16) * (normal.x, -1.2246467991473532e-16) + (normal.z, 0.5) * (normal.z, 0.5)) * tanTheta, 11, true, $__.uid)), 'normalize', $__.fs.J$__v494107025_428_486.call(vvv_tmp69, 11, true, $__.uid);
    vvv_tmp70 = normals, 'setXYZ', $__.fs.J$__v494107025_1159_756.call(vvv_tmp70, index, (normal.x, -2.1907147930568105e-16), (normal.y, 0.4472135954999579), (normal.z, 0.8944271909999159), 23, true, $__.uid);
    vvv_tmp71 = uvs, 'setXY', $__.fs.J$__v494107025_1157_755.call(vvv_tmp71, index, u, 1 - v, 11, true, $__.uid);
    indexRow['push'](index);
    (index = +index + 1) - 1;
    (x = +x + 1) - 1;
    x <= radialSegments;
    indexArray['push'](indexRow);
    (y = +y + 1) - 1;
    y <= heightSegments;
    x = 0;
    x < radialSegments;
    y = 0;
    y < heightSegments;
    i1 = (TAJS_restrictToType(indexArray[y, 0], 'object')[x, 0], 0);
    i2 = (TAJS_restrictToType(indexArray[y + 1, 1], 'object')[x, 0], 6);
    i3 = (TAJS_restrictToType(indexArray[y + 1, 1], 'object')[x + 1, 1], 7);
    i4 = (TAJS_restrictToType(indexArray[y, 0], 'object')[x + 1, 1], 1);
    vvv_tmp72 = indices, 'setX', $__.fs.J$__v494107025_1143_748.call(vvv_tmp72, indexOffset, i1, 0, true, $__.uid);
    (indexOffset = +indexOffset + 1) - 1;
    vvv_tmp73 = indices, 'setX', $__.fs.J$__v494107025_1143_748.call(vvv_tmp73, indexOffset, i2, 1, true, $__.uid);
    (indexOffset = +indexOffset + 1) - 1;
    vvv_tmp74 = indices, 'setX', $__.fs.J$__v494107025_1143_748.call(vvv_tmp74, indexOffset, i4, 2, true, $__.uid);
    (indexOffset = +indexOffset + 1) - 1;
    vvv_tmp75 = indices, 'setX', $__.fs.J$__v494107025_1143_748.call(vvv_tmp75, indexOffset, i2, 3, true, $__.uid);
    (indexOffset = +indexOffset + 1) - 1;
    vvv_tmp76 = indices, 'setX', $__.fs.J$__v494107025_1143_748.call(vvv_tmp76, indexOffset, i3, 4, true, $__.uid);
    (indexOffset = +indexOffset + 1) - 1;
    vvv_tmp77 = indices, 'setX', $__.fs.J$__v494107025_1143_748.call(vvv_tmp77, indexOffset, i4, 5, true, $__.uid);
    (indexOffset = +indexOffset + 1) - 1;
    groupCount = groupCount + 6;
    (y = +y + 1) - 1;
    y < heightSegments;
    (x = +x + 1) - 1;
    x < radialSegments;
    y = 0;
    y < heightSegments;
    i1 = (TAJS_restrictToType(indexArray[y, 0], 'object')[x, 1], 1);
    i2 = (TAJS_restrictToType(indexArray[y + 1, 1], 'object')[x, 1], 7);
    i3 = (TAJS_restrictToType(indexArray[y + 1, 1], 'object')[x + 1, 2], 8);
    i4 = (TAJS_restrictToType(indexArray[y, 0], 'object')[x + 1, 2], 2);
    vvv_tmp78 = indices, 'setX', $__.fs.J$__v494107025_1143_748.call(vvv_tmp78, indexOffset, i1, 6, true, $__.uid);
    (indexOffset = +indexOffset + 1) - 1;
    vvv_tmp79 = indices, 'setX', $__.fs.J$__v494107025_1143_748.call(vvv_tmp79, indexOffset, i2, 7, true, $__.uid);
    (indexOffset = +indexOffset + 1) - 1;
    vvv_tmp80 = indices, 'setX', $__.fs.J$__v494107025_1143_748.call(vvv_tmp80, indexOffset, i4, 8, true, $__.uid);
    (indexOffset = +indexOffset + 1) - 1;
    vvv_tmp81 = indices, 'setX', $__.fs.J$__v494107025_1143_748.call(vvv_tmp81, indexOffset, i2, 9, true, $__.uid);
    (indexOffset = +indexOffset + 1) - 1;
    vvv_tmp82 = indices, 'setX', $__.fs.J$__v494107025_1143_748.call(vvv_tmp82, indexOffset, i3, 10, true, $__.uid);
    (indexOffset = +indexOffset + 1) - 1;
    vvv_tmp83 = indices, 'setX', $__.fs.J$__v494107025_1143_748.call(vvv_tmp83, indexOffset, i4, 11, true, $__.uid);
    (indexOffset = +indexOffset + 1) - 1;
    groupCount = groupCount + 6;
    (y = +y + 1) - 1;
    y < heightSegments;
    (x = +x + 1) - 1;
    x < radialSegments;
    y = 0;
    y < heightSegments;
    i1 = (TAJS_restrictToType(indexArray[y, 0], 'object')[x, 2], 2);
    i2 = (TAJS_restrictToType(indexArray[y + 1, 1], 'object')[x, 2], 8);
    i3 = (TAJS_restrictToType(indexArray[y + 1, 1], 'object')[x + 1, 3], 9);
    i4 = (TAJS_restrictToType(indexArray[y, 0], 'object')[x + 1, 3], 3);
    vvv_tmp84 = indices, 'setX', $__.fs.J$__v494107025_1143_748.call(vvv_tmp84, indexOffset, i1, 12, true, $__.uid);
    (indexOffset = +indexOffset + 1) - 1;
    vvv_tmp85 = indices, 'setX', $__.fs.J$__v494107025_1143_748.call(vvv_tmp85, indexOffset, i2, 13, true, $__.uid);
    (indexOffset = +indexOffset + 1) - 1;
    vvv_tmp86 = indices, 'setX', $__.fs.J$__v494107025_1143_748.call(vvv_tmp86, indexOffset, i4, 14, true, $__.uid);
    (indexOffset = +indexOffset + 1) - 1;
    vvv_tmp87 = indices, 'setX', $__.fs.J$__v494107025_1143_748.call(vvv_tmp87, indexOffset, i2, 15, true, $__.uid);
    (indexOffset = +indexOffset + 1) - 1;
    vvv_tmp88 = indices, 'setX', $__.fs.J$__v494107025_1143_748.call(vvv_tmp88, indexOffset, i3, 16, true, $__.uid);
    (indexOffset = +indexOffset + 1) - 1;
    vvv_tmp89 = indices, 'setX', $__.fs.J$__v494107025_1143_748.call(vvv_tmp89, indexOffset, i4, 17, true, $__.uid);
    (indexOffset = +indexOffset + 1) - 1;
    groupCount = groupCount + 6;
    (y = +y + 1) - 1;
    y < heightSegments;
    (x = +x + 1) - 1;
    x < radialSegments;
    y = 0;
    y < heightSegments;
    i1 = (TAJS_restrictToType(indexArray[y, 0], 'object')[x, 3], 3);
    i2 = (TAJS_restrictToType(indexArray[y + 1, 1], 'object')[x, 3], 9);
    i3 = (TAJS_restrictToType(indexArray[y + 1, 1], 'object')[x + 1, 4], 10);
    i4 = (TAJS_restrictToType(indexArray[y, 0], 'object')[x + 1, 4], 4);
    vvv_tmp90 = indices, 'setX', $__.fs.J$__v494107025_1143_748.call(vvv_tmp90, indexOffset, i1, 18, true, $__.uid);
    (indexOffset = +indexOffset + 1) - 1;
    vvv_tmp91 = indices, 'setX', $__.fs.J$__v494107025_1143_748.call(vvv_tmp91, indexOffset, i2, 19, true, $__.uid);
    (indexOffset = +indexOffset + 1) - 1;
    vvv_tmp92 = indices, 'setX', $__.fs.J$__v494107025_1143_748.call(vvv_tmp92, indexOffset, i4, 20, true, $__.uid);
    (indexOffset = +indexOffset + 1) - 1;
    vvv_tmp93 = indices, 'setX', $__.fs.J$__v494107025_1143_748.call(vvv_tmp93, indexOffset, i2, 21, true, $__.uid);
    (indexOffset = +indexOffset + 1) - 1;
    vvv_tmp94 = indices, 'setX', $__.fs.J$__v494107025_1143_748.call(vvv_tmp94, indexOffset, i3, 22, true, $__.uid);
    (indexOffset = +indexOffset + 1) - 1;
    vvv_tmp95 = indices, 'setX', $__.fs.J$__v494107025_1143_748.call(vvv_tmp95, indexOffset, i4, 23, true, $__.uid);
    (indexOffset = +indexOffset + 1) - 1;
    groupCount = groupCount + 6;
    (y = +y + 1) - 1;
    y < heightSegments;
    (x = +x + 1) - 1;
    x < radialSegments;
    y = 0;
    y < heightSegments;
    i1 = (TAJS_restrictToType(indexArray[y, 0], 'object')[x, 4], 4);
    i2 = (TAJS_restrictToType(indexArray[y + 1, 1], 'object')[x, 4], 10);
    i3 = (TAJS_restrictToType(indexArray[y + 1, 1], 'object')[x + 1, 5], 11);
    i4 = (TAJS_restrictToType(indexArray[y, 0], 'object')[x + 1, 5], 5);
    vvv_tmp96 = indices, 'setX', $__.fs.J$__v494107025_1143_748.call(vvv_tmp96, indexOffset, i1, 24, true, $__.uid);
    (indexOffset = +indexOffset + 1) - 1;
    vvv_tmp97 = indices, 'setX', $__.fs.J$__v494107025_1143_748.call(vvv_tmp97, indexOffset, i2, 25, true, $__.uid);
    (indexOffset = +indexOffset + 1) - 1;
    vvv_tmp98 = indices, 'setX', $__.fs.J$__v494107025_1143_748.call(vvv_tmp98, indexOffset, i4, 26, true, $__.uid);
    (indexOffset = +indexOffset + 1) - 1;
    vvv_tmp99 = indices, 'setX', $__.fs.J$__v494107025_1143_748.call(vvv_tmp99, indexOffset, i2, 27, true, $__.uid);
    (indexOffset = +indexOffset + 1) - 1;
    vvv_tmp100 = indices, 'setX', $__.fs.J$__v494107025_1143_748.call(vvv_tmp100, indexOffset, i3, 28, true, $__.uid);
    (indexOffset = +indexOffset + 1) - 1;
    vvv_tmp101 = indices, 'setX', $__.fs.J$__v494107025_1143_748.call(vvv_tmp101, indexOffset, i4, 29, true, $__.uid);
    (indexOffset = +indexOffset + 1) - 1;
    groupCount = groupCount + 6;
    (y = +y + 1) - 1;
    y < heightSegments;
    (x = +x + 1) - 1;
    x < radialSegments;
    vvv_tmp102 = scope, 'addGroup', $__.fs.J$__v494107025_1411_881.call(vvv_tmp102, groupStart, groupCount, 0, 0, true, $__.uid);
    groupStart = groupStart + groupCount;
    return;
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
normal = new Vector3();
vertex = new Vector3();
groupCount = 0;
tanTheta = (radiusBottom - radiusTop) / height;
for (y = 0; y <= heightSegments; y++) {
    indexRow = [];
    v = y / heightSegments;
    radius = v * (radiusBottom - radiusTop) + radiusTop;
    for (x = 0; x <= radialSegments; x++) {
        u = x / radialSegments;
        vertex.x = radius * Math.sin(u * thetaLength + thetaStart);
        vertex.y = -v * height + halfHeight;
        vertex.z = radius * Math.cos(u * thetaLength + thetaStart);
        vertices.setXYZ(index, vertex.x, vertex.y, vertex.z);
        normal.copy(vertex);
        if (radiusTop === 0 && y === 0 || radiusBottom === 0 && y === heightSegments) {
            normal.x = Math.sin(u * thetaLength + thetaStart);
            normal.z = Math.cos(u * thetaLength + thetaStart);
        }
        normal.setY(Math.sqrt(normal.x * normal.x + normal.z * normal.z) * tanTheta).normalize();
        normals.setXYZ(index, normal.x, normal.y, normal.z);
        uvs.setXY(index, u, 1 - v);
        indexRow.push(index);
        index++;
    }
    indexArray.push(indexRow);
}
for (x = 0; x < radialSegments; x++) {
    for (y = 0; y < heightSegments; y++) {
        i1 = indexArray[y][x];
        i2 = indexArray[y + 1][x];
        i3 = indexArray[y + 1][x + 1];
        i4 = indexArray[y][x + 1];
        indices.setX(indexOffset, i1);
        indexOffset++;
        indices.setX(indexOffset, i2);
        indexOffset++;
        indices.setX(indexOffset, i4);
        indexOffset++;
        indices.setX(indexOffset, i2);
        indexOffset++;
        indices.setX(indexOffset, i3);
        indexOffset++;
        indices.setX(indexOffset, i4);
        indexOffset++;
        groupCount += 6;
    }
}
scope.addGroup(groupStart, groupCount, 0);
groupStart += groupCount;});
    generateCap = ($__.fs.generateCap_1459 = function generateCap(top) {
var vvv_return, vvv_switch, vvv_tmp0, vvv_tmp1, vvv_tmp2, vvv_tmp3, vvv_tmp4, vvv_tmp5, vvv_tmp6, vvv_tmp7, vvv_tmp8, vvv_tmp9, vvv_tmp10, vvv_tmp11, vvv_tmp12, vvv_tmp13, vvv_tmp14, vvv_tmp15, vvv_tmp16, vvv_tmp17, vvv_tmp18, vvv_tmp19, vvv_tmp20, vvv_tmp21, vvv_tmp22, vvv_tmp23, vvv_tmp24, vvv_tmp25, vvv_tmp26, vvv_tmp27, vvv_tmp28, vvv_tmp29, vvv_tmp30, vvv_tmp31, vvv_tmp32, vvv_tmp33, vvv_tmp34, vvv_tmp35, vvv_tmp36, vvv_tmp37, vvv_tmp38, vvv_tmp39, vvv_tmp40, vvv_tmp41, vvv_tmp42, vvv_tmp43, vvv_tmp44, vvv_tmp45, vvv_tmp46, vvv_tmp47, vvv_tmp48, x, centerIndexStart, centerIndexEnd, uv, vertex, groupCount, radius, sign, u, theta, cosTheta, sinTheta, c, i;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
top = arguments[0];
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    uv = new (Vector2, $__.fs.Vector2_6)(13, true, $__.uid);
    vertex = new (Vector3, $__.fs.Vector3_11)(101, true, $__.uid);
    groupCount = 0;
    radius = (top === true, radiusBottom);
    sign = (top === true, -1);
    centerIndexStart = index;
    x = 1;
    x <= radialSegments;
    vvv_tmp0 = vertices, 'setXYZ', $__.fs.J$__v494107025_1159_756.call(vvv_tmp0, index, 0, halfHeight * sign, 0, 24, true, $__.uid);
    vvv_tmp1 = normals, 'setXYZ', $__.fs.J$__v494107025_1159_756.call(vvv_tmp1, index, 0, sign, 0, 25, true, $__.uid);
    uv.x = 0.5;
    uv.y = 0.5;
    vvv_tmp2 = uvs, 'setXY', $__.fs.J$__v494107025_1157_755.call(vvv_tmp2, index, (uv.x, 0.5), (uv.y, 0.5), 12, true, $__.uid);
    (index = +index + 1) - 1;
    (x = +x + 1) - 1;
    x <= radialSegments;
    vvv_tmp3 = vertices, 'setXYZ', $__.fs.J$__v494107025_1159_756.call(vvv_tmp3, index, 0, halfHeight * sign, 0, 26, true, $__.uid);
    vvv_tmp4 = normals, 'setXYZ', $__.fs.J$__v494107025_1159_756.call(vvv_tmp4, index, 0, sign, 0, 27, true, $__.uid);
    uv.x = 0.5;
    uv.y = 0.5;
    vvv_tmp5 = uvs, 'setXY', $__.fs.J$__v494107025_1157_755.call(vvv_tmp5, index, (uv.x, 0.5), (uv.y, 0.5), 13, true, $__.uid);
    (index = +index + 1) - 1;
    (x = +x + 1) - 1;
    x <= radialSegments;
    vvv_tmp6 = vertices, 'setXYZ', $__.fs.J$__v494107025_1159_756.call(vvv_tmp6, index, 0, halfHeight * sign, 0, 28, true, $__.uid);
    vvv_tmp7 = normals, 'setXYZ', $__.fs.J$__v494107025_1159_756.call(vvv_tmp7, index, 0, sign, 0, 29, true, $__.uid);
    uv.x = 0.5;
    uv.y = 0.5;
    vvv_tmp8 = uvs, 'setXY', $__.fs.J$__v494107025_1157_755.call(vvv_tmp8, index, (uv.x, 0.5), (uv.y, 0.5), 14, true, $__.uid);
    (index = +index + 1) - 1;
    (x = +x + 1) - 1;
    x <= radialSegments;
    vvv_tmp9 = vertices, 'setXYZ', $__.fs.J$__v494107025_1159_756.call(vvv_tmp9, index, 0, halfHeight * sign, 0, 30, true, $__.uid);
    vvv_tmp10 = normals, 'setXYZ', $__.fs.J$__v494107025_1159_756.call(vvv_tmp10, index, 0, sign, 0, 31, true, $__.uid);
    uv.x = 0.5;
    uv.y = 0.5;
    vvv_tmp11 = uvs, 'setXY', $__.fs.J$__v494107025_1157_755.call(vvv_tmp11, index, (uv.x, 0.5), (uv.y, 0.5), 15, true, $__.uid);
    (index = +index + 1) - 1;
    (x = +x + 1) - 1;
    x <= radialSegments;
    vvv_tmp12 = vertices, 'setXYZ', $__.fs.J$__v494107025_1159_756.call(vvv_tmp12, index, 0, halfHeight * sign, 0, 32, true, $__.uid);
    vvv_tmp13 = normals, 'setXYZ', $__.fs.J$__v494107025_1159_756.call(vvv_tmp13, index, 0, sign, 0, 33, true, $__.uid);
    uv.x = 0.5;
    uv.y = 0.5;
    vvv_tmp14 = uvs, 'setXY', $__.fs.J$__v494107025_1157_755.call(vvv_tmp14, index, (uv.x, 0.5), (uv.y, 0.5), 16, true, $__.uid);
    (index = +index + 1) - 1;
    (x = +x + 1) - 1;
    x <= radialSegments;
    centerIndexEnd = index;
    x = 0;
    x <= radialSegments;
    u = x / radialSegments;
    theta = u * thetaLength + thetaStart;
    cosTheta = Math['cos'](theta);
    sinTheta = Math['sin'](theta);
    vertex.x = radius * sinTheta;
    vertex.y = halfHeight * sign;
    vertex.z = radius * cosTheta;
    vvv_tmp15 = vertices, 'setXYZ', $__.fs.J$__v494107025_1159_756.call(vvv_tmp15, index, (vertex.x, 0), (vertex.y, -0.5), (vertex.z, 0.5), 34, true, $__.uid);
    vvv_tmp16 = normals, 'setXYZ', $__.fs.J$__v494107025_1159_756.call(vvv_tmp16, index, 0, sign, 0, 35, true, $__.uid);
    uv.x = cosTheta * 0.5 + 0.5;
    uv.y = sinTheta * 0.5 * sign + 0.5;
    vvv_tmp17 = uvs, 'setXY', $__.fs.J$__v494107025_1157_755.call(vvv_tmp17, index, (uv.x, 1), (uv.y, 0.5), 17, true, $__.uid);
    (index = +index + 1) - 1;
    (x = +x + 1) - 1;
    x <= radialSegments;
    u = x / radialSegments;
    theta = u * thetaLength + thetaStart;
    cosTheta = Math['cos'](theta);
    sinTheta = Math['sin'](theta);
    vertex.x = radius * sinTheta;
    vertex.y = halfHeight * sign;
    vertex.z = radius * cosTheta;
    vvv_tmp18 = vertices, 'setXYZ', $__.fs.J$__v494107025_1159_756.call(vvv_tmp18, index, (vertex.x, 0.47552825814757677), (vertex.y, -0.5), (vertex.z, 0.15450849718747373), 36, true, $__.uid);
    vvv_tmp19 = normals, 'setXYZ', $__.fs.J$__v494107025_1159_756.call(vvv_tmp19, index, 0, sign, 0, 37, true, $__.uid);
    uv.x = cosTheta * 0.5 + 0.5;
    uv.y = sinTheta * 0.5 * sign + 0.5;
    vvv_tmp20 = uvs, 'setXY', $__.fs.J$__v494107025_1157_755.call(vvv_tmp20, index, (uv.x, 0.6545084971874737), (uv.y, 0.024471741852423234), 18, true, $__.uid);
    (index = +index + 1) - 1;
    (x = +x + 1) - 1;
    x <= radialSegments;
    u = x / radialSegments;
    theta = u * thetaLength + thetaStart;
    cosTheta = Math['cos'](theta);
    sinTheta = Math['sin'](theta);
    vertex.x = radius * sinTheta;
    vertex.y = halfHeight * sign;
    vertex.z = radius * cosTheta;
    vvv_tmp21 = vertices, 'setXYZ', $__.fs.J$__v494107025_1159_756.call(vvv_tmp21, index, (vertex.x, 0.2938926261462366), (vertex.y, -0.5), (vertex.z, -0.40450849718747367), 38, true, $__.uid);
    vvv_tmp22 = normals, 'setXYZ', $__.fs.J$__v494107025_1159_756.call(vvv_tmp22, index, 0, sign, 0, 39, true, $__.uid);
    uv.x = cosTheta * 0.5 + 0.5;
    uv.y = sinTheta * 0.5 * sign + 0.5;
    vvv_tmp23 = uvs, 'setXY', $__.fs.J$__v494107025_1157_755.call(vvv_tmp23, index, (uv.x, 0.09549150281252633), (uv.y, 0.20610737385376338), 19, true, $__.uid);
    (index = +index + 1) - 1;
    (x = +x + 1) - 1;
    x <= radialSegments;
    u = x / radialSegments;
    theta = u * thetaLength + thetaStart;
    cosTheta = Math['cos'](theta);
    sinTheta = Math['sin'](theta);
    vertex.x = radius * sinTheta;
    vertex.y = halfHeight * sign;
    vertex.z = radius * cosTheta;
    vvv_tmp24 = vertices, 'setXYZ', $__.fs.J$__v494107025_1159_756.call(vvv_tmp24, index, (vertex.x, -0.2938926261462365), (vertex.y, -0.5), (vertex.z, -0.4045084971874737), 40, true, $__.uid);
    vvv_tmp25 = normals, 'setXYZ', $__.fs.J$__v494107025_1159_756.call(vvv_tmp25, index, 0, sign, 0, 41, true, $__.uid);
    uv.x = cosTheta * 0.5 + 0.5;
    uv.y = sinTheta * 0.5 * sign + 0.5;
    vvv_tmp26 = uvs, 'setXY', $__.fs.J$__v494107025_1157_755.call(vvv_tmp26, index, (uv.x, 0.09549150281252627), (uv.y, 0.7938926261462365), 20, true, $__.uid);
    (index = +index + 1) - 1;
    (x = +x + 1) - 1;
    x <= radialSegments;
    u = x / radialSegments;
    theta = u * thetaLength + thetaStart;
    cosTheta = Math['cos'](theta);
    sinTheta = Math['sin'](theta);
    vertex.x = radius * sinTheta;
    vertex.y = halfHeight * sign;
    vertex.z = radius * cosTheta;
    vvv_tmp27 = vertices, 'setXYZ', $__.fs.J$__v494107025_1159_756.call(vvv_tmp27, index, (vertex.x, -0.4755282581475768), (vertex.y, -0.5), (vertex.z, 0.15450849718747361), 42, true, $__.uid);
    vvv_tmp28 = normals, 'setXYZ', $__.fs.J$__v494107025_1159_756.call(vvv_tmp28, index, 0, sign, 0, 43, true, $__.uid);
    uv.x = cosTheta * 0.5 + 0.5;
    uv.y = sinTheta * 0.5 * sign + 0.5;
    vvv_tmp29 = uvs, 'setXY', $__.fs.J$__v494107025_1157_755.call(vvv_tmp29, index, (uv.x, 0.6545084971874736), (uv.y, 0.9755282581475768), 21, true, $__.uid);
    (index = +index + 1) - 1;
    (x = +x + 1) - 1;
    x <= radialSegments;
    u = x / radialSegments;
    theta = u * thetaLength + thetaStart;
    cosTheta = Math['cos'](theta);
    sinTheta = Math['sin'](theta);
    vertex.x = radius * sinTheta;
    vertex.y = halfHeight * sign;
    vertex.z = radius * cosTheta;
    vvv_tmp30 = vertices, 'setXYZ', $__.fs.J$__v494107025_1159_756.call(vvv_tmp30, index, (vertex.x, -1.2246467991473532e-16), (vertex.y, -0.5), (vertex.z, 0.5), 44, true, $__.uid);
    vvv_tmp31 = normals, 'setXYZ', $__.fs.J$__v494107025_1159_756.call(vvv_tmp31, index, 0, sign, 0, 45, true, $__.uid);
    uv.x = cosTheta * 0.5 + 0.5;
    uv.y = sinTheta * 0.5 * sign + 0.5;
    vvv_tmp32 = uvs, 'setXY', $__.fs.J$__v494107025_1157_755.call(vvv_tmp32, index, (uv.x, 1), (uv.y, 0.5000000000000001), 22, true, $__.uid);
    (index = +index + 1) - 1;
    (x = +x + 1) - 1;
    x <= radialSegments;
    x = 0;
    x < radialSegments;
    c = centerIndexStart + x;
    i = centerIndexEnd + x;
    top === true;
    vvv_tmp33 = indices, 'setX', $__.fs.J$__v494107025_1143_748.call(vvv_tmp33, indexOffset, i + 1, 30, true, $__.uid);
    (indexOffset = +indexOffset + 1) - 1;
    vvv_tmp34 = indices, 'setX', $__.fs.J$__v494107025_1143_748.call(vvv_tmp34, indexOffset, i, 31, true, $__.uid);
    (indexOffset = +indexOffset + 1) - 1;
    vvv_tmp35 = indices, 'setX', $__.fs.J$__v494107025_1143_748.call(vvv_tmp35, indexOffset, c, 32, true, $__.uid);
    (indexOffset = +indexOffset + 1) - 1;
    groupCount = groupCount + 3;
    (x = +x + 1) - 1;
    x < radialSegments;
    c = centerIndexStart + x;
    i = centerIndexEnd + x;
    top === true;
    vvv_tmp36 = indices, 'setX', $__.fs.J$__v494107025_1143_748.call(vvv_tmp36, indexOffset, i + 1, 33, true, $__.uid);
    (indexOffset = +indexOffset + 1) - 1;
    vvv_tmp37 = indices, 'setX', $__.fs.J$__v494107025_1143_748.call(vvv_tmp37, indexOffset, i, 34, true, $__.uid);
    (indexOffset = +indexOffset + 1) - 1;
    vvv_tmp38 = indices, 'setX', $__.fs.J$__v494107025_1143_748.call(vvv_tmp38, indexOffset, c, 35, true, $__.uid);
    (indexOffset = +indexOffset + 1) - 1;
    groupCount = groupCount + 3;
    (x = +x + 1) - 1;
    x < radialSegments;
    c = centerIndexStart + x;
    i = centerIndexEnd + x;
    top === true;
    vvv_tmp39 = indices, 'setX', $__.fs.J$__v494107025_1143_748.call(vvv_tmp39, indexOffset, i + 1, 36, true, $__.uid);
    (indexOffset = +indexOffset + 1) - 1;
    vvv_tmp40 = indices, 'setX', $__.fs.J$__v494107025_1143_748.call(vvv_tmp40, indexOffset, i, 37, true, $__.uid);
    (indexOffset = +indexOffset + 1) - 1;
    vvv_tmp41 = indices, 'setX', $__.fs.J$__v494107025_1143_748.call(vvv_tmp41, indexOffset, c, 38, true, $__.uid);
    (indexOffset = +indexOffset + 1) - 1;
    groupCount = groupCount + 3;
    (x = +x + 1) - 1;
    x < radialSegments;
    c = centerIndexStart + x;
    i = centerIndexEnd + x;
    top === true;
    vvv_tmp42 = indices, 'setX', $__.fs.J$__v494107025_1143_748.call(vvv_tmp42, indexOffset, i + 1, 39, true, $__.uid);
    (indexOffset = +indexOffset + 1) - 1;
    vvv_tmp43 = indices, 'setX', $__.fs.J$__v494107025_1143_748.call(vvv_tmp43, indexOffset, i, 40, true, $__.uid);
    (indexOffset = +indexOffset + 1) - 1;
    vvv_tmp44 = indices, 'setX', $__.fs.J$__v494107025_1143_748.call(vvv_tmp44, indexOffset, c, 41, true, $__.uid);
    (indexOffset = +indexOffset + 1) - 1;
    groupCount = groupCount + 3;
    (x = +x + 1) - 1;
    x < radialSegments;
    c = centerIndexStart + x;
    i = centerIndexEnd + x;
    top === true;
    vvv_tmp45 = indices, 'setX', $__.fs.J$__v494107025_1143_748.call(vvv_tmp45, indexOffset, i + 1, 42, true, $__.uid);
    (indexOffset = +indexOffset + 1) - 1;
    vvv_tmp46 = indices, 'setX', $__.fs.J$__v494107025_1143_748.call(vvv_tmp46, indexOffset, i, 43, true, $__.uid);
    (indexOffset = +indexOffset + 1) - 1;
    vvv_tmp47 = indices, 'setX', $__.fs.J$__v494107025_1143_748.call(vvv_tmp47, indexOffset, c, 44, true, $__.uid);
    (indexOffset = +indexOffset + 1) - 1;
    groupCount = groupCount + 3;
    (x = +x + 1) - 1;
    x < radialSegments;
    vvv_tmp48 = scope, 'addGroup', $__.fs.J$__v494107025_1411_881.call(vvv_tmp48, groupStart, groupCount, (top === true, 2), 1, true, $__.uid);
    groupStart = groupStart + groupCount;
    return;
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
uv = new Vector2();
vertex = new Vector3();
groupCount = 0;
radius = top === true ? radiusTop : radiusBottom;
sign = top === true ? 1 : -1;
centerIndexStart = index;
for (x = 1; x <= radialSegments; x++) {
    vertices.setXYZ(index, 0, halfHeight * sign, 0);
    normals.setXYZ(index, 0, sign, 0);
    uv.x = 0.5;
    uv.y = 0.5;
    uvs.setXY(index, uv.x, uv.y);
    index++;
}
centerIndexEnd = index;
for (x = 0; x <= radialSegments; x++) {
    u = x / radialSegments;
    theta = u * thetaLength + thetaStart;
    cosTheta = Math.cos(theta);
    sinTheta = Math.sin(theta);
    vertex.x = radius * sinTheta;
    vertex.y = halfHeight * sign;
    vertex.z = radius * cosTheta;
    vertices.setXYZ(index, vertex.x, vertex.y, vertex.z);
    normals.setXYZ(index, 0, sign, 0);
    uv.x = cosTheta * 0.5 + 0.5;
    uv.y = sinTheta * 0.5 * sign + 0.5;
    uvs.setXY(index, uv.x, uv.y);
    index++;
}
for (x = 0; x < radialSegments; x++) {
    c = centerIndexStart + x;
    i = centerIndexEnd + x;
    if (top === true) {
        indices.setX(indexOffset, i);
        indexOffset++;
        indices.setX(indexOffset, i + 1);
        indexOffset++;
        indices.setX(indexOffset, c);
        indexOffset++;
    } else {
        indices.setX(indexOffset, i + 1);
        indexOffset++;
        indices.setX(indexOffset, i);
        indexOffset++;
        indices.setX(indexOffset, c);
        indexOffset++;
    }
    groupCount += 3;
}
scope.addGroup(groupStart, groupCount, top === true ? 1 : 2);
groupStart += groupCount;});
    vvv_tmp0 = this, (BufferGeometry, $__.fs.BufferGeometry_100).call(vvv_tmp0, 1, true, $__.uid);
    this.type = 'CylinderBufferGeometry';
    this.parameters = $__.os.oid539 = {
        'radiusTop': radiusTop,
        'radiusBottom': radiusBottom,
        'height': height,
        'radialSegments': radialSegments,
        'heightSegments': heightSegments,
        'openEnded': openEnded,
        'thetaStart': thetaStart,
        'thetaLength': thetaLength
    };
    scope = this;
    radiusTop = (radiusTop !== undefined, radiusTop);
    radiusBottom = (radiusBottom !== undefined, radiusBottom);
    height = (height !== undefined, height);
    radialSegments = Math['floor'](radialSegments);
    heightSegments = Math['floor'](heightSegments);
    openEnded = (openEnded !== undefined, false);
    thetaStart = (thetaStart !== undefined, 0);
    thetaLength = (thetaLength !== undefined, 2 * (Math.PI, 3.141592653589793));
    nbCap = 0;
    openEnded === false;
    radiusTop > 0;
    radiusBottom > 0;
    (nbCap = +nbCap + 1) - 1;
    vertexCount = (calculateVertexCount, $__.fs.calculateVertexCount_1456)(0, true, $__.uid);
    indexCount = (calculateIndexCount, $__.fs.calculateIndexCount_1457)(0, true, $__.uid);
    indices = new (BufferAttribute, $__.fs.BufferAttribute_81)(new (indexCount > 65535, Uint16Array)(indexCount), 1, 1, true, $__.uid);
    vertices = new (BufferAttribute, $__.fs.BufferAttribute_81)(new Float32Array(vertexCount * 3), 3, 2, true, $__.uid);
    normals = new (BufferAttribute, $__.fs.BufferAttribute_81)(new Float32Array(vertexCount * 3), 3, 3, true, $__.uid);
    uvs = new (BufferAttribute, $__.fs.BufferAttribute_81)(new Float32Array(vertexCount * 2), 2, 4, true, $__.uid);
    index = 0;
    indexOffset = 0;
    indexArray = [];
    halfHeight = height / 2;
    groupStart = 0;
    (generateTorso, $__.fs.generateTorso_1458)(0, true, $__.uid);
    openEnded === false;
    radiusTop > 0;
    radiusBottom > 0;
    (generateCap, $__.fs.generateCap_1459)(false, 0, true, $__.uid);
    vvv_tmp1 = this, 'setIndex', $__.fs.J$__v494107025_1403_877.call(vvv_tmp1, indices, 0, true, $__.uid);
    vvv_tmp2 = this, 'addAttribute', $__.fs.J$__v494107025_1405_878.call(vvv_tmp2, 'position', vertices, 1, true, $__.uid);
    vvv_tmp3 = this, 'addAttribute', $__.fs.J$__v494107025_1405_878.call(vvv_tmp3, 'normal', normals, 2, true, $__.uid);
    vvv_tmp4 = this, 'addAttribute', $__.fs.J$__v494107025_1405_878.call(vvv_tmp4, 'uv', uvs, 3, true, $__.uid);
    return;
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
BufferGeometry.call(this);
this.type = 'CylinderBufferGeometry';
this.parameters = {
    radiusTop: radiusTop,
    radiusBottom: radiusBottom,
    height: height,
    radialSegments: radialSegments,
    heightSegments: heightSegments,
    openEnded: openEnded,
    thetaStart: thetaStart,
    thetaLength: thetaLength
};
scope = this;
radiusTop = radiusTop !== undefined ? radiusTop : 20;
radiusBottom = radiusBottom !== undefined ? radiusBottom : 20;
height = height !== undefined ? height : 100;
radialSegments = Math.floor(radialSegments) || 8;
heightSegments = Math.floor(heightSegments) || 1;
openEnded = openEnded !== undefined ? openEnded : false;
thetaStart = thetaStart !== undefined ? thetaStart : 0;
thetaLength = thetaLength !== undefined ? thetaLength : 2 * Math.PI;
nbCap = 0;
if (openEnded === false) {
    if (radiusTop > 0)
        nbCap++;
    if (radiusBottom > 0)
        nbCap++;
}
vertexCount = calculateVertexCount();
indexCount = calculateIndexCount();
indices = new BufferAttribute(new (indexCount > 65535 ? Uint32Array : Uint16Array)(indexCount), 1);
vertices = new BufferAttribute(new Float32Array(vertexCount * 3), 3);
normals = new BufferAttribute(new Float32Array(vertexCount * 3), 3);
uvs = new BufferAttribute(new Float32Array(vertexCount * 2), 2);
index = 0;
indexOffset = 0;
indexArray = [];
halfHeight = height / 2;
groupStart = 0;
generateTorso();
if (openEnded === false) {
    if (radiusTop > 0)
        generateCap(true);
    if (radiusBottom > 0)
        generateCap(false);
}
this.setIndex(indices);
this.addAttribute('position', vertices);
this.addAttribute('normal', normals);
this.addAttribute('uv', uvs);});
    ArrowHelper = ($__.fs.ArrowHelper_247 = function ArrowHelper(dir, origin, length, color, headLength, headWidth) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
dir = arguments[0], origin = arguments[1], length = arguments[2], color = arguments[3], headLength = arguments[4], headWidth = arguments[5];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
Object3D.call(this);
if (color === undefined)
    color = 16776960;
if (length === undefined)
    length = 1;
if (headLength === undefined)
    headLength = 0.2 * length;
if (headWidth === undefined)
    headWidth = 0.2 * headLength;
this.position.copy(origin);
this.line = new Line(lineGeometry, new LineBasicMaterial({
    color: color
}));
this.line.matrixAutoUpdate = false;
this.add(this.line);
this.cone = new Mesh(coneGeometry, new MeshBasicMaterial({
    color: color
}));
this.cone.matrixAutoUpdate = false;
this.add(this.cone);
this.setDirection(dir);
this.setLength(length, headLength, headWidth);});
    AxisHelper = ($__.fs.AxisHelper_248 = function AxisHelper(size) {
var vvv_return, vvv_switch, vertices, colors, geometry, material;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
size = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
size = size || 1;
vertices = new Float32Array([
    0,
    0,
    0,
    size,
    0,
    0,
    0,
    0,
    0,
    0,
    size,
    0,
    0,
    0,
    0,
    0,
    0,
    size
]);
colors = new Float32Array([
    1,
    0,
    0,
    1,
    0.6,
    0,
    0,
    1,
    0,
    0.6,
    1,
    0,
    0,
    0,
    1,
    0,
    0.6,
    1
]);
geometry = new BufferGeometry();
geometry.addAttribute('position', new BufferAttribute(vertices, 3));
geometry.addAttribute('color', new BufferAttribute(colors, 3));
material = new LineBasicMaterial({
    vertexColors: VertexColors
});
LineSegments.call(this, geometry, material);});
    ParametricGeometry = ($__.fs.ParametricGeometry_249 = function ParametricGeometry(func, slices, stacks) {
var vvv_return, vvv_switch, verts, faces, uvs, i, j, p, u, v, sliceCount, a, b, c, d, uva, uvb, uvc, uvd;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
func = arguments[0], slices = arguments[1], stacks = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
Geometry.call(this);
this.type = 'ParametricGeometry';
this.parameters = {
    func: func,
    slices: slices,
    stacks: stacks
};
verts = this.vertices;
faces = this.faces;
uvs = this.faceVertexUvs[0];
sliceCount = slices + 1;
for (i = 0; i <= stacks; i++) {
    v = i / stacks;
    for (j = 0; j <= slices; j++) {
        u = j / slices;
        p = func(u, v);
        verts.push(p);
    }
}
for (i = 0; i < stacks; i++) {
    for (j = 0; j < slices; j++) {
        a = i * sliceCount + j;
        b = i * sliceCount + j + 1;
        c = (i + 1) * sliceCount + j + 1;
        d = (i + 1) * sliceCount + j;
        uva = new Vector2(j / slices, i / stacks);
        uvb = new Vector2((j + 1) / slices, i / stacks);
        uvc = new Vector2((j + 1) / slices, (i + 1) / stacks);
        uvd = new Vector2(j / slices, (i + 1) / stacks);
        faces.push(new Face3(a, b, d));
        uvs.push([
            uva,
            uvb,
            uvd
        ]);
        faces.push(new Face3(b, c, d));
        uvs.push([
            uvb.clone(),
            uvc,
            uvd.clone()
        ]);
    }
}
this.computeFaceNormals();
this.computeVertexNormals();});
    PolyhedronGeometry = ($__.fs.PolyhedronGeometry_250 = function PolyhedronGeometry(vertices, indices, radius, detail) {
var vvv_return, vvv_switch, that, p, faces, v1, v2, v3, centroid, uvs, x0, x1, x2, max, min, prepare, make, subdivide, azimuth, inclination, correctUV;
prepare = function prepare(vector) {
    var vertex = vector.normalize().clone();
    vertex.index = that.vertices.push(vertex) - 1;
    var u = azimuth(vector) / 2 / Math.PI + 0.5;
    var v = inclination(vector) / Math.PI + 0.5;
    vertex.uv = new Vector2(u, 1 - v);
    return vertex;
};
make = function make(v1, v2, v3) {
    var face = new Face3(v1.index, v2.index, v3.index, [
        v1.clone(),
        v2.clone(),
        v3.clone()
    ]);
    that.faces.push(face);
    centroid.copy(v1).add(v2).add(v3).divideScalar(3);
    var azi = azimuth(centroid);
    that.faceVertexUvs[0].push([
        correctUV(v1.uv, v1, azi),
        correctUV(v2.uv, v2, azi),
        correctUV(v3.uv, v3, azi)
    ]);
};
subdivide = function subdivide(face, detail) {
    var cols = Math.pow(2, detail);
    var a = prepare(that.vertices[face.a]);
    var b = prepare(that.vertices[face.b]);
    var c = prepare(that.vertices[face.c]);
    var v = [];
    for (var i = 0; i <= cols; i++) {
        v[i] = [];
        var aj = prepare(a.clone().lerp(c, i / cols));
        var bj = prepare(b.clone().lerp(c, i / cols));
        var rows = cols - i;
        for (var j = 0; j <= rows; j++) {
            if (j === 0 && i === cols) {
                v[i][j] = aj;
            } else {
                v[i][j] = prepare(aj.clone().lerp(bj, j / rows));
            }
        }
    }
    for (var i = 0; i < cols; i++) {
        for (var j = 0; j < 2 * (cols - i) - 1; j++) {
            var k = Math.floor(j / 2);
            if (j % 2 === 0) {
                make(v[i][k + 1], v[i + 1][k], v[i][k]);
            } else {
                make(v[i][k + 1], v[i + 1][k + 1], v[i + 1][k]);
            }
        }
    }
};
azimuth = function azimuth(vector) {
    return Math.atan2(vector.z, -vector.x);
};
inclination = function inclination(vector) {
    return Math.atan2(-vector.y, Math.sqrt(vector.x * vector.x + vector.z * vector.z));
};
correctUV = function correctUV(uv, vector, azimuth) {
    if (azimuth < 0 && uv.x === 1)
        uv = new Vector2(uv.x - 1, uv.y);
    if (vector.x === 0 && vector.z === 0)
        uv = new Vector2(azimuth / 2 / Math.PI + 0.5, uv.y);
    return uv.clone();
};
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
vertices = arguments[0], indices = arguments[1], radius = arguments[2], detail = arguments[3];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
Geometry.call(this);
this.type = 'PolyhedronGeometry';
this.parameters = {
    vertices: vertices,
    indices: indices,
    radius: radius,
    detail: detail
};
radius = radius || 1;
detail = detail || 0;
that = this;
for (var i = 0, l = vertices.length; i < l; i += 3) {
    prepare(new Vector3(vertices[i], vertices[i + 1], vertices[i + 2]));
}
p = this.vertices;
faces = [];
for (var i = 0, j = 0, l = indices.length; i < l; i += 3, j++) {
    v1 = p[indices[i]];
    v2 = p[indices[i + 1]];
    v3 = p[indices[i + 2]];
    faces[j] = new Face3(v1.index, v2.index, v3.index, [
        v1.clone(),
        v2.clone(),
        v3.clone()
    ]);
}
centroid = new Vector3();
for (var i = 0, l = faces.length; i < l; i++) {
    subdivide(faces[i], detail);
}
for (var i = 0, l = this.faceVertexUvs[0].length; i < l; i++) {
    uvs = this.faceVertexUvs[0][i];
    x0 = uvs[0].x;
    x1 = uvs[1].x;
    x2 = uvs[2].x;
    max = Math.max(x0, x1, x2);
    min = Math.min(x0, x1, x2);
    if (max > 0.9 && min < 0.1) {
        if (x0 < 0.2)
            uvs[0].x += 1;
        if (x1 < 0.2)
            uvs[1].x += 1;
        if (x2 < 0.2)
            uvs[2].x += 1;
    }
}
for (var i = 0, l = this.vertices.length; i < l; i++) {
    this.vertices[i].multiplyScalar(radius);
}
this.mergeVertices();
this.computeFaceNormals();
this.boundingSphere = new Sphere(new Vector3(), radius);});
    TetrahedronGeometry = ($__.fs.TetrahedronGeometry_251 = function TetrahedronGeometry(radius, detail) {
var vvv_return, vvv_switch, vertices, indices;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
radius = arguments[0], detail = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
vertices = [
    1,
    1,
    1,
    -1,
    -1,
    1,
    -1,
    1,
    -1,
    1,
    -1,
    -1
];
indices = [
    2,
    1,
    0,
    0,
    3,
    2,
    1,
    3,
    0,
    2,
    3,
    1
];
PolyhedronGeometry.call(this, vertices, indices, radius, detail);
this.type = 'TetrahedronGeometry';
this.parameters = {
    radius: radius,
    detail: detail
};});
    OctahedronGeometry = ($__.fs.OctahedronGeometry_252 = function OctahedronGeometry(radius, detail) {
var vvv_return, vvv_switch, vertices, indices;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
radius = arguments[0], detail = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
vertices = [
    1,
    0,
    0,
    -1,
    0,
    0,
    0,
    1,
    0,
    0,
    -1,
    0,
    0,
    0,
    1,
    0,
    0,
    -1
];
indices = [
    0,
    2,
    4,
    0,
    4,
    3,
    0,
    3,
    5,
    0,
    5,
    2,
    1,
    2,
    5,
    1,
    5,
    3,
    1,
    3,
    4,
    1,
    4,
    2
];
PolyhedronGeometry.call(this, vertices, indices, radius, detail);
this.type = 'OctahedronGeometry';
this.parameters = {
    radius: radius,
    detail: detail
};});
    IcosahedronGeometry = ($__.fs.IcosahedronGeometry_253 = function IcosahedronGeometry(radius, detail) {
var vvv_return, vvv_switch, t, vertices, indices;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
radius = arguments[0], detail = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
t = (1 + Math.sqrt(5)) / 2;
vertices = [
    -1,
    t,
    0,
    1,
    t,
    0,
    -1,
    -t,
    0,
    1,
    -t,
    0,
    0,
    -1,
    t,
    0,
    1,
    t,
    0,
    -1,
    -t,
    0,
    1,
    -t,
    t,
    0,
    -1,
    t,
    0,
    1,
    -t,
    0,
    -1,
    -t,
    0,
    1
];
indices = [
    0,
    11,
    5,
    0,
    5,
    1,
    0,
    1,
    7,
    0,
    7,
    10,
    0,
    10,
    11,
    1,
    5,
    9,
    5,
    11,
    4,
    11,
    10,
    2,
    10,
    7,
    6,
    7,
    1,
    8,
    3,
    9,
    4,
    3,
    4,
    2,
    3,
    2,
    6,
    3,
    6,
    8,
    3,
    8,
    9,
    4,
    9,
    5,
    2,
    4,
    11,
    6,
    2,
    10,
    8,
    6,
    7,
    9,
    8,
    1
];
PolyhedronGeometry.call(this, vertices, indices, radius, detail);
this.type = 'IcosahedronGeometry';
this.parameters = {
    radius: radius,
    detail: detail
};});
    DodecahedronGeometry = ($__.fs.DodecahedronGeometry_254 = function DodecahedronGeometry(radius, detail) {
var vvv_return, vvv_switch, t, r, vertices, indices;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
radius = arguments[0], detail = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
t = (1 + Math.sqrt(5)) / 2;
r = 1 / t;
vertices = [
    -1,
    -1,
    -1,
    -1,
    -1,
    1,
    -1,
    1,
    -1,
    -1,
    1,
    1,
    1,
    -1,
    -1,
    1,
    -1,
    1,
    1,
    1,
    -1,
    1,
    1,
    1,
    0,
    -r,
    -t,
    0,
    -r,
    t,
    0,
    r,
    -t,
    0,
    r,
    t,
    -r,
    -t,
    0,
    -r,
    t,
    0,
    r,
    -t,
    0,
    r,
    t,
    0,
    -t,
    0,
    -r,
    t,
    0,
    -r,
    -t,
    0,
    r,
    t,
    0,
    r
];
indices = [
    3,
    11,
    7,
    3,
    7,
    15,
    3,
    15,
    13,
    7,
    19,
    17,
    7,
    17,
    6,
    7,
    6,
    15,
    17,
    4,
    8,
    17,
    8,
    10,
    17,
    10,
    6,
    8,
    0,
    16,
    8,
    16,
    2,
    8,
    2,
    10,
    0,
    12,
    1,
    0,
    1,
    18,
    0,
    18,
    16,
    6,
    10,
    2,
    6,
    2,
    13,
    6,
    13,
    15,
    2,
    16,
    18,
    2,
    18,
    3,
    2,
    3,
    13,
    18,
    1,
    9,
    18,
    9,
    11,
    18,
    11,
    3,
    4,
    14,
    12,
    4,
    12,
    0,
    4,
    0,
    8,
    11,
    9,
    5,
    11,
    5,
    19,
    11,
    19,
    7,
    19,
    5,
    14,
    19,
    14,
    4,
    19,
    4,
    17,
    1,
    12,
    14,
    1,
    14,
    5,
    1,
    5,
    9
];
PolyhedronGeometry.call(this, vertices, indices, radius, detail);
this.type = 'DodecahedronGeometry';
this.parameters = {
    radius: radius,
    detail: detail
};});
    TorusKnotBufferGeometry = ($__.fs.TorusKnotBufferGeometry_255 = function TorusKnotBufferGeometry(radius, tube, tubularSegments, radialSegments, p, q) {
var vvv_return, vvv_switch, vertexCount, indexCount, indices, vertices, normals, uvs, i, j, index, indexOffset, vertex, normal, uv, P1, P2, B, T, N, u, v, cx, cy, a, b, c, d, calculatePositionOnCurve;
calculatePositionOnCurve = function calculatePositionOnCurve(u, p, q, radius, position) {
    var cu = Math.cos(u);
    var su = Math.sin(u);
    var quOverP = q / p * u;
    var cs = Math.cos(quOverP);
    position.x = radius * (2 + cs) * 0.5 * cu;
    position.y = radius * (2 + cs) * su * 0.5;
    position.z = radius * Math.sin(quOverP) * 0.5;
};
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
radius = arguments[0], tube = arguments[1], tubularSegments = arguments[2], radialSegments = arguments[3], p = arguments[4], q = arguments[5];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
BufferGeometry.call(this);
this.type = 'TorusKnotBufferGeometry';
this.parameters = {
    radius: radius,
    tube: tube,
    tubularSegments: tubularSegments,
    radialSegments: radialSegments,
    p: p,
    q: q
};
radius = radius || 100;
tube = tube || 40;
tubularSegments = Math.floor(tubularSegments) || 64;
radialSegments = Math.floor(radialSegments) || 8;
p = p || 2;
q = q || 3;
vertexCount = (radialSegments + 1) * (tubularSegments + 1);
indexCount = radialSegments * tubularSegments * 2 * 3;
indices = new BufferAttribute(new (indexCount > 65535 ? Uint32Array : Uint16Array)(indexCount), 1);
vertices = new BufferAttribute(new Float32Array(vertexCount * 3), 3);
normals = new BufferAttribute(new Float32Array(vertexCount * 3), 3);
uvs = new BufferAttribute(new Float32Array(vertexCount * 2), 2);
index = 0;
indexOffset = 0;
vertex = new Vector3();
normal = new Vector3();
uv = new Vector2();
P1 = new Vector3();
P2 = new Vector3();
B = new Vector3();
T = new Vector3();
N = new Vector3();
for (i = 0; i <= tubularSegments; ++i) {
    u = i / tubularSegments * p * Math.PI * 2;
    calculatePositionOnCurve(u, p, q, radius, P1);
    calculatePositionOnCurve(u + 0.01, p, q, radius, P2);
    T.subVectors(P2, P1);
    N.addVectors(P2, P1);
    B.crossVectors(T, N);
    N.crossVectors(B, T);
    B.normalize();
    N.normalize();
    for (j = 0; j <= radialSegments; ++j) {
        v = j / radialSegments * Math.PI * 2;
        cx = -tube * Math.cos(v);
        cy = tube * Math.sin(v);
        vertex.x = P1.x + (cx * N.x + cy * B.x);
        vertex.y = P1.y + (cx * N.y + cy * B.y);
        vertex.z = P1.z + (cx * N.z + cy * B.z);
        vertices.setXYZ(index, vertex.x, vertex.y, vertex.z);
        normal.subVectors(vertex, P1).normalize();
        normals.setXYZ(index, normal.x, normal.y, normal.z);
        uv.x = i / tubularSegments;
        uv.y = j / radialSegments;
        uvs.setXY(index, uv.x, uv.y);
        index++;
    }
}
for (j = 1; j <= tubularSegments; j++) {
    for (i = 1; i <= radialSegments; i++) {
        a = (radialSegments + 1) * (j - 1) + (i - 1);
        b = (radialSegments + 1) * j + (i - 1);
        c = (radialSegments + 1) * j + i;
        d = (radialSegments + 1) * (j - 1) + i;
        indices.setX(indexOffset, a);
        indexOffset++;
        indices.setX(indexOffset, b);
        indexOffset++;
        indices.setX(indexOffset, d);
        indexOffset++;
        indices.setX(indexOffset, b);
        indexOffset++;
        indices.setX(indexOffset, c);
        indexOffset++;
        indices.setX(indexOffset, d);
        indexOffset++;
    }
}
this.setIndex(indices);
this.addAttribute('position', vertices);
this.addAttribute('normal', normals);
this.addAttribute('uv', uvs);});
    TorusKnotGeometry = ($__.fs.TorusKnotGeometry_256 = function TorusKnotGeometry(radius, tube, tubularSegments, radialSegments, p, q, heightScale) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
radius = arguments[0], tube = arguments[1], tubularSegments = arguments[2], radialSegments = arguments[3], p = arguments[4], q = arguments[5], heightScale = arguments[6];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
Geometry.call(this);
this.type = 'TorusKnotGeometry';
this.parameters = {
    radius: radius,
    tube: tube,
    tubularSegments: tubularSegments,
    radialSegments: radialSegments,
    p: p,
    q: q
};
if (heightScale !== undefined)
    console.warn('THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead.');
this.fromBufferGeometry(new TorusKnotBufferGeometry(radius, tube, tubularSegments, radialSegments, p, q));
this.mergeVertices();});
    TorusBufferGeometry = ($__.fs.TorusBufferGeometry_257 = function TorusBufferGeometry(radius, tube, radialSegments, tubularSegments, arc) {
var vvv_return, vvv_switch, vertexCount, indexCount, indices, vertices, normals, uvs, vertexBufferOffset, uvBufferOffset, indexBufferOffset, center, vertex, normal, j, i, u, v, a, b, c, d;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
radius = arguments[0], tube = arguments[1], radialSegments = arguments[2], tubularSegments = arguments[3], arc = arguments[4];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
BufferGeometry.call(this);
this.type = 'TorusBufferGeometry';
this.parameters = {
    radius: radius,
    tube: tube,
    radialSegments: radialSegments,
    tubularSegments: tubularSegments,
    arc: arc
};
radius = radius || 100;
tube = tube || 40;
radialSegments = Math.floor(radialSegments) || 8;
tubularSegments = Math.floor(tubularSegments) || 6;
arc = arc || Math.PI * 2;
vertexCount = (radialSegments + 1) * (tubularSegments + 1);
indexCount = radialSegments * tubularSegments * 2 * 3;
indices = new (indexCount > 65535 ? Uint32Array : Uint16Array)(indexCount);
vertices = new Float32Array(vertexCount * 3);
normals = new Float32Array(vertexCount * 3);
uvs = new Float32Array(vertexCount * 2);
vertexBufferOffset = 0;
uvBufferOffset = 0;
indexBufferOffset = 0;
center = new Vector3();
vertex = new Vector3();
normal = new Vector3();
for (j = 0; j <= radialSegments; j++) {
    for (i = 0; i <= tubularSegments; i++) {
        u = i / tubularSegments * arc;
        v = j / radialSegments * Math.PI * 2;
        vertex.x = (radius + tube * Math.cos(v)) * Math.cos(u);
        vertex.y = (radius + tube * Math.cos(v)) * Math.sin(u);
        vertex.z = tube * Math.sin(v);
        vertices[vertexBufferOffset] = vertex.x;
        vertices[vertexBufferOffset + 1] = vertex.y;
        vertices[vertexBufferOffset + 2] = vertex.z;
        center.x = radius * Math.cos(u);
        center.y = radius * Math.sin(u);
        normal.subVectors(vertex, center).normalize();
        normals[vertexBufferOffset] = normal.x;
        normals[vertexBufferOffset + 1] = normal.y;
        normals[vertexBufferOffset + 2] = normal.z;
        uvs[uvBufferOffset] = i / tubularSegments;
        uvs[uvBufferOffset + 1] = j / radialSegments;
        vertexBufferOffset += 3;
        uvBufferOffset += 2;
    }
}
for (j = 1; j <= radialSegments; j++) {
    for (i = 1; i <= tubularSegments; i++) {
        a = (tubularSegments + 1) * j + i - 1;
        b = (tubularSegments + 1) * (j - 1) + i - 1;
        c = (tubularSegments + 1) * (j - 1) + i;
        d = (tubularSegments + 1) * j + i;
        indices[indexBufferOffset] = a;
        indices[indexBufferOffset + 1] = b;
        indices[indexBufferOffset + 2] = d;
        indices[indexBufferOffset + 3] = b;
        indices[indexBufferOffset + 4] = c;
        indices[indexBufferOffset + 5] = d;
        indexBufferOffset += 6;
    }
}
this.setIndex(new BufferAttribute(indices, 1));
this.addAttribute('position', new BufferAttribute(vertices, 3));
this.addAttribute('normal', new BufferAttribute(normals, 3));
this.addAttribute('uv', new BufferAttribute(uvs, 2));});
    TorusGeometry = ($__.fs.TorusGeometry_258 = function TorusGeometry(radius, tube, radialSegments, tubularSegments, arc) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
radius = arguments[0], tube = arguments[1], radialSegments = arguments[2], tubularSegments = arguments[3], arc = arguments[4];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
Geometry.call(this);
this.type = 'TorusGeometry';
this.parameters = {
    radius: radius,
    tube: tube,
    radialSegments: radialSegments,
    tubularSegments: tubularSegments,
    arc: arc
};
this.fromBufferGeometry(new TorusBufferGeometry(radius, tube, radialSegments, tubularSegments, arc));});
    TextGeometry = ($__.fs.TextGeometry_259 = function TextGeometry(text, parameters) {
var vvv_return, vvv_switch, font, shapes;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
text = arguments[0], parameters = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
parameters = parameters || {};
font = parameters.font;
if ((font && font.isFont) === false) {
    console.error('THREE.TextGeometry: font parameter is not an instance of THREE.Font.');
    return new Geometry();
}
shapes = font.generateShapes(text, parameters.size, parameters.curveSegments);
parameters.amount = parameters.height !== undefined ? parameters.height : 50;
if (parameters.bevelThickness === undefined)
    parameters.bevelThickness = 10;
if (parameters.bevelSize === undefined)
    parameters.bevelSize = 8;
if (parameters.bevelEnabled === undefined)
    parameters.bevelEnabled = false;
ExtrudeGeometry.call(this, shapes, parameters);
this.type = 'TextGeometry';});
    RingBufferGeometry = ($__.fs.RingBufferGeometry_260 = function RingBufferGeometry(innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength) {
var vvv_return, vvv_switch, vertexCount, indexCount, indices, vertices, normals, uvs, index, indexOffset, segment, radius, radiusStep, vertex, uv, j, i, thetaSegmentLevel, a, b, c, d;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
innerRadius = arguments[0], outerRadius = arguments[1], thetaSegments = arguments[2], phiSegments = arguments[3], thetaStart = arguments[4], thetaLength = arguments[5];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
BufferGeometry.call(this);
this.type = 'RingBufferGeometry';
this.parameters = {
    innerRadius: innerRadius,
    outerRadius: outerRadius,
    thetaSegments: thetaSegments,
    phiSegments: phiSegments,
    thetaStart: thetaStart,
    thetaLength: thetaLength
};
innerRadius = innerRadius || 20;
outerRadius = outerRadius || 50;
thetaStart = thetaStart !== undefined ? thetaStart : 0;
thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;
thetaSegments = thetaSegments !== undefined ? Math.max(3, thetaSegments) : 8;
phiSegments = phiSegments !== undefined ? Math.max(1, phiSegments) : 1;
vertexCount = (thetaSegments + 1) * (phiSegments + 1);
indexCount = thetaSegments * phiSegments * 2 * 3;
indices = new BufferAttribute(new (indexCount > 65535 ? Uint32Array : Uint16Array)(indexCount), 1);
vertices = new BufferAttribute(new Float32Array(vertexCount * 3), 3);
normals = new BufferAttribute(new Float32Array(vertexCount * 3), 3);
uvs = new BufferAttribute(new Float32Array(vertexCount * 2), 2);
index = 0;
indexOffset = 0;
radius = innerRadius;
radiusStep = (outerRadius - innerRadius) / phiSegments;
vertex = new Vector3();
uv = new Vector2();
for (j = 0; j <= phiSegments; j++) {
    for (i = 0; i <= thetaSegments; i++) {
        segment = thetaStart + i / thetaSegments * thetaLength;
        vertex.x = radius * Math.cos(segment);
        vertex.y = radius * Math.sin(segment);
        vertices.setXYZ(index, vertex.x, vertex.y, vertex.z);
        normals.setXYZ(index, 0, 0, 1);
        uv.x = (vertex.x / outerRadius + 1) / 2;
        uv.y = (vertex.y / outerRadius + 1) / 2;
        uvs.setXY(index, uv.x, uv.y);
        index++;
    }
    radius += radiusStep;
}
for (j = 0; j < phiSegments; j++) {
    thetaSegmentLevel = j * (thetaSegments + 1);
    for (i = 0; i < thetaSegments; i++) {
        segment = i + thetaSegmentLevel;
        a = segment;
        b = segment + thetaSegments + 1;
        c = segment + thetaSegments + 2;
        d = segment + 1;
        indices.setX(indexOffset, a);
        indexOffset++;
        indices.setX(indexOffset, b);
        indexOffset++;
        indices.setX(indexOffset, c);
        indexOffset++;
        indices.setX(indexOffset, a);
        indexOffset++;
        indices.setX(indexOffset, c);
        indexOffset++;
        indices.setX(indexOffset, d);
        indexOffset++;
    }
}
this.setIndex(indices);
this.addAttribute('position', vertices);
this.addAttribute('normal', normals);
this.addAttribute('uv', uvs);});
    RingGeometry = ($__.fs.RingGeometry_261 = function RingGeometry(innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
innerRadius = arguments[0], outerRadius = arguments[1], thetaSegments = arguments[2], phiSegments = arguments[3], thetaStart = arguments[4], thetaLength = arguments[5];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
Geometry.call(this);
this.type = 'RingGeometry';
this.parameters = {
    innerRadius: innerRadius,
    outerRadius: outerRadius,
    thetaSegments: thetaSegments,
    phiSegments: phiSegments,
    thetaStart: thetaStart,
    thetaLength: thetaLength
};
this.fromBufferGeometry(new RingBufferGeometry(innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength));});
    PlaneGeometry = ($__.fs.PlaneGeometry_262 = function PlaneGeometry(width, height, widthSegments, heightSegments) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
width = arguments[0], height = arguments[1], widthSegments = arguments[2], heightSegments = arguments[3];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
Geometry.call(this);
this.type = 'PlaneGeometry';
this.parameters = {
    width: width,
    height: height,
    widthSegments: widthSegments,
    heightSegments: heightSegments
};
this.fromBufferGeometry(new PlaneBufferGeometry(width, height, widthSegments, heightSegments));});
    LatheBufferGeometry = ($__.fs.LatheBufferGeometry_263 = function LatheBufferGeometry(points, segments, phiStart, phiLength) {
var vvv_return, vvv_switch, vertexCount, indexCount, indices, vertices, uvs, index, indexOffset, base, inverseSegments, vertex, uv, i, j, phi, sin, cos, a, b, c, d, normals, n1, n2, n;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
points = arguments[0], segments = arguments[1], phiStart = arguments[2], phiLength = arguments[3];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
BufferGeometry.call(this);
this.type = 'LatheBufferGeometry';
this.parameters = {
    points: points,
    segments: segments,
    phiStart: phiStart,
    phiLength: phiLength
};
segments = Math.floor(segments) || 12;
phiStart = phiStart || 0;
phiLength = phiLength || Math.PI * 2;
phiLength = exports.Math.clamp(phiLength, 0, Math.PI * 2);
vertexCount = (segments + 1) * points.length;
indexCount = segments * points.length * 2 * 3;
indices = new BufferAttribute(new (indexCount > 65535 ? Uint32Array : Uint16Array)(indexCount), 1);
vertices = new BufferAttribute(new Float32Array(vertexCount * 3), 3);
uvs = new BufferAttribute(new Float32Array(vertexCount * 2), 2);
index = 0;
indexOffset = 0;
inverseSegments = 1 / segments;
vertex = new Vector3();
uv = new Vector2();
for (i = 0; i <= segments; i++) {
    phi = phiStart + i * inverseSegments * phiLength;
    sin = Math.sin(phi);
    cos = Math.cos(phi);
    for (j = 0; j <= points.length - 1; j++) {
        vertex.x = points[j].x * sin;
        vertex.y = points[j].y;
        vertex.z = points[j].x * cos;
        vertices.setXYZ(index, vertex.x, vertex.y, vertex.z);
        uv.x = i / segments;
        uv.y = j / (points.length - 1);
        uvs.setXY(index, uv.x, uv.y);
        index++;
    }
}
for (i = 0; i < segments; i++) {
    for (j = 0; j < points.length - 1; j++) {
        base = j + i * points.length;
        a = base;
        b = base + points.length;
        c = base + points.length + 1;
        d = base + 1;
        indices.setX(indexOffset, a);
        indexOffset++;
        indices.setX(indexOffset, b);
        indexOffset++;
        indices.setX(indexOffset, d);
        indexOffset++;
        indices.setX(indexOffset, b);
        indexOffset++;
        indices.setX(indexOffset, c);
        indexOffset++;
        indices.setX(indexOffset, d);
        indexOffset++;
    }
}
this.setIndex(indices);
this.addAttribute('position', vertices);
this.addAttribute('uv', uvs);
this.computeVertexNormals();
if (phiLength === Math.PI * 2) {
    normals = this.attributes.normal.array;
    n1 = new Vector3();
    n2 = new Vector3();
    n = new Vector3();
    base = segments * points.length * 3;
    for (i = 0, j = 0; i < points.length; i++, j += 3) {
        n1.x = normals[j + 0];
        n1.y = normals[j + 1];
        n1.z = normals[j + 2];
        n2.x = normals[base + j + 0];
        n2.y = normals[base + j + 1];
        n2.z = normals[base + j + 2];
        n.addVectors(n1, n2).normalize();
        normals[j + 0] = normals[base + j + 0] = n.x;
        normals[j + 1] = normals[base + j + 1] = n.y;
        normals[j + 2] = normals[base + j + 2] = n.z;
    }
}});
    LatheGeometry = ($__.fs.LatheGeometry_264 = function LatheGeometry(points, segments, phiStart, phiLength) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
points = arguments[0], segments = arguments[1], phiStart = arguments[2], phiLength = arguments[3];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
Geometry.call(this);
this.type = 'LatheGeometry';
this.parameters = {
    points: points,
    segments: segments,
    phiStart: phiStart,
    phiLength: phiLength
};
this.fromBufferGeometry(new LatheBufferGeometry(points, segments, phiStart, phiLength));
this.mergeVertices();});
    CylinderGeometry = ($__.fs.CylinderGeometry_265 = function CylinderGeometry(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
radiusTop = arguments[0], radiusBottom = arguments[1], height = arguments[2], radialSegments = arguments[3], heightSegments = arguments[4], openEnded = arguments[5], thetaStart = arguments[6], thetaLength = arguments[7];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
Geometry.call(this);
this.type = 'CylinderGeometry';
this.parameters = {
    radiusTop: radiusTop,
    radiusBottom: radiusBottom,
    height: height,
    radialSegments: radialSegments,
    heightSegments: heightSegments,
    openEnded: openEnded,
    thetaStart: thetaStart,
    thetaLength: thetaLength
};
this.fromBufferGeometry(new CylinderBufferGeometry(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength));
this.mergeVertices();});
    ConeGeometry = ($__.fs.ConeGeometry_266 = function ConeGeometry(radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
radius = arguments[0], height = arguments[1], radialSegments = arguments[2], heightSegments = arguments[3], openEnded = arguments[4], thetaStart = arguments[5], thetaLength = arguments[6];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
CylinderGeometry.call(this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength);
this.type = 'ConeGeometry';
this.parameters = {
    radius: radius,
    height: height,
    radialSegments: radialSegments,
    heightSegments: heightSegments,
    openEnded: openEnded,
    thetaStart: thetaStart,
    thetaLength: thetaLength
};});
    ConeBufferGeometry = ($__.fs.ConeBufferGeometry_267 = function ConeBufferGeometry(radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
radius = arguments[0], height = arguments[1], radialSegments = arguments[2], heightSegments = arguments[3], openEnded = arguments[4], thetaStart = arguments[5], thetaLength = arguments[6];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
CylinderBufferGeometry.call(this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength);
this.type = 'ConeBufferGeometry';
this.parameters = {
    radius: radius,
    height: height,
    radialSegments: radialSegments,
    heightSegments: heightSegments,
    thetaStart: thetaStart,
    thetaLength: thetaLength
};});
    CircleBufferGeometry = ($__.fs.CircleBufferGeometry_268 = function CircleBufferGeometry(radius, segments, thetaStart, thetaLength) {
var vvv_return, vvv_switch, vertices, positions, normals, uvs, segment, indices;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
radius = arguments[0], segments = arguments[1], thetaStart = arguments[2], thetaLength = arguments[3];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
BufferGeometry.call(this);
this.type = 'CircleBufferGeometry';
this.parameters = {
    radius: radius,
    segments: segments,
    thetaStart: thetaStart,
    thetaLength: thetaLength
};
radius = radius || 50;
segments = segments !== undefined ? Math.max(3, segments) : 8;
thetaStart = thetaStart !== undefined ? thetaStart : 0;
thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;
vertices = segments + 2;
positions = new Float32Array(vertices * 3);
normals = new Float32Array(vertices * 3);
uvs = new Float32Array(vertices * 2);
normals[2] = 1;
uvs[0] = 0.5;
uvs[1] = 0.5;
for (var s = 0, i = 3, ii = 2; s <= segments; s++, i += 3, ii += 2) {
    segment = thetaStart + s / segments * thetaLength;
    positions[i] = radius * Math.cos(segment);
    positions[i + 1] = radius * Math.sin(segment);
    normals[i + 2] = 1;
    uvs[ii] = (positions[i] / radius + 1) / 2;
    uvs[ii + 1] = (positions[i + 1] / radius + 1) / 2;
}
indices = [];
for (var i = 1; i <= segments; i++) {
    indices.push(i, i + 1, 0);
}
this.setIndex(new BufferAttribute(new Uint16Array(indices), 1));
this.addAttribute('position', new BufferAttribute(positions, 3));
this.addAttribute('normal', new BufferAttribute(normals, 3));
this.addAttribute('uv', new BufferAttribute(uvs, 2));
this.boundingSphere = new Sphere(new Vector3(), radius);});
    CircleGeometry = ($__.fs.CircleGeometry_269 = function CircleGeometry(radius, segments, thetaStart, thetaLength) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
radius = arguments[0], segments = arguments[1], thetaStart = arguments[2], thetaLength = arguments[3];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
Geometry.call(this);
this.type = 'CircleGeometry';
this.parameters = {
    radius: radius,
    segments: segments,
    thetaStart: thetaStart,
    thetaLength: thetaLength
};
this.fromBufferGeometry(new CircleBufferGeometry(radius, segments, thetaStart, thetaLength));});
    ClosedSplineCurve3 = ($__.fs.ClosedSplineCurve3_270 = function ClosedSplineCurve3(points) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
points = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
console.warn('THREE.ClosedSplineCurve3 has been deprecated. Please use THREE.CatmullRomCurve3.');
exports.CatmullRomCurve3.call(this, points);
this.type = 'catmullrom';
this.closed = true;});
    ArcCurve = ($__.fs.ArcCurve_271 = function ArcCurve(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
aX = arguments[0], aY = arguments[1], aRadius = arguments[2], aStartAngle = arguments[3], aEndAngle = arguments[4], aClockwise = arguments[5];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
EllipseCurve.call(this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);});
    Face4 = ($__.fs.Face4_272 = function Face4(a, b, c, d, normal, color, materialIndex) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
a = arguments[0], b = arguments[1], c = arguments[2], d = arguments[3], normal = arguments[4], color = arguments[5], materialIndex = arguments[6];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
console.warn('THREE.Face4 has been removed. A THREE.Face3 will be created instead.');
return new Face3(a, b, c, normal, color, materialIndex);});
    PointCloud = ($__.fs.PointCloud_273 = function PointCloud(geometry, material) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
geometry = arguments[0], material = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
console.warn('THREE.PointCloud has been renamed to THREE.Points.');
return new Points(geometry, material);});
    ParticleSystem = ($__.fs.ParticleSystem_274 = function ParticleSystem(geometry, material) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
geometry = arguments[0], material = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
console.warn('THREE.ParticleSystem has been renamed to THREE.Points.');
return new Points(geometry, material);});
    PointCloudMaterial = ($__.fs.PointCloudMaterial_275 = function PointCloudMaterial(parameters) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
parameters = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
console.warn('THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.');
return new PointsMaterial(parameters);});
    ParticleBasicMaterial = ($__.fs.ParticleBasicMaterial_276 = function ParticleBasicMaterial(parameters) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
parameters = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
console.warn('THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.');
return new PointsMaterial(parameters);});
    ParticleSystemMaterial = ($__.fs.ParticleSystemMaterial_277 = function ParticleSystemMaterial(parameters) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
parameters = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
console.warn('THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.');
return new PointsMaterial(parameters);});
    Vertex = ($__.fs.Vertex_278 = function Vertex(x, y, z) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
x = arguments[0], y = arguments[1], z = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
console.warn('THREE.Vertex has been removed. Use THREE.Vector3 instead.');
return new Vector3(x, y, z);});
    Projector = ($__.fs.Projector_279 = function Projector() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
console.error('THREE.Projector has been moved to /examples/js/renderers/Projector.js.');
this.projectVector = function (vector, camera) {
    console.warn('THREE.Projector: .projectVector() is now vector.project().');
    vector.project(camera);
};
this.unprojectVector = function (vector, camera) {
    console.warn('THREE.Projector: .unprojectVector() is now vector.unproject().');
    vector.unproject(camera);
};
this.pickingRay = function (vector, camera) {
    console.error('THREE.Projector: .pickingRay() is now raycaster.setFromCamera().');
};});
    CanvasRenderer = ($__.fs.CanvasRenderer_280 = function CanvasRenderer() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
console.error('THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js');
this.domElement = document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');
this.clear = function () {
};
this.render = function () {
};
this.setClearColor = function () {
};
this.setSize = function () {
};});
    (Number.EPSILON, 2.220446049250313e-16) === undefined;
    TAJS_restrictToType(Math.sign, 'function') === undefined;
    TAJS_restrictToType(TAJS_restrictToType(Function.prototype, 'function').name, 'string') === undefined;
    TAJS_restrictToType(Object.assign, 'function') === undefined;
    Object['assign'](TAJS_restrictToType(EventDispatcher.prototype, 'object'), $__.os.oid1 = {
        'addEventListener': ($__.fs.J$__v494107025_25_281 = function J$__v494107025_25(type, listener) {
var vvv_return, vvv_switch, listeners;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
type = arguments[0], listener = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (this._listeners === undefined)
    this._listeners = {};
listeners = this._listeners;
if (listeners[type] === undefined) {
    listeners[type] = [];
}
if (listeners[type].indexOf(listener) === -1) {
    listeners[type].push(listener);
}}),
        'hasEventListener': ($__.fs.J$__v494107025_27_282 = function J$__v494107025_27(type, listener) {
var vvv_return, vvv_switch, listeners;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
type = arguments[0], listener = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (this._listeners === undefined)
    return false;
listeners = this._listeners;
if (listeners[type] !== undefined && listeners[type].indexOf(listener) !== -1) {
    return true;
}
return false;}),
        'removeEventListener': ($__.fs.J$__v494107025_29_283 = function J$__v494107025_29(type, listener) {
var vvv_return, vvv_switch, listeners, listenerArray, index;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
type = arguments[0], listener = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (this._listeners === undefined)
    return;
listeners = this._listeners;
listenerArray = listeners[type];
if (listenerArray !== undefined) {
    index = listenerArray.indexOf(listener);
    if (index !== -1) {
        listenerArray.splice(index, 1);
    }
}}),
        'dispatchEvent': ($__.fs.J$__v494107025_31_284 = function J$__v494107025_31(event) {
var vvv_return, vvv_switch, listeners, listenerArray, array, i, length;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
event = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (this._listeners === undefined)
    return;
listeners = this._listeners;
listenerArray = listeners[event.type];
if (listenerArray !== undefined) {
    event.target = this;
    array = [];
    i = 0;
    length = listenerArray.length;
    for (i = 0; i < length; i++) {
        array[i] = listenerArray[i];
    }
    for (i = 0; i < length; i++) {
        array[i].call(this, event);
    }
}})
    });
    REVISION = '80';
    MOUSE = $__.os.oid2 = {
        'LEFT': 0,
        'MIDDLE': 1,
        'RIGHT': 2
    };
    CullFaceNone = 0;
    CullFaceBack = 1;
    CullFaceFront = 2;
    CullFaceFrontBack = 3;
    FrontFaceDirectionCW = 0;
    FrontFaceDirectionCCW = 1;
    BasicShadowMap = 0;
    PCFShadowMap = 1;
    PCFSoftShadowMap = 2;
    FrontSide = 0;
    BackSide = 1;
    DoubleSide = 2;
    FlatShading = 1;
    SmoothShading = 2;
    NoColors = 0;
    FaceColors = 1;
    VertexColors = 2;
    NoBlending = 0;
    NormalBlending = 1;
    AdditiveBlending = 2;
    SubtractiveBlending = 3;
    MultiplyBlending = 4;
    CustomBlending = 5;
    AddEquation = 100;
    SubtractEquation = 101;
    ReverseSubtractEquation = 102;
    MinEquation = 103;
    MaxEquation = 104;
    ZeroFactor = 200;
    OneFactor = 201;
    SrcColorFactor = 202;
    OneMinusSrcColorFactor = 203;
    SrcAlphaFactor = 204;
    OneMinusSrcAlphaFactor = 205;
    DstAlphaFactor = 206;
    OneMinusDstAlphaFactor = 207;
    DstColorFactor = 208;
    OneMinusDstColorFactor = 209;
    SrcAlphaSaturateFactor = 210;
    NeverDepth = 0;
    AlwaysDepth = 1;
    LessDepth = 2;
    LessEqualDepth = 3;
    EqualDepth = 4;
    GreaterEqualDepth = 5;
    GreaterDepth = 6;
    NotEqualDepth = 7;
    MultiplyOperation = 0;
    MixOperation = 1;
    AddOperation = 2;
    NoToneMapping = 0;
    LinearToneMapping = 1;
    ReinhardToneMapping = 2;
    Uncharted2ToneMapping = 3;
    CineonToneMapping = 4;
    UVMapping = 300;
    CubeReflectionMapping = 301;
    CubeRefractionMapping = 302;
    EquirectangularReflectionMapping = 303;
    EquirectangularRefractionMapping = 304;
    SphericalReflectionMapping = 305;
    CubeUVReflectionMapping = 306;
    CubeUVRefractionMapping = 307;
    RepeatWrapping = 1000;
    ClampToEdgeWrapping = 1001;
    MirroredRepeatWrapping = 1002;
    NearestFilter = 1003;
    NearestMipMapNearestFilter = 1004;
    NearestMipMapLinearFilter = 1005;
    LinearFilter = 1006;
    LinearMipMapNearestFilter = 1007;
    LinearMipMapLinearFilter = 1008;
    UnsignedByteType = 1009;
    ByteType = 1010;
    ShortType = 1011;
    UnsignedShortType = 1012;
    IntType = 1013;
    UnsignedIntType = 1014;
    FloatType = 1015;
    HalfFloatType = 1016;
    UnsignedShort4444Type = 1017;
    UnsignedShort5551Type = 1018;
    UnsignedShort565Type = 1019;
    UnsignedInt248Type = 1020;
    AlphaFormat = 1021;
    RGBFormat = 1022;
    RGBAFormat = 1023;
    LuminanceFormat = 1024;
    LuminanceAlphaFormat = 1025;
    RGBEFormat = RGBAFormat;
    DepthFormat = 1026;
    DepthStencilFormat = 1027;
    RGB_S3TC_DXT1_Format = 2001;
    RGBA_S3TC_DXT1_Format = 2002;
    RGBA_S3TC_DXT3_Format = 2003;
    RGBA_S3TC_DXT5_Format = 2004;
    RGB_PVRTC_4BPPV1_Format = 2100;
    RGB_PVRTC_2BPPV1_Format = 2101;
    RGBA_PVRTC_4BPPV1_Format = 2102;
    RGBA_PVRTC_2BPPV1_Format = 2103;
    RGB_ETC1_Format = 2151;
    LoopOnce = 2200;
    LoopRepeat = 2201;
    LoopPingPong = 2202;
    InterpolateDiscrete = 2300;
    InterpolateLinear = 2301;
    InterpolateSmooth = 2302;
    ZeroCurvatureEnding = 2400;
    ZeroSlopeEnding = 2401;
    WrapAroundEnding = 2402;
    TrianglesDrawMode = 0;
    TriangleStripDrawMode = 1;
    TriangleFanDrawMode = 2;
    LinearEncoding = 3000;
    sRGBEncoding = 3001;
    GammaEncoding = 3007;
    RGBEEncoding = 3002;
    LogLuvEncoding = 3003;
    RGBM7Encoding = 3004;
    RGBM16Encoding = 3005;
    RGBDEncoding = 3006;
    BasicDepthPacking = 3200;
    RGBADepthPacking = 3201;
    (exports, $__.os.oid0).Math = $__.os.oid3 = {
        'DEG2RAD': (Math.PI, 3.141592653589793) / 180,
        'RAD2DEG': 180 / (Math.PI, 3.141592653589793),
        'generateUUID': (($__.fs.J$__v494107025_34_285 = function J$__v494107025_34() {
var vvv_return, vvv_switch, chars, uuid, rnd, r;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    chars = function $__lt0(res) {
        res.length = 62;
        if (res.length != 62)
            TAJS_dumpValue('Possible loss of precision');
        return res;
        ;
        TAJS_makeContextSensitive($__lt0, -2);
    }('0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'['split'](''));
    uuid = function $__lt1(res) {
        res.length = 36;
        if (res.length != 36)
            TAJS_dumpValue('Possible loss of precision');
        return res;
        ;
        TAJS_makeContextSensitive($__lt1, -2);
    }(new Array(36));
    rnd = 0;
    return ($__.fs.generateUUID_286 = function generateUUID() {
var vvv_return, vvv_switch, i;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    i = 0;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    rnd = 33554432 + (Math['random'](), 0.572196540521684) * 16777216 | 0;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 0] = TAJS_restrictToType(chars[(i === 19, r), 8], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 1] = TAJS_restrictToType(chars[(i === 19, r), 7], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 2] = TAJS_restrictToType(chars[(i === 19, r), 11], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 3] = TAJS_restrictToType(chars[(i === 19, r), 7], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 4] = TAJS_restrictToType(chars[(i === 19, r), 2], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 5] = TAJS_restrictToType(chars[(i === 19, r), 9], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    rnd = 33554432 + (Math['random'](), 0.5223690327600667) * 16777216 | 0;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 6] = TAJS_restrictToType(chars[(i === 19, r), 10], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 7] = TAJS_restrictToType(chars[(i === 19, r), 15], 'string');
    (i = +i + 1) - 1;
    i < 36;
    i === 8;
    uuid[i, 8] = '-';
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 9] = TAJS_restrictToType(chars[(i === 19, r), 9], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 10] = TAJS_restrictToType(chars[(i === 19, r), 11], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 11] = TAJS_restrictToType(chars[(i === 19, r), 5], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 12] = TAJS_restrictToType(chars[(i === 19, r), 8], 'string');
    (i = +i + 1) - 1;
    i < 36;
    i === 8, i === 13;
    uuid[i, 13] = '-';
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    uuid[i, 14] = '4';
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    rnd = 33554432 + (Math['random'](), 0.6447791243729757) * 16777216 | 0;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 15] = TAJS_restrictToType(chars[(i === 19, r), 14], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 16] = TAJS_restrictToType(chars[(i === 19, r), 3], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 17] = TAJS_restrictToType(chars[(i === 19, r), 0], 'string');
    (i = +i + 1) - 1;
    i < 36;
    (i === 8, i === 13), i === 18;
    uuid[i, 18] = '-';
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 19] = TAJS_restrictToType(chars[(i === 19, r & 3 | 8), 9], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 20] = TAJS_restrictToType(chars[(i === 19, r), 5], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 21] = TAJS_restrictToType(chars[(i === 19, r), 10], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    rnd = 33554432 + (Math['random'](), 0.9977354843862101) * 16777216 | 0;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 22] = TAJS_restrictToType(chars[(i === 19, r), 7], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    uuid[i, 23] = '-';
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 24] = TAJS_restrictToType(chars[(i === 19, r), 9], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 25] = TAJS_restrictToType(chars[(i === 19, r), 11], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 26] = TAJS_restrictToType(chars[(i === 19, r), 6], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 27] = TAJS_restrictToType(chars[(i === 19, r), 15], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 28] = TAJS_restrictToType(chars[(i === 19, r), 15], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    rnd = 33554432 + (Math['random'](), 0.5264919881891685) * 16777216 | 0;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 29] = TAJS_restrictToType(chars[(i === 19, r), 13], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 30] = TAJS_restrictToType(chars[(i === 19, r), 2], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 31] = TAJS_restrictToType(chars[(i === 19, r), 8], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 32] = TAJS_restrictToType(chars[(i === 19, r), 12], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 33] = TAJS_restrictToType(chars[(i === 19, r), 6], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 34] = TAJS_restrictToType(chars[(i === 19, r), 8], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    rnd = 33554432 + (Math['random'](), 0.9060959396071946) * 16777216 | 0;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 35] = TAJS_restrictToType(chars[(i === 19, r), 7], 'string');
    (i = +i + 1) - 1;
    i < 36;
    return uuid['join']('');
case 1:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 1);
    i = 0;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 0] = TAJS_restrictToType(chars[(i === 19, r), 14], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 1] = TAJS_restrictToType(chars[(i === 19, r), 5], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 2] = TAJS_restrictToType(chars[(i === 19, r), 15], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 3] = TAJS_restrictToType(chars[(i === 19, r), 7], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 4] = TAJS_restrictToType(chars[(i === 19, r), 14], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    rnd = 33554432 + (Math['random'](), 0.8442992248346282) * 16777216 | 0;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 5] = TAJS_restrictToType(chars[(i === 19, r), 14], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 6] = TAJS_restrictToType(chars[(i === 19, r), 15], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 7] = TAJS_restrictToType(chars[(i === 19, r), 3], 'string');
    (i = +i + 1) - 1;
    i < 36;
    i === 8;
    uuid[i, 8] = '-';
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 9] = TAJS_restrictToType(chars[(i === 19, r), 2], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 10] = TAJS_restrictToType(chars[(i === 19, r), 8], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 11] = TAJS_restrictToType(chars[(i === 19, r), 13], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    rnd = 33554432 + (Math['random'](), 0.16847221533990098) * 16777216 | 0;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 12] = TAJS_restrictToType(chars[(i === 19, r), 14], 'string');
    (i = +i + 1) - 1;
    i < 36;
    i === 8, i === 13;
    uuid[i, 13] = '-';
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    uuid[i, 14] = '4';
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 15] = TAJS_restrictToType(chars[(i === 19, r), 15], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 16] = TAJS_restrictToType(chars[(i === 19, r), 0], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 17] = TAJS_restrictToType(chars[(i === 19, r), 2], 'string');
    (i = +i + 1) - 1;
    i < 36;
    (i === 8, i === 13), i === 18;
    uuid[i, 18] = '-';
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 19] = TAJS_restrictToType(chars[(i === 19, r & 3 | 8), 11], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 20] = TAJS_restrictToType(chars[(i === 19, r), 2], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    rnd = 33554432 + (Math['random'](), 0.8741091920484181) * 16777216 | 0;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 21] = TAJS_restrictToType(chars[(i === 19, r), 14], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 22] = TAJS_restrictToType(chars[(i === 19, r), 9], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    uuid[i, 23] = '-';
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 24] = TAJS_restrictToType(chars[(i === 19, r), 5], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 25] = TAJS_restrictToType(chars[(i === 19, r), 12], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 26] = TAJS_restrictToType(chars[(i === 19, r), 15], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 27] = TAJS_restrictToType(chars[(i === 19, r), 13], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    rnd = 33554432 + (Math['random'](), 0.8476239561820791) * 16777216 | 0;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 28] = TAJS_restrictToType(chars[(i === 19, r), 2], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 29] = TAJS_restrictToType(chars[(i === 19, r), 14], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 30] = TAJS_restrictToType(chars[(i === 19, r), 13], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 31] = TAJS_restrictToType(chars[(i === 19, r), 15], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 32] = TAJS_restrictToType(chars[(i === 19, r), 8], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 33] = TAJS_restrictToType(chars[(i === 19, r), 13], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    rnd = 33554432 + (Math['random'](), 0.8668748011220837) * 16777216 | 0;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 34] = TAJS_restrictToType(chars[(i === 19, r), 1], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 35] = TAJS_restrictToType(chars[(i === 19, r), 8], 'string');
    (i = +i + 1) - 1;
    i < 36;
    return uuid['join']('');
case 2:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 2);
    i = 0;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 0] = TAJS_restrictToType(chars[(i === 19, r), 11], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 1] = TAJS_restrictToType(chars[(i === 19, r), 14], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 2] = TAJS_restrictToType(chars[(i === 19, r), 13], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 3] = TAJS_restrictToType(chars[(i === 19, r), 13], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    rnd = 33554432 + (Math['random'](), 0.7008030645353676) * 16777216 | 0;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 4] = TAJS_restrictToType(chars[(i === 19, r), 4], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 5] = TAJS_restrictToType(chars[(i === 19, r), 13], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 6] = TAJS_restrictToType(chars[(i === 19, r), 7], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 7] = TAJS_restrictToType(chars[(i === 19, r), 6], 'string');
    (i = +i + 1) - 1;
    i < 36;
    i === 8;
    uuid[i, 8] = '-';
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 9] = TAJS_restrictToType(chars[(i === 19, r), 3], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 10] = TAJS_restrictToType(chars[(i === 19, r), 11], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    rnd = 33554432 + (Math['random'](), 0.6023442687580081) * 16777216 | 0;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 11] = TAJS_restrictToType(chars[(i === 19, r), 11], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 12] = TAJS_restrictToType(chars[(i === 19, r), 3], 'string');
    (i = +i + 1) - 1;
    i < 36;
    i === 8, i === 13;
    uuid[i, 13] = '-';
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    uuid[i, 14] = '4';
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 15] = TAJS_restrictToType(chars[(i === 19, r), 3], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 16] = TAJS_restrictToType(chars[(i === 19, r), 3], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 17] = TAJS_restrictToType(chars[(i === 19, r), 10], 'string');
    (i = +i + 1) - 1;
    i < 36;
    (i === 8, i === 13), i === 18;
    uuid[i, 18] = '-';
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 19] = TAJS_restrictToType(chars[(i === 19, r & 3 | 8), 9], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    rnd = 33554432 + (Math['random'](), 0.49281903163767393) * 16777216 | 0;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 20] = TAJS_restrictToType(chars[(i === 19, r), 3], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 21] = TAJS_restrictToType(chars[(i === 19, r), 6], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 22] = TAJS_restrictToType(chars[(i === 19, r), 9], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    uuid[i, 23] = '-';
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 24] = TAJS_restrictToType(chars[(i === 19, r), 2], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 25] = TAJS_restrictToType(chars[(i === 19, r), 14], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 26] = TAJS_restrictToType(chars[(i === 19, r), 7], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    rnd = 33554432 + (Math['random'](), 0.6728270315827007) * 16777216 | 0;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 27] = TAJS_restrictToType(chars[(i === 19, r), 4], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 28] = TAJS_restrictToType(chars[(i === 19, r), 6], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 29] = TAJS_restrictToType(chars[(i === 19, r), 14], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 30] = TAJS_restrictToType(chars[(i === 19, r), 3], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 31] = TAJS_restrictToType(chars[(i === 19, r), 12], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 32] = TAJS_restrictToType(chars[(i === 19, r), 10], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    rnd = 33554432 + (Math['random'](), 0.6651824090730427) * 16777216 | 0;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 33] = TAJS_restrictToType(chars[(i === 19, r), 4], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 34] = TAJS_restrictToType(chars[(i === 19, r), 6], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 35] = TAJS_restrictToType(chars[(i === 19, r), 9], 'string');
    (i = +i + 1) - 1;
    i < 36;
    return uuid['join']('');
case 3:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 3);
    i = 0;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 0] = TAJS_restrictToType(chars[(i === 19, r), 4], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 1] = TAJS_restrictToType(chars[(i === 19, r), 10], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 2] = TAJS_restrictToType(chars[(i === 19, r), 10], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    rnd = 33554432 + (Math['random'](), 0.6112093340174753) * 16777216 | 0;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 3] = TAJS_restrictToType(chars[(i === 19, r), 7], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 4] = TAJS_restrictToType(chars[(i === 19, r), 3], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 5] = TAJS_restrictToType(chars[(i === 19, r), 8], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 6] = TAJS_restrictToType(chars[(i === 19, r), 7], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 7] = TAJS_restrictToType(chars[(i === 19, r), 12], 'string');
    (i = +i + 1) - 1;
    i < 36;
    i === 8;
    uuid[i, 8] = '-';
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 9] = TAJS_restrictToType(chars[(i === 19, r), 9], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    rnd = 33554432 + (Math['random'](), 0.26851060210516664) * 16777216 | 0;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 10] = TAJS_restrictToType(chars[(i === 19, r), 12], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 11] = TAJS_restrictToType(chars[(i === 19, r), 1], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 12] = TAJS_restrictToType(chars[(i === 19, r), 13], 'string');
    (i = +i + 1) - 1;
    i < 36;
    i === 8, i === 13;
    uuid[i, 13] = '-';
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    uuid[i, 14] = '4';
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 15] = TAJS_restrictToType(chars[(i === 19, r), 11], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 16] = TAJS_restrictToType(chars[(i === 19, r), 4], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 17] = TAJS_restrictToType(chars[(i === 19, r), 4], 'string');
    (i = +i + 1) - 1;
    i < 36;
    (i === 8, i === 13), i === 18;
    uuid[i, 18] = '-';
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    rnd = 33554432 + (Math['random'](), 0.8933593375319511) * 16777216 | 0;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 19] = TAJS_restrictToType(chars[(i === 19, r & 3 | 8), 10], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 20] = TAJS_restrictToType(chars[(i === 19, r), 3], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 21] = TAJS_restrictToType(chars[(i === 19, r), 3], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 22] = TAJS_restrictToType(chars[(i === 19, r), 11], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    uuid[i, 23] = '-';
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 24] = TAJS_restrictToType(chars[(i === 19, r), 4], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 25] = TAJS_restrictToType(chars[(i === 19, r), 14], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    rnd = 33554432 + (Math['random'](), 0.944738558098188) * 16777216 | 0;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 26] = TAJS_restrictToType(chars[(i === 19, r), 2], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 27] = TAJS_restrictToType(chars[(i === 19, r), 6], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 28] = TAJS_restrictToType(chars[(i === 19, r), 10], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 29] = TAJS_restrictToType(chars[(i === 19, r), 13], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 30] = TAJS_restrictToType(chars[(i === 19, r), 1], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 31] = TAJS_restrictToType(chars[(i === 19, r), 15], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    rnd = 33554432 + (Math['random'](), 0.2367703818396687) * 16777216 | 0;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 32] = TAJS_restrictToType(chars[(i === 19, r), 11], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 33] = TAJS_restrictToType(chars[(i === 19, r), 15], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 34] = TAJS_restrictToType(chars[(i === 19, r), 12], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 35] = TAJS_restrictToType(chars[(i === 19, r), 9], 'string');
    (i = +i + 1) - 1;
    i < 36;
    return uuid['join']('');
case 4:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 4);
    i = 0;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 0] = TAJS_restrictToType(chars[(i === 19, r), 12], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 1] = TAJS_restrictToType(chars[(i === 19, r), 3], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    rnd = 33554432 + (Math['random'](), 0.19546064898774618) * 16777216 | 0;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 2] = TAJS_restrictToType(chars[(i === 19, r), 5], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 3] = TAJS_restrictToType(chars[(i === 19, r), 11], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 4] = TAJS_restrictToType(chars[(i === 19, r), 9], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 5] = TAJS_restrictToType(chars[(i === 19, r), 0], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 6] = TAJS_restrictToType(chars[(i === 19, r), 2], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 7] = TAJS_restrictToType(chars[(i === 19, r), 3], 'string');
    (i = +i + 1) - 1;
    i < 36;
    i === 8;
    uuid[i, 8] = '-';
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    rnd = 33554432 + (Math['random'](), 0.23372742774093558) * 16777216 | 0;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 9] = TAJS_restrictToType(chars[(i === 19, r), 15], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 10] = TAJS_restrictToType(chars[(i === 19, r), 8], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 11] = TAJS_restrictToType(chars[(i === 19, r), 5], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 12] = TAJS_restrictToType(chars[(i === 19, r), 13], 'string');
    (i = +i + 1) - 1;
    i < 36;
    i === 8, i === 13;
    uuid[i, 13] = '-';
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    uuid[i, 14] = '4';
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 15] = TAJS_restrictToType(chars[(i === 19, r), 11], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 16] = TAJS_restrictToType(chars[(i === 19, r), 3], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    rnd = 33554432 + (Math['random'](), 0.5712137782159494) * 16777216 | 0;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 17] = TAJS_restrictToType(chars[(i === 19, r), 0], 'string');
    (i = +i + 1) - 1;
    i < 36;
    (i === 8, i === 13), i === 18;
    uuid[i, 18] = '-';
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 19] = TAJS_restrictToType(chars[(i === 19, r & 3 | 8), 9], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 20] = TAJS_restrictToType(chars[(i === 19, r), 11], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 21] = TAJS_restrictToType(chars[(i === 19, r), 3], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 22] = TAJS_restrictToType(chars[(i === 19, r), 2], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    uuid[i, 23] = '-';
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 24] = TAJS_restrictToType(chars[(i === 19, r), 9], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    rnd = 33554432 + (Math['random'](), 0.6398624872647087) * 16777216 | 0;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 25] = TAJS_restrictToType(chars[(i === 19, r), 7], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 26] = TAJS_restrictToType(chars[(i === 19, r), 0], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 27] = TAJS_restrictToType(chars[(i === 19, r), 14], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 28] = TAJS_restrictToType(chars[(i === 19, r), 12], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 29] = TAJS_restrictToType(chars[(i === 19, r), 3], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 30] = TAJS_restrictToType(chars[(i === 19, r), 10], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    rnd = 33554432 + (Math['random'](), 0.6491885741601566) * 16777216 | 0;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 31] = TAJS_restrictToType(chars[(i === 19, r), 8], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 32] = TAJS_restrictToType(chars[(i === 19, r), 3], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 33] = TAJS_restrictToType(chars[(i === 19, r), 1], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 34] = TAJS_restrictToType(chars[(i === 19, r), 3], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 35] = TAJS_restrictToType(chars[(i === 19, r), 6], 'string');
    (i = +i + 1) - 1;
    i < 36;
    return uuid['join']('');
case 5:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 5);
    i = 0;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 0] = TAJS_restrictToType(chars[(i === 19, r), 10], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    rnd = 33554432 + (Math['random'](), 0.48631953127177363) * 16777216 | 0;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 1] = TAJS_restrictToType(chars[(i === 19, r), 15], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 2] = TAJS_restrictToType(chars[(i === 19, r), 6], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 3] = TAJS_restrictToType(chars[(i === 19, r), 15], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 4] = TAJS_restrictToType(chars[(i === 19, r), 7], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 5] = TAJS_restrictToType(chars[(i === 19, r), 12], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 6] = TAJS_restrictToType(chars[(i === 19, r), 7], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    rnd = 33554432 + (Math['random'](), 0.051637323040767846) * 16777216 | 0;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 7] = TAJS_restrictToType(chars[(i === 19, r), 10], 'string');
    (i = +i + 1) - 1;
    i < 36;
    i === 8;
    uuid[i, 8] = '-';
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 9] = TAJS_restrictToType(chars[(i === 19, r), 1], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 10] = TAJS_restrictToType(chars[(i === 19, r), 8], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 11] = TAJS_restrictToType(chars[(i === 19, r), 3], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 12] = TAJS_restrictToType(chars[(i === 19, r), 13], 'string');
    (i = +i + 1) - 1;
    i < 36;
    i === 8, i === 13;
    uuid[i, 13] = '-';
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    uuid[i, 14] = '4';
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 15] = TAJS_restrictToType(chars[(i === 19, r), 0], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    rnd = 33554432 + (Math['random'](), 0.7516790280812713) * 16777216 | 0;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 16] = TAJS_restrictToType(chars[(i === 19, r), 9], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 17] = TAJS_restrictToType(chars[(i === 19, r), 0], 'string');
    (i = +i + 1) - 1;
    i < 36;
    (i === 8, i === 13), i === 18;
    uuid[i, 18] = '-';
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 19] = TAJS_restrictToType(chars[(i === 19, r & 3 | 8), 10], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 20] = TAJS_restrictToType(chars[(i === 19, r), 6], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 21] = TAJS_restrictToType(chars[(i === 19, r), 0], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 22] = TAJS_restrictToType(chars[(i === 19, r), 12], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    uuid[i, 23] = '-';
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    rnd = 33554432 + (Math['random'](), 0.1741245407482257) * 16777216 | 0;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 24] = TAJS_restrictToType(chars[(i === 19, r), 13], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 25] = TAJS_restrictToType(chars[(i === 19, r), 6], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 26] = TAJS_restrictToType(chars[(i === 19, r), 3], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 27] = TAJS_restrictToType(chars[(i === 19, r), 9], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 28] = TAJS_restrictToType(chars[(i === 19, r), 12], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 29] = TAJS_restrictToType(chars[(i === 19, r), 2], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    rnd = 33554432 + (Math['random'](), 0.3025146266567096) * 16777216 | 0;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 30] = TAJS_restrictToType(chars[(i === 19, r), 9], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 31] = TAJS_restrictToType(chars[(i === 19, r), 9], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 32] = TAJS_restrictToType(chars[(i === 19, r), 1], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 33] = TAJS_restrictToType(chars[(i === 19, r), 7], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 34] = TAJS_restrictToType(chars[(i === 19, r), 13], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 35] = TAJS_restrictToType(chars[(i === 19, r), 4], 'string');
    (i = +i + 1) - 1;
    i < 36;
    return uuid['join']('');
case 6:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 6);
    i = 0;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    rnd = 33554432 + (Math['random'](), 0.1499679680065138) * 16777216 | 0;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 0] = TAJS_restrictToType(chars[(i === 19, r), 12], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 1] = TAJS_restrictToType(chars[(i === 19, r), 4], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 2] = TAJS_restrictToType(chars[(i === 19, r), 4], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 3] = TAJS_restrictToType(chars[(i === 19, r), 6], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 4] = TAJS_restrictToType(chars[(i === 19, r), 6], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 5] = TAJS_restrictToType(chars[(i === 19, r), 2], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    rnd = 33554432 + (Math['random'](), 0.3411599415348523) * 16777216 | 0;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 6] = TAJS_restrictToType(chars[(i === 19, r), 2], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 7] = TAJS_restrictToType(chars[(i === 19, r), 4], 'string');
    (i = +i + 1) - 1;
    i < 36;
    i === 8;
    uuid[i, 8] = '-';
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 9] = TAJS_restrictToType(chars[(i === 19, r), 6], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 10] = TAJS_restrictToType(chars[(i === 19, r), 5], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 11] = TAJS_restrictToType(chars[(i === 19, r), 7], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 12] = TAJS_restrictToType(chars[(i === 19, r), 5], 'string');
    (i = +i + 1) - 1;
    i < 36;
    i === 8, i === 13;
    uuid[i, 13] = '-';
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    uuid[i, 14] = '4';
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    rnd = 33554432 + (Math['random'](), 0.016282090879339295) * 16777216 | 0;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 15] = TAJS_restrictToType(chars[(i === 19, r), 0], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 16] = TAJS_restrictToType(chars[(i === 19, r), 1], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 17] = TAJS_restrictToType(chars[(i === 19, r), 11], 'string');
    (i = +i + 1) - 1;
    i < 36;
    (i === 8, i === 13), i === 18;
    uuid[i, 18] = '-';
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 19] = TAJS_restrictToType(chars[(i === 19, r & 3 | 8), 10], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 20] = TAJS_restrictToType(chars[(i === 19, r), 4], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 21] = TAJS_restrictToType(chars[(i === 19, r), 0], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    rnd = 33554432 + (Math['random'](), 0.9604431070364461) * 16777216 | 0;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 22] = TAJS_restrictToType(chars[(i === 19, r), 9], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    uuid[i, 23] = '-';
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 24] = TAJS_restrictToType(chars[(i === 19, r), 9], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 25] = TAJS_restrictToType(chars[(i === 19, r), 15], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 26] = TAJS_restrictToType(chars[(i === 19, r), 13], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 27] = TAJS_restrictToType(chars[(i === 19, r), 5], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 28] = TAJS_restrictToType(chars[(i === 19, r), 15], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    rnd = 33554432 + (Math['random'](), 0.2918742633167335) * 16777216 | 0;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 29] = TAJS_restrictToType(chars[(i === 19, r), 5], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 30] = TAJS_restrictToType(chars[(i === 19, r), 4], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 31] = TAJS_restrictToType(chars[(i === 19, r), 8], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 32] = TAJS_restrictToType(chars[(i === 19, r), 11], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 33] = TAJS_restrictToType(chars[(i === 19, r), 10], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 34] = TAJS_restrictToType(chars[(i === 19, r), 4], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    rnd = 33554432 + (Math['random'](), 0.5477770838562273) * 16777216 | 0;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 35] = TAJS_restrictToType(chars[(i === 19, r), 14], 'string');
    (i = +i + 1) - 1;
    i < 36;
    return uuid['join']('');
case 7:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 7);
    i = 0;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 0] = TAJS_restrictToType(chars[(i === 19, r), 1], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 1] = TAJS_restrictToType(chars[(i === 19, r), 11], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 2] = TAJS_restrictToType(chars[(i === 19, r), 3], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 3] = TAJS_restrictToType(chars[(i === 19, r), 12], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 4] = TAJS_restrictToType(chars[(i === 19, r), 8], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    rnd = 33554432 + (Math['random'](), 0.09311810618718042) * 16777216 | 0;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 5] = TAJS_restrictToType(chars[(i === 19, r), 6], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 6] = TAJS_restrictToType(chars[(i === 19, r), 9], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 7] = TAJS_restrictToType(chars[(i === 19, r), 6], 'string');
    (i = +i + 1) - 1;
    i < 36;
    i === 8;
    uuid[i, 8] = '-';
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 9] = TAJS_restrictToType(chars[(i === 19, r), 13], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 10] = TAJS_restrictToType(chars[(i === 19, r), 7], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 11] = TAJS_restrictToType(chars[(i === 19, r), 1], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    rnd = 33554432 + (Math['random'](), 0.5971115177647235) * 16777216 | 0;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 12] = TAJS_restrictToType(chars[(i === 19, r), 12], 'string');
    (i = +i + 1) - 1;
    i < 36;
    i === 8, i === 13;
    uuid[i, 13] = '-';
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    uuid[i, 14] = '4';
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 15] = TAJS_restrictToType(chars[(i === 19, r), 4], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 16] = TAJS_restrictToType(chars[(i === 19, r), 12], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 17] = TAJS_restrictToType(chars[(i === 19, r), 13], 'string');
    (i = +i + 1) - 1;
    i < 36;
    (i === 8, i === 13), i === 18;
    uuid[i, 18] = '-';
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 19] = TAJS_restrictToType(chars[(i === 19, r & 3 | 8), 8], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 20] = TAJS_restrictToType(chars[(i === 19, r), 9], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    rnd = 33554432 + (Math['random'](), 0.647053753071793) * 16777216 | 0;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 21] = TAJS_restrictToType(chars[(i === 19, r), 0], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 22] = TAJS_restrictToType(chars[(i === 19, r), 5], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    uuid[i, 23] = '-';
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 24] = TAJS_restrictToType(chars[(i === 19, r), 5], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 25] = TAJS_restrictToType(chars[(i === 19, r), 10], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 26] = TAJS_restrictToType(chars[(i === 19, r), 5], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 27] = TAJS_restrictToType(chars[(i === 19, r), 10], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    rnd = 33554432 + (Math['random'](), 0.6601550448588194) * 16777216 | 0;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 28] = TAJS_restrictToType(chars[(i === 19, r), 11], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 29] = TAJS_restrictToType(chars[(i === 19, r), 14], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 30] = TAJS_restrictToType(chars[(i === 19, r), 15], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 31] = TAJS_restrictToType(chars[(i === 19, r), 15], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 32] = TAJS_restrictToType(chars[(i === 19, r), 8], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 33] = TAJS_restrictToType(chars[(i === 19, r), 10], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    rnd = 33554432 + (Math['random'](), 0.5976181712655386) * 16777216 | 0;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 34] = TAJS_restrictToType(chars[(i === 19, r), 1], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 35] = TAJS_restrictToType(chars[(i === 19, r), 8], 'string');
    (i = +i + 1) - 1;
    i < 36;
    return uuid['join']('');
case 8:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 8);
    i = 0;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 0] = TAJS_restrictToType(chars[(i === 19, r), 13], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 1] = TAJS_restrictToType(chars[(i === 19, r), 15], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 2] = TAJS_restrictToType(chars[(i === 19, r), 8], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 3] = TAJS_restrictToType(chars[(i === 19, r), 9], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    rnd = 33554432 + (Math['random'](), 0.5269462519380423) * 16777216 | 0;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 4] = TAJS_restrictToType(chars[(i === 19, r), 3], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 5] = TAJS_restrictToType(chars[(i === 19, r), 15], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 6] = TAJS_restrictToType(chars[(i === 19, r), 5], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 7] = TAJS_restrictToType(chars[(i === 19, r), 14], 'string');
    (i = +i + 1) - 1;
    i < 36;
    i === 8;
    uuid[i, 8] = '-';
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 9] = TAJS_restrictToType(chars[(i === 19, r), 6], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 10] = TAJS_restrictToType(chars[(i === 19, r), 8], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    rnd = 33554432 + (Math['random'](), 0.3618541440718981) * 16777216 | 0;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 11] = TAJS_restrictToType(chars[(i === 19, r), 9], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 12] = TAJS_restrictToType(chars[(i === 19, r), 7], 'string');
    (i = +i + 1) - 1;
    i < 36;
    i === 8, i === 13;
    uuid[i, 13] = '-';
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    uuid[i, 14] = '4';
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 15] = TAJS_restrictToType(chars[(i === 19, r), 2], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 16] = TAJS_restrictToType(chars[(i === 19, r), 10], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 17] = TAJS_restrictToType(chars[(i === 19, r), 12], 'string');
    (i = +i + 1) - 1;
    i < 36;
    (i === 8, i === 13), i === 18;
    uuid[i, 18] = '-';
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 19] = TAJS_restrictToType(chars[(i === 19, r & 3 | 8), 9], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    rnd = 33554432 + (Math['random'](), 0.5637964928188219) * 16777216 | 0;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 20] = TAJS_restrictToType(chars[(i === 19, r), 7], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 21] = TAJS_restrictToType(chars[(i === 19, r), 15], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 22] = TAJS_restrictToType(chars[(i === 19, r), 4], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    uuid[i, 23] = '-';
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 24] = TAJS_restrictToType(chars[(i === 19, r), 5], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 25] = TAJS_restrictToType(chars[(i === 19, r), 0], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 26] = TAJS_restrictToType(chars[(i === 19, r), 9], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    rnd = 33554432 + (Math['random'](), 0.3395144588601975) * 16777216 | 0;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 27] = TAJS_restrictToType(chars[(i === 19, r), 11], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 28] = TAJS_restrictToType(chars[(i === 19, r), 6], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 29] = TAJS_restrictToType(chars[(i === 19, r), 10], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 30] = TAJS_restrictToType(chars[(i === 19, r), 14], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 31] = TAJS_restrictToType(chars[(i === 19, r), 6], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 32] = TAJS_restrictToType(chars[(i === 19, r), 5], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    rnd = 33554432 + (Math['random'](), 0.978320491685269) * 16777216 | 0;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 33] = TAJS_restrictToType(chars[(i === 19, r), 6], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 34] = TAJS_restrictToType(chars[(i === 19, r), 3], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 35] = TAJS_restrictToType(chars[(i === 19, r), 3], 'string');
    (i = +i + 1) - 1;
    i < 36;
    return uuid['join']('');
case 9:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 9);
    i = 0;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 0] = TAJS_restrictToType(chars[(i === 19, r), 7], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 1] = TAJS_restrictToType(chars[(i === 19, r), 10], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 2] = TAJS_restrictToType(chars[(i === 19, r), 15], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    rnd = 33554432 + (Math['random'](), 0.1532268546697828) * 16777216 | 0;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 3] = TAJS_restrictToType(chars[(i === 19, r), 0], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 4] = TAJS_restrictToType(chars[(i === 19, r), 14], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 5] = TAJS_restrictToType(chars[(i === 19, r), 9], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 6] = TAJS_restrictToType(chars[(i === 19, r), 3], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 7] = TAJS_restrictToType(chars[(i === 19, r), 7], 'string');
    (i = +i + 1) - 1;
    i < 36;
    i === 8;
    uuid[i, 8] = '-';
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 9] = TAJS_restrictToType(chars[(i === 19, r), 2], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    rnd = 33554432 + (Math['random'](), 0.4418255668314799) * 16777216 | 0;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 10] = TAJS_restrictToType(chars[(i === 19, r), 10], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 11] = TAJS_restrictToType(chars[(i === 19, r), 7], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 12] = TAJS_restrictToType(chars[(i === 19, r), 11], 'string');
    (i = +i + 1) - 1;
    i < 36;
    i === 8, i === 13;
    uuid[i, 13] = '-';
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    uuid[i, 14] = '4';
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 15] = TAJS_restrictToType(chars[(i === 19, r), 1], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 16] = TAJS_restrictToType(chars[(i === 19, r), 1], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 17] = TAJS_restrictToType(chars[(i === 19, r), 7], 'string');
    (i = +i + 1) - 1;
    i < 36;
    (i === 8, i === 13), i === 18;
    uuid[i, 18] = '-';
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    rnd = 33554432 + (Math['random'](), 0.7487842500268627) * 16777216 | 0;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 19] = TAJS_restrictToType(chars[(i === 19, r & 3 | 8), 11], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 20] = TAJS_restrictToType(chars[(i === 19, r), 5], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 21] = TAJS_restrictToType(chars[(i === 19, r), 0], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 22] = TAJS_restrictToType(chars[(i === 19, r), 11], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    uuid[i, 23] = '-';
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 24] = TAJS_restrictToType(chars[(i === 19, r), 15], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 25] = TAJS_restrictToType(chars[(i === 19, r), 11], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    rnd = 33554432 + (Math['random'](), 0.0506385265381839) * 16777216 | 0;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 26] = TAJS_restrictToType(chars[(i === 19, r), 5], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 27] = TAJS_restrictToType(chars[(i === 19, r), 10], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 28] = TAJS_restrictToType(chars[(i === 19, r), 6], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 29] = TAJS_restrictToType(chars[(i === 19, r), 15], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 30] = TAJS_restrictToType(chars[(i === 19, r), 12], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 31] = TAJS_restrictToType(chars[(i === 19, r), 0], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    rnd = 33554432 + (Math['random'](), 0.3526983200892748) * 16777216 | 0;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 32] = TAJS_restrictToType(chars[(i === 19, r), 15], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 33] = TAJS_restrictToType(chars[(i === 19, r), 6], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 34] = TAJS_restrictToType(chars[(i === 19, r), 10], 'string');
    (i = +i + 1) - 1;
    i < 36;
    ((i === 8, i === 13), i === 18), i === 23;
    i === 14;
    rnd <= 2;
    r = rnd & 15;
    rnd = rnd >> 4;
    uuid[i, 35] = TAJS_restrictToType(chars[(i === 19, r), 4], 'string');
    (i = +i + 1) - 1;
    i < 36;
    return uuid['join']('');
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
for (var i = 0; i < 36; i++) {
    if (i === 8 || i === 13 || i === 18 || i === 23) {
        uuid[i] = '-';
    } else if (i === 14) {
        uuid[i] = '4';
    } else {
        if (rnd <= 2)
            rnd = 33554432 + Math.random() * 16777216 | 0;
        r = rnd & 15;
        rnd = rnd >> 4;
        uuid[i] = chars[i === 19 ? r & 3 | 8 : r];
    }
}
return uuid.join('');});
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split('');
uuid = new Array(36);
rnd = 0;
return function generateUUID() {
    for (var i = 0; i < 36; i++) {
        if (i === 8 || i === 13 || i === 18 || i === 23) {
            uuid[i] = '-';
        } else if (i === 14) {
            uuid[i] = '4';
        } else {
            if (rnd <= 2)
                rnd = 33554432 + Math.random() * 16777216 | 0;
            r = rnd & 15;
            rnd = rnd >> 4;
            uuid[i] = chars[i === 19 ? r & 3 | 8 : r];
        }
    }
    return uuid.join('');
};}), $__.fs.J$__v494107025_34_285)(0, true, $__.uid),
        'clamp': ($__.fs.J$__v494107025_36_287 = function J$__v494107025_36(value, min, max) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
value = arguments[0], min = arguments[1], max = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return Math.max(min, Math.min(max, value));}),
        'euclideanModulo': ($__.fs.J$__v494107025_38_288 = function J$__v494107025_38(n, m) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
n = arguments[0], m = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return (n % m + m) % m;}),
        'mapLinear': ($__.fs.J$__v494107025_40_289 = function J$__v494107025_40(x, a1, a2, b1, b2) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
x = arguments[0], a1 = arguments[1], a2 = arguments[2], b1 = arguments[3], b2 = arguments[4];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return b1 + (x - a1) * (b2 - b1) / (a2 - a1);}),
        'smoothstep': ($__.fs.J$__v494107025_42_290 = function J$__v494107025_42(x, min, max) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
x = arguments[0], min = arguments[1], max = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (x <= min)
    return 0;
if (x >= max)
    return 1;
x = (x - min) / (max - min);
return x * x * (3 - 2 * x);}),
        'smootherstep': ($__.fs.J$__v494107025_44_291 = function J$__v494107025_44(x, min, max) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
x = arguments[0], min = arguments[1], max = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (x <= min)
    return 0;
if (x >= max)
    return 1;
x = (x - min) / (max - min);
return x * x * x * (x * (x * 6 - 15) + 10);}),
        'random16': ($__.fs.J$__v494107025_46_292 = function J$__v494107025_46() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
console.warn('THREE.Math.random16() has been deprecated. Use Math.random() instead.');
return Math.random();}),
        'randInt': ($__.fs.J$__v494107025_48_293 = function J$__v494107025_48(low, high) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
low = arguments[0], high = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return low + Math.floor(Math.random() * (high - low + 1));}),
        'randFloat': ($__.fs.J$__v494107025_50_294 = function J$__v494107025_50(low, high) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
low = arguments[0], high = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return low + Math.random() * (high - low);}),
        'randFloatSpread': ($__.fs.J$__v494107025_52_295 = function J$__v494107025_52(range) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
range = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return range * (0.5 - Math.random());}),
        'degToRad': ($__.fs.J$__v494107025_54_296 = function J$__v494107025_54(degrees) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
degrees = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return degrees * exports.Math.DEG2RAD;}),
        'radToDeg': ($__.fs.J$__v494107025_56_297 = function J$__v494107025_56(radians) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
radians = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return radians * exports.Math.RAD2DEG;}),
        'isPowerOfTwo': ($__.fs.J$__v494107025_58_298 = function J$__v494107025_58(value) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
value = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return (value & value - 1) === 0 && value !== 0;}),
        'nearestPowerOfTwo': ($__.fs.J$__v494107025_60_299 = function J$__v494107025_60(value) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
value = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return Math.pow(2, Math.round(Math.log(value) / Math.LN2));}),
        'nextPowerOfTwo': ($__.fs.J$__v494107025_62_300 = function J$__v494107025_62(value) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
value = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
value--;
value |= value >> 1;
value |= value >> 2;
value |= value >> 4;
value |= value >> 8;
value |= value >> 16;
value++;
return value;})
    };
    Vector2.prototype = (vvv_tmp0 = {
        'constructor': Vector2,
        'isVector2': true,
        'set': ($__.fs.J$__v494107025_73_301 = function J$__v494107025_73(x, y) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
x = arguments[0], y = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.x = x;
this.y = y;
return this;}),
        'setScalar': ($__.fs.J$__v494107025_75_302 = function J$__v494107025_75(scalar) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
scalar = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.x = scalar;
this.y = scalar;
return this;}),
        'setX': ($__.fs.J$__v494107025_77_303 = function J$__v494107025_77(x) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
x = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.x = x;
return this;}),
        'setY': ($__.fs.J$__v494107025_79_304 = function J$__v494107025_79(y) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
y = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.y = y;
return this;}),
        'setComponent': ($__.fs.J$__v494107025_81_305 = function J$__v494107025_81(index, value) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
index = arguments[0], value = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
switch (index) {
case 0:
    this.x = value;
    break;
case 1:
    this.y = value;
    break;
default:
    throw new Error('index is out of range: ' + index);
}}),
        'getComponent': ($__.fs.J$__v494107025_83_306 = function J$__v494107025_83(index) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
index = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
switch (index) {
case 0:
    return this.x;
case 1:
    return this.y;
default:
    throw new Error('index is out of range: ' + index);
}}),
        'clone': ($__.fs.J$__v494107025_85_307 = function J$__v494107025_85() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    return new $__.fs.Vector2_6((this.x, 1), (this.y, 1), 7, true, $__.uid);
case 1:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 1);
    return new $__.fs.Vector2_6((this.x, 1), (this.y, 1), 8, true, $__.uid);
case 2:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 2);
    return new $__.fs.Vector2_6((this.x, 1), (this.y, 1), 9, true, $__.uid);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return new this.constructor(this.x, this.y);}),
        'copy': ($__.fs.J$__v494107025_87_308 = function J$__v494107025_87(v) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
v = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.x = v.x;
this.y = v.y;
return this;}),
        'add': ($__.fs.J$__v494107025_89_309 = function J$__v494107025_89(v, w) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
v = arguments[0], w = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (w !== undefined) {
    console.warn('THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');
    return this.addVectors(v, w);
}
this.x += v.x;
this.y += v.y;
return this;}),
        'addScalar': ($__.fs.J$__v494107025_91_310 = function J$__v494107025_91(s) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
s = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.x += s;
this.y += s;
return this;}),
        'addVectors': ($__.fs.J$__v494107025_93_311 = function J$__v494107025_93(a, b) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
a = arguments[0], b = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.x = a.x + b.x;
this.y = a.y + b.y;
return this;}),
        'addScaledVector': ($__.fs.J$__v494107025_95_312 = function J$__v494107025_95(v, s) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
v = arguments[0], s = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.x += v.x * s;
this.y += v.y * s;
return this;}),
        'sub': ($__.fs.J$__v494107025_97_313 = function J$__v494107025_97(v, w) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
v = arguments[0], w = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (w !== undefined) {
    console.warn('THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');
    return this.subVectors(v, w);
}
this.x -= v.x;
this.y -= v.y;
return this;}),
        'subScalar': ($__.fs.J$__v494107025_99_314 = function J$__v494107025_99(s) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
s = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.x -= s;
this.y -= s;
return this;}),
        'subVectors': ($__.fs.J$__v494107025_101_315 = function J$__v494107025_101(a, b) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
a = arguments[0], b = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.x = a.x - b.x;
this.y = a.y - b.y;
return this;}),
        'multiply': ($__.fs.J$__v494107025_103_316 = function J$__v494107025_103(v) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
v = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.x *= v.x;
this.y *= v.y;
return this;}),
        'multiplyScalar': ($__.fs.J$__v494107025_105_317 = function J$__v494107025_105(scalar) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
scalar = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (isFinite(scalar)) {
    this.x *= scalar;
    this.y *= scalar;
} else {
    this.x = 0;
    this.y = 0;
}
return this;}),
        'divide': ($__.fs.J$__v494107025_107_318 = function J$__v494107025_107(v) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
v = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.x /= v.x;
this.y /= v.y;
return this;}),
        'divideScalar': ($__.fs.J$__v494107025_109_319 = function J$__v494107025_109(scalar) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
scalar = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return this.multiplyScalar(1 / scalar);}),
        'min': ($__.fs.J$__v494107025_111_320 = function J$__v494107025_111(v) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
v = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.x = Math.min(this.x, v.x);
this.y = Math.min(this.y, v.y);
return this;}),
        'max': ($__.fs.J$__v494107025_113_321 = function J$__v494107025_113(v) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
v = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.x = Math.max(this.x, v.x);
this.y = Math.max(this.y, v.y);
return this;}),
        'clamp': ($__.fs.J$__v494107025_115_322 = function J$__v494107025_115(min, max) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
min = arguments[0], max = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.x = Math.max(min.x, Math.min(max.x, this.x));
this.y = Math.max(min.y, Math.min(max.y, this.y));
return this;}),
        'clampScalar': (($__.fs.J$__v494107025_118_323 = function J$__v494107025_118() {
var vvv_return, vvv_switch, min, max;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    return ($__.fs.clampScalar_324 = function clampScalar(minVal, maxVal) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
minVal = arguments[0], maxVal = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (min === undefined) {
    min = new Vector2();
    max = new Vector2();
}
min.set(minVal, minVal);
max.set(maxVal, maxVal);
return this.clamp(min, max);});
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return function clampScalar(minVal, maxVal) {
    if (min === undefined) {
        min = new Vector2();
        max = new Vector2();
    }
    min.set(minVal, minVal);
    max.set(maxVal, maxVal);
    return this.clamp(min, max);
};}), $__.fs.J$__v494107025_118_323)(0, true, $__.uid),
        'clampLength': ($__.fs.J$__v494107025_120_325 = function J$__v494107025_120(min, max) {
var vvv_return, vvv_switch, length;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
min = arguments[0], max = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
length = this.length();
return this.multiplyScalar(Math.max(min, Math.min(max, length)) / length);}),
        'floor': ($__.fs.J$__v494107025_122_326 = function J$__v494107025_122() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.x = Math.floor(this.x);
this.y = Math.floor(this.y);
return this;}),
        'ceil': ($__.fs.J$__v494107025_124_327 = function J$__v494107025_124() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.x = Math.ceil(this.x);
this.y = Math.ceil(this.y);
return this;}),
        'round': ($__.fs.J$__v494107025_126_328 = function J$__v494107025_126() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.x = Math.round(this.x);
this.y = Math.round(this.y);
return this;}),
        'roundToZero': ($__.fs.J$__v494107025_128_329 = function J$__v494107025_128() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
return this;}),
        'negate': ($__.fs.J$__v494107025_130_330 = function J$__v494107025_130() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.x = -this.x;
this.y = -this.y;
return this;}),
        'dot': ($__.fs.J$__v494107025_132_331 = function J$__v494107025_132(v) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
v = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return this.x * v.x + this.y * v.y;}),
        'lengthSq': ($__.fs.J$__v494107025_134_332 = function J$__v494107025_134() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return this.x * this.x + this.y * this.y;}),
        'length': ($__.fs.J$__v494107025_136_333 = function J$__v494107025_136() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return Math.sqrt(this.x * this.x + this.y * this.y);}),
        'lengthManhattan': ($__.fs.J$__v494107025_138_334 = function J$__v494107025_138() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return Math.abs(this.x) + Math.abs(this.y);}),
        'normalize': ($__.fs.J$__v494107025_140_335 = function J$__v494107025_140() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return this.divideScalar(this.length());}),
        'angle': ($__.fs.J$__v494107025_142_336 = function J$__v494107025_142() {
var vvv_return, vvv_switch, angle;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
angle = Math.atan2(this.y, this.x);
if (angle < 0)
    angle += 2 * Math.PI;
return angle;}),
        'distanceTo': ($__.fs.J$__v494107025_144_337 = function J$__v494107025_144(v) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
v = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return Math.sqrt(this.distanceToSquared(v));}),
        'distanceToSquared': ($__.fs.J$__v494107025_146_338 = function J$__v494107025_146(v) {
var vvv_return, vvv_switch, dx, dy;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
v = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
dx = this.x - v.x;
dy = this.y - v.y;
return dx * dx + dy * dy;}),
        'distanceToManhattan': ($__.fs.J$__v494107025_148_339 = function J$__v494107025_148(v) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
v = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return Math.abs(this.x - v.x) + Math.abs(this.y - v.y);}),
        'setLength': ($__.fs.J$__v494107025_150_340 = function J$__v494107025_150(length) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
length = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return this.multiplyScalar(length / this.length());}),
        'lerp': ($__.fs.J$__v494107025_152_341 = function J$__v494107025_152(v, alpha) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
v = arguments[0], alpha = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.x += (v.x - this.x) * alpha;
this.y += (v.y - this.y) * alpha;
return this;}),
        'lerpVectors': ($__.fs.J$__v494107025_154_342 = function J$__v494107025_154(v1, v2, alpha) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
v1 = arguments[0], v2 = arguments[1], alpha = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);}),
        'equals': ($__.fs.J$__v494107025_156_343 = function J$__v494107025_156(v) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
v = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return v.x === this.x && v.y === this.y;}),
        'fromArray': ($__.fs.J$__v494107025_158_344 = function J$__v494107025_158(array, offset) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
array = arguments[0], offset = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (offset === undefined)
    offset = 0;
this.x = array[offset];
this.y = array[offset + 1];
return this;}),
        'toArray': ($__.fs.J$__v494107025_160_345 = function J$__v494107025_160(array, offset) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
array = arguments[0], offset = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (array === undefined)
    array = [];
if (offset === undefined)
    offset = 0;
array[offset] = this.x;
array[offset + 1] = this.y;
return array;}),
        'fromAttribute': ($__.fs.J$__v494107025_162_346 = function J$__v494107025_162(attribute, index, offset) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
attribute = arguments[0], index = arguments[1], offset = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (offset === undefined)
    offset = 0;
index = index * attribute.itemSize + offset;
this.x = attribute.array[index];
this.y = attribute.array[index + 1];
return this;}),
        'rotateAround': ($__.fs.J$__v494107025_164_347 = function J$__v494107025_164(center, angle) {
var vvv_return, vvv_switch, c, s, x, y;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
center = arguments[0], angle = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
c = Math.cos(angle);
s = Math.sin(angle);
x = this.x - center.x;
y = this.y - center.y;
this.x = x * c - y * s + center.x;
this.y = x * s + y * c + center.y;
return this;}),
        get width() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return this.x;},
        set width(value) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
value = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.x = value;},
        get height() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return this.y;},
        set height(value) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
value = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.y = value;}
    }, $__.fs.width_348 = Object.getOwnPropertyDescriptor(vvv_tmp0, 'width').get, $__.fs.width_349 = Object.getOwnPropertyDescriptor(vvv_tmp0, 'width').set, $__.fs.height_350 = Object.getOwnPropertyDescriptor(vvv_tmp0, 'height').get, $__.fs.height_351 = Object.getOwnPropertyDescriptor(vvv_tmp0, 'height').set, $__.os.oid4 = vvv_tmp0);
    Texture.DEFAULT_IMAGE = undefined;
    Texture.DEFAULT_MAPPING = UVMapping;
    Texture.prototype = (vvv_tmp1 = {
        'constructor': Texture,
        'isTexture': true,
        'clone': ($__.fs.J$__v494107025_169_352 = function J$__v494107025_169() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return new this.constructor().copy(this);}),
        'copy': ($__.fs.J$__v494107025_171_353 = function J$__v494107025_171(source) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
source = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.image = source.image;
this.mipmaps = source.mipmaps.slice(0);
this.mapping = source.mapping;
this.wrapS = source.wrapS;
this.wrapT = source.wrapT;
this.magFilter = source.magFilter;
this.minFilter = source.minFilter;
this.anisotropy = source.anisotropy;
this.format = source.format;
this.type = source.type;
this.offset.copy(source.offset);
this.repeat.copy(source.repeat);
this.generateMipmaps = source.generateMipmaps;
this.premultiplyAlpha = source.premultiplyAlpha;
this.flipY = source.flipY;
this.unpackAlignment = source.unpackAlignment;
this.encoding = source.encoding;
return this;}),
        'toJSON': ($__.fs.J$__v494107025_174_354 = function J$__v494107025_174(meta) {
var vvv_return, vvv_switch, getDataURL, output, image;
getDataURL = function getDataURL(image) {
    var canvas;
    if (image.toDataURL !== undefined) {
        canvas = image;
    } else {
        canvas = document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');
        canvas.width = image.width;
        canvas.height = image.height;
        canvas.getContext('2d').drawImage(image, 0, 0, image.width, image.height);
    }
    if (canvas.width > 2048 || canvas.height > 2048) {
        return canvas.toDataURL('image/jpeg', 0.6);
    } else {
        return canvas.toDataURL('image/png');
    }
};
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
meta = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (meta.textures[this.uuid] !== undefined) {
    return meta.textures[this.uuid];
}
output = {
    metadata: {
        version: 4.4,
        type: 'Texture',
        generator: 'Texture.toJSON'
    },
    uuid: this.uuid,
    name: this.name,
    mapping: this.mapping,
    repeat: [
        this.repeat.x,
        this.repeat.y
    ],
    offset: [
        this.offset.x,
        this.offset.y
    ],
    wrap: [
        this.wrapS,
        this.wrapT
    ],
    minFilter: this.minFilter,
    magFilter: this.magFilter,
    anisotropy: this.anisotropy,
    flipY: this.flipY
};
if (this.image !== undefined) {
    image = this.image;
    if (image.uuid === undefined) {
        image.uuid = exports.Math.generateUUID();
    }
    if (meta.images[image.uuid] === undefined) {
        meta.images[image.uuid] = {
            uuid: image.uuid,
            url: getDataURL(image)
        };
    }
    output.image = image.uuid;
}
meta.textures[this.uuid] = output;
return output;}),
        'dispose': ($__.fs.J$__v494107025_176_355 = function J$__v494107025_176() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.dispatchEvent({
    type: 'dispose'
});}),
        'transformUv': ($__.fs.J$__v494107025_178_356 = function J$__v494107025_178(uv) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
uv = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (this.mapping !== UVMapping)
    return;
uv.multiply(this.repeat);
uv.add(this.offset);
if (uv.x < 0 || uv.x > 1) {
    switch (this.wrapS) {
    case RepeatWrapping:
        uv.x = uv.x - Math.floor(uv.x);
        break;
    case ClampToEdgeWrapping:
        uv.x = uv.x < 0 ? 0 : 1;
        break;
    case MirroredRepeatWrapping:
        if (Math.abs(Math.floor(uv.x) % 2) === 1) {
            uv.x = Math.ceil(uv.x) - uv.x;
        } else {
            uv.x = uv.x - Math.floor(uv.x);
        }
        break;
    }
}
if (uv.y < 0 || uv.y > 1) {
    switch (this.wrapT) {
    case RepeatWrapping:
        uv.y = uv.y - Math.floor(uv.y);
        break;
    case ClampToEdgeWrapping:
        uv.y = uv.y < 0 ? 0 : 1;
        break;
    case MirroredRepeatWrapping:
        if (Math.abs(Math.floor(uv.y) % 2) === 1) {
            uv.y = Math.ceil(uv.y) - uv.y;
        } else {
            uv.y = uv.y - Math.floor(uv.y);
        }
        break;
    }
}
if (this.flipY) {
    uv.y = 1 - uv.y;
}}),
        set needsUpdate(value) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
value = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (value === true)
    this.version++;}
    }, $__.fs.needsUpdate_357 = Object.getOwnPropertyDescriptor(vvv_tmp1, 'needsUpdate').set, $__.os.oid5 = vvv_tmp1);
    Object['assign']((Texture.prototype, $__.os.oid5), TAJS_restrictToType(EventDispatcher.prototype, 'object'));
    count = 0;
    Matrix4.prototype = $__.os.oid6 = {
        'constructor': Matrix4,
        'isMatrix4': true,
        'set': ($__.fs.J$__v494107025_182_358 = function J$__v494107025_182(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
var vvv_return, vvv_switch, te;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
n11 = arguments[0], n12 = arguments[1], n13 = arguments[2], n14 = arguments[3], n21 = arguments[4], n22 = arguments[5], n23 = arguments[6], n24 = arguments[7], n31 = arguments[8], n32 = arguments[9], n33 = arguments[10], n34 = arguments[11], n41 = arguments[12], n42 = arguments[13], n43 = arguments[14], n44 = arguments[15];
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    te = TAJS_restrictToType(this.elements, 'object');
    te[0, 0] = n11;
    te[4, 4] = n12;
    te[8, 8] = n13;
    te[12, 12] = n14;
    te[1, 1] = n21;
    te[5, 5] = n22;
    te[9, 9] = n23;
    te[13, 13] = n24;
    te[2, 2] = n31;
    te[6, 6] = n32;
    te[10, 10] = n33;
    te[14, 14] = n34;
    te[3, 3] = n41;
    te[7, 7] = n42;
    te[11, 11] = n43;
    te[15, 15] = n44;
    return this;
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
te = this.elements;
te[0] = n11;
te[4] = n12;
te[8] = n13;
te[12] = n14;
te[1] = n21;
te[5] = n22;
te[9] = n23;
te[13] = n24;
te[2] = n31;
te[6] = n32;
te[10] = n33;
te[14] = n34;
te[3] = n41;
te[7] = n42;
te[11] = n43;
te[15] = n44;
return this;}),
        'identity': ($__.fs.J$__v494107025_184_359 = function J$__v494107025_184() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
return this;}),
        'clone': ($__.fs.J$__v494107025_186_360 = function J$__v494107025_186() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return new Matrix4().fromArray(this.elements);}),
        'copy': ($__.fs.J$__v494107025_188_361 = function J$__v494107025_188(m) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
m = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.elements.set(m.elements);
return this;}),
        'copyPosition': ($__.fs.J$__v494107025_190_362 = function J$__v494107025_190(m) {
var vvv_return, vvv_switch, te, me;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
m = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
te = this.elements;
me = m.elements;
te[12] = me[12];
te[13] = me[13];
te[14] = me[14];
return this;}),
        'extractBasis': ($__.fs.J$__v494107025_192_363 = function J$__v494107025_192(xAxis, yAxis, zAxis) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
xAxis = arguments[0], yAxis = arguments[1], zAxis = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
xAxis.setFromMatrixColumn(this, 0);
yAxis.setFromMatrixColumn(this, 1);
zAxis.setFromMatrixColumn(this, 2);
return this;}),
        'makeBasis': ($__.fs.J$__v494107025_194_364 = function J$__v494107025_194(xAxis, yAxis, zAxis) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
xAxis = arguments[0], yAxis = arguments[1], zAxis = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.set(xAxis.x, yAxis.x, zAxis.x, 0, xAxis.y, yAxis.y, zAxis.y, 0, xAxis.z, yAxis.z, zAxis.z, 0, 0, 0, 0, 1);
return this;}),
        'extractRotation': (($__.fs.J$__v494107025_197_365 = function J$__v494107025_197() {
var vvv_return, vvv_switch, v1;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    return ($__.fs.extractRotation_366 = function extractRotation(m) {
var vvv_return, vvv_switch, te, me, scaleX, scaleY, scaleZ;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
m = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (v1 === undefined)
    v1 = new Vector3();
te = this.elements;
me = m.elements;
scaleX = 1 / v1.setFromMatrixColumn(m, 0).length();
scaleY = 1 / v1.setFromMatrixColumn(m, 1).length();
scaleZ = 1 / v1.setFromMatrixColumn(m, 2).length();
te[0] = me[0] * scaleX;
te[1] = me[1] * scaleX;
te[2] = me[2] * scaleX;
te[4] = me[4] * scaleY;
te[5] = me[5] * scaleY;
te[6] = me[6] * scaleY;
te[8] = me[8] * scaleZ;
te[9] = me[9] * scaleZ;
te[10] = me[10] * scaleZ;
return this;});
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return function extractRotation(m) {
    if (v1 === undefined)
        v1 = new Vector3();
    var te = this.elements;
    var me = m.elements;
    var scaleX = 1 / v1.setFromMatrixColumn(m, 0).length();
    var scaleY = 1 / v1.setFromMatrixColumn(m, 1).length();
    var scaleZ = 1 / v1.setFromMatrixColumn(m, 2).length();
    te[0] = me[0] * scaleX;
    te[1] = me[1] * scaleX;
    te[2] = me[2] * scaleX;
    te[4] = me[4] * scaleY;
    te[5] = me[5] * scaleY;
    te[6] = me[6] * scaleY;
    te[8] = me[8] * scaleZ;
    te[9] = me[9] * scaleZ;
    te[10] = me[10] * scaleZ;
    return this;
};}), $__.fs.J$__v494107025_197_365)(0, true, $__.uid),
        'makeRotationFromEuler': ($__.fs.J$__v494107025_199_367 = function J$__v494107025_199(euler) {
var vvv_return, vvv_switch, te, x, y, z, a, b, c, d, e, f, ae, af, be, bf, ce, cf, de, df, ac, ad, bc, bd;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
euler = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if ((euler && euler.isEuler) === false) {
    console.error('THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.');
}
te = this.elements;
x = euler.x;
y = euler.y;
z = euler.z;
a = Math.cos(x);
b = Math.sin(x);
c = Math.cos(y);
d = Math.sin(y);
e = Math.cos(z);
f = Math.sin(z);
if (euler.order === 'XYZ') {
    ae = a * e;
    af = a * f;
    be = b * e;
    bf = b * f;
    te[0] = c * e;
    te[4] = -c * f;
    te[8] = d;
    te[1] = af + be * d;
    te[5] = ae - bf * d;
    te[9] = -b * c;
    te[2] = bf - ae * d;
    te[6] = be + af * d;
    te[10] = a * c;
} else if (euler.order === 'YXZ') {
    ce = c * e;
    cf = c * f;
    de = d * e;
    df = d * f;
    te[0] = ce + df * b;
    te[4] = de * b - cf;
    te[8] = a * d;
    te[1] = a * f;
    te[5] = a * e;
    te[9] = -b;
    te[2] = cf * b - de;
    te[6] = df + ce * b;
    te[10] = a * c;
} else if (euler.order === 'ZXY') {
    ce = c * e;
    cf = c * f;
    de = d * e;
    df = d * f;
    te[0] = ce - df * b;
    te[4] = -a * f;
    te[8] = de + cf * b;
    te[1] = cf + de * b;
    te[5] = a * e;
    te[9] = df - ce * b;
    te[2] = -a * d;
    te[6] = b;
    te[10] = a * c;
} else if (euler.order === 'ZYX') {
    ae = a * e;
    af = a * f;
    be = b * e;
    bf = b * f;
    te[0] = c * e;
    te[4] = be * d - af;
    te[8] = ae * d + bf;
    te[1] = c * f;
    te[5] = bf * d + ae;
    te[9] = af * d - be;
    te[2] = -d;
    te[6] = b * c;
    te[10] = a * c;
} else if (euler.order === 'YZX') {
    ac = a * c;
    ad = a * d;
    bc = b * c;
    bd = b * d;
    te[0] = c * e;
    te[4] = bd - ac * f;
    te[8] = bc * f + ad;
    te[1] = f;
    te[5] = a * e;
    te[9] = -b * e;
    te[2] = -d * e;
    te[6] = ad * f + bc;
    te[10] = ac - bd * f;
} else if (euler.order === 'XZY') {
    ac = a * c;
    ad = a * d;
    bc = b * c;
    bd = b * d;
    te[0] = c * e;
    te[4] = -f;
    te[8] = d * e;
    te[1] = ac * f + bd;
    te[5] = a * e;
    te[9] = ad * f - bc;
    te[2] = bc * f - ad;
    te[6] = b * e;
    te[10] = bd * f + ac;
}
te[3] = 0;
te[7] = 0;
te[11] = 0;
te[12] = 0;
te[13] = 0;
te[14] = 0;
te[15] = 1;
return this;}),
        'makeRotationFromQuaternion': ($__.fs.J$__v494107025_201_368 = function J$__v494107025_201(q) {
var vvv_return, vvv_switch, te, x, y, z, w, x2, y2, z2, xx, xy, xz, yy, yz, zz, wx, wy, wz;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
q = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
te = this.elements;
x = q.x;
y = q.y;
z = q.z;
w = q.w;
x2 = x + x;
y2 = y + y;
z2 = z + z;
xx = x * x2;
xy = x * y2;
xz = x * z2;
yy = y * y2;
yz = y * z2;
zz = z * z2;
wx = w * x2;
wy = w * y2;
wz = w * z2;
te[0] = 1 - (yy + zz);
te[4] = xy - wz;
te[8] = xz + wy;
te[1] = xy + wz;
te[5] = 1 - (xx + zz);
te[9] = yz - wx;
te[2] = xz - wy;
te[6] = yz + wx;
te[10] = 1 - (xx + yy);
te[3] = 0;
te[7] = 0;
te[11] = 0;
te[12] = 0;
te[13] = 0;
te[14] = 0;
te[15] = 1;
return this;}),
        'lookAt': (($__.fs.J$__v494107025_204_369 = function J$__v494107025_204() {
var vvv_return, vvv_switch, x, y, z;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    return ($__.fs.lookAt_370 = function lookAt(eye, target, up) {
var vvv_return, vvv_switch, te;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
eye = arguments[0], target = arguments[1], up = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (x === undefined) {
    x = new Vector3();
    y = new Vector3();
    z = new Vector3();
}
te = this.elements;
z.subVectors(eye, target).normalize();
if (z.lengthSq() === 0) {
    z.z = 1;
}
x.crossVectors(up, z).normalize();
if (x.lengthSq() === 0) {
    z.z += 0.0001;
    x.crossVectors(up, z).normalize();
}
y.crossVectors(z, x);
te[0] = x.x;
te[4] = y.x;
te[8] = z.x;
te[1] = x.y;
te[5] = y.y;
te[9] = z.y;
te[2] = x.z;
te[6] = y.z;
te[10] = z.z;
return this;});
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return function lookAt(eye, target, up) {
    if (x === undefined) {
        x = new Vector3();
        y = new Vector3();
        z = new Vector3();
    }
    var te = this.elements;
    z.subVectors(eye, target).normalize();
    if (z.lengthSq() === 0) {
        z.z = 1;
    }
    x.crossVectors(up, z).normalize();
    if (x.lengthSq() === 0) {
        z.z += 0.0001;
        x.crossVectors(up, z).normalize();
    }
    y.crossVectors(z, x);
    te[0] = x.x;
    te[4] = y.x;
    te[8] = z.x;
    te[1] = x.y;
    te[5] = y.y;
    te[9] = z.y;
    te[2] = x.z;
    te[6] = y.z;
    te[10] = z.z;
    return this;
};}), $__.fs.J$__v494107025_204_369)(0, true, $__.uid),
        'multiply': ($__.fs.J$__v494107025_206_371 = function J$__v494107025_206(m, n) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
m = arguments[0], n = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (n !== undefined) {
    console.warn('THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.');
    return this.multiplyMatrices(m, n);
}
return this.multiplyMatrices(this, m);}),
        'premultiply': ($__.fs.J$__v494107025_208_372 = function J$__v494107025_208(m) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
m = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return this.multiplyMatrices(m, this);}),
        'multiplyMatrices': ($__.fs.J$__v494107025_210_373 = function J$__v494107025_210(a, b) {
var vvv_return, vvv_switch, ae, be, te, a11, a12, a13, a14, a21, a22, a23, a24, a31, a32, a33, a34, a41, a42, a43, a44, b11, b12, b13, b14, b21, b22, b23, b24, b31, b32, b33, b34, b41, b42, b43, b44;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
a = arguments[0], b = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
ae = a.elements;
be = b.elements;
te = this.elements;
a11 = ae[0];
a12 = ae[4];
a13 = ae[8];
a14 = ae[12];
a21 = ae[1];
a22 = ae[5];
a23 = ae[9];
a24 = ae[13];
a31 = ae[2];
a32 = ae[6];
a33 = ae[10];
a34 = ae[14];
a41 = ae[3];
a42 = ae[7];
a43 = ae[11];
a44 = ae[15];
b11 = be[0];
b12 = be[4];
b13 = be[8];
b14 = be[12];
b21 = be[1];
b22 = be[5];
b23 = be[9];
b24 = be[13];
b31 = be[2];
b32 = be[6];
b33 = be[10];
b34 = be[14];
b41 = be[3];
b42 = be[7];
b43 = be[11];
b44 = be[15];
te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
return this;}),
        'multiplyToArray': ($__.fs.J$__v494107025_212_374 = function J$__v494107025_212(a, b, r) {
var vvv_return, vvv_switch, te;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
a = arguments[0], b = arguments[1], r = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
te = this.elements;
this.multiplyMatrices(a, b);
r[0] = te[0];
r[1] = te[1];
r[2] = te[2];
r[3] = te[3];
r[4] = te[4];
r[5] = te[5];
r[6] = te[6];
r[7] = te[7];
r[8] = te[8];
r[9] = te[9];
r[10] = te[10];
r[11] = te[11];
r[12] = te[12];
r[13] = te[13];
r[14] = te[14];
r[15] = te[15];
return this;}),
        'multiplyScalar': ($__.fs.J$__v494107025_214_375 = function J$__v494107025_214(s) {
var vvv_return, vvv_switch, te;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
s = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
te = this.elements;
te[0] *= s;
te[4] *= s;
te[8] *= s;
te[12] *= s;
te[1] *= s;
te[5] *= s;
te[9] *= s;
te[13] *= s;
te[2] *= s;
te[6] *= s;
te[10] *= s;
te[14] *= s;
te[3] *= s;
te[7] *= s;
te[11] *= s;
te[15] *= s;
return this;}),
        'applyToVector3Array': (($__.fs.J$__v494107025_217_376 = function J$__v494107025_217() {
var vvv_return, vvv_switch, v1;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    return ($__.fs.applyToVector3Array_377 = function applyToVector3Array(array, offset, length) {
var vvv_return, vvv_switch, vvv_tmp0, vvv_tmp1, vvv_tmp2, vvv_tmp3, vvv_tmp4, vvv_tmp5, vvv_tmp6, vvv_tmp7, vvv_tmp8, vvv_tmp9, vvv_tmp10, vvv_tmp11, vvv_tmp12, vvv_tmp13, vvv_tmp14, vvv_tmp15, vvv_tmp16, vvv_tmp17, vvv_tmp18, vvv_tmp19, vvv_tmp20, vvv_tmp21, vvv_tmp22, vvv_tmp23, vvv_tmp24, vvv_tmp25, vvv_tmp26, vvv_tmp27, vvv_tmp28, vvv_tmp29, vvv_tmp30, vvv_tmp31, vvv_tmp32, vvv_tmp33, vvv_tmp34, vvv_tmp35, vvv_tmp36, vvv_tmp37, vvv_tmp38, vvv_tmp39, vvv_tmp40, vvv_tmp41, vvv_tmp42, vvv_tmp43, vvv_tmp44, vvv_tmp45, vvv_tmp46, vvv_tmp47, vvv_tmp48, vvv_tmp49, vvv_tmp50, vvv_tmp51, vvv_tmp52, vvv_tmp53, vvv_tmp54, vvv_tmp55, vvv_tmp56, vvv_tmp57, vvv_tmp58, vvv_tmp59, vvv_tmp60, vvv_tmp61, vvv_tmp62, vvv_tmp63, vvv_tmp64, vvv_tmp65, vvv_tmp66, vvv_tmp67, vvv_tmp68, i, j;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
array = arguments[0], offset = arguments[1], length = arguments[2];
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    v1 === undefined;
    v1 = new (Vector3, $__.fs.Vector3_11)(102, true, $__.uid);
    offset === undefined;
    offset = 0;
    length === undefined;
    length = (array.length, 69);
    i = 0;
    j = offset;
    i < length;
    vvv_tmp0 = v1, 'fromArray', $__.fs.J$__v494107025_466_506.call(vvv_tmp0, array, j, 0, true, $__.uid);
    vvv_tmp1 = v1, 'applyMatrix4', $__.fs.J$__v494107025_381_461.call(vvv_tmp1, this, 0, true, $__.uid);
    vvv_tmp2 = v1, 'toArray', $__.fs.J$__v494107025_468_507.call(vvv_tmp2, array, j, 0, true, $__.uid);
    i = i + 3, j = j + 3;
    i < length;
    vvv_tmp3 = v1, 'fromArray', $__.fs.J$__v494107025_466_506.call(vvv_tmp3, array, j, 1, true, $__.uid);
    vvv_tmp4 = v1, 'applyMatrix4', $__.fs.J$__v494107025_381_461.call(vvv_tmp4, this, 1, true, $__.uid);
    vvv_tmp5 = v1, 'toArray', $__.fs.J$__v494107025_468_507.call(vvv_tmp5, array, j, 1, true, $__.uid);
    i = i + 3, j = j + 3;
    i < length;
    vvv_tmp6 = v1, 'fromArray', $__.fs.J$__v494107025_466_506.call(vvv_tmp6, array, j, 2, true, $__.uid);
    vvv_tmp7 = v1, 'applyMatrix4', $__.fs.J$__v494107025_381_461.call(vvv_tmp7, this, 2, true, $__.uid);
    vvv_tmp8 = v1, 'toArray', $__.fs.J$__v494107025_468_507.call(vvv_tmp8, array, j, 2, true, $__.uid);
    i = i + 3, j = j + 3;
    i < length;
    vvv_tmp9 = v1, 'fromArray', $__.fs.J$__v494107025_466_506.call(vvv_tmp9, array, j, 3, true, $__.uid);
    vvv_tmp10 = v1, 'applyMatrix4', $__.fs.J$__v494107025_381_461.call(vvv_tmp10, this, 3, true, $__.uid);
    vvv_tmp11 = v1, 'toArray', $__.fs.J$__v494107025_468_507.call(vvv_tmp11, array, j, 3, true, $__.uid);
    i = i + 3, j = j + 3;
    i < length;
    vvv_tmp12 = v1, 'fromArray', $__.fs.J$__v494107025_466_506.call(vvv_tmp12, array, j, 4, true, $__.uid);
    vvv_tmp13 = v1, 'applyMatrix4', $__.fs.J$__v494107025_381_461.call(vvv_tmp13, this, 4, true, $__.uid);
    vvv_tmp14 = v1, 'toArray', $__.fs.J$__v494107025_468_507.call(vvv_tmp14, array, j, 4, true, $__.uid);
    i = i + 3, j = j + 3;
    i < length;
    vvv_tmp15 = v1, 'fromArray', $__.fs.J$__v494107025_466_506.call(vvv_tmp15, array, j, 5, true, $__.uid);
    vvv_tmp16 = v1, 'applyMatrix4', $__.fs.J$__v494107025_381_461.call(vvv_tmp16, this, 5, true, $__.uid);
    vvv_tmp17 = v1, 'toArray', $__.fs.J$__v494107025_468_507.call(vvv_tmp17, array, j, 5, true, $__.uid);
    i = i + 3, j = j + 3;
    i < length;
    vvv_tmp18 = v1, 'fromArray', $__.fs.J$__v494107025_466_506.call(vvv_tmp18, array, j, 6, true, $__.uid);
    vvv_tmp19 = v1, 'applyMatrix4', $__.fs.J$__v494107025_381_461.call(vvv_tmp19, this, 6, true, $__.uid);
    vvv_tmp20 = v1, 'toArray', $__.fs.J$__v494107025_468_507.call(vvv_tmp20, array, j, 6, true, $__.uid);
    i = i + 3, j = j + 3;
    i < length;
    vvv_tmp21 = v1, 'fromArray', $__.fs.J$__v494107025_466_506.call(vvv_tmp21, array, j, 7, true, $__.uid);
    vvv_tmp22 = v1, 'applyMatrix4', $__.fs.J$__v494107025_381_461.call(vvv_tmp22, this, 7, true, $__.uid);
    vvv_tmp23 = v1, 'toArray', $__.fs.J$__v494107025_468_507.call(vvv_tmp23, array, j, 7, true, $__.uid);
    i = i + 3, j = j + 3;
    i < length;
    vvv_tmp24 = v1, 'fromArray', $__.fs.J$__v494107025_466_506.call(vvv_tmp24, array, j, 8, true, $__.uid);
    vvv_tmp25 = v1, 'applyMatrix4', $__.fs.J$__v494107025_381_461.call(vvv_tmp25, this, 8, true, $__.uid);
    vvv_tmp26 = v1, 'toArray', $__.fs.J$__v494107025_468_507.call(vvv_tmp26, array, j, 8, true, $__.uid);
    i = i + 3, j = j + 3;
    i < length;
    vvv_tmp27 = v1, 'fromArray', $__.fs.J$__v494107025_466_506.call(vvv_tmp27, array, j, 9, true, $__.uid);
    vvv_tmp28 = v1, 'applyMatrix4', $__.fs.J$__v494107025_381_461.call(vvv_tmp28, this, 9, true, $__.uid);
    vvv_tmp29 = v1, 'toArray', $__.fs.J$__v494107025_468_507.call(vvv_tmp29, array, j, 9, true, $__.uid);
    i = i + 3, j = j + 3;
    i < length;
    vvv_tmp30 = v1, 'fromArray', $__.fs.J$__v494107025_466_506.call(vvv_tmp30, array, j, 10, true, $__.uid);
    vvv_tmp31 = v1, 'applyMatrix4', $__.fs.J$__v494107025_381_461.call(vvv_tmp31, this, 10, true, $__.uid);
    vvv_tmp32 = v1, 'toArray', $__.fs.J$__v494107025_468_507.call(vvv_tmp32, array, j, 10, true, $__.uid);
    i = i + 3, j = j + 3;
    i < length;
    vvv_tmp33 = v1, 'fromArray', $__.fs.J$__v494107025_466_506.call(vvv_tmp33, array, j, 11, true, $__.uid);
    vvv_tmp34 = v1, 'applyMatrix4', $__.fs.J$__v494107025_381_461.call(vvv_tmp34, this, 11, true, $__.uid);
    vvv_tmp35 = v1, 'toArray', $__.fs.J$__v494107025_468_507.call(vvv_tmp35, array, j, 11, true, $__.uid);
    i = i + 3, j = j + 3;
    i < length;
    vvv_tmp36 = v1, 'fromArray', $__.fs.J$__v494107025_466_506.call(vvv_tmp36, array, j, 12, true, $__.uid);
    vvv_tmp37 = v1, 'applyMatrix4', $__.fs.J$__v494107025_381_461.call(vvv_tmp37, this, 12, true, $__.uid);
    vvv_tmp38 = v1, 'toArray', $__.fs.J$__v494107025_468_507.call(vvv_tmp38, array, j, 12, true, $__.uid);
    i = i + 3, j = j + 3;
    i < length;
    vvv_tmp39 = v1, 'fromArray', $__.fs.J$__v494107025_466_506.call(vvv_tmp39, array, j, 13, true, $__.uid);
    vvv_tmp40 = v1, 'applyMatrix4', $__.fs.J$__v494107025_381_461.call(vvv_tmp40, this, 13, true, $__.uid);
    vvv_tmp41 = v1, 'toArray', $__.fs.J$__v494107025_468_507.call(vvv_tmp41, array, j, 13, true, $__.uid);
    i = i + 3, j = j + 3;
    i < length;
    vvv_tmp42 = v1, 'fromArray', $__.fs.J$__v494107025_466_506.call(vvv_tmp42, array, j, 14, true, $__.uid);
    vvv_tmp43 = v1, 'applyMatrix4', $__.fs.J$__v494107025_381_461.call(vvv_tmp43, this, 14, true, $__.uid);
    vvv_tmp44 = v1, 'toArray', $__.fs.J$__v494107025_468_507.call(vvv_tmp44, array, j, 14, true, $__.uid);
    i = i + 3, j = j + 3;
    i < length;
    vvv_tmp45 = v1, 'fromArray', $__.fs.J$__v494107025_466_506.call(vvv_tmp45, array, j, 15, true, $__.uid);
    vvv_tmp46 = v1, 'applyMatrix4', $__.fs.J$__v494107025_381_461.call(vvv_tmp46, this, 15, true, $__.uid);
    vvv_tmp47 = v1, 'toArray', $__.fs.J$__v494107025_468_507.call(vvv_tmp47, array, j, 15, true, $__.uid);
    i = i + 3, j = j + 3;
    i < length;
    vvv_tmp48 = v1, 'fromArray', $__.fs.J$__v494107025_466_506.call(vvv_tmp48, array, j, 16, true, $__.uid);
    vvv_tmp49 = v1, 'applyMatrix4', $__.fs.J$__v494107025_381_461.call(vvv_tmp49, this, 16, true, $__.uid);
    vvv_tmp50 = v1, 'toArray', $__.fs.J$__v494107025_468_507.call(vvv_tmp50, array, j, 16, true, $__.uid);
    i = i + 3, j = j + 3;
    i < length;
    vvv_tmp51 = v1, 'fromArray', $__.fs.J$__v494107025_466_506.call(vvv_tmp51, array, j, 17, true, $__.uid);
    vvv_tmp52 = v1, 'applyMatrix4', $__.fs.J$__v494107025_381_461.call(vvv_tmp52, this, 17, true, $__.uid);
    vvv_tmp53 = v1, 'toArray', $__.fs.J$__v494107025_468_507.call(vvv_tmp53, array, j, 17, true, $__.uid);
    i = i + 3, j = j + 3;
    i < length;
    vvv_tmp54 = v1, 'fromArray', $__.fs.J$__v494107025_466_506.call(vvv_tmp54, array, j, 18, true, $__.uid);
    vvv_tmp55 = v1, 'applyMatrix4', $__.fs.J$__v494107025_381_461.call(vvv_tmp55, this, 18, true, $__.uid);
    vvv_tmp56 = v1, 'toArray', $__.fs.J$__v494107025_468_507.call(vvv_tmp56, array, j, 18, true, $__.uid);
    i = i + 3, j = j + 3;
    i < length;
    vvv_tmp57 = v1, 'fromArray', $__.fs.J$__v494107025_466_506.call(vvv_tmp57, array, j, 19, true, $__.uid);
    vvv_tmp58 = v1, 'applyMatrix4', $__.fs.J$__v494107025_381_461.call(vvv_tmp58, this, 19, true, $__.uid);
    vvv_tmp59 = v1, 'toArray', $__.fs.J$__v494107025_468_507.call(vvv_tmp59, array, j, 19, true, $__.uid);
    i = i + 3, j = j + 3;
    i < length;
    vvv_tmp60 = v1, 'fromArray', $__.fs.J$__v494107025_466_506.call(vvv_tmp60, array, j, 20, true, $__.uid);
    vvv_tmp61 = v1, 'applyMatrix4', $__.fs.J$__v494107025_381_461.call(vvv_tmp61, this, 20, true, $__.uid);
    vvv_tmp62 = v1, 'toArray', $__.fs.J$__v494107025_468_507.call(vvv_tmp62, array, j, 20, true, $__.uid);
    i = i + 3, j = j + 3;
    i < length;
    vvv_tmp63 = v1, 'fromArray', $__.fs.J$__v494107025_466_506.call(vvv_tmp63, array, j, 21, true, $__.uid);
    vvv_tmp64 = v1, 'applyMatrix4', $__.fs.J$__v494107025_381_461.call(vvv_tmp64, this, 21, true, $__.uid);
    vvv_tmp65 = v1, 'toArray', $__.fs.J$__v494107025_468_507.call(vvv_tmp65, array, j, 21, true, $__.uid);
    i = i + 3, j = j + 3;
    i < length;
    vvv_tmp66 = v1, 'fromArray', $__.fs.J$__v494107025_466_506.call(vvv_tmp66, array, j, 22, true, $__.uid);
    vvv_tmp67 = v1, 'applyMatrix4', $__.fs.J$__v494107025_381_461.call(vvv_tmp67, this, 22, true, $__.uid);
    vvv_tmp68 = v1, 'toArray', $__.fs.J$__v494107025_468_507.call(vvv_tmp68, array, j, 22, true, $__.uid);
    i = i + 3, j = j + 3;
    i < length;
    return array;
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (v1 === undefined)
    v1 = new Vector3();
if (offset === undefined)
    offset = 0;
if (length === undefined)
    length = array.length;
for (var i = 0, j = offset; i < length; i += 3, j += 3) {
    v1.fromArray(array, j);
    v1.applyMatrix4(this);
    v1.toArray(array, j);
}
return array;});
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return function applyToVector3Array(array, offset, length) {
    if (v1 === undefined)
        v1 = new Vector3();
    if (offset === undefined)
        offset = 0;
    if (length === undefined)
        length = array.length;
    for (var i = 0, j = offset; i < length; i += 3, j += 3) {
        v1.fromArray(array, j);
        v1.applyMatrix4(this);
        v1.toArray(array, j);
    }
    return array;
};}), $__.fs.J$__v494107025_217_376)(0, true, $__.uid),
        'applyToBuffer': (($__.fs.J$__v494107025_220_378 = function J$__v494107025_220() {
var vvv_return, vvv_switch, v1;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    return ($__.fs.applyToBuffer_379 = function applyToBuffer(buffer, offset, length) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
buffer = arguments[0], offset = arguments[1], length = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (v1 === undefined)
    v1 = new Vector3();
if (offset === undefined)
    offset = 0;
if (length === undefined)
    length = buffer.length / buffer.itemSize;
for (var i = 0, j = offset; i < length; i++, j++) {
    v1.x = buffer.getX(j);
    v1.y = buffer.getY(j);
    v1.z = buffer.getZ(j);
    v1.applyMatrix4(this);
    buffer.setXYZ(v1.x, v1.y, v1.z);
}
return buffer;});
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return function applyToBuffer(buffer, offset, length) {
    if (v1 === undefined)
        v1 = new Vector3();
    if (offset === undefined)
        offset = 0;
    if (length === undefined)
        length = buffer.length / buffer.itemSize;
    for (var i = 0, j = offset; i < length; i++, j++) {
        v1.x = buffer.getX(j);
        v1.y = buffer.getY(j);
        v1.z = buffer.getZ(j);
        v1.applyMatrix4(this);
        buffer.setXYZ(v1.x, v1.y, v1.z);
    }
    return buffer;
};}), $__.fs.J$__v494107025_220_378)(0, true, $__.uid),
        'determinant': ($__.fs.J$__v494107025_222_380 = function J$__v494107025_222() {
var vvv_return, vvv_switch, te, n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
te = this.elements;
n11 = te[0];
n12 = te[4];
n13 = te[8];
n14 = te[12];
n21 = te[1];
n22 = te[5];
n23 = te[9];
n24 = te[13];
n31 = te[2];
n32 = te[6];
n33 = te[10];
n34 = te[14];
n41 = te[3];
n42 = te[7];
n43 = te[11];
n44 = te[15];
return n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31);}),
        'transpose': ($__.fs.J$__v494107025_224_381 = function J$__v494107025_224() {
var vvv_return, vvv_switch, te, tmp;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
te = this.elements;
tmp = te[1];
te[1] = te[4];
te[4] = tmp;
tmp = te[2];
te[2] = te[8];
te[8] = tmp;
tmp = te[6];
te[6] = te[9];
te[9] = tmp;
tmp = te[3];
te[3] = te[12];
te[12] = tmp;
tmp = te[7];
te[7] = te[13];
te[13] = tmp;
tmp = te[11];
te[11] = te[14];
te[14] = tmp;
return this;}),
        'flattenToArrayOffset': ($__.fs.J$__v494107025_226_382 = function J$__v494107025_226(array, offset) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
array = arguments[0], offset = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
console.warn('THREE.Matrix3: .flattenToArrayOffset is deprecated ' + '- just use .toArray instead.');
return this.toArray(array, offset);}),
        'getPosition': (($__.fs.J$__v494107025_229_383 = function J$__v494107025_229() {
var vvv_return, vvv_switch, v1;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    return ($__.fs.getPosition_384 = function getPosition() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (v1 === undefined)
    v1 = new Vector3();
console.warn('THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.');
return v1.setFromMatrixColumn(this, 3);});
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return function getPosition() {
    if (v1 === undefined)
        v1 = new Vector3();
    console.warn('THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.');
    return v1.setFromMatrixColumn(this, 3);
};}), $__.fs.J$__v494107025_229_383)(0, true, $__.uid),
        'setPosition': ($__.fs.J$__v494107025_231_385 = function J$__v494107025_231(v) {
var vvv_return, vvv_switch, te;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
v = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
te = this.elements;
te[12] = v.x;
te[13] = v.y;
te[14] = v.z;
return this;}),
        'getInverse': ($__.fs.J$__v494107025_233_386 = function J$__v494107025_233(m, throwOnDegenerate) {
var vvv_return, vvv_switch, te, me, n11, n21, n31, n41, n12, n22, n32, n42, n13, n23, n33, n43, n14, n24, n34, n44, t11, t12, t13, t14, det, msg, detInv;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
m = arguments[0], throwOnDegenerate = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
te = this.elements;
me = m.elements;
n11 = me[0];
n21 = me[1];
n31 = me[2];
n41 = me[3];
n12 = me[4];
n22 = me[5];
n32 = me[6];
n42 = me[7];
n13 = me[8];
n23 = me[9];
n33 = me[10];
n43 = me[11];
n14 = me[12];
n24 = me[13];
n34 = me[14];
n44 = me[15];
t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44;
t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44;
t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44;
t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
if (det === 0) {
    msg = 'THREE.Matrix4.getInverse(): can\'t invert matrix, determinant is 0';
    if (throwOnDegenerate === true) {
        throw new Error(msg);
    } else {
        console.warn(msg);
    }
    return this.identity();
}
detInv = 1 / det;
te[0] = t11 * detInv;
te[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;
te[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;
te[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;
te[4] = t12 * detInv;
te[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;
te[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;
te[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;
te[8] = t13 * detInv;
te[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;
te[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;
te[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;
te[12] = t14 * detInv;
te[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;
te[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;
te[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;
return this;}),
        'scale': ($__.fs.J$__v494107025_235_387 = function J$__v494107025_235(v) {
var vvv_return, vvv_switch, te, x, y, z;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
v = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
te = this.elements;
x = v.x;
y = v.y;
z = v.z;
te[0] *= x;
te[4] *= y;
te[8] *= z;
te[1] *= x;
te[5] *= y;
te[9] *= z;
te[2] *= x;
te[6] *= y;
te[10] *= z;
te[3] *= x;
te[7] *= y;
te[11] *= z;
return this;}),
        'getMaxScaleOnAxis': ($__.fs.J$__v494107025_237_388 = function J$__v494107025_237() {
var vvv_return, vvv_switch, te, scaleXSq, scaleYSq, scaleZSq;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
te = this.elements;
scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];
scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];
scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];
return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));}),
        'makeTranslation': ($__.fs.J$__v494107025_239_389 = function J$__v494107025_239(x, y, z) {
var vvv_return, vvv_switch, vvv_tmp0;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
x = arguments[0], y = arguments[1], z = arguments[2];
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    vvv_tmp0 = this, 'set', $__.fs.J$__v494107025_182_358.call(vvv_tmp0, 1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z, 0, 0, 0, 1, 0, true, $__.uid);
    return this;
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.set(1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z, 0, 0, 0, 1);
return this;}),
        'makeRotationX': ($__.fs.J$__v494107025_241_390 = function J$__v494107025_241(theta) {
var vvv_return, vvv_switch, c, s;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
theta = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
c = Math.cos(theta);
s = Math.sin(theta);
this.set(1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1);
return this;}),
        'makeRotationY': ($__.fs.J$__v494107025_243_391 = function J$__v494107025_243(theta) {
var vvv_return, vvv_switch, c, s;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
theta = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
c = Math.cos(theta);
s = Math.sin(theta);
this.set(c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1);
return this;}),
        'makeRotationZ': ($__.fs.J$__v494107025_245_392 = function J$__v494107025_245(theta) {
var vvv_return, vvv_switch, c, s;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
theta = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
c = Math.cos(theta);
s = Math.sin(theta);
this.set(c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
return this;}),
        'makeRotationAxis': ($__.fs.J$__v494107025_247_393 = function J$__v494107025_247(axis, angle) {
var vvv_return, vvv_switch, c, s, t, x, y, z, tx, ty;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
axis = arguments[0], angle = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
c = Math.cos(angle);
s = Math.sin(angle);
t = 1 - c;
x = axis.x;
y = axis.y;
z = axis.z;
tx = t * x;
ty = t * y;
this.set(tx * x + c, tx * y - s * z, tx * z + s * y, 0, tx * y + s * z, ty * y + c, ty * z - s * x, 0, tx * z - s * y, ty * z + s * x, t * z * z + c, 0, 0, 0, 0, 1);
return this;}),
        'makeScale': ($__.fs.J$__v494107025_249_394 = function J$__v494107025_249(x, y, z) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
x = arguments[0], y = arguments[1], z = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.set(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1);
return this;}),
        'compose': ($__.fs.J$__v494107025_251_395 = function J$__v494107025_251(position, quaternion, scale) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
position = arguments[0], quaternion = arguments[1], scale = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.makeRotationFromQuaternion(quaternion);
this.scale(scale);
this.setPosition(position);
return this;}),
        'decompose': (($__.fs.J$__v494107025_254_396 = function J$__v494107025_254() {
var vvv_return, vvv_switch, vector, matrix;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    return ($__.fs.decompose_397 = function decompose(position, quaternion, scale) {
var vvv_return, vvv_switch, te, sx, sy, sz, det, invSX, invSY, invSZ;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
position = arguments[0], quaternion = arguments[1], scale = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (vector === undefined) {
    vector = new Vector3();
    matrix = new Matrix4();
}
te = this.elements;
sx = vector.set(te[0], te[1], te[2]).length();
sy = vector.set(te[4], te[5], te[6]).length();
sz = vector.set(te[8], te[9], te[10]).length();
det = this.determinant();
if (det < 0) {
    sx = -sx;
}
position.x = te[12];
position.y = te[13];
position.z = te[14];
matrix.elements.set(this.elements);
invSX = 1 / sx;
invSY = 1 / sy;
invSZ = 1 / sz;
matrix.elements[0] *= invSX;
matrix.elements[1] *= invSX;
matrix.elements[2] *= invSX;
matrix.elements[4] *= invSY;
matrix.elements[5] *= invSY;
matrix.elements[6] *= invSY;
matrix.elements[8] *= invSZ;
matrix.elements[9] *= invSZ;
matrix.elements[10] *= invSZ;
quaternion.setFromRotationMatrix(matrix);
scale.x = sx;
scale.y = sy;
scale.z = sz;
return this;});
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return function decompose(position, quaternion, scale) {
    if (vector === undefined) {
        vector = new Vector3();
        matrix = new Matrix4();
    }
    var te = this.elements;
    var sx = vector.set(te[0], te[1], te[2]).length();
    var sy = vector.set(te[4], te[5], te[6]).length();
    var sz = vector.set(te[8], te[9], te[10]).length();
    var det = this.determinant();
    if (det < 0) {
        sx = -sx;
    }
    position.x = te[12];
    position.y = te[13];
    position.z = te[14];
    matrix.elements.set(this.elements);
    var invSX = 1 / sx;
    var invSY = 1 / sy;
    var invSZ = 1 / sz;
    matrix.elements[0] *= invSX;
    matrix.elements[1] *= invSX;
    matrix.elements[2] *= invSX;
    matrix.elements[4] *= invSY;
    matrix.elements[5] *= invSY;
    matrix.elements[6] *= invSY;
    matrix.elements[8] *= invSZ;
    matrix.elements[9] *= invSZ;
    matrix.elements[10] *= invSZ;
    quaternion.setFromRotationMatrix(matrix);
    scale.x = sx;
    scale.y = sy;
    scale.z = sz;
    return this;
};}), $__.fs.J$__v494107025_254_396)(0, true, $__.uid),
        'makeFrustum': ($__.fs.J$__v494107025_256_398 = function J$__v494107025_256(left, right, bottom, top, near, far) {
var vvv_return, vvv_switch, te, x, y, a, b, c, d;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
left = arguments[0], right = arguments[1], bottom = arguments[2], top = arguments[3], near = arguments[4], far = arguments[5];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
te = this.elements;
x = 2 * near / (right - left);
y = 2 * near / (top - bottom);
a = (right + left) / (right - left);
b = (top + bottom) / (top - bottom);
c = -(far + near) / (far - near);
d = -2 * far * near / (far - near);
te[0] = x;
te[4] = 0;
te[8] = a;
te[12] = 0;
te[1] = 0;
te[5] = y;
te[9] = b;
te[13] = 0;
te[2] = 0;
te[6] = 0;
te[10] = c;
te[14] = d;
te[3] = 0;
te[7] = 0;
te[11] = -1;
te[15] = 0;
return this;}),
        'makePerspective': ($__.fs.J$__v494107025_258_399 = function J$__v494107025_258(fov, aspect, near, far) {
var vvv_return, vvv_switch, ymax, ymin, xmin, xmax;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
fov = arguments[0], aspect = arguments[1], near = arguments[2], far = arguments[3];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
ymax = near * Math.tan(exports.Math.DEG2RAD * fov * 0.5);
ymin = -ymax;
xmin = ymin * aspect;
xmax = ymax * aspect;
return this.makeFrustum(xmin, xmax, ymin, ymax, near, far);}),
        'makeOrthographic': ($__.fs.J$__v494107025_260_400 = function J$__v494107025_260(left, right, top, bottom, near, far) {
var vvv_return, vvv_switch, te, w, h, p, x, y, z;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
left = arguments[0], right = arguments[1], top = arguments[2], bottom = arguments[3], near = arguments[4], far = arguments[5];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
te = this.elements;
w = 1 / (right - left);
h = 1 / (top - bottom);
p = 1 / (far - near);
x = (right + left) * w;
y = (top + bottom) * h;
z = (far + near) * p;
te[0] = 2 * w;
te[4] = 0;
te[8] = 0;
te[12] = -x;
te[1] = 0;
te[5] = 2 * h;
te[9] = 0;
te[13] = -y;
te[2] = 0;
te[6] = 0;
te[10] = -2 * p;
te[14] = -z;
te[3] = 0;
te[7] = 0;
te[11] = 0;
te[15] = 1;
return this;}),
        'equals': ($__.fs.J$__v494107025_262_401 = function J$__v494107025_262(matrix) {
var vvv_return, vvv_switch, te, me;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
matrix = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
te = this.elements;
me = matrix.elements;
for (var i = 0; i < 16; i++) {
    if (te[i] !== me[i])
        return false;
}
return true;}),
        'fromArray': ($__.fs.J$__v494107025_264_402 = function J$__v494107025_264(array) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
array = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.elements.set(array);
return this;}),
        'toArray': ($__.fs.J$__v494107025_266_403 = function J$__v494107025_266(array, offset) {
var vvv_return, vvv_switch, te;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
array = arguments[0], offset = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (array === undefined)
    array = [];
if (offset === undefined)
    offset = 0;
te = this.elements;
array[offset] = te[0];
array[offset + 1] = te[1];
array[offset + 2] = te[2];
array[offset + 3] = te[3];
array[offset + 4] = te[4];
array[offset + 5] = te[5];
array[offset + 6] = te[6];
array[offset + 7] = te[7];
array[offset + 8] = te[8];
array[offset + 9] = te[9];
array[offset + 10] = te[10];
array[offset + 11] = te[11];
array[offset + 12] = te[12];
array[offset + 13] = te[13];
array[offset + 14] = te[14];
array[offset + 15] = te[15];
return array;})
    };
    Quaternion.prototype = (vvv_tmp2 = {
        'constructor': Quaternion,
        'set': ($__.fs.J$__v494107025_285_404 = function J$__v494107025_285(x, y, z, w) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
x = arguments[0], y = arguments[1], z = arguments[2], w = arguments[3];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this._x = x;
this._y = y;
this._z = z;
this._w = w;
this.onChangeCallback();
return this;}),
        'clone': ($__.fs.J$__v494107025_287_405 = function J$__v494107025_287() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return new this.constructor(this._x, this._y, this._z, this._w);}),
        'copy': ($__.fs.J$__v494107025_289_406 = function J$__v494107025_289(quaternion) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
quaternion = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this._x = quaternion.x;
this._y = quaternion.y;
this._z = quaternion.z;
this._w = quaternion.w;
this.onChangeCallback();
return this;}),
        'setFromEuler': ($__.fs.J$__v494107025_291_407 = function J$__v494107025_291(euler, update) {
var vvv_return, vvv_switch, c1, c2, c3, s1, s2, s3, order;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
euler = arguments[0], update = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if ((euler && euler.isEuler) === false) {
    throw new Error('THREE.Quaternion: .setFromEuler() now expects a Euler rotation rather than a Vector3 and order.');
}
c1 = Math.cos(euler._x / 2);
c2 = Math.cos(euler._y / 2);
c3 = Math.cos(euler._z / 2);
s1 = Math.sin(euler._x / 2);
s2 = Math.sin(euler._y / 2);
s3 = Math.sin(euler._z / 2);
order = euler.order;
if (order === 'XYZ') {
    this._x = s1 * c2 * c3 + c1 * s2 * s3;
    this._y = c1 * s2 * c3 - s1 * c2 * s3;
    this._z = c1 * c2 * s3 + s1 * s2 * c3;
    this._w = c1 * c2 * c3 - s1 * s2 * s3;
} else if (order === 'YXZ') {
    this._x = s1 * c2 * c3 + c1 * s2 * s3;
    this._y = c1 * s2 * c3 - s1 * c2 * s3;
    this._z = c1 * c2 * s3 - s1 * s2 * c3;
    this._w = c1 * c2 * c3 + s1 * s2 * s3;
} else if (order === 'ZXY') {
    this._x = s1 * c2 * c3 - c1 * s2 * s3;
    this._y = c1 * s2 * c3 + s1 * c2 * s3;
    this._z = c1 * c2 * s3 + s1 * s2 * c3;
    this._w = c1 * c2 * c3 - s1 * s2 * s3;
} else if (order === 'ZYX') {
    this._x = s1 * c2 * c3 - c1 * s2 * s3;
    this._y = c1 * s2 * c3 + s1 * c2 * s3;
    this._z = c1 * c2 * s3 - s1 * s2 * c3;
    this._w = c1 * c2 * c3 + s1 * s2 * s3;
} else if (order === 'YZX') {
    this._x = s1 * c2 * c3 + c1 * s2 * s3;
    this._y = c1 * s2 * c3 + s1 * c2 * s3;
    this._z = c1 * c2 * s3 - s1 * s2 * c3;
    this._w = c1 * c2 * c3 - s1 * s2 * s3;
} else if (order === 'XZY') {
    this._x = s1 * c2 * c3 - c1 * s2 * s3;
    this._y = c1 * s2 * c3 - s1 * c2 * s3;
    this._z = c1 * c2 * s3 + s1 * s2 * c3;
    this._w = c1 * c2 * c3 + s1 * s2 * s3;
}
if (update !== false)
    this.onChangeCallback();
return this;}),
        'setFromAxisAngle': ($__.fs.J$__v494107025_293_408 = function J$__v494107025_293(axis, angle) {
var vvv_return, vvv_switch, halfAngle, s;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
axis = arguments[0], angle = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
halfAngle = angle / 2;
s = Math.sin(halfAngle);
this._x = axis.x * s;
this._y = axis.y * s;
this._z = axis.z * s;
this._w = Math.cos(halfAngle);
this.onChangeCallback();
return this;}),
        'setFromRotationMatrix': ($__.fs.J$__v494107025_295_409 = function J$__v494107025_295(m) {
var vvv_return, vvv_switch, te, m11, m12, m13, m21, m22, m23, m31, m32, m33, trace, s;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
m = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
te = m.elements;
m11 = te[0];
m12 = te[4];
m13 = te[8];
m21 = te[1];
m22 = te[5];
m23 = te[9];
m31 = te[2];
m32 = te[6];
m33 = te[10];
trace = m11 + m22 + m33;
if (trace > 0) {
    s = 0.5 / Math.sqrt(trace + 1);
    this._w = 0.25 / s;
    this._x = (m32 - m23) * s;
    this._y = (m13 - m31) * s;
    this._z = (m21 - m12) * s;
} else if (m11 > m22 && m11 > m33) {
    s = 2 * Math.sqrt(1 + m11 - m22 - m33);
    this._w = (m32 - m23) / s;
    this._x = 0.25 * s;
    this._y = (m12 + m21) / s;
    this._z = (m13 + m31) / s;
} else if (m22 > m33) {
    s = 2 * Math.sqrt(1 + m22 - m11 - m33);
    this._w = (m13 - m31) / s;
    this._x = (m12 + m21) / s;
    this._y = 0.25 * s;
    this._z = (m23 + m32) / s;
} else {
    s = 2 * Math.sqrt(1 + m33 - m11 - m22);
    this._w = (m21 - m12) / s;
    this._x = (m13 + m31) / s;
    this._y = (m23 + m32) / s;
    this._z = 0.25 * s;
}
this.onChangeCallback();
return this;}),
        'setFromUnitVectors': (($__.fs.J$__v494107025_298_410 = function J$__v494107025_298() {
var vvv_return, vvv_switch, v1, r, EPS;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    EPS = 0.000001;
    return ($__.fs.setFromUnitVectors_411 = function setFromUnitVectors(vFrom, vTo) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
vFrom = arguments[0], vTo = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (v1 === undefined)
    v1 = new Vector3();
r = vFrom.dot(vTo) + 1;
if (r < EPS) {
    r = 0;
    if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {
        v1.set(-vFrom.y, vFrom.x, 0);
    } else {
        v1.set(0, -vFrom.z, vFrom.y);
    }
} else {
    v1.crossVectors(vFrom, vTo);
}
this._x = v1.x;
this._y = v1.y;
this._z = v1.z;
this._w = r;
return this.normalize();});
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
EPS = 0.000001;
return function setFromUnitVectors(vFrom, vTo) {
    if (v1 === undefined)
        v1 = new Vector3();
    r = vFrom.dot(vTo) + 1;
    if (r < EPS) {
        r = 0;
        if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {
            v1.set(-vFrom.y, vFrom.x, 0);
        } else {
            v1.set(0, -vFrom.z, vFrom.y);
        }
    } else {
        v1.crossVectors(vFrom, vTo);
    }
    this._x = v1.x;
    this._y = v1.y;
    this._z = v1.z;
    this._w = r;
    return this.normalize();
};}), $__.fs.J$__v494107025_298_410)(0, true, $__.uid),
        'inverse': ($__.fs.J$__v494107025_300_412 = function J$__v494107025_300() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return this.conjugate().normalize();}),
        'conjugate': ($__.fs.J$__v494107025_302_413 = function J$__v494107025_302() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this._x *= -1;
this._y *= -1;
this._z *= -1;
this.onChangeCallback();
return this;}),
        'dot': ($__.fs.J$__v494107025_304_414 = function J$__v494107025_304(v) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
v = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;}),
        'lengthSq': ($__.fs.J$__v494107025_306_415 = function J$__v494107025_306() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;}),
        'length': ($__.fs.J$__v494107025_308_416 = function J$__v494107025_308() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);}),
        'normalize': ($__.fs.J$__v494107025_310_417 = function J$__v494107025_310() {
var vvv_return, vvv_switch, l;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
l = this.length();
if (l === 0) {
    this._x = 0;
    this._y = 0;
    this._z = 0;
    this._w = 1;
} else {
    l = 1 / l;
    this._x = this._x * l;
    this._y = this._y * l;
    this._z = this._z * l;
    this._w = this._w * l;
}
this.onChangeCallback();
return this;}),
        'multiply': ($__.fs.J$__v494107025_312_418 = function J$__v494107025_312(q, p) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
q = arguments[0], p = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (p !== undefined) {
    console.warn('THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.');
    return this.multiplyQuaternions(q, p);
}
return this.multiplyQuaternions(this, q);}),
        'premultiply': ($__.fs.J$__v494107025_314_419 = function J$__v494107025_314(q) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
q = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return this.multiplyQuaternions(q, this);}),
        'multiplyQuaternions': ($__.fs.J$__v494107025_316_420 = function J$__v494107025_316(a, b) {
var vvv_return, vvv_switch, qax, qay, qaz, qaw, qbx, qby, qbz, qbw;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
a = arguments[0], b = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
qax = a._x;
qay = a._y;
qaz = a._z;
qaw = a._w;
qbx = b._x;
qby = b._y;
qbz = b._z;
qbw = b._w;
this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
this.onChangeCallback();
return this;}),
        'slerp': ($__.fs.J$__v494107025_318_421 = function J$__v494107025_318(qb, t) {
var vvv_return, vvv_switch, x, y, z, w, cosHalfTheta, sinHalfTheta, halfTheta, ratioA, ratioB;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
qb = arguments[0], t = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (t === 0)
    return this;
if (t === 1)
    return this.copy(qb);
x = this._x;
y = this._y;
z = this._z;
w = this._w;
cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;
if (cosHalfTheta < 0) {
    this._w = -qb._w;
    this._x = -qb._x;
    this._y = -qb._y;
    this._z = -qb._z;
    cosHalfTheta = -cosHalfTheta;
} else {
    this.copy(qb);
}
if (cosHalfTheta >= 1) {
    this._w = w;
    this._x = x;
    this._y = y;
    this._z = z;
    return this;
}
sinHalfTheta = Math.sqrt(1 - cosHalfTheta * cosHalfTheta);
if (Math.abs(sinHalfTheta) < 0.001) {
    this._w = 0.5 * (w + this._w);
    this._x = 0.5 * (x + this._x);
    this._y = 0.5 * (y + this._y);
    this._z = 0.5 * (z + this._z);
    return this;
}
halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta;
ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
this._w = w * ratioA + this._w * ratioB;
this._x = x * ratioA + this._x * ratioB;
this._y = y * ratioA + this._y * ratioB;
this._z = z * ratioA + this._z * ratioB;
this.onChangeCallback();
return this;}),
        'equals': ($__.fs.J$__v494107025_320_422 = function J$__v494107025_320(quaternion) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
quaternion = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w;}),
        'fromArray': ($__.fs.J$__v494107025_322_423 = function J$__v494107025_322(array, offset) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
array = arguments[0], offset = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (offset === undefined)
    offset = 0;
this._x = array[offset];
this._y = array[offset + 1];
this._z = array[offset + 2];
this._w = array[offset + 3];
this.onChangeCallback();
return this;}),
        'toArray': ($__.fs.J$__v494107025_324_424 = function J$__v494107025_324(array, offset) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
array = arguments[0], offset = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (array === undefined)
    array = [];
if (offset === undefined)
    offset = 0;
array[offset] = this._x;
array[offset + 1] = this._y;
array[offset + 2] = this._z;
array[offset + 3] = this._w;
return array;}),
        'onChange': ($__.fs.J$__v494107025_326_425 = function J$__v494107025_326(callback) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
callback = arguments[0];
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    this.onChangeCallback = callback;
    return this;
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.onChangeCallback = callback;
return this;}),
        'onChangeCallback': ($__.fs.J$__v494107025_328_426 = function J$__v494107025_328() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');}),
        get x() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return this._x;},
        set x(value) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
value = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this._x = value;
this.onChangeCallback();},
        get y() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return this._y;},
        set y(value) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
value = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this._y = value;
this.onChangeCallback();},
        get z() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return this._z;},
        set z(value) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
value = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this._z = value;
this.onChangeCallback();},
        get w() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return this._w;},
        set w(value) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
value = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this._w = value;
this.onChangeCallback();}
    }, $__.fs.x_427 = Object.getOwnPropertyDescriptor(vvv_tmp2, 'x').get, $__.fs.x_428 = Object.getOwnPropertyDescriptor(vvv_tmp2, 'x').set, $__.fs.y_429 = Object.getOwnPropertyDescriptor(vvv_tmp2, 'y').get, $__.fs.y_430 = Object.getOwnPropertyDescriptor(vvv_tmp2, 'y').set, $__.fs.z_431 = Object.getOwnPropertyDescriptor(vvv_tmp2, 'z').get, $__.fs.z_432 = Object.getOwnPropertyDescriptor(vvv_tmp2, 'z').set, $__.fs.w_433 = Object.getOwnPropertyDescriptor(vvv_tmp2, 'w').get, $__.fs.w_434 = Object.getOwnPropertyDescriptor(vvv_tmp2, 'w').set, $__.os.oid7 = vvv_tmp2);
    Object['assign'](((Quaternion, $__.fs.Quaternion_10), $__.fs.Quaternion_10_0), $__.os.oid8 = {
        'slerp': ($__.fs.J$__v494107025_330_435 = function J$__v494107025_330(qa, qb, qm, t) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
qa = arguments[0], qb = arguments[1], qm = arguments[2], t = arguments[3];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return qm.copy(qa).slerp(qb, t);}),
        'slerpFlat': ($__.fs.J$__v494107025_332_436 = function J$__v494107025_332(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) {
var vvv_return, vvv_switch, x0, y0, z0, w0, x1, y1, z1, w1, s, cos, dir, sqrSin, sin, len, tDir, f;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
dst = arguments[0], dstOffset = arguments[1], src0 = arguments[2], srcOffset0 = arguments[3], src1 = arguments[4], srcOffset1 = arguments[5], t = arguments[6];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
x0 = src0[srcOffset0 + 0];
y0 = src0[srcOffset0 + 1];
z0 = src0[srcOffset0 + 2];
w0 = src0[srcOffset0 + 3];
x1 = src1[srcOffset1 + 0];
y1 = src1[srcOffset1 + 1];
z1 = src1[srcOffset1 + 2];
w1 = src1[srcOffset1 + 3];
if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {
    s = 1 - t;
    cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1;
    dir = cos >= 0 ? 1 : -1;
    sqrSin = 1 - cos * cos;
    if (sqrSin > Number.EPSILON) {
        sin = Math.sqrt(sqrSin);
        len = Math.atan2(sin, cos * dir);
        s = Math.sin(s * len) / sin;
        t = Math.sin(t * len) / sin;
    }
    tDir = t * dir;
    x0 = x0 * s + x1 * tDir;
    y0 = y0 * s + y1 * tDir;
    z0 = z0 * s + z1 * tDir;
    w0 = w0 * s + w1 * tDir;
    if (s === 1 - t) {
        f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);
        x0 *= f;
        y0 *= f;
        z0 *= f;
        w0 *= f;
    }
}
dst[dstOffset] = x0;
dst[dstOffset + 1] = y0;
dst[dstOffset + 2] = z0;
dst[dstOffset + 3] = w0;})
    });
    Vector3.prototype = $__.os.oid9 = {
        'constructor': Vector3,
        'isVector3': true,
        'set': ($__.fs.J$__v494107025_335_437 = function J$__v494107025_335(x, y, z) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
x = arguments[0], y = arguments[1], z = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.x = x;
this.y = y;
this.z = z;
return this;}),
        'setScalar': ($__.fs.J$__v494107025_337_438 = function J$__v494107025_337(scalar) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
scalar = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.x = scalar;
this.y = scalar;
this.z = scalar;
return this;}),
        'setX': ($__.fs.J$__v494107025_339_439 = function J$__v494107025_339(x) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
x = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.x = x;
return this;}),
        'setY': ($__.fs.J$__v494107025_341_440 = function J$__v494107025_341(y) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
y = arguments[0];
switch (vvv_switch) {
case 0:
case 1:
case 2:
case 3:
case 4:
case 5:
case 6:
case 7:
case 8:
case 9:
case 10:
case 11:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(0 <= vvv_switch && vvv_switch <= 11);
    this.y = y;
    return this;
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.y = y;
return this;}),
        'setZ': ($__.fs.J$__v494107025_343_441 = function J$__v494107025_343(z) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
z = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.z = z;
return this;}),
        'setComponent': ($__.fs.J$__v494107025_345_442 = function J$__v494107025_345(index, value) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
index = arguments[0], value = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
switch (index) {
case 0:
    this.x = value;
    break;
case 1:
    this.y = value;
    break;
case 2:
    this.z = value;
    break;
default:
    throw new Error('index is out of range: ' + index);
}}),
        'getComponent': ($__.fs.J$__v494107025_347_443 = function J$__v494107025_347(index) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
index = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
switch (index) {
case 0:
    return this.x;
case 1:
    return this.y;
case 2:
    return this.z;
default:
    throw new Error('index is out of range: ' + index);
}}),
        'clone': ($__.fs.J$__v494107025_349_444 = function J$__v494107025_349() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    return new $__.fs.Vector3_11((this.x, 0), (this.y, 1), (this.z, 0), 94, true, $__.uid);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return new this.constructor(this.x, this.y, this.z);}),
        'copy': ($__.fs.J$__v494107025_351_445 = function J$__v494107025_351(v) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
v = arguments[0];
switch (vvv_switch) {
case 0:
case 1:
case 2:
case 3:
case 4:
case 5:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(0 <= vvv_switch && vvv_switch <= 5);
    this.x = (v.x, 0);
    this.y = (v.y, 0.5);
    this.z = (v.z, 0);
    return this;
case 6:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 6);
    this.x = (v.x, 0);
    this.y = (v.y, -0.5);
    this.z = (v.z, 0.5);
    return this;
case 7:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 7);
    this.x = (v.x, 0.47552825814757677);
    this.y = (v.y, -0.5);
    this.z = (v.z, 0.15450849718747373);
    return this;
case 8:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 8);
    this.x = (v.x, 0.2938926261462366);
    this.y = (v.y, -0.5);
    this.z = (v.z, -0.40450849718747367);
    return this;
case 9:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 9);
    this.x = (v.x, -0.2938926261462365);
    this.y = (v.y, -0.5);
    this.z = (v.z, -0.4045084971874737);
    return this;
case 10:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 10);
    this.x = (v.x, -0.4755282581475768);
    this.y = (v.y, -0.5);
    this.z = (v.z, 0.15450849718747361);
    return this;
case 11:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 11);
    this.x = (v.x, -1.2246467991473532e-16);
    this.y = (v.y, -0.5);
    this.z = (v.z, 0.5);
    return this;
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.x = v.x;
this.y = v.y;
this.z = v.z;
return this;}),
        'add': ($__.fs.J$__v494107025_353_446 = function J$__v494107025_353(v, w) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
v = arguments[0], w = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (w !== undefined) {
    console.warn('THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');
    return this.addVectors(v, w);
}
this.x += v.x;
this.y += v.y;
this.z += v.z;
return this;}),
        'addScalar': ($__.fs.J$__v494107025_355_447 = function J$__v494107025_355(s) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
s = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.x += s;
this.y += s;
this.z += s;
return this;}),
        'addVectors': ($__.fs.J$__v494107025_357_448 = function J$__v494107025_357(a, b) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
a = arguments[0], b = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.x = a.x + b.x;
this.y = a.y + b.y;
this.z = a.z + b.z;
return this;}),
        'addScaledVector': ($__.fs.J$__v494107025_359_449 = function J$__v494107025_359(v, s) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
v = arguments[0], s = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.x += v.x * s;
this.y += v.y * s;
this.z += v.z * s;
return this;}),
        'sub': ($__.fs.J$__v494107025_361_450 = function J$__v494107025_361(v, w) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
v = arguments[0], w = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (w !== undefined) {
    console.warn('THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');
    return this.subVectors(v, w);
}
this.x -= v.x;
this.y -= v.y;
this.z -= v.z;
return this;}),
        'subScalar': ($__.fs.J$__v494107025_363_451 = function J$__v494107025_363(s) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
s = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.x -= s;
this.y -= s;
this.z -= s;
return this;}),
        'subVectors': ($__.fs.J$__v494107025_365_452 = function J$__v494107025_365(a, b) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
a = arguments[0], b = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.x = a.x - b.x;
this.y = a.y - b.y;
this.z = a.z - b.z;
return this;}),
        'multiply': ($__.fs.J$__v494107025_367_453 = function J$__v494107025_367(v, w) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
v = arguments[0], w = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (w !== undefined) {
    console.warn('THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.');
    return this.multiplyVectors(v, w);
}
this.x *= v.x;
this.y *= v.y;
this.z *= v.z;
return this;}),
        'multiplyScalar': ($__.fs.J$__v494107025_369_454 = function J$__v494107025_369(scalar) {
var vvv_return, vvv_switch, vvv_tmp0, vvv_tmp1, vvv_tmp2;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
scalar = arguments[0];
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    isFinite(scalar);
    (vvv_tmp0 = this).x = (vvv_tmp0.x, 0) * scalar;
    (vvv_tmp1 = this).y = (vvv_tmp1.y, 0.5) * scalar;
    (vvv_tmp2 = this).z = (vvv_tmp2.z, 1) * scalar;
    return this;
case 1:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 1);
    isFinite(scalar);
    (vvv_tmp0 = this).x = (vvv_tmp0.x, 0.9510565162951535) * scalar;
    (vvv_tmp1 = this).y = (vvv_tmp1.y, 0.49999999999999994) * scalar;
    (vvv_tmp2 = this).z = (vvv_tmp2.z, 0.30901699437494745) * scalar;
    return this;
case 2:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 2);
    isFinite(scalar);
    (vvv_tmp0 = this).x = (vvv_tmp0.x, 0.5877852522924732) * scalar;
    (vvv_tmp1 = this).y = (vvv_tmp1.y, 0.5) * scalar;
    (vvv_tmp2 = this).z = (vvv_tmp2.z, -0.8090169943749473) * scalar;
    return this;
case 3:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 3);
    isFinite(scalar);
    (vvv_tmp0 = this).x = (vvv_tmp0.x, -0.587785252292473) * scalar;
    (vvv_tmp1 = this).y = (vvv_tmp1.y, 0.49999999999999994) * scalar;
    (vvv_tmp2 = this).z = (vvv_tmp2.z, -0.8090169943749475) * scalar;
    return this;
case 4:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 4);
    isFinite(scalar);
    (vvv_tmp0 = this).x = (vvv_tmp0.x, -0.9510565162951536) * scalar;
    (vvv_tmp1 = this).y = (vvv_tmp1.y, 0.5) * scalar;
    (vvv_tmp2 = this).z = (vvv_tmp2.z, 0.30901699437494723) * scalar;
    return this;
case 5:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 5);
    isFinite(scalar);
    (vvv_tmp0 = this).x = (vvv_tmp0.x, -2.4492935982947064e-16) * scalar;
    (vvv_tmp1 = this).y = (vvv_tmp1.y, 0.5) * scalar;
    (vvv_tmp2 = this).z = (vvv_tmp2.z, 1) * scalar;
    return this;
case 6:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 6);
    isFinite(scalar);
    (vvv_tmp0 = this).x = (vvv_tmp0.x, 0) * scalar;
    (vvv_tmp1 = this).y = (vvv_tmp1.y, 0.25) * scalar;
    (vvv_tmp2 = this).z = (vvv_tmp2.z, 0.5) * scalar;
    return this;
case 7:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 7);
    isFinite(scalar);
    (vvv_tmp0 = this).x = (vvv_tmp0.x, 0.47552825814757677) * scalar;
    (vvv_tmp1 = this).y = (vvv_tmp1.y, 0.24999999999999997) * scalar;
    (vvv_tmp2 = this).z = (vvv_tmp2.z, 0.15450849718747373) * scalar;
    return this;
case 8:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 8);
    isFinite(scalar);
    (vvv_tmp0 = this).x = (vvv_tmp0.x, 0.2938926261462366) * scalar;
    (vvv_tmp1 = this).y = (vvv_tmp1.y, 0.25) * scalar;
    (vvv_tmp2 = this).z = (vvv_tmp2.z, -0.40450849718747367) * scalar;
    return this;
case 9:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 9);
    isFinite(scalar);
    (vvv_tmp0 = this).x = (vvv_tmp0.x, -0.2938926261462365) * scalar;
    (vvv_tmp1 = this).y = (vvv_tmp1.y, 0.24999999999999997) * scalar;
    (vvv_tmp2 = this).z = (vvv_tmp2.z, -0.4045084971874737) * scalar;
    return this;
case 10:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 10);
    isFinite(scalar);
    (vvv_tmp0 = this).x = (vvv_tmp0.x, -0.4755282581475768) * scalar;
    (vvv_tmp1 = this).y = (vvv_tmp1.y, 0.25) * scalar;
    (vvv_tmp2 = this).z = (vvv_tmp2.z, 0.15450849718747361) * scalar;
    return this;
case 11:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 11);
    isFinite(scalar);
    (vvv_tmp0 = this).x = (vvv_tmp0.x, -1.2246467991473532e-16) * scalar;
    (vvv_tmp1 = this).y = (vvv_tmp1.y, 0.25) * scalar;
    (vvv_tmp2 = this).z = (vvv_tmp2.z, 0.5) * scalar;
    return this;
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (isFinite(scalar)) {
    this.x *= scalar;
    this.y *= scalar;
    this.z *= scalar;
} else {
    this.x = 0;
    this.y = 0;
    this.z = 0;
}
return this;}),
        'multiplyVectors': ($__.fs.J$__v494107025_371_455 = function J$__v494107025_371(a, b) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
a = arguments[0], b = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.x = a.x * b.x;
this.y = a.y * b.y;
this.z = a.z * b.z;
return this;}),
        'applyEuler': (($__.fs.J$__v494107025_374_456 = function J$__v494107025_374() {
var vvv_return, vvv_switch, quaternion;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    return ($__.fs.applyEuler_457 = function applyEuler(euler) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
euler = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if ((euler && euler.isEuler) === false) {
    console.error('THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.');
}
if (quaternion === undefined)
    quaternion = new Quaternion();
return this.applyQuaternion(quaternion.setFromEuler(euler));});
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return function applyEuler(euler) {
    if ((euler && euler.isEuler) === false) {
        console.error('THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.');
    }
    if (quaternion === undefined)
        quaternion = new Quaternion();
    return this.applyQuaternion(quaternion.setFromEuler(euler));
};}), $__.fs.J$__v494107025_374_456)(0, true, $__.uid),
        'applyAxisAngle': (($__.fs.J$__v494107025_377_458 = function J$__v494107025_377() {
var vvv_return, vvv_switch, quaternion;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    return ($__.fs.applyAxisAngle_459 = function applyAxisAngle(axis, angle) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
axis = arguments[0], angle = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (quaternion === undefined)
    quaternion = new Quaternion();
return this.applyQuaternion(quaternion.setFromAxisAngle(axis, angle));});
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return function applyAxisAngle(axis, angle) {
    if (quaternion === undefined)
        quaternion = new Quaternion();
    return this.applyQuaternion(quaternion.setFromAxisAngle(axis, angle));
};}), $__.fs.J$__v494107025_377_458)(0, true, $__.uid),
        'applyMatrix3': ($__.fs.J$__v494107025_379_460 = function J$__v494107025_379(m) {
var vvv_return, vvv_switch, x, y, z, e;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
m = arguments[0];
switch (vvv_switch) {
case 0:
case 6:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(0 <= vvv_switch && vvv_switch <= 6);
    x = (this.x, 0);
    y = (this.y, 0.4472135901451111);
    z = (this.z, 0.8944271802902222);
    e = TAJS_restrictToType(m.elements, 'object');
    this.x = (e[0, 0], 1) * x + (e[3, 3], 0) * y + (e[6, 6], 0) * z;
    this.y = (e[1, 1], 0) * x + (e[4, 4], 1) * y + (e[7, 7], 0) * z;
    this.z = (e[2, 2], 0) * x + (e[5, 5], 0) * y + (e[8, 8], 1) * z;
    return this;
case 1:
case 7:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(1 <= vvv_switch && vvv_switch <= 7);
    x = (this.x, 0.8506507873535156);
    y = (this.y, 0.4472135901451111);
    z = (this.z, 0.27639320492744446);
    e = TAJS_restrictToType(m.elements, 'object');
    this.x = (e[0, 0], 1) * x + (e[3, 3], 0) * y + (e[6, 6], 0) * z;
    this.y = (e[1, 1], 0) * x + (e[4, 4], 1) * y + (e[7, 7], 0) * z;
    this.z = (e[2, 2], 0) * x + (e[5, 5], 0) * y + (e[8, 8], 1) * z;
    return this;
case 2:
case 8:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(2 <= vvv_switch && vvv_switch <= 8);
    x = (this.x, 0.525731086730957);
    y = (this.y, 0.4472135901451111);
    z = (this.z, -0.7236068248748779);
    e = TAJS_restrictToType(m.elements, 'object');
    this.x = (e[0, 0], 1) * x + (e[3, 3], 0) * y + (e[6, 6], 0) * z;
    this.y = (e[1, 1], 0) * x + (e[4, 4], 1) * y + (e[7, 7], 0) * z;
    this.z = (e[2, 2], 0) * x + (e[5, 5], 0) * y + (e[8, 8], 1) * z;
    return this;
case 3:
case 9:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(3 <= vvv_switch && vvv_switch <= 9);
    x = (this.x, -0.525731086730957);
    y = (this.y, 0.4472135901451111);
    z = (this.z, -0.7236068248748779);
    e = TAJS_restrictToType(m.elements, 'object');
    this.x = (e[0, 0], 1) * x + (e[3, 3], 0) * y + (e[6, 6], 0) * z;
    this.y = (e[1, 1], 0) * x + (e[4, 4], 1) * y + (e[7, 7], 0) * z;
    this.z = (e[2, 2], 0) * x + (e[5, 5], 0) * y + (e[8, 8], 1) * z;
    return this;
case 4:
case 10:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(4 <= vvv_switch && vvv_switch <= 10);
    x = (this.x, -0.8506507873535156);
    y = (this.y, 0.4472135901451111);
    z = (this.z, 0.27639320492744446);
    e = TAJS_restrictToType(m.elements, 'object');
    this.x = (e[0, 0], 1) * x + (e[3, 3], 0) * y + (e[6, 6], 0) * z;
    this.y = (e[1, 1], 0) * x + (e[4, 4], 1) * y + (e[7, 7], 0) * z;
    this.z = (e[2, 2], 0) * x + (e[5, 5], 0) * y + (e[8, 8], 1) * z;
    return this;
case 5:
case 11:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(5 <= vvv_switch && vvv_switch <= 11);
    x = (this.x, -2.190714795754993e-16);
    y = (this.y, 0.4472135901451111);
    z = (this.z, 0.8944271802902222);
    e = TAJS_restrictToType(m.elements, 'object');
    this.x = (e[0, 0], 1) * x + (e[3, 3], 0) * y + (e[6, 6], 0) * z;
    this.y = (e[1, 1], 0) * x + (e[4, 4], 1) * y + (e[7, 7], 0) * z;
    this.z = (e[2, 2], 0) * x + (e[5, 5], 0) * y + (e[8, 8], 1) * z;
    return this;
case 12:
case 13:
case 14:
case 15:
case 16:
case 17:
case 18:
case 19:
case 20:
case 21:
case 22:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(12 <= vvv_switch && vvv_switch <= 22);
    x = (this.x, 0);
    y = (this.y, -1);
    z = (this.z, 0);
    e = TAJS_restrictToType(m.elements, 'object');
    this.x = (e[0, 0], 1) * x + (e[3, 3], 0) * y + (e[6, 6], 0) * z;
    this.y = (e[1, 1], 0) * x + (e[4, 4], 1) * y + (e[7, 7], 0) * z;
    this.z = (e[2, 2], 0) * x + (e[5, 5], 0) * y + (e[8, 8], 1) * z;
    return this;
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
x = this.x;
y = this.y;
z = this.z;
e = m.elements;
this.x = e[0] * x + e[3] * y + e[6] * z;
this.y = e[1] * x + e[4] * y + e[7] * z;
this.z = e[2] * x + e[5] * y + e[8] * z;
return this;}),
        'applyMatrix4': ($__.fs.J$__v494107025_381_461 = function J$__v494107025_381(m) {
var vvv_return, vvv_switch, x, y, z, e;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
m = arguments[0];
switch (vvv_switch) {
case 0:
case 1:
case 2:
case 3:
case 4:
case 5:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(0 <= vvv_switch && vvv_switch <= 5);
    x = (this.x, 0);
    y = (this.y, 0.5);
    z = (this.z, 0);
    e = TAJS_restrictToType(m.elements, 'object');
    this.x = (e[0, 0], 1) * x + (e[4, 4], 0) * y + (e[8, 8], 0) * z + (e[12, 12], 0);
    this.y = (e[1, 1], 0) * x + (e[5, 5], 1) * y + (e[9, 9], 0) * z + (e[13, 13], -0.5);
    this.z = (e[2, 2], 0) * x + (e[6, 6], 0) * y + (e[10, 10], 1) * z + (e[14, 14], 0);
    return this;
case 6:
case 17:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(6 <= vvv_switch && vvv_switch <= 17);
    x = (this.x, 0);
    y = (this.y, -0.5);
    z = (this.z, 0.5);
    e = TAJS_restrictToType(m.elements, 'object');
    this.x = (e[0, 0], 1) * x + (e[4, 4], 0) * y + (e[8, 8], 0) * z + (e[12, 12], 0);
    this.y = (e[1, 1], 0) * x + (e[5, 5], 1) * y + (e[9, 9], 0) * z + (e[13, 13], -0.5);
    this.z = (e[2, 2], 0) * x + (e[6, 6], 0) * y + (e[10, 10], 1) * z + (e[14, 14], 0);
    return this;
case 7:
case 18:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(7 <= vvv_switch && vvv_switch <= 18);
    x = (this.x, 0.4755282700061798);
    y = (this.y, -0.5);
    z = (this.z, 0.15450850129127502);
    e = TAJS_restrictToType(m.elements, 'object');
    this.x = (e[0, 0], 1) * x + (e[4, 4], 0) * y + (e[8, 8], 0) * z + (e[12, 12], 0);
    this.y = (e[1, 1], 0) * x + (e[5, 5], 1) * y + (e[9, 9], 0) * z + (e[13, 13], -0.5);
    this.z = (e[2, 2], 0) * x + (e[6, 6], 0) * y + (e[10, 10], 1) * z + (e[14, 14], 0);
    return this;
case 8:
case 19:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(8 <= vvv_switch && vvv_switch <= 19);
    x = (this.x, 0.29389262199401855);
    y = (this.y, -0.5);
    z = (this.z, -0.404508501291275);
    e = TAJS_restrictToType(m.elements, 'object');
    this.x = (e[0, 0], 1) * x + (e[4, 4], 0) * y + (e[8, 8], 0) * z + (e[12, 12], 0);
    this.y = (e[1, 1], 0) * x + (e[5, 5], 1) * y + (e[9, 9], 0) * z + (e[13, 13], -0.5);
    this.z = (e[2, 2], 0) * x + (e[6, 6], 0) * y + (e[10, 10], 1) * z + (e[14, 14], 0);
    return this;
case 9:
case 20:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(9 <= vvv_switch && vvv_switch <= 20);
    x = (this.x, -0.29389262199401855);
    y = (this.y, -0.5);
    z = (this.z, -0.404508501291275);
    e = TAJS_restrictToType(m.elements, 'object');
    this.x = (e[0, 0], 1) * x + (e[4, 4], 0) * y + (e[8, 8], 0) * z + (e[12, 12], 0);
    this.y = (e[1, 1], 0) * x + (e[5, 5], 1) * y + (e[9, 9], 0) * z + (e[13, 13], -0.5);
    this.z = (e[2, 2], 0) * x + (e[6, 6], 0) * y + (e[10, 10], 1) * z + (e[14, 14], 0);
    return this;
case 10:
case 21:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(10 <= vvv_switch && vvv_switch <= 21);
    x = (this.x, -0.4755282700061798);
    y = (this.y, -0.5);
    z = (this.z, 0.15450850129127502);
    e = TAJS_restrictToType(m.elements, 'object');
    this.x = (e[0, 0], 1) * x + (e[4, 4], 0) * y + (e[8, 8], 0) * z + (e[12, 12], 0);
    this.y = (e[1, 1], 0) * x + (e[5, 5], 1) * y + (e[9, 9], 0) * z + (e[13, 13], -0.5);
    this.z = (e[2, 2], 0) * x + (e[6, 6], 0) * y + (e[10, 10], 1) * z + (e[14, 14], 0);
    return this;
case 11:
case 22:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(11 <= vvv_switch && vvv_switch <= 22);
    x = (this.x, -1.2246468525851679e-16);
    y = (this.y, -0.5);
    z = (this.z, 0.5);
    e = TAJS_restrictToType(m.elements, 'object');
    this.x = (e[0, 0], 1) * x + (e[4, 4], 0) * y + (e[8, 8], 0) * z + (e[12, 12], 0);
    this.y = (e[1, 1], 0) * x + (e[5, 5], 1) * y + (e[9, 9], 0) * z + (e[13, 13], -0.5);
    this.z = (e[2, 2], 0) * x + (e[6, 6], 0) * y + (e[10, 10], 1) * z + (e[14, 14], 0);
    return this;
case 12:
case 13:
case 14:
case 15:
case 16:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(12 <= vvv_switch && vvv_switch <= 16);
    x = (this.x, 0);
    y = (this.y, -0.5);
    z = (this.z, 0);
    e = TAJS_restrictToType(m.elements, 'object');
    this.x = (e[0, 0], 1) * x + (e[4, 4], 0) * y + (e[8, 8], 0) * z + (e[12, 12], 0);
    this.y = (e[1, 1], 0) * x + (e[5, 5], 1) * y + (e[9, 9], 0) * z + (e[13, 13], -0.5);
    this.z = (e[2, 2], 0) * x + (e[6, 6], 0) * y + (e[10, 10], 1) * z + (e[14, 14], 0);
    return this;
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
x = this.x;
y = this.y;
z = this.z;
e = m.elements;
this.x = e[0] * x + e[4] * y + e[8] * z + e[12];
this.y = e[1] * x + e[5] * y + e[9] * z + e[13];
this.z = e[2] * x + e[6] * y + e[10] * z + e[14];
return this;}),
        'applyProjection': ($__.fs.J$__v494107025_383_462 = function J$__v494107025_383(m) {
var vvv_return, vvv_switch, x, y, z, e, d;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
m = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
x = this.x;
y = this.y;
z = this.z;
e = m.elements;
d = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);
this.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * d;
this.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * d;
this.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * d;
return this;}),
        'applyQuaternion': ($__.fs.J$__v494107025_385_463 = function J$__v494107025_385(q) {
var vvv_return, vvv_switch, x, y, z, qx, qy, qz, qw, ix, iy, iz, iw;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
q = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
x = this.x;
y = this.y;
z = this.z;
qx = q.x;
qy = q.y;
qz = q.z;
qw = q.w;
ix = qw * x + qy * z - qz * y;
iy = qw * y + qz * x - qx * z;
iz = qw * z + qx * y - qy * x;
iw = -qx * x - qy * y - qz * z;
this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
return this;}),
        'project': (($__.fs.J$__v494107025_388_464 = function J$__v494107025_388() {
var vvv_return, vvv_switch, matrix;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    return ($__.fs.project_465 = function project(camera) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
camera = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (matrix === undefined)
    matrix = new Matrix4();
matrix.multiplyMatrices(camera.projectionMatrix, matrix.getInverse(camera.matrixWorld));
return this.applyProjection(matrix);});
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return function project(camera) {
    if (matrix === undefined)
        matrix = new Matrix4();
    matrix.multiplyMatrices(camera.projectionMatrix, matrix.getInverse(camera.matrixWorld));
    return this.applyProjection(matrix);
};}), $__.fs.J$__v494107025_388_464)(0, true, $__.uid),
        'unproject': (($__.fs.J$__v494107025_391_466 = function J$__v494107025_391() {
var vvv_return, vvv_switch, matrix;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    return ($__.fs.unproject_467 = function unproject(camera) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
camera = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (matrix === undefined)
    matrix = new Matrix4();
matrix.multiplyMatrices(camera.matrixWorld, matrix.getInverse(camera.projectionMatrix));
return this.applyProjection(matrix);});
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return function unproject(camera) {
    if (matrix === undefined)
        matrix = new Matrix4();
    matrix.multiplyMatrices(camera.matrixWorld, matrix.getInverse(camera.projectionMatrix));
    return this.applyProjection(matrix);
};}), $__.fs.J$__v494107025_391_466)(0, true, $__.uid),
        'transformDirection': ($__.fs.J$__v494107025_393_468 = function J$__v494107025_393(m) {
var vvv_return, vvv_switch, x, y, z, e;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
m = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
x = this.x;
y = this.y;
z = this.z;
e = m.elements;
this.x = e[0] * x + e[4] * y + e[8] * z;
this.y = e[1] * x + e[5] * y + e[9] * z;
this.z = e[2] * x + e[6] * y + e[10] * z;
return this.normalize();}),
        'divide': ($__.fs.J$__v494107025_395_469 = function J$__v494107025_395(v) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
v = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.x /= v.x;
this.y /= v.y;
this.z /= v.z;
return this;}),
        'divideScalar': ($__.fs.J$__v494107025_397_470 = function J$__v494107025_397(scalar) {
var vvv_return, vvv_switch, vvv_tmp0;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
scalar = arguments[0];
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    return vvv_tmp0 = this, 'multiplyScalar', $__.fs.J$__v494107025_369_454.call(vvv_tmp0, 1 / scalar, 0, true, $__.uid);
case 1:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 1);
    return vvv_tmp0 = this, 'multiplyScalar', $__.fs.J$__v494107025_369_454.call(vvv_tmp0, 1 / scalar, 1, true, $__.uid);
case 2:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 2);
    return vvv_tmp0 = this, 'multiplyScalar', $__.fs.J$__v494107025_369_454.call(vvv_tmp0, 1 / scalar, 2, true, $__.uid);
case 3:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 3);
    return vvv_tmp0 = this, 'multiplyScalar', $__.fs.J$__v494107025_369_454.call(vvv_tmp0, 1 / scalar, 3, true, $__.uid);
case 4:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 4);
    return vvv_tmp0 = this, 'multiplyScalar', $__.fs.J$__v494107025_369_454.call(vvv_tmp0, 1 / scalar, 4, true, $__.uid);
case 5:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 5);
    return vvv_tmp0 = this, 'multiplyScalar', $__.fs.J$__v494107025_369_454.call(vvv_tmp0, 1 / scalar, 5, true, $__.uid);
case 6:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 6);
    return vvv_tmp0 = this, 'multiplyScalar', $__.fs.J$__v494107025_369_454.call(vvv_tmp0, 1 / scalar, 6, true, $__.uid);
case 7:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 7);
    return vvv_tmp0 = this, 'multiplyScalar', $__.fs.J$__v494107025_369_454.call(vvv_tmp0, 1 / scalar, 7, true, $__.uid);
case 8:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 8);
    return vvv_tmp0 = this, 'multiplyScalar', $__.fs.J$__v494107025_369_454.call(vvv_tmp0, 1 / scalar, 8, true, $__.uid);
case 9:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 9);
    return vvv_tmp0 = this, 'multiplyScalar', $__.fs.J$__v494107025_369_454.call(vvv_tmp0, 1 / scalar, 9, true, $__.uid);
case 10:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 10);
    return vvv_tmp0 = this, 'multiplyScalar', $__.fs.J$__v494107025_369_454.call(vvv_tmp0, 1 / scalar, 10, true, $__.uid);
case 11:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 11);
    return vvv_tmp0 = this, 'multiplyScalar', $__.fs.J$__v494107025_369_454.call(vvv_tmp0, 1 / scalar, 11, true, $__.uid);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return this.multiplyScalar(1 / scalar);}),
        'min': ($__.fs.J$__v494107025_399_471 = function J$__v494107025_399(v) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
v = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.x = Math.min(this.x, v.x);
this.y = Math.min(this.y, v.y);
this.z = Math.min(this.z, v.z);
return this;}),
        'max': ($__.fs.J$__v494107025_401_472 = function J$__v494107025_401(v) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
v = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.x = Math.max(this.x, v.x);
this.y = Math.max(this.y, v.y);
this.z = Math.max(this.z, v.z);
return this;}),
        'clamp': ($__.fs.J$__v494107025_403_473 = function J$__v494107025_403(min, max) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
min = arguments[0], max = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.x = Math.max(min.x, Math.min(max.x, this.x));
this.y = Math.max(min.y, Math.min(max.y, this.y));
this.z = Math.max(min.z, Math.min(max.z, this.z));
return this;}),
        'clampScalar': (($__.fs.J$__v494107025_406_474 = function J$__v494107025_406() {
var vvv_return, vvv_switch, min, max;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    return ($__.fs.clampScalar_475 = function clampScalar(minVal, maxVal) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
minVal = arguments[0], maxVal = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (min === undefined) {
    min = new Vector3();
    max = new Vector3();
}
min.set(minVal, minVal, minVal);
max.set(maxVal, maxVal, maxVal);
return this.clamp(min, max);});
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return function clampScalar(minVal, maxVal) {
    if (min === undefined) {
        min = new Vector3();
        max = new Vector3();
    }
    min.set(minVal, minVal, minVal);
    max.set(maxVal, maxVal, maxVal);
    return this.clamp(min, max);
};}), $__.fs.J$__v494107025_406_474)(0, true, $__.uid),
        'clampLength': ($__.fs.J$__v494107025_408_476 = function J$__v494107025_408(min, max) {
var vvv_return, vvv_switch, length;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
min = arguments[0], max = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
length = this.length();
return this.multiplyScalar(Math.max(min, Math.min(max, length)) / length);}),
        'floor': ($__.fs.J$__v494107025_410_477 = function J$__v494107025_410() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.x = Math.floor(this.x);
this.y = Math.floor(this.y);
this.z = Math.floor(this.z);
return this;}),
        'ceil': ($__.fs.J$__v494107025_412_478 = function J$__v494107025_412() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.x = Math.ceil(this.x);
this.y = Math.ceil(this.y);
this.z = Math.ceil(this.z);
return this;}),
        'round': ($__.fs.J$__v494107025_414_479 = function J$__v494107025_414() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.x = Math.round(this.x);
this.y = Math.round(this.y);
this.z = Math.round(this.z);
return this;}),
        'roundToZero': ($__.fs.J$__v494107025_416_480 = function J$__v494107025_416() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
return this;}),
        'negate': ($__.fs.J$__v494107025_418_481 = function J$__v494107025_418() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.x = -this.x;
this.y = -this.y;
this.z = -this.z;
return this;}),
        'dot': ($__.fs.J$__v494107025_420_482 = function J$__v494107025_420(v) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
v = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return this.x * v.x + this.y * v.y + this.z * v.z;}),
        'lengthSq': ($__.fs.J$__v494107025_422_483 = function J$__v494107025_422() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return this.x * this.x + this.y * this.y + this.z * this.z;}),
        'length': ($__.fs.J$__v494107025_424_484 = function J$__v494107025_424() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    return Math['sqrt']((this.x, 0) * (this.x, 0) + (this.y, 0.5) * (this.y, 0.5) + (this.z, 1) * (this.z, 1));
case 1:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 1);
    return Math['sqrt']((this.x, 0.9510565162951535) * (this.x, 0.9510565162951535) + (this.y, 0.49999999999999994) * (this.y, 0.49999999999999994) + (this.z, 0.30901699437494745) * (this.z, 0.30901699437494745));
case 2:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 2);
    return Math['sqrt']((this.x, 0.5877852522924732) * (this.x, 0.5877852522924732) + (this.y, 0.5) * (this.y, 0.5) + (this.z, -0.8090169943749473) * (this.z, -0.8090169943749473));
case 3:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 3);
    return Math['sqrt']((this.x, -0.587785252292473) * (this.x, -0.587785252292473) + (this.y, 0.49999999999999994) * (this.y, 0.49999999999999994) + (this.z, -0.8090169943749475) * (this.z, -0.8090169943749475));
case 4:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 4);
    return Math['sqrt']((this.x, -0.9510565162951536) * (this.x, -0.9510565162951536) + (this.y, 0.5) * (this.y, 0.5) + (this.z, 0.30901699437494723) * (this.z, 0.30901699437494723));
case 5:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 5);
    return Math['sqrt']((this.x, -2.4492935982947064e-16) * (this.x, -2.4492935982947064e-16) + (this.y, 0.5) * (this.y, 0.5) + (this.z, 1) * (this.z, 1));
case 6:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 6);
    return Math['sqrt']((this.x, 0) * (this.x, 0) + (this.y, 0.25) * (this.y, 0.25) + (this.z, 0.5) * (this.z, 0.5));
case 7:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 7);
    return Math['sqrt']((this.x, 0.47552825814757677) * (this.x, 0.47552825814757677) + (this.y, 0.24999999999999997) * (this.y, 0.24999999999999997) + (this.z, 0.15450849718747373) * (this.z, 0.15450849718747373));
case 8:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 8);
    return Math['sqrt']((this.x, 0.2938926261462366) * (this.x, 0.2938926261462366) + (this.y, 0.25) * (this.y, 0.25) + (this.z, -0.40450849718747367) * (this.z, -0.40450849718747367));
case 9:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 9);
    return Math['sqrt']((this.x, -0.2938926261462365) * (this.x, -0.2938926261462365) + (this.y, 0.24999999999999997) * (this.y, 0.24999999999999997) + (this.z, -0.4045084971874737) * (this.z, -0.4045084971874737));
case 10:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 10);
    return Math['sqrt']((this.x, -0.4755282581475768) * (this.x, -0.4755282581475768) + (this.y, 0.25) * (this.y, 0.25) + (this.z, 0.15450849718747361) * (this.z, 0.15450849718747361));
case 11:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 11);
    return Math['sqrt']((this.x, -1.2246467991473532e-16) * (this.x, -1.2246467991473532e-16) + (this.y, 0.25) * (this.y, 0.25) + (this.z, 0.5) * (this.z, 0.5));
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);}),
        'lengthManhattan': ($__.fs.J$__v494107025_426_485 = function J$__v494107025_426() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);}),
        'normalize': ($__.fs.J$__v494107025_428_486 = function J$__v494107025_428() {
var vvv_return, vvv_switch, vvv_tmp0, vvv_tmp1;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    return vvv_tmp1 = this, 'divideScalar', $__.fs.J$__v494107025_397_470.call(vvv_tmp1, (vvv_tmp0 = this, 'length', $__.fs.J$__v494107025_424_484.call(vvv_tmp0, 0, true, $__.uid)), 0, true, $__.uid);
case 1:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 1);
    return vvv_tmp1 = this, 'divideScalar', $__.fs.J$__v494107025_397_470.call(vvv_tmp1, (vvv_tmp0 = this, 'length', $__.fs.J$__v494107025_424_484.call(vvv_tmp0, 1, true, $__.uid)), 1, true, $__.uid);
case 2:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 2);
    return vvv_tmp1 = this, 'divideScalar', $__.fs.J$__v494107025_397_470.call(vvv_tmp1, (vvv_tmp0 = this, 'length', $__.fs.J$__v494107025_424_484.call(vvv_tmp0, 2, true, $__.uid)), 2, true, $__.uid);
case 3:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 3);
    return vvv_tmp1 = this, 'divideScalar', $__.fs.J$__v494107025_397_470.call(vvv_tmp1, (vvv_tmp0 = this, 'length', $__.fs.J$__v494107025_424_484.call(vvv_tmp0, 3, true, $__.uid)), 3, true, $__.uid);
case 4:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 4);
    return vvv_tmp1 = this, 'divideScalar', $__.fs.J$__v494107025_397_470.call(vvv_tmp1, (vvv_tmp0 = this, 'length', $__.fs.J$__v494107025_424_484.call(vvv_tmp0, 4, true, $__.uid)), 4, true, $__.uid);
case 5:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 5);
    return vvv_tmp1 = this, 'divideScalar', $__.fs.J$__v494107025_397_470.call(vvv_tmp1, (vvv_tmp0 = this, 'length', $__.fs.J$__v494107025_424_484.call(vvv_tmp0, 5, true, $__.uid)), 5, true, $__.uid);
case 6:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 6);
    return vvv_tmp1 = this, 'divideScalar', $__.fs.J$__v494107025_397_470.call(vvv_tmp1, (vvv_tmp0 = this, 'length', $__.fs.J$__v494107025_424_484.call(vvv_tmp0, 6, true, $__.uid)), 6, true, $__.uid);
case 7:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 7);
    return vvv_tmp1 = this, 'divideScalar', $__.fs.J$__v494107025_397_470.call(vvv_tmp1, (vvv_tmp0 = this, 'length', $__.fs.J$__v494107025_424_484.call(vvv_tmp0, 7, true, $__.uid)), 7, true, $__.uid);
case 8:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 8);
    return vvv_tmp1 = this, 'divideScalar', $__.fs.J$__v494107025_397_470.call(vvv_tmp1, (vvv_tmp0 = this, 'length', $__.fs.J$__v494107025_424_484.call(vvv_tmp0, 8, true, $__.uid)), 8, true, $__.uid);
case 9:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 9);
    return vvv_tmp1 = this, 'divideScalar', $__.fs.J$__v494107025_397_470.call(vvv_tmp1, (vvv_tmp0 = this, 'length', $__.fs.J$__v494107025_424_484.call(vvv_tmp0, 9, true, $__.uid)), 9, true, $__.uid);
case 10:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 10);
    return vvv_tmp1 = this, 'divideScalar', $__.fs.J$__v494107025_397_470.call(vvv_tmp1, (vvv_tmp0 = this, 'length', $__.fs.J$__v494107025_424_484.call(vvv_tmp0, 10, true, $__.uid)), 10, true, $__.uid);
case 11:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 11);
    return vvv_tmp1 = this, 'divideScalar', $__.fs.J$__v494107025_397_470.call(vvv_tmp1, (vvv_tmp0 = this, 'length', $__.fs.J$__v494107025_424_484.call(vvv_tmp0, 11, true, $__.uid)), 11, true, $__.uid);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return this.divideScalar(this.length());}),
        'setLength': ($__.fs.J$__v494107025_430_487 = function J$__v494107025_430(length) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
length = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return this.multiplyScalar(length / this.length());}),
        'lerp': ($__.fs.J$__v494107025_432_488 = function J$__v494107025_432(v, alpha) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
v = arguments[0], alpha = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.x += (v.x - this.x) * alpha;
this.y += (v.y - this.y) * alpha;
this.z += (v.z - this.z) * alpha;
return this;}),
        'lerpVectors': ($__.fs.J$__v494107025_434_489 = function J$__v494107025_434(v1, v2, alpha) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
v1 = arguments[0], v2 = arguments[1], alpha = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);}),
        'cross': ($__.fs.J$__v494107025_436_490 = function J$__v494107025_436(v, w) {
var vvv_return, vvv_switch, x, y, z;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
v = arguments[0], w = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (w !== undefined) {
    console.warn('THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.');
    return this.crossVectors(v, w);
}
x = this.x;
y = this.y;
z = this.z;
this.x = y * v.z - z * v.y;
this.y = z * v.x - x * v.z;
this.z = x * v.y - y * v.x;
return this;}),
        'crossVectors': ($__.fs.J$__v494107025_438_491 = function J$__v494107025_438(a, b) {
var vvv_return, vvv_switch, ax, ay, az, bx, by, bz;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
a = arguments[0], b = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
ax = a.x;
ay = a.y;
az = a.z;
bx = b.x;
by = b.y;
bz = b.z;
this.x = ay * bz - az * by;
this.y = az * bx - ax * bz;
this.z = ax * by - ay * bx;
return this;}),
        'projectOnVector': ($__.fs.J$__v494107025_440_492 = function J$__v494107025_440(vector) {
var vvv_return, vvv_switch, scalar;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
vector = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
scalar = vector.dot(this) / vector.lengthSq();
return this.copy(vector).multiplyScalar(scalar);}),
        'projectOnPlane': (($__.fs.J$__v494107025_443_493 = function J$__v494107025_443() {
var vvv_return, vvv_switch, v1;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    return ($__.fs.projectOnPlane_494 = function projectOnPlane(planeNormal) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
planeNormal = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (v1 === undefined)
    v1 = new Vector3();
v1.copy(this).projectOnVector(planeNormal);
return this.sub(v1);});
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return function projectOnPlane(planeNormal) {
    if (v1 === undefined)
        v1 = new Vector3();
    v1.copy(this).projectOnVector(planeNormal);
    return this.sub(v1);
};}), $__.fs.J$__v494107025_443_493)(0, true, $__.uid),
        'reflect': (($__.fs.J$__v494107025_446_495 = function J$__v494107025_446() {
var vvv_return, vvv_switch, v1;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    return ($__.fs.reflect_496 = function reflect(normal) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
normal = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (v1 === undefined)
    v1 = new Vector3();
return this.sub(v1.copy(normal).multiplyScalar(2 * this.dot(normal)));});
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return function reflect(normal) {
    if (v1 === undefined)
        v1 = new Vector3();
    return this.sub(v1.copy(normal).multiplyScalar(2 * this.dot(normal)));
};}), $__.fs.J$__v494107025_446_495)(0, true, $__.uid),
        'angleTo': ($__.fs.J$__v494107025_448_497 = function J$__v494107025_448(v) {
var vvv_return, vvv_switch, theta;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
v = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
theta = this.dot(v) / Math.sqrt(this.lengthSq() * v.lengthSq());
return Math.acos(exports.Math.clamp(theta, -1, 1));}),
        'distanceTo': ($__.fs.J$__v494107025_450_498 = function J$__v494107025_450(v) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
v = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return Math.sqrt(this.distanceToSquared(v));}),
        'distanceToSquared': ($__.fs.J$__v494107025_452_499 = function J$__v494107025_452(v) {
var vvv_return, vvv_switch, dx, dy, dz;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
v = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
dx = this.x - v.x;
dy = this.y - v.y;
dz = this.z - v.z;
return dx * dx + dy * dy + dz * dz;}),
        'distanceToManhattan': ($__.fs.J$__v494107025_454_500 = function J$__v494107025_454(v) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
v = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z);}),
        'setFromSpherical': ($__.fs.J$__v494107025_456_501 = function J$__v494107025_456(s) {
var vvv_return, vvv_switch, sinPhiRadius;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
s = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
sinPhiRadius = Math.sin(s.phi) * s.radius;
this.x = sinPhiRadius * Math.sin(s.theta);
this.y = Math.cos(s.phi) * s.radius;
this.z = sinPhiRadius * Math.cos(s.theta);
return this;}),
        'setFromMatrixPosition': ($__.fs.J$__v494107025_458_502 = function J$__v494107025_458(m) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
m = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return this.setFromMatrixColumn(m, 3);}),
        'setFromMatrixScale': ($__.fs.J$__v494107025_460_503 = function J$__v494107025_460(m) {
var vvv_return, vvv_switch, sx, sy, sz;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
m = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
sx = this.setFromMatrixColumn(m, 0).length();
sy = this.setFromMatrixColumn(m, 1).length();
sz = this.setFromMatrixColumn(m, 2).length();
this.x = sx;
this.y = sy;
this.z = sz;
return this;}),
        'setFromMatrixColumn': ($__.fs.J$__v494107025_462_504 = function J$__v494107025_462(m, index) {
var vvv_return, vvv_switch, temp;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
m = arguments[0], index = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (typeof m === 'number') {
    console.warn('THREE.Vector3: setFromMatrixColumn now expects ( matrix, index ).');
    temp = m;
    m = index;
    index = temp;
}
return this.fromArray(m.elements, index * 4);}),
        'equals': ($__.fs.J$__v494107025_464_505 = function J$__v494107025_464(v) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
v = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return v.x === this.x && v.y === this.y && v.z === this.z;}),
        'fromArray': ($__.fs.J$__v494107025_466_506 = function J$__v494107025_466(array, offset) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
array = arguments[0], offset = arguments[1];
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    offset === undefined;
    this.x = (array[offset, 0], 0);
    this.y = (array[offset + 1, 1], 0.5);
    this.z = (array[offset + 2, 2], 0);
    return this;
case 1:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 1);
    offset === undefined;
    this.x = (array[offset, 3], 0);
    this.y = (array[offset + 1, 4], 0.5);
    this.z = (array[offset + 2, 5], 0);
    return this;
case 2:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 2);
    offset === undefined;
    this.x = (array[offset, 6], 0);
    this.y = (array[offset + 1, 7], 0.5);
    this.z = (array[offset + 2, 8], 0);
    return this;
case 3:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 3);
    offset === undefined;
    this.x = (array[offset, 9], 0);
    this.y = (array[offset + 1, 10], 0.5);
    this.z = (array[offset + 2, 11], 0);
    return this;
case 4:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 4);
    offset === undefined;
    this.x = (array[offset, 12], 0);
    this.y = (array[offset + 1, 13], 0.5);
    this.z = (array[offset + 2, 14], 0);
    return this;
case 5:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 5);
    offset === undefined;
    this.x = (array[offset, 15], 0);
    this.y = (array[offset + 1, 16], 0.5);
    this.z = (array[offset + 2, 17], 0);
    return this;
case 6:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 6);
    offset === undefined;
    this.x = (array[offset, 18], 0);
    this.y = (array[offset + 1, 19], -0.5);
    this.z = (array[offset + 2, 20], 0.5);
    return this;
case 7:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 7);
    offset === undefined;
    this.x = (array[offset, 21], 0.4755282700061798);
    this.y = (array[offset + 1, 22], -0.5);
    this.z = (array[offset + 2, 23], 0.15450850129127502);
    return this;
case 8:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 8);
    offset === undefined;
    this.x = (array[offset, 24], 0.29389262199401855);
    this.y = (array[offset + 1, 25], -0.5);
    this.z = (array[offset + 2, 26], -0.404508501291275);
    return this;
case 9:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 9);
    offset === undefined;
    this.x = (array[offset, 27], -0.29389262199401855);
    this.y = (array[offset + 1, 28], -0.5);
    this.z = (array[offset + 2, 29], -0.404508501291275);
    return this;
case 10:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 10);
    offset === undefined;
    this.x = (array[offset, 30], -0.4755282700061798);
    this.y = (array[offset + 1, 31], -0.5);
    this.z = (array[offset + 2, 32], 0.15450850129127502);
    return this;
case 11:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 11);
    offset === undefined;
    this.x = (array[offset, 33], -1.2246468525851679e-16);
    this.y = (array[offset + 1, 34], -0.5);
    this.z = (array[offset + 2, 35], 0.5);
    return this;
case 12:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 12);
    offset === undefined;
    this.x = (array[offset, 36], 0);
    this.y = (array[offset + 1, 37], -0.5);
    this.z = (array[offset + 2, 38], 0);
    return this;
case 13:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 13);
    offset === undefined;
    this.x = (array[offset, 39], 0);
    this.y = (array[offset + 1, 40], -0.5);
    this.z = (array[offset + 2, 41], 0);
    return this;
case 14:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 14);
    offset === undefined;
    this.x = (array[offset, 42], 0);
    this.y = (array[offset + 1, 43], -0.5);
    this.z = (array[offset + 2, 44], 0);
    return this;
case 15:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 15);
    offset === undefined;
    this.x = (array[offset, 45], 0);
    this.y = (array[offset + 1, 46], -0.5);
    this.z = (array[offset + 2, 47], 0);
    return this;
case 16:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 16);
    offset === undefined;
    this.x = (array[offset, 48], 0);
    this.y = (array[offset + 1, 49], -0.5);
    this.z = (array[offset + 2, 50], 0);
    return this;
case 17:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 17);
    offset === undefined;
    this.x = (array[offset, 51], 0);
    this.y = (array[offset + 1, 52], -0.5);
    this.z = (array[offset + 2, 53], 0.5);
    return this;
case 18:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 18);
    offset === undefined;
    this.x = (array[offset, 54], 0.4755282700061798);
    this.y = (array[offset + 1, 55], -0.5);
    this.z = (array[offset + 2, 56], 0.15450850129127502);
    return this;
case 19:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 19);
    offset === undefined;
    this.x = (array[offset, 57], 0.29389262199401855);
    this.y = (array[offset + 1, 58], -0.5);
    this.z = (array[offset + 2, 59], -0.404508501291275);
    return this;
case 20:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 20);
    offset === undefined;
    this.x = (array[offset, 60], -0.29389262199401855);
    this.y = (array[offset + 1, 61], -0.5);
    this.z = (array[offset + 2, 62], -0.404508501291275);
    return this;
case 21:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 21);
    offset === undefined;
    this.x = (array[offset, 63], -0.4755282700061798);
    this.y = (array[offset + 1, 64], -0.5);
    this.z = (array[offset + 2, 65], 0.15450850129127502);
    return this;
case 22:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 22);
    offset === undefined;
    this.x = (array[offset, 66], -1.2246468525851679e-16);
    this.y = (array[offset + 1, 67], -0.5);
    this.z = (array[offset + 2, 68], 0.5);
    return this;
case 23:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 23);
    offset === undefined;
    this.x = (array[offset, 0], 0);
    this.y = (array[offset + 1, 1], 0.4472135901451111);
    this.z = (array[offset + 2, 2], 0.8944271802902222);
    return this;
case 24:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 24);
    offset === undefined;
    this.x = (array[offset, 3], 0.8506507873535156);
    this.y = (array[offset + 1, 4], 0.4472135901451111);
    this.z = (array[offset + 2, 5], 0.27639320492744446);
    return this;
case 25:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 25);
    offset === undefined;
    this.x = (array[offset, 6], 0.525731086730957);
    this.y = (array[offset + 1, 7], 0.4472135901451111);
    this.z = (array[offset + 2, 8], -0.7236068248748779);
    return this;
case 26:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 26);
    offset === undefined;
    this.x = (array[offset, 9], -0.525731086730957);
    this.y = (array[offset + 1, 10], 0.4472135901451111);
    this.z = (array[offset + 2, 11], -0.7236068248748779);
    return this;
case 27:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 27);
    offset === undefined;
    this.x = (array[offset, 12], -0.8506507873535156);
    this.y = (array[offset + 1, 13], 0.4472135901451111);
    this.z = (array[offset + 2, 14], 0.27639320492744446);
    return this;
case 28:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 28);
    offset === undefined;
    this.x = (array[offset, 15], -2.190714795754993e-16);
    this.y = (array[offset + 1, 16], 0.4472135901451111);
    this.z = (array[offset + 2, 17], 0.8944271802902222);
    return this;
case 29:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 29);
    offset === undefined;
    this.x = (array[offset, 18], 0);
    this.y = (array[offset + 1, 19], 0.4472135901451111);
    this.z = (array[offset + 2, 20], 0.8944271802902222);
    return this;
case 30:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 30);
    offset === undefined;
    this.x = (array[offset, 21], 0.8506507873535156);
    this.y = (array[offset + 1, 22], 0.4472135901451111);
    this.z = (array[offset + 2, 23], 0.27639320492744446);
    return this;
case 31:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 31);
    offset === undefined;
    this.x = (array[offset, 24], 0.525731086730957);
    this.y = (array[offset + 1, 25], 0.4472135901451111);
    this.z = (array[offset + 2, 26], -0.7236068248748779);
    return this;
case 32:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 32);
    offset === undefined;
    this.x = (array[offset, 27], -0.525731086730957);
    this.y = (array[offset + 1, 28], 0.4472135901451111);
    this.z = (array[offset + 2, 29], -0.7236068248748779);
    return this;
case 33:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 33);
    offset === undefined;
    this.x = (array[offset, 30], -0.8506507873535156);
    this.y = (array[offset + 1, 31], 0.4472135901451111);
    this.z = (array[offset + 2, 32], 0.27639320492744446);
    return this;
case 34:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 34);
    offset === undefined;
    this.x = (array[offset, 33], -2.190714795754993e-16);
    this.y = (array[offset + 1, 34], 0.4472135901451111);
    this.z = (array[offset + 2, 35], 0.8944271802902222);
    return this;
case 35:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 35);
    offset === undefined;
    this.x = (array[offset, 36], 0);
    this.y = (array[offset + 1, 37], -1);
    this.z = (array[offset + 2, 38], 0);
    return this;
case 36:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 36);
    offset === undefined;
    this.x = (array[offset, 39], 0);
    this.y = (array[offset + 1, 40], -1);
    this.z = (array[offset + 2, 41], 0);
    return this;
case 37:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 37);
    offset === undefined;
    this.x = (array[offset, 42], 0);
    this.y = (array[offset + 1, 43], -1);
    this.z = (array[offset + 2, 44], 0);
    return this;
case 38:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 38);
    offset === undefined;
    this.x = (array[offset, 45], 0);
    this.y = (array[offset + 1, 46], -1);
    this.z = (array[offset + 2, 47], 0);
    return this;
case 39:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 39);
    offset === undefined;
    this.x = (array[offset, 48], 0);
    this.y = (array[offset + 1, 49], -1);
    this.z = (array[offset + 2, 50], 0);
    return this;
case 40:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 40);
    offset === undefined;
    this.x = (array[offset, 51], 0);
    this.y = (array[offset + 1, 52], -1);
    this.z = (array[offset + 2, 53], 0);
    return this;
case 41:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 41);
    offset === undefined;
    this.x = (array[offset, 54], 0);
    this.y = (array[offset + 1, 55], -1);
    this.z = (array[offset + 2, 56], 0);
    return this;
case 42:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 42);
    offset === undefined;
    this.x = (array[offset, 57], 0);
    this.y = (array[offset + 1, 58], -1);
    this.z = (array[offset + 2, 59], 0);
    return this;
case 43:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 43);
    offset === undefined;
    this.x = (array[offset, 60], 0);
    this.y = (array[offset + 1, 61], -1);
    this.z = (array[offset + 2, 62], 0);
    return this;
case 44:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 44);
    offset === undefined;
    this.x = (array[offset, 63], 0);
    this.y = (array[offset + 1, 64], -1);
    this.z = (array[offset + 2, 65], 0);
    return this;
case 45:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 45);
    offset === undefined;
    this.x = (array[offset, 66], 0);
    this.y = (array[offset + 1, 67], -1);
    this.z = (array[offset + 2, 68], 0);
    return this;
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (offset === undefined)
    offset = 0;
this.x = array[offset];
this.y = array[offset + 1];
this.z = array[offset + 2];
return this;}),
        'toArray': ($__.fs.J$__v494107025_468_507 = function J$__v494107025_468(array, offset) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
array = arguments[0], offset = arguments[1];
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    array === undefined;
    offset === undefined;
    array[offset, 0] = (this.x, 0);
    array[offset + 1, 1] = (this.y, 0);
    array[offset + 2, 2] = (this.z, 0);
    return array;
case 1:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 1);
    array === undefined;
    offset === undefined;
    array[offset, 3] = (this.x, 0);
    array[offset + 1, 4] = (this.y, 0);
    array[offset + 2, 5] = (this.z, 0);
    return array;
case 2:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 2);
    array === undefined;
    offset === undefined;
    array[offset, 6] = (this.x, 0);
    array[offset + 1, 7] = (this.y, 0);
    array[offset + 2, 8] = (this.z, 0);
    return array;
case 3:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 3);
    array === undefined;
    offset === undefined;
    array[offset, 9] = (this.x, 0);
    array[offset + 1, 10] = (this.y, 0);
    array[offset + 2, 11] = (this.z, 0);
    return array;
case 4:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 4);
    array === undefined;
    offset === undefined;
    array[offset, 12] = (this.x, 0);
    array[offset + 1, 13] = (this.y, 0);
    array[offset + 2, 14] = (this.z, 0);
    return array;
case 5:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 5);
    array === undefined;
    offset === undefined;
    array[offset, 15] = (this.x, 0);
    array[offset + 1, 16] = (this.y, 0);
    array[offset + 2, 17] = (this.z, 0);
    return array;
case 6:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 6);
    array === undefined;
    offset === undefined;
    array[offset, 18] = (this.x, 0);
    array[offset + 1, 19] = (this.y, -1);
    array[offset + 2, 20] = (this.z, 0.5);
    return array;
case 7:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 7);
    array === undefined;
    offset === undefined;
    array[offset, 21] = (this.x, 0.4755282700061798);
    array[offset + 1, 22] = (this.y, -1);
    array[offset + 2, 23] = (this.z, 0.15450850129127502);
    return array;
case 8:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 8);
    array === undefined;
    offset === undefined;
    array[offset, 24] = (this.x, 0.29389262199401855);
    array[offset + 1, 25] = (this.y, -1);
    array[offset + 2, 26] = (this.z, -0.404508501291275);
    return array;
case 9:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 9);
    array === undefined;
    offset === undefined;
    array[offset, 27] = (this.x, -0.29389262199401855);
    array[offset + 1, 28] = (this.y, -1);
    array[offset + 2, 29] = (this.z, -0.404508501291275);
    return array;
case 10:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 10);
    array === undefined;
    offset === undefined;
    array[offset, 30] = (this.x, -0.4755282700061798);
    array[offset + 1, 31] = (this.y, -1);
    array[offset + 2, 32] = (this.z, 0.15450850129127502);
    return array;
case 11:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 11);
    array === undefined;
    offset === undefined;
    array[offset, 33] = (this.x, -1.2246468525851679e-16);
    array[offset + 1, 34] = (this.y, -1);
    array[offset + 2, 35] = (this.z, 0.5);
    return array;
case 12:
case 35:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(12 <= vvv_switch && vvv_switch <= 35);
    array === undefined;
    offset === undefined;
    array[offset, 36] = (this.x, 0);
    array[offset + 1, 37] = (this.y, -1);
    array[offset + 2, 38] = (this.z, 0);
    return array;
case 13:
case 36:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(13 <= vvv_switch && vvv_switch <= 36);
    array === undefined;
    offset === undefined;
    array[offset, 39] = (this.x, 0);
    array[offset + 1, 40] = (this.y, -1);
    array[offset + 2, 41] = (this.z, 0);
    return array;
case 14:
case 37:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(14 <= vvv_switch && vvv_switch <= 37);
    array === undefined;
    offset === undefined;
    array[offset, 42] = (this.x, 0);
    array[offset + 1, 43] = (this.y, -1);
    array[offset + 2, 44] = (this.z, 0);
    return array;
case 15:
case 38:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(15 <= vvv_switch && vvv_switch <= 38);
    array === undefined;
    offset === undefined;
    array[offset, 45] = (this.x, 0);
    array[offset + 1, 46] = (this.y, -1);
    array[offset + 2, 47] = (this.z, 0);
    return array;
case 16:
case 39:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(16 <= vvv_switch && vvv_switch <= 39);
    array === undefined;
    offset === undefined;
    array[offset, 48] = (this.x, 0);
    array[offset + 1, 49] = (this.y, -1);
    array[offset + 2, 50] = (this.z, 0);
    return array;
case 17:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 17);
    array === undefined;
    offset === undefined;
    array[offset, 51] = (this.x, 0);
    array[offset + 1, 52] = (this.y, -1);
    array[offset + 2, 53] = (this.z, 0.5);
    return array;
case 18:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 18);
    array === undefined;
    offset === undefined;
    array[offset, 54] = (this.x, 0.4755282700061798);
    array[offset + 1, 55] = (this.y, -1);
    array[offset + 2, 56] = (this.z, 0.15450850129127502);
    return array;
case 19:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 19);
    array === undefined;
    offset === undefined;
    array[offset, 57] = (this.x, 0.29389262199401855);
    array[offset + 1, 58] = (this.y, -1);
    array[offset + 2, 59] = (this.z, -0.404508501291275);
    return array;
case 20:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 20);
    array === undefined;
    offset === undefined;
    array[offset, 60] = (this.x, -0.29389262199401855);
    array[offset + 1, 61] = (this.y, -1);
    array[offset + 2, 62] = (this.z, -0.404508501291275);
    return array;
case 21:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 21);
    array === undefined;
    offset === undefined;
    array[offset, 63] = (this.x, -0.4755282700061798);
    array[offset + 1, 64] = (this.y, -1);
    array[offset + 2, 65] = (this.z, 0.15450850129127502);
    return array;
case 22:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 22);
    array === undefined;
    offset === undefined;
    array[offset, 66] = (this.x, -1.2246468525851679e-16);
    array[offset + 1, 67] = (this.y, -1);
    array[offset + 2, 68] = (this.z, 0.5);
    return array;
case 23:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 23);
    array === undefined;
    offset === undefined;
    array[offset, 0] = (this.x, 0);
    array[offset + 1, 1] = (this.y, 0.4472135901451111);
    array[offset + 2, 2] = (this.z, 0.8944271802902222);
    return array;
case 24:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 24);
    array === undefined;
    offset === undefined;
    array[offset, 3] = (this.x, 0.8506507873535156);
    array[offset + 1, 4] = (this.y, 0.4472135901451111);
    array[offset + 2, 5] = (this.z, 0.27639320492744446);
    return array;
case 25:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 25);
    array === undefined;
    offset === undefined;
    array[offset, 6] = (this.x, 0.525731086730957);
    array[offset + 1, 7] = (this.y, 0.4472135901451111);
    array[offset + 2, 8] = (this.z, -0.7236068248748779);
    return array;
case 26:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 26);
    array === undefined;
    offset === undefined;
    array[offset, 9] = (this.x, -0.525731086730957);
    array[offset + 1, 10] = (this.y, 0.4472135901451111);
    array[offset + 2, 11] = (this.z, -0.7236068248748779);
    return array;
case 27:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 27);
    array === undefined;
    offset === undefined;
    array[offset, 12] = (this.x, -0.8506507873535156);
    array[offset + 1, 13] = (this.y, 0.4472135901451111);
    array[offset + 2, 14] = (this.z, 0.27639320492744446);
    return array;
case 28:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 28);
    array === undefined;
    offset === undefined;
    array[offset, 15] = (this.x, -2.190714795754993e-16);
    array[offset + 1, 16] = (this.y, 0.4472135901451111);
    array[offset + 2, 17] = (this.z, 0.8944271802902222);
    return array;
case 29:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 29);
    array === undefined;
    offset === undefined;
    array[offset, 18] = (this.x, 0);
    array[offset + 1, 19] = (this.y, 0.4472135901451111);
    array[offset + 2, 20] = (this.z, 0.8944271802902222);
    return array;
case 30:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 30);
    array === undefined;
    offset === undefined;
    array[offset, 21] = (this.x, 0.8506507873535156);
    array[offset + 1, 22] = (this.y, 0.4472135901451111);
    array[offset + 2, 23] = (this.z, 0.27639320492744446);
    return array;
case 31:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 31);
    array === undefined;
    offset === undefined;
    array[offset, 24] = (this.x, 0.525731086730957);
    array[offset + 1, 25] = (this.y, 0.4472135901451111);
    array[offset + 2, 26] = (this.z, -0.7236068248748779);
    return array;
case 32:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 32);
    array === undefined;
    offset === undefined;
    array[offset, 27] = (this.x, -0.525731086730957);
    array[offset + 1, 28] = (this.y, 0.4472135901451111);
    array[offset + 2, 29] = (this.z, -0.7236068248748779);
    return array;
case 33:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 33);
    array === undefined;
    offset === undefined;
    array[offset, 30] = (this.x, -0.8506507873535156);
    array[offset + 1, 31] = (this.y, 0.4472135901451111);
    array[offset + 2, 32] = (this.z, 0.27639320492744446);
    return array;
case 34:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 34);
    array === undefined;
    offset === undefined;
    array[offset, 33] = (this.x, -2.190714795754993e-16);
    array[offset + 1, 34] = (this.y, 0.4472135901451111);
    array[offset + 2, 35] = (this.z, 0.8944271802902222);
    return array;
case 40:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 40);
    array === undefined;
    offset === undefined;
    array[offset, 51] = (this.x, 0);
    array[offset + 1, 52] = (this.y, -1);
    array[offset + 2, 53] = (this.z, 0);
    return array;
case 41:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 41);
    array === undefined;
    offset === undefined;
    array[offset, 54] = (this.x, 0);
    array[offset + 1, 55] = (this.y, -1);
    array[offset + 2, 56] = (this.z, 0);
    return array;
case 42:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 42);
    array === undefined;
    offset === undefined;
    array[offset, 57] = (this.x, 0);
    array[offset + 1, 58] = (this.y, -1);
    array[offset + 2, 59] = (this.z, 0);
    return array;
case 43:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 43);
    array === undefined;
    offset === undefined;
    array[offset, 60] = (this.x, 0);
    array[offset + 1, 61] = (this.y, -1);
    array[offset + 2, 62] = (this.z, 0);
    return array;
case 44:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 44);
    array === undefined;
    offset === undefined;
    array[offset, 63] = (this.x, 0);
    array[offset + 1, 64] = (this.y, -1);
    array[offset + 2, 65] = (this.z, 0);
    return array;
case 45:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 45);
    array === undefined;
    offset === undefined;
    array[offset, 66] = (this.x, 0);
    array[offset + 1, 67] = (this.y, -1);
    array[offset + 2, 68] = (this.z, 0);
    return array;
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (array === undefined)
    array = [];
if (offset === undefined)
    offset = 0;
array[offset] = this.x;
array[offset + 1] = this.y;
array[offset + 2] = this.z;
return array;}),
        'fromAttribute': ($__.fs.J$__v494107025_470_508 = function J$__v494107025_470(attribute, index, offset) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
attribute = arguments[0], index = arguments[1], offset = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (offset === undefined)
    offset = 0;
index = index * attribute.itemSize + offset;
this.x = attribute.array[index];
this.y = attribute.array[index + 1];
this.z = attribute.array[index + 2];
return this;})
    };
    Box2.prototype = $__.os.oid10 = {
        'constructor': Box2,
        'set': ($__.fs.J$__v494107025_479_509 = function J$__v494107025_479(min, max) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
min = arguments[0], max = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.min.copy(min);
this.max.copy(max);
return this;}),
        'setFromPoints': ($__.fs.J$__v494107025_481_510 = function J$__v494107025_481(points) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
points = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.makeEmpty();
for (var i = 0, il = points.length; i < il; i++) {
    this.expandByPoint(points[i]);
}
return this;}),
        'setFromCenterAndSize': (($__.fs.J$__v494107025_484_511 = function J$__v494107025_484() {
var vvv_return, vvv_switch, v1;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    v1 = new (Vector2, $__.fs.Vector2_6)(0, true, $__.uid);
    return ($__.fs.setFromCenterAndSize_512 = function setFromCenterAndSize(center, size) {
var vvv_return, vvv_switch, halfSize;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
center = arguments[0], size = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
halfSize = v1.copy(size).multiplyScalar(0.5);
this.min.copy(center).sub(halfSize);
this.max.copy(center).add(halfSize);
return this;});
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
v1 = new Vector2();
return function setFromCenterAndSize(center, size) {
    var halfSize = v1.copy(size).multiplyScalar(0.5);
    this.min.copy(center).sub(halfSize);
    this.max.copy(center).add(halfSize);
    return this;
};}), $__.fs.J$__v494107025_484_511)(0, true, $__.uid),
        'clone': ($__.fs.J$__v494107025_486_513 = function J$__v494107025_486() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return new this.constructor().copy(this);}),
        'copy': ($__.fs.J$__v494107025_488_514 = function J$__v494107025_488(box) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
box = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.min.copy(box.min);
this.max.copy(box.max);
return this;}),
        'makeEmpty': ($__.fs.J$__v494107025_490_515 = function J$__v494107025_490() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.min.x = this.min.y = +Infinity;
this.max.x = this.max.y = -Infinity;
return this;}),
        'isEmpty': ($__.fs.J$__v494107025_492_516 = function J$__v494107025_492() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return this.max.x < this.min.x || this.max.y < this.min.y;}),
        'center': ($__.fs.J$__v494107025_494_517 = function J$__v494107025_494(optionalTarget) {
var vvv_return, vvv_switch, result;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
optionalTarget = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
result = optionalTarget || new Vector2();
return result.addVectors(this.min, this.max).multiplyScalar(0.5);}),
        'size': ($__.fs.J$__v494107025_496_518 = function J$__v494107025_496(optionalTarget) {
var vvv_return, vvv_switch, result;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
optionalTarget = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
result = optionalTarget || new Vector2();
return result.subVectors(this.max, this.min);}),
        'expandByPoint': ($__.fs.J$__v494107025_498_519 = function J$__v494107025_498(point) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
point = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.min.min(point);
this.max.max(point);
return this;}),
        'expandByVector': ($__.fs.J$__v494107025_500_520 = function J$__v494107025_500(vector) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
vector = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.min.sub(vector);
this.max.add(vector);
return this;}),
        'expandByScalar': ($__.fs.J$__v494107025_502_521 = function J$__v494107025_502(scalar) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
scalar = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.min.addScalar(-scalar);
this.max.addScalar(scalar);
return this;}),
        'containsPoint': ($__.fs.J$__v494107025_504_522 = function J$__v494107025_504(point) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
point = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y) {
    return false;
}
return true;}),
        'containsBox': ($__.fs.J$__v494107025_506_523 = function J$__v494107025_506(box) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
box = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y) {
    return true;
}
return false;}),
        'getParameter': ($__.fs.J$__v494107025_508_524 = function J$__v494107025_508(point, optionalTarget) {
var vvv_return, vvv_switch, result;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
point = arguments[0], optionalTarget = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
result = optionalTarget || new Vector2();
return result.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y));}),
        'intersectsBox': ($__.fs.J$__v494107025_510_525 = function J$__v494107025_510(box) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
box = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y) {
    return false;
}
return true;}),
        'clampPoint': ($__.fs.J$__v494107025_512_526 = function J$__v494107025_512(point, optionalTarget) {
var vvv_return, vvv_switch, result;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
point = arguments[0], optionalTarget = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
result = optionalTarget || new Vector2();
return result.copy(point).clamp(this.min, this.max);}),
        'distanceToPoint': (($__.fs.J$__v494107025_515_527 = function J$__v494107025_515() {
var vvv_return, vvv_switch, v1;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    v1 = new (Vector2, $__.fs.Vector2_6)(1, true, $__.uid);
    return ($__.fs.distanceToPoint_528 = function distanceToPoint(point) {
var vvv_return, vvv_switch, clampedPoint;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
point = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
clampedPoint = v1.copy(point).clamp(this.min, this.max);
return clampedPoint.sub(point).length();});
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
v1 = new Vector2();
return function distanceToPoint(point) {
    var clampedPoint = v1.copy(point).clamp(this.min, this.max);
    return clampedPoint.sub(point).length();
};}), $__.fs.J$__v494107025_515_527)(0, true, $__.uid),
        'intersect': ($__.fs.J$__v494107025_517_529 = function J$__v494107025_517(box) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
box = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.min.max(box.min);
this.max.min(box.max);
return this;}),
        'union': ($__.fs.J$__v494107025_519_530 = function J$__v494107025_519(box) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
box = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.min.min(box.min);
this.max.max(box.max);
return this;}),
        'translate': ($__.fs.J$__v494107025_521_531 = function J$__v494107025_521(offset) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
offset = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.min.add(offset);
this.max.add(offset);
return this;}),
        'equals': ($__.fs.J$__v494107025_523_532 = function J$__v494107025_523(box) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
box = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return box.min.equals(this.min) && box.max.equals(this.max);})
    };
    CubeTexture.prototype = Object['create']((Texture.prototype, $__.os.oid5));
    TAJS_restrictToType(CubeTexture.prototype, 'object').constructor = CubeTexture;
    TAJS_restrictToType(CubeTexture.prototype, 'object').isCubeTexture = true;
    Object['defineProperty'](TAJS_restrictToType(CubeTexture.prototype, 'object'), 'images', $__.os.oid11 = {
        'get': ($__.fs.J$__v494107025_531_533 = function J$__v494107025_531() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return this.image;}),
        'set': ($__.fs.J$__v494107025_533_534 = function J$__v494107025_533(value) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
value = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.image = value;})
    });
    emptyTexture = new (Texture, $__.fs.Texture_7)(0, true, $__.uid);
    emptyCubeTexture = new (CubeTexture, $__.fs.CubeTexture_15)(0, true, $__.uid);
    arrayCacheF32 = [];
    arrayCacheI32 = [];
    TAJS_restrictToType(StructuredUniform.prototype, 'object').setValue = ($__.fs.J$__v494107025_566_535 = function J$__v494107025_566(gl, value) {
var vvv_return, vvv_switch, seq, u;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
gl = arguments[0], value = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
seq = this.seq;
for (var i = 0, n = seq.length; i !== n; ++i) {
    u = seq[i];
    u.setValue(gl, value[u.id]);
}});
    RePathPart = /([\w\d_]+)(\])?(\[|\.)?/g;
    TAJS_restrictToType(WebGLUniforms.prototype, 'object').setValue = ($__.fs.J$__v494107025_571_536 = function J$__v494107025_571(gl, name, value) {
var vvv_return, vvv_switch, u;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
gl = arguments[0], name = arguments[1], value = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
u = this.map[name];
if (u !== undefined)
    u.setValue(gl, value, this.renderer);});
    TAJS_restrictToType(WebGLUniforms.prototype, 'object').set = ($__.fs.J$__v494107025_573_537 = function J$__v494107025_573(gl, object, name) {
var vvv_return, vvv_switch, u;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
gl = arguments[0], object = arguments[1], name = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
u = this.map[name];
if (u !== undefined)
    u.setValue(gl, object[name], this.renderer);});
    TAJS_restrictToType(WebGLUniforms.prototype, 'object').setOptional = ($__.fs.J$__v494107025_575_538 = function J$__v494107025_575(gl, object, name) {
var vvv_return, vvv_switch, v;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
gl = arguments[0], object = arguments[1], name = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
v = object[name];
if (v !== undefined)
    this.setValue(gl, name, v);});
    WebGLUniforms.upload = ($__.fs.J$__v494107025_577_539 = function J$__v494107025_577(gl, seq, values, renderer) {
var vvv_return, vvv_switch, u, v;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
gl = arguments[0], seq = arguments[1], values = arguments[2], renderer = arguments[3];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
for (var i = 0, n = seq.length; i !== n; ++i) {
    u = seq[i];
    v = values[u.id];
    if (v.needsUpdate !== false) {
        u.setValue(gl, v.value, renderer);
    }
}});
    WebGLUniforms.seqWithValue = ($__.fs.J$__v494107025_579_540 = function J$__v494107025_579(seq, values) {
var vvv_return, vvv_switch, r, u;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
seq = arguments[0], values = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
r = [];
for (var i = 0, n = seq.length; i !== n; ++i) {
    u = seq[i];
    if (u.id in values)
        r.push(u);
}
return r;});
    WebGLUniforms.splitDynamic = ($__.fs.J$__v494107025_581_541 = function J$__v494107025_581(seq, values) {
var vvv_return, vvv_switch, r, n, w, u, v;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
seq = arguments[0], values = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
r = null;
n = seq.length;
w = 0;
for (var i = 0; i !== n; ++i) {
    u = seq[i];
    v = values[u.id];
    if (v && v.dynamic === true) {
        if (r === null)
            r = [];
        r.push(u);
    } else {
        if (w < i)
            seq[w] = u;
        ++w;
    }
}
if (w < n)
    seq.length = w;
return r;});
    WebGLUniforms.evalDynamic = ($__.fs.J$__v494107025_583_542 = function J$__v494107025_583(seq, values, object, camera) {
var vvv_return, vvv_switch, v, f;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
seq = arguments[0], values = arguments[1], object = arguments[2], camera = arguments[3];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
for (var i = 0, n = seq.length; i !== n; ++i) {
    v = values[seq[i].id];
    f = v.onUpdateCallback;
    if (f !== undefined)
        f.call(v, object, camera);
}});
    Vector4.prototype = $__.os.oid14 = {
        'constructor': Vector4,
        'isVector4': true,
        'set': ($__.fs.J$__v494107025_607_543 = function J$__v494107025_607(x, y, z, w) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
x = arguments[0], y = arguments[1], z = arguments[2], w = arguments[3];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.x = x;
this.y = y;
this.z = z;
this.w = w;
return this;}),
        'setScalar': ($__.fs.J$__v494107025_609_544 = function J$__v494107025_609(scalar) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
scalar = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.x = scalar;
this.y = scalar;
this.z = scalar;
this.w = scalar;
return this;}),
        'setX': ($__.fs.J$__v494107025_611_545 = function J$__v494107025_611(x) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
x = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.x = x;
return this;}),
        'setY': ($__.fs.J$__v494107025_613_546 = function J$__v494107025_613(y) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
y = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.y = y;
return this;}),
        'setZ': ($__.fs.J$__v494107025_615_547 = function J$__v494107025_615(z) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
z = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.z = z;
return this;}),
        'setW': ($__.fs.J$__v494107025_617_548 = function J$__v494107025_617(w) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
w = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.w = w;
return this;}),
        'setComponent': ($__.fs.J$__v494107025_619_549 = function J$__v494107025_619(index, value) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
index = arguments[0], value = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
switch (index) {
case 0:
    this.x = value;
    break;
case 1:
    this.y = value;
    break;
case 2:
    this.z = value;
    break;
case 3:
    this.w = value;
    break;
default:
    throw new Error('index is out of range: ' + index);
}}),
        'getComponent': ($__.fs.J$__v494107025_621_550 = function J$__v494107025_621(index) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
index = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
switch (index) {
case 0:
    return this.x;
case 1:
    return this.y;
case 2:
    return this.z;
case 3:
    return this.w;
default:
    throw new Error('index is out of range: ' + index);
}}),
        'clone': ($__.fs.J$__v494107025_623_551 = function J$__v494107025_623() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    return new $__.fs.Vector4_51((this.x, 0), (this.y, 0), (this.z, 1), (this.w, 1), 2, true, $__.uid);
case 1:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 1);
    return new $__.fs.Vector4_51((this.x, 0), (this.y, 0), (this.z, 1), (this.w, 1), 3, true, $__.uid);
case 2:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 2);
    return new $__.fs.Vector4_51((this.x, 0), (this.y, 0), (this.z, 1), (this.w, 1), 4, true, $__.uid);
case 3:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 3);
    return new $__.fs.Vector4_51((this.x, 0), (this.y, 0), (this.z, 1), (this.w, 1), 5, true, $__.uid);
case 4:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 4);
    return new $__.fs.Vector4_51((this.x, 0), (this.y, 0), (this.z, 1), (this.w, 1), 6, true, $__.uid);
case 5:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 5);
    return new $__.fs.Vector4_51((this.x, 0), (this.y, 0), (this.z, 1), (this.w, 1), 7, true, $__.uid);
case 6:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 6);
    return new $__.fs.Vector4_51((this.x, 0), (this.y, 0), (this.z, 1), (this.w, 1), 8, true, $__.uid);
case 7:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 7);
    return new $__.fs.Vector4_51((this.x, 0), (this.y, 0), (this.z, 1), (this.w, 1), 9, true, $__.uid);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return new this.constructor(this.x, this.y, this.z, this.w);}),
        'copy': ($__.fs.J$__v494107025_625_552 = function J$__v494107025_625(v) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
v = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.x = v.x;
this.y = v.y;
this.z = v.z;
this.w = v.w !== undefined ? v.w : 1;
return this;}),
        'add': ($__.fs.J$__v494107025_627_553 = function J$__v494107025_627(v, w) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
v = arguments[0], w = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (w !== undefined) {
    console.warn('THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');
    return this.addVectors(v, w);
}
this.x += v.x;
this.y += v.y;
this.z += v.z;
this.w += v.w;
return this;}),
        'addScalar': ($__.fs.J$__v494107025_629_554 = function J$__v494107025_629(s) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
s = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.x += s;
this.y += s;
this.z += s;
this.w += s;
return this;}),
        'addVectors': ($__.fs.J$__v494107025_631_555 = function J$__v494107025_631(a, b) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
a = arguments[0], b = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.x = a.x + b.x;
this.y = a.y + b.y;
this.z = a.z + b.z;
this.w = a.w + b.w;
return this;}),
        'addScaledVector': ($__.fs.J$__v494107025_633_556 = function J$__v494107025_633(v, s) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
v = arguments[0], s = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.x += v.x * s;
this.y += v.y * s;
this.z += v.z * s;
this.w += v.w * s;
return this;}),
        'sub': ($__.fs.J$__v494107025_635_557 = function J$__v494107025_635(v, w) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
v = arguments[0], w = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (w !== undefined) {
    console.warn('THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');
    return this.subVectors(v, w);
}
this.x -= v.x;
this.y -= v.y;
this.z -= v.z;
this.w -= v.w;
return this;}),
        'subScalar': ($__.fs.J$__v494107025_637_558 = function J$__v494107025_637(s) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
s = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.x -= s;
this.y -= s;
this.z -= s;
this.w -= s;
return this;}),
        'subVectors': ($__.fs.J$__v494107025_639_559 = function J$__v494107025_639(a, b) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
a = arguments[0], b = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.x = a.x - b.x;
this.y = a.y - b.y;
this.z = a.z - b.z;
this.w = a.w - b.w;
return this;}),
        'multiplyScalar': ($__.fs.J$__v494107025_641_560 = function J$__v494107025_641(scalar) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
scalar = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (isFinite(scalar)) {
    this.x *= scalar;
    this.y *= scalar;
    this.z *= scalar;
    this.w *= scalar;
} else {
    this.x = 0;
    this.y = 0;
    this.z = 0;
    this.w = 0;
}
return this;}),
        'applyMatrix4': ($__.fs.J$__v494107025_643_561 = function J$__v494107025_643(m) {
var vvv_return, vvv_switch, x, y, z, w, e;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
m = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
x = this.x;
y = this.y;
z = this.z;
w = this.w;
e = m.elements;
this.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w;
this.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w;
this.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w;
this.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w;
return this;}),
        'divideScalar': ($__.fs.J$__v494107025_645_562 = function J$__v494107025_645(scalar) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
scalar = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return this.multiplyScalar(1 / scalar);}),
        'setAxisAngleFromQuaternion': ($__.fs.J$__v494107025_647_563 = function J$__v494107025_647(q) {
var vvv_return, vvv_switch, s;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
q = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.w = 2 * Math.acos(q.w);
s = Math.sqrt(1 - q.w * q.w);
if (s < 0.0001) {
    this.x = 1;
    this.y = 0;
    this.z = 0;
} else {
    this.x = q.x / s;
    this.y = q.y / s;
    this.z = q.z / s;
}
return this;}),
        'setAxisAngleFromRotationMatrix': ($__.fs.J$__v494107025_649_564 = function J$__v494107025_649(m) {
var vvv_return, vvv_switch, angle, x, y, z, epsilon, epsilon2, te, m11, m12, m13, m21, m22, m23, m31, m32, m33, xx, yy, zz, xy, xz, yz, s;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
m = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
epsilon = 0.01;
epsilon2 = 0.1;
te = m.elements;
m11 = te[0];
m12 = te[4];
m13 = te[8];
m21 = te[1];
m22 = te[5];
m23 = te[9];
m31 = te[2];
m32 = te[6];
m33 = te[10];
if (Math.abs(m12 - m21) < epsilon && Math.abs(m13 - m31) < epsilon && Math.abs(m23 - m32) < epsilon) {
    if (Math.abs(m12 + m21) < epsilon2 && Math.abs(m13 + m31) < epsilon2 && Math.abs(m23 + m32) < epsilon2 && Math.abs(m11 + m22 + m33 - 3) < epsilon2) {
        this.set(1, 0, 0, 0);
        return this;
    }
    angle = Math.PI;
    xx = (m11 + 1) / 2;
    yy = (m22 + 1) / 2;
    zz = (m33 + 1) / 2;
    xy = (m12 + m21) / 4;
    xz = (m13 + m31) / 4;
    yz = (m23 + m32) / 4;
    if (xx > yy && xx > zz) {
        if (xx < epsilon) {
            x = 0;
            y = 0.707106781;
            z = 0.707106781;
        } else {
            x = Math.sqrt(xx);
            y = xy / x;
            z = xz / x;
        }
    } else if (yy > zz) {
        if (yy < epsilon) {
            x = 0.707106781;
            y = 0;
            z = 0.707106781;
        } else {
            y = Math.sqrt(yy);
            x = xy / y;
            z = yz / y;
        }
    } else {
        if (zz < epsilon) {
            x = 0.707106781;
            y = 0.707106781;
            z = 0;
        } else {
            z = Math.sqrt(zz);
            x = xz / z;
            y = yz / z;
        }
    }
    this.set(x, y, z, angle);
    return this;
}
s = Math.sqrt((m32 - m23) * (m32 - m23) + (m13 - m31) * (m13 - m31) + (m21 - m12) * (m21 - m12));
if (Math.abs(s) < 0.001)
    s = 1;
this.x = (m32 - m23) / s;
this.y = (m13 - m31) / s;
this.z = (m21 - m12) / s;
this.w = Math.acos((m11 + m22 + m33 - 1) / 2);
return this;}),
        'min': ($__.fs.J$__v494107025_651_565 = function J$__v494107025_651(v) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
v = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.x = Math.min(this.x, v.x);
this.y = Math.min(this.y, v.y);
this.z = Math.min(this.z, v.z);
this.w = Math.min(this.w, v.w);
return this;}),
        'max': ($__.fs.J$__v494107025_653_566 = function J$__v494107025_653(v) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
v = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.x = Math.max(this.x, v.x);
this.y = Math.max(this.y, v.y);
this.z = Math.max(this.z, v.z);
this.w = Math.max(this.w, v.w);
return this;}),
        'clamp': ($__.fs.J$__v494107025_655_567 = function J$__v494107025_655(min, max) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
min = arguments[0], max = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.x = Math.max(min.x, Math.min(max.x, this.x));
this.y = Math.max(min.y, Math.min(max.y, this.y));
this.z = Math.max(min.z, Math.min(max.z, this.z));
this.w = Math.max(min.w, Math.min(max.w, this.w));
return this;}),
        'clampScalar': (($__.fs.J$__v494107025_658_568 = function J$__v494107025_658() {
var vvv_return, vvv_switch, min, max;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    return ($__.fs.clampScalar_569 = function clampScalar(minVal, maxVal) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
minVal = arguments[0], maxVal = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (min === undefined) {
    min = new Vector4();
    max = new Vector4();
}
min.set(minVal, minVal, minVal, minVal);
max.set(maxVal, maxVal, maxVal, maxVal);
return this.clamp(min, max);});
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return function clampScalar(minVal, maxVal) {
    if (min === undefined) {
        min = new Vector4();
        max = new Vector4();
    }
    min.set(minVal, minVal, minVal, minVal);
    max.set(maxVal, maxVal, maxVal, maxVal);
    return this.clamp(min, max);
};}), $__.fs.J$__v494107025_658_568)(0, true, $__.uid),
        'floor': ($__.fs.J$__v494107025_660_570 = function J$__v494107025_660() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.x = Math.floor(this.x);
this.y = Math.floor(this.y);
this.z = Math.floor(this.z);
this.w = Math.floor(this.w);
return this;}),
        'ceil': ($__.fs.J$__v494107025_662_571 = function J$__v494107025_662() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.x = Math.ceil(this.x);
this.y = Math.ceil(this.y);
this.z = Math.ceil(this.z);
this.w = Math.ceil(this.w);
return this;}),
        'round': ($__.fs.J$__v494107025_664_572 = function J$__v494107025_664() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.x = Math.round(this.x);
this.y = Math.round(this.y);
this.z = Math.round(this.z);
this.w = Math.round(this.w);
return this;}),
        'roundToZero': ($__.fs.J$__v494107025_666_573 = function J$__v494107025_666() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w);
return this;}),
        'negate': ($__.fs.J$__v494107025_668_574 = function J$__v494107025_668() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.x = -this.x;
this.y = -this.y;
this.z = -this.z;
this.w = -this.w;
return this;}),
        'dot': ($__.fs.J$__v494107025_670_575 = function J$__v494107025_670(v) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
v = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;}),
        'lengthSq': ($__.fs.J$__v494107025_672_576 = function J$__v494107025_672() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;}),
        'length': ($__.fs.J$__v494107025_674_577 = function J$__v494107025_674() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);}),
        'lengthManhattan': ($__.fs.J$__v494107025_676_578 = function J$__v494107025_676() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);}),
        'normalize': ($__.fs.J$__v494107025_678_579 = function J$__v494107025_678() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return this.divideScalar(this.length());}),
        'setLength': ($__.fs.J$__v494107025_680_580 = function J$__v494107025_680(length) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
length = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return this.multiplyScalar(length / this.length());}),
        'lerp': ($__.fs.J$__v494107025_682_581 = function J$__v494107025_682(v, alpha) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
v = arguments[0], alpha = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.x += (v.x - this.x) * alpha;
this.y += (v.y - this.y) * alpha;
this.z += (v.z - this.z) * alpha;
this.w += (v.w - this.w) * alpha;
return this;}),
        'lerpVectors': ($__.fs.J$__v494107025_684_582 = function J$__v494107025_684(v1, v2, alpha) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
v1 = arguments[0], v2 = arguments[1], alpha = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);}),
        'equals': ($__.fs.J$__v494107025_686_583 = function J$__v494107025_686(v) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
v = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return v.x === this.x && v.y === this.y && v.z === this.z && v.w === this.w;}),
        'fromArray': ($__.fs.J$__v494107025_688_584 = function J$__v494107025_688(array, offset) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
array = arguments[0], offset = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (offset === undefined)
    offset = 0;
this.x = array[offset];
this.y = array[offset + 1];
this.z = array[offset + 2];
this.w = array[offset + 3];
return this;}),
        'toArray': ($__.fs.J$__v494107025_690_585 = function J$__v494107025_690(array, offset) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
array = arguments[0], offset = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (array === undefined)
    array = [];
if (offset === undefined)
    offset = 0;
array[offset] = this.x;
array[offset + 1] = this.y;
array[offset + 2] = this.z;
array[offset + 3] = this.w;
return array;}),
        'fromAttribute': ($__.fs.J$__v494107025_692_586 = function J$__v494107025_692(attribute, index, offset) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
attribute = arguments[0], index = arguments[1], offset = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (offset === undefined)
    offset = 0;
index = index * attribute.itemSize + offset;
this.x = attribute.array[index];
this.y = attribute.array[index + 1];
this.z = attribute.array[index + 2];
this.w = attribute.array[index + 3];
return this;})
    };
    Object['assign'](TAJS_restrictToType(WebGLRenderTarget.prototype, 'object'), TAJS_restrictToType(EventDispatcher.prototype, 'object'), $__.os.oid15 = {
        'isWebGLRenderTarget': true,
        'setSize': ($__.fs.J$__v494107025_769_587 = function J$__v494107025_769(width, height) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
width = arguments[0], height = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (this.width !== width || this.height !== height) {
    this.width = width;
    this.height = height;
    this.dispose();
}
this.viewport.set(0, 0, width, height);
this.scissor.set(0, 0, width, height);}),
        'clone': ($__.fs.J$__v494107025_771_588 = function J$__v494107025_771() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return new this.constructor().copy(this);}),
        'copy': ($__.fs.J$__v494107025_773_589 = function J$__v494107025_773(source) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
source = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.width = source.width;
this.height = source.height;
this.viewport.copy(source.viewport);
this.texture = source.texture.clone();
this.depthBuffer = source.depthBuffer;
this.stencilBuffer = source.stencilBuffer;
this.depthTexture = source.depthTexture;
return this;}),
        'dispose': ($__.fs.J$__v494107025_775_590 = function J$__v494107025_775() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.dispatchEvent({
    type: 'dispose'
});})
    });
    Material.prototype = (vvv_tmp3 = {
        'constructor': Material,
        'isMaterial': true,
        'setValues': ($__.fs.J$__v494107025_782_591 = function J$__v494107025_782(values) {
var vvv_return, vvv_switch, newValue, currentValue;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
values = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (values === undefined)
    return;
for (var key in values) {
    newValue = values[key];
    if (newValue === undefined) {
        console.warn('THREE.Material: \'' + key + '\' parameter is undefined.');
        continue;
    }
    currentValue = this[key];
    if (currentValue === undefined) {
        console.warn('THREE.' + this.type + ': \'' + key + '\' is not a property of this material.');
        continue;
    }
    if (currentValue && currentValue.isColor) {
        currentValue.set(newValue);
    } else if (currentValue && currentValue.isVector3 && (newValue && newValue.isVector3)) {
        currentValue.copy(newValue);
    } else if (key === 'overdraw') {
        this[key] = Number(newValue);
    } else {
        this[key] = newValue;
    }
}}),
        'toJSON': ($__.fs.J$__v494107025_785_592 = function J$__v494107025_785(meta) {
var vvv_return, vvv_switch, isRoot, data, extractFromCache, textures, images;
extractFromCache = function extractFromCache(cache) {
    var values = [];
    for (var key in cache) {
        var data = cache[key];
        delete data.metadata;
        values.push(data);
    }
    return values;
};
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
meta = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
isRoot = meta === undefined;
if (isRoot) {
    meta = {
        textures: {},
        images: {}
    };
}
data = {
    metadata: {
        version: 4.4,
        type: 'Material',
        generator: 'Material.toJSON'
    }
};
data.uuid = this.uuid;
data.type = this.type;
if (this.name !== '')
    data.name = this.name;
if (this.color && this.color.isColor)
    data.color = this.color.getHex();
if (this.roughness !== undefined)
    data.roughness = this.roughness;
if (this.metalness !== undefined)
    data.metalness = this.metalness;
if (this.emissive && this.emissive.isColor)
    data.emissive = this.emissive.getHex();
if (this.specular && this.specular.isColor)
    data.specular = this.specular.getHex();
if (this.shininess !== undefined)
    data.shininess = this.shininess;
if (this.map && this.map.isTexture)
    data.map = this.map.toJSON(meta).uuid;
if (this.alphaMap && this.alphaMap.isTexture)
    data.alphaMap = this.alphaMap.toJSON(meta).uuid;
if (this.lightMap && this.lightMap.isTexture)
    data.lightMap = this.lightMap.toJSON(meta).uuid;
if (this.bumpMap && this.bumpMap.isTexture) {
    data.bumpMap = this.bumpMap.toJSON(meta).uuid;
    data.bumpScale = this.bumpScale;
}
if (this.normalMap && this.normalMap.isTexture) {
    data.normalMap = this.normalMap.toJSON(meta).uuid;
    data.normalScale = this.normalScale.toArray();
}
if (this.displacementMap && this.displacementMap.isTexture) {
    data.displacementMap = this.displacementMap.toJSON(meta).uuid;
    data.displacementScale = this.displacementScale;
    data.displacementBias = this.displacementBias;
}
if (this.roughnessMap && this.roughnessMap.isTexture)
    data.roughnessMap = this.roughnessMap.toJSON(meta).uuid;
if (this.metalnessMap && this.metalnessMap.isTexture)
    data.metalnessMap = this.metalnessMap.toJSON(meta).uuid;
if (this.emissiveMap && this.emissiveMap.isTexture)
    data.emissiveMap = this.emissiveMap.toJSON(meta).uuid;
if (this.specularMap && this.specularMap.isTexture)
    data.specularMap = this.specularMap.toJSON(meta).uuid;
if (this.envMap && this.envMap.isTexture) {
    data.envMap = this.envMap.toJSON(meta).uuid;
    data.reflectivity = this.reflectivity;
}
if (this.size !== undefined)
    data.size = this.size;
if (this.sizeAttenuation !== undefined)
    data.sizeAttenuation = this.sizeAttenuation;
if (this.blending !== NormalBlending)
    data.blending = this.blending;
if (this.shading !== SmoothShading)
    data.shading = this.shading;
if (this.side !== FrontSide)
    data.side = this.side;
if (this.vertexColors !== NoColors)
    data.vertexColors = this.vertexColors;
if (this.opacity < 1)
    data.opacity = this.opacity;
if (this.transparent === true)
    data.transparent = this.transparent;
data.depthFunc = this.depthFunc;
data.depthTest = this.depthTest;
data.depthWrite = this.depthWrite;
if (this.alphaTest > 0)
    data.alphaTest = this.alphaTest;
if (this.premultipliedAlpha === true)
    data.premultipliedAlpha = this.premultipliedAlpha;
if (this.wireframe === true)
    data.wireframe = this.wireframe;
if (this.wireframeLinewidth > 1)
    data.wireframeLinewidth = this.wireframeLinewidth;
if (this.wireframeLinecap !== 'round')
    data.wireframeLinecap = this.wireframeLinecap;
if (this.wireframeLinejoin !== 'round')
    data.wireframeLinejoin = this.wireframeLinejoin;
data.skinning = this.skinning;
data.morphTargets = this.morphTargets;
if (isRoot) {
    textures = extractFromCache(meta.textures);
    images = extractFromCache(meta.images);
    if (textures.length > 0)
        data.textures = textures;
    if (images.length > 0)
        data.images = images;
}
return data;}),
        'clone': ($__.fs.J$__v494107025_787_593 = function J$__v494107025_787() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return new this.constructor().copy(this);}),
        'copy': ($__.fs.J$__v494107025_789_594 = function J$__v494107025_789(source) {
var vvv_return, vvv_switch, srcPlanes, dstPlanes, n;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
source = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.name = source.name;
this.fog = source.fog;
this.lights = source.lights;
this.blending = source.blending;
this.side = source.side;
this.shading = source.shading;
this.vertexColors = source.vertexColors;
this.opacity = source.opacity;
this.transparent = source.transparent;
this.blendSrc = source.blendSrc;
this.blendDst = source.blendDst;
this.blendEquation = source.blendEquation;
this.blendSrcAlpha = source.blendSrcAlpha;
this.blendDstAlpha = source.blendDstAlpha;
this.blendEquationAlpha = source.blendEquationAlpha;
this.depthFunc = source.depthFunc;
this.depthTest = source.depthTest;
this.depthWrite = source.depthWrite;
this.colorWrite = source.colorWrite;
this.precision = source.precision;
this.polygonOffset = source.polygonOffset;
this.polygonOffsetFactor = source.polygonOffsetFactor;
this.polygonOffsetUnits = source.polygonOffsetUnits;
this.alphaTest = source.alphaTest;
this.premultipliedAlpha = source.premultipliedAlpha;
this.overdraw = source.overdraw;
this.visible = source.visible;
this.clipShadows = source.clipShadows;
srcPlanes = source.clippingPlanes;
dstPlanes = null;
if (srcPlanes !== null) {
    n = srcPlanes.length;
    dstPlanes = new Array(n);
    for (var i = 0; i !== n; ++i)
        dstPlanes[i] = srcPlanes[i].clone();
}
this.clippingPlanes = dstPlanes;
return this;}),
        'update': ($__.fs.J$__v494107025_791_595 = function J$__v494107025_791() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.dispatchEvent({
    type: 'update'
});}),
        'dispose': ($__.fs.J$__v494107025_793_596 = function J$__v494107025_793() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.dispatchEvent({
    type: 'dispose'
});}),
        get needsUpdate() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return this._needsUpdate;},
        set needsUpdate(value) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
value = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (value === true)
    this.update();
this._needsUpdate = value;}
    }, $__.fs.needsUpdate_597 = Object.getOwnPropertyDescriptor(vvv_tmp3, 'needsUpdate').get, $__.fs.needsUpdate_598 = Object.getOwnPropertyDescriptor(vvv_tmp3, 'needsUpdate').set, $__.os.oid16 = vvv_tmp3);
    Object['assign']((Material.prototype, $__.os.oid16), TAJS_restrictToType(EventDispatcher.prototype, 'object'));
    count$1 = 0;
    (exports, $__.os.oid0).UniformsUtils = $__.os.oid17 = {
        'merge': ($__.fs.J$__v494107025_796_599 = function J$__v494107025_796(uniforms) {
var vvv_return, vvv_switch, vvv_tmp0, vvv_tmp1, vvv_tmp2, vvv_tmp3, vvv_tmp4, vvv_tmp5, merged, u, tmp, p, vvv_tmp6, vvv_tmp7, vvv_tmp8, vvv_tmp9, vvv_tmp10, vvv_tmp11, vvv_tmp12, vvv_tmp13, vvv_tmp14, vvv_tmp15, vvv_tmp16, vvv_tmp17, vvv_tmp18, vvv_tmp19, vvv_tmp20, vvv_tmp21, vvv_tmp22, vvv_tmp23;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
uniforms = arguments[0];
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    merged = $__.os.oid111 = {};
    u = 0;
    u < (uniforms.length, 3);
    tmp = (vvv_tmp0 = this, 'clone', $__.fs.J$__v494107025_798_600.call(vvv_tmp0, (uniforms[u, 0], $__.os.oid31), 0, true, $__.uid));
    vvv_tmp1 = tmp;
    'diffuse' in vvv_tmp1;
    p = 'diffuse';
    (merged, $__.os.oid111)[p, 'diffuse'] = ((tmp, $__.os.oid112)[p, 'diffuse'], $__.os.oid113);
    'opacity' in vvv_tmp1;
    p = 'opacity';
    (merged, $__.os.oid111)[p, 'opacity'] = ((tmp, $__.os.oid112)[p, 'opacity'], $__.os.oid114);
    'map' in vvv_tmp1;
    p = 'map';
    (merged, $__.os.oid111)[p, 'map'] = ((tmp, $__.os.oid112)[p, 'map'], $__.os.oid115);
    'offsetRepeat' in vvv_tmp1;
    p = 'offsetRepeat';
    (merged, $__.os.oid111)[p, 'offsetRepeat'] = ((tmp, $__.os.oid112)[p, 'offsetRepeat'], $__.os.oid116);
    'specularMap' in vvv_tmp1;
    p = 'specularMap';
    (merged, $__.os.oid111)[p, 'specularMap'] = ((tmp, $__.os.oid112)[p, 'specularMap'], $__.os.oid117);
    'alphaMap' in vvv_tmp1;
    p = 'alphaMap';
    (merged, $__.os.oid111)[p, 'alphaMap'] = ((tmp, $__.os.oid112)[p, 'alphaMap'], $__.os.oid118);
    'envMap' in vvv_tmp1;
    p = 'envMap';
    (merged, $__.os.oid111)[p, 'envMap'] = ((tmp, $__.os.oid112)[p, 'envMap'], $__.os.oid119);
    'flipEnvMap' in vvv_tmp1;
    p = 'flipEnvMap';
    (merged, $__.os.oid111)[p, 'flipEnvMap'] = ((tmp, $__.os.oid112)[p, 'flipEnvMap'], $__.os.oid120);
    'reflectivity' in vvv_tmp1;
    p = 'reflectivity';
    (merged, $__.os.oid111)[p, 'reflectivity'] = ((tmp, $__.os.oid112)[p, 'reflectivity'], $__.os.oid121);
    'refractionRatio' in vvv_tmp1;
    p = 'refractionRatio';
    (merged, $__.os.oid111)[p, 'refractionRatio'] = ((tmp, $__.os.oid112)[p, 'refractionRatio'], $__.os.oid122);
    (u = +u + 1) - 1;
    u < (uniforms.length, 3);
    tmp = (vvv_tmp2 = this, 'clone', $__.fs.J$__v494107025_798_600.call(vvv_tmp2, (uniforms[u, 1], $__.os.oid34), 1, true, $__.uid));
    vvv_tmp3 = tmp;
    'aoMap' in vvv_tmp3;
    p = 'aoMap';
    (merged, $__.os.oid111)[p, 'aoMap'] = ((tmp, $__.os.oid123)[p, 'aoMap'], $__.os.oid124);
    'aoMapIntensity' in vvv_tmp3;
    p = 'aoMapIntensity';
    (merged, $__.os.oid111)[p, 'aoMapIntensity'] = ((tmp, $__.os.oid123)[p, 'aoMapIntensity'], $__.os.oid125);
    (u = +u + 1) - 1;
    u < (uniforms.length, 3);
    tmp = (vvv_tmp4 = this, 'clone', $__.fs.J$__v494107025_798_600.call(vvv_tmp4, (uniforms[u, 2], $__.os.oid58), 2, true, $__.uid));
    vvv_tmp5 = tmp;
    'fogDensity' in vvv_tmp5;
    p = 'fogDensity';
    (merged, $__.os.oid111)[p, 'fogDensity'] = ((tmp, $__.os.oid126)[p, 'fogDensity'], $__.os.oid127);
    'fogNear' in vvv_tmp5;
    p = 'fogNear';
    (merged, $__.os.oid111)[p, 'fogNear'] = ((tmp, $__.os.oid126)[p, 'fogNear'], $__.os.oid128);
    'fogFar' in vvv_tmp5;
    p = 'fogFar';
    (merged, $__.os.oid111)[p, 'fogFar'] = ((tmp, $__.os.oid126)[p, 'fogFar'], $__.os.oid129);
    'fogColor' in vvv_tmp5;
    p = 'fogColor';
    (merged, $__.os.oid111)[p, 'fogColor'] = ((tmp, $__.os.oid126)[p, 'fogColor'], $__.os.oid130);
    (u = +u + 1) - 1;
    u < (uniforms.length, 3);
    return merged;
case 1:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 1);
    merged = $__.os.oid134 = {};
    u = 0;
    u < (uniforms.length, 7);
    tmp = (vvv_tmp0 = this, 'clone', $__.fs.J$__v494107025_798_600.call(vvv_tmp0, (uniforms[u, 0], $__.os.oid31), 3, true, $__.uid));
    vvv_tmp1 = tmp;
    'diffuse' in vvv_tmp1;
    p = 'diffuse';
    (merged, $__.os.oid134)[p, 'diffuse'] = ((tmp, $__.os.oid135)[p, 'diffuse'], $__.os.oid136);
    'opacity' in vvv_tmp1;
    p = 'opacity';
    (merged, $__.os.oid134)[p, 'opacity'] = ((tmp, $__.os.oid135)[p, 'opacity'], $__.os.oid137);
    'map' in vvv_tmp1;
    p = 'map';
    (merged, $__.os.oid134)[p, 'map'] = ((tmp, $__.os.oid135)[p, 'map'], $__.os.oid138);
    'offsetRepeat' in vvv_tmp1;
    p = 'offsetRepeat';
    (merged, $__.os.oid134)[p, 'offsetRepeat'] = ((tmp, $__.os.oid135)[p, 'offsetRepeat'], $__.os.oid139);
    'specularMap' in vvv_tmp1;
    p = 'specularMap';
    (merged, $__.os.oid134)[p, 'specularMap'] = ((tmp, $__.os.oid135)[p, 'specularMap'], $__.os.oid140);
    'alphaMap' in vvv_tmp1;
    p = 'alphaMap';
    (merged, $__.os.oid134)[p, 'alphaMap'] = ((tmp, $__.os.oid135)[p, 'alphaMap'], $__.os.oid141);
    'envMap' in vvv_tmp1;
    p = 'envMap';
    (merged, $__.os.oid134)[p, 'envMap'] = ((tmp, $__.os.oid135)[p, 'envMap'], $__.os.oid142);
    'flipEnvMap' in vvv_tmp1;
    p = 'flipEnvMap';
    (merged, $__.os.oid134)[p, 'flipEnvMap'] = ((tmp, $__.os.oid135)[p, 'flipEnvMap'], $__.os.oid143);
    'reflectivity' in vvv_tmp1;
    p = 'reflectivity';
    (merged, $__.os.oid134)[p, 'reflectivity'] = ((tmp, $__.os.oid135)[p, 'reflectivity'], $__.os.oid144);
    'refractionRatio' in vvv_tmp1;
    p = 'refractionRatio';
    (merged, $__.os.oid134)[p, 'refractionRatio'] = ((tmp, $__.os.oid135)[p, 'refractionRatio'], $__.os.oid145);
    (u = +u + 1) - 1;
    u < (uniforms.length, 7);
    tmp = (vvv_tmp2 = this, 'clone', $__.fs.J$__v494107025_798_600.call(vvv_tmp2, (uniforms[u, 1], $__.os.oid34), 4, true, $__.uid));
    vvv_tmp3 = tmp;
    'aoMap' in vvv_tmp3;
    p = 'aoMap';
    (merged, $__.os.oid134)[p, 'aoMap'] = ((tmp, $__.os.oid146)[p, 'aoMap'], $__.os.oid147);
    'aoMapIntensity' in vvv_tmp3;
    p = 'aoMapIntensity';
    (merged, $__.os.oid134)[p, 'aoMapIntensity'] = ((tmp, $__.os.oid146)[p, 'aoMapIntensity'], $__.os.oid148);
    (u = +u + 1) - 1;
    u < (uniforms.length, 7);
    tmp = (vvv_tmp4 = this, 'clone', $__.fs.J$__v494107025_798_600.call(vvv_tmp4, (uniforms[u, 2], $__.os.oid37), 5, true, $__.uid));
    vvv_tmp5 = tmp;
    'lightMap' in vvv_tmp5;
    p = 'lightMap';
    (merged, $__.os.oid134)[p, 'lightMap'] = ((tmp, $__.os.oid149)[p, 'lightMap'], $__.os.oid150);
    'lightMapIntensity' in vvv_tmp5;
    p = 'lightMapIntensity';
    (merged, $__.os.oid134)[p, 'lightMapIntensity'] = ((tmp, $__.os.oid149)[p, 'lightMapIntensity'], $__.os.oid151);
    (u = +u + 1) - 1;
    u < (uniforms.length, 7);
    tmp = (vvv_tmp6 = this, 'clone', $__.fs.J$__v494107025_798_600.call(vvv_tmp6, (uniforms[u, 3], $__.os.oid39), 6, true, $__.uid));
    vvv_tmp7 = tmp;
    'emissiveMap' in vvv_tmp7;
    p = 'emissiveMap';
    (merged, $__.os.oid134)[p, 'emissiveMap'] = ((tmp, $__.os.oid152)[p, 'emissiveMap'], $__.os.oid153);
    (u = +u + 1) - 1;
    u < (uniforms.length, 7);
    tmp = (vvv_tmp8 = this, 'clone', $__.fs.J$__v494107025_798_600.call(vvv_tmp8, (uniforms[u, 4], $__.os.oid58), 7, true, $__.uid));
    vvv_tmp9 = tmp;
    'fogDensity' in vvv_tmp9;
    p = 'fogDensity';
    (merged, $__.os.oid134)[p, 'fogDensity'] = ((tmp, $__.os.oid154)[p, 'fogDensity'], $__.os.oid155);
    'fogNear' in vvv_tmp9;
    p = 'fogNear';
    (merged, $__.os.oid134)[p, 'fogNear'] = ((tmp, $__.os.oid154)[p, 'fogNear'], $__.os.oid156);
    'fogFar' in vvv_tmp9;
    p = 'fogFar';
    (merged, $__.os.oid134)[p, 'fogFar'] = ((tmp, $__.os.oid154)[p, 'fogFar'], $__.os.oid157);
    'fogColor' in vvv_tmp9;
    p = 'fogColor';
    (merged, $__.os.oid134)[p, 'fogColor'] = ((tmp, $__.os.oid154)[p, 'fogColor'], $__.os.oid158);
    (u = +u + 1) - 1;
    u < (uniforms.length, 7);
    tmp = (vvv_tmp10 = this, 'clone', $__.fs.J$__v494107025_798_600.call(vvv_tmp10, (uniforms[u, 5], $__.os.oid102), 8, true, $__.uid));
    vvv_tmp11 = tmp;
    'ambientLightColor' in vvv_tmp11;
    p = 'ambientLightColor';
    (merged, $__.os.oid134)[p, 'ambientLightColor'] = ((tmp, $__.os.oid159)[p, 'ambientLightColor'], $__.os.oid160);
    'directionalLights' in vvv_tmp11;
    p = 'directionalLights';
    (merged, $__.os.oid134)[p, 'directionalLights'] = ((tmp, $__.os.oid159)[p, 'directionalLights'], $__.os.oid161);
    'directionalShadowMap' in vvv_tmp11;
    p = 'directionalShadowMap';
    (merged, $__.os.oid134)[p, 'directionalShadowMap'] = ((tmp, $__.os.oid159)[p, 'directionalShadowMap'], $__.os.oid162);
    'directionalShadowMatrix' in vvv_tmp11;
    p = 'directionalShadowMatrix';
    (merged, $__.os.oid134)[p, 'directionalShadowMatrix'] = ((tmp, $__.os.oid159)[p, 'directionalShadowMatrix'], $__.os.oid163);
    'spotLights' in vvv_tmp11;
    p = 'spotLights';
    (merged, $__.os.oid134)[p, 'spotLights'] = ((tmp, $__.os.oid159)[p, 'spotLights'], $__.os.oid164);
    'spotShadowMap' in vvv_tmp11;
    p = 'spotShadowMap';
    (merged, $__.os.oid134)[p, 'spotShadowMap'] = ((tmp, $__.os.oid159)[p, 'spotShadowMap'], $__.os.oid165);
    'spotShadowMatrix' in vvv_tmp11;
    p = 'spotShadowMatrix';
    (merged, $__.os.oid134)[p, 'spotShadowMatrix'] = ((tmp, $__.os.oid159)[p, 'spotShadowMatrix'], $__.os.oid166);
    'pointLights' in vvv_tmp11;
    p = 'pointLights';
    (merged, $__.os.oid134)[p, 'pointLights'] = ((tmp, $__.os.oid159)[p, 'pointLights'], $__.os.oid167);
    'pointShadowMap' in vvv_tmp11;
    p = 'pointShadowMap';
    (merged, $__.os.oid134)[p, 'pointShadowMap'] = ((tmp, $__.os.oid159)[p, 'pointShadowMap'], $__.os.oid168);
    'pointShadowMatrix' in vvv_tmp11;
    p = 'pointShadowMatrix';
    (merged, $__.os.oid134)[p, 'pointShadowMatrix'] = ((tmp, $__.os.oid159)[p, 'pointShadowMatrix'], $__.os.oid169);
    'hemisphereLights' in vvv_tmp11;
    p = 'hemisphereLights';
    (merged, $__.os.oid134)[p, 'hemisphereLights'] = ((tmp, $__.os.oid159)[p, 'hemisphereLights'], $__.os.oid170);
    (u = +u + 1) - 1;
    u < (uniforms.length, 7);
    tmp = (vvv_tmp12 = this, 'clone', $__.fs.J$__v494107025_798_600.call(vvv_tmp12, (uniforms[u, 6], $__.os.oid133), 9, true, $__.uid));
    vvv_tmp13 = tmp;
    'emissive' in vvv_tmp13;
    p = 'emissive';
    (merged, $__.os.oid134)[p, 'emissive'] = ((tmp, $__.os.oid171)[p, 'emissive'], $__.os.oid172);
    (u = +u + 1) - 1;
    u < (uniforms.length, 7);
    return merged;
case 2:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 2);
    merged = $__.os.oid178 = {};
    u = 0;
    u < (uniforms.length, 10);
    tmp = (vvv_tmp0 = this, 'clone', $__.fs.J$__v494107025_798_600.call(vvv_tmp0, (uniforms[u, 0], $__.os.oid31), 10, true, $__.uid));
    vvv_tmp1 = tmp;
    'diffuse' in vvv_tmp1;
    p = 'diffuse';
    (merged, $__.os.oid178)[p, 'diffuse'] = ((tmp, $__.os.oid179)[p, 'diffuse'], $__.os.oid180);
    'opacity' in vvv_tmp1;
    p = 'opacity';
    (merged, $__.os.oid178)[p, 'opacity'] = ((tmp, $__.os.oid179)[p, 'opacity'], $__.os.oid181);
    'map' in vvv_tmp1;
    p = 'map';
    (merged, $__.os.oid178)[p, 'map'] = ((tmp, $__.os.oid179)[p, 'map'], $__.os.oid182);
    'offsetRepeat' in vvv_tmp1;
    p = 'offsetRepeat';
    (merged, $__.os.oid178)[p, 'offsetRepeat'] = ((tmp, $__.os.oid179)[p, 'offsetRepeat'], $__.os.oid183);
    'specularMap' in vvv_tmp1;
    p = 'specularMap';
    (merged, $__.os.oid178)[p, 'specularMap'] = ((tmp, $__.os.oid179)[p, 'specularMap'], $__.os.oid184);
    'alphaMap' in vvv_tmp1;
    p = 'alphaMap';
    (merged, $__.os.oid178)[p, 'alphaMap'] = ((tmp, $__.os.oid179)[p, 'alphaMap'], $__.os.oid185);
    'envMap' in vvv_tmp1;
    p = 'envMap';
    (merged, $__.os.oid178)[p, 'envMap'] = ((tmp, $__.os.oid179)[p, 'envMap'], $__.os.oid186);
    'flipEnvMap' in vvv_tmp1;
    p = 'flipEnvMap';
    (merged, $__.os.oid178)[p, 'flipEnvMap'] = ((tmp, $__.os.oid179)[p, 'flipEnvMap'], $__.os.oid187);
    'reflectivity' in vvv_tmp1;
    p = 'reflectivity';
    (merged, $__.os.oid178)[p, 'reflectivity'] = ((tmp, $__.os.oid179)[p, 'reflectivity'], $__.os.oid188);
    'refractionRatio' in vvv_tmp1;
    p = 'refractionRatio';
    (merged, $__.os.oid178)[p, 'refractionRatio'] = ((tmp, $__.os.oid179)[p, 'refractionRatio'], $__.os.oid189);
    (u = +u + 1) - 1;
    u < (uniforms.length, 10);
    tmp = (vvv_tmp2 = this, 'clone', $__.fs.J$__v494107025_798_600.call(vvv_tmp2, (uniforms[u, 1], $__.os.oid34), 11, true, $__.uid));
    vvv_tmp3 = tmp;
    'aoMap' in vvv_tmp3;
    p = 'aoMap';
    (merged, $__.os.oid178)[p, 'aoMap'] = ((tmp, $__.os.oid190)[p, 'aoMap'], $__.os.oid191);
    'aoMapIntensity' in vvv_tmp3;
    p = 'aoMapIntensity';
    (merged, $__.os.oid178)[p, 'aoMapIntensity'] = ((tmp, $__.os.oid190)[p, 'aoMapIntensity'], $__.os.oid192);
    (u = +u + 1) - 1;
    u < (uniforms.length, 10);
    tmp = (vvv_tmp4 = this, 'clone', $__.fs.J$__v494107025_798_600.call(vvv_tmp4, (uniforms[u, 2], $__.os.oid37), 12, true, $__.uid));
    vvv_tmp5 = tmp;
    'lightMap' in vvv_tmp5;
    p = 'lightMap';
    (merged, $__.os.oid178)[p, 'lightMap'] = ((tmp, $__.os.oid193)[p, 'lightMap'], $__.os.oid194);
    'lightMapIntensity' in vvv_tmp5;
    p = 'lightMapIntensity';
    (merged, $__.os.oid178)[p, 'lightMapIntensity'] = ((tmp, $__.os.oid193)[p, 'lightMapIntensity'], $__.os.oid195);
    (u = +u + 1) - 1;
    u < (uniforms.length, 10);
    tmp = (vvv_tmp6 = this, 'clone', $__.fs.J$__v494107025_798_600.call(vvv_tmp6, (uniforms[u, 3], $__.os.oid39), 13, true, $__.uid));
    vvv_tmp7 = tmp;
    'emissiveMap' in vvv_tmp7;
    p = 'emissiveMap';
    (merged, $__.os.oid178)[p, 'emissiveMap'] = ((tmp, $__.os.oid196)[p, 'emissiveMap'], $__.os.oid197);
    (u = +u + 1) - 1;
    u < (uniforms.length, 10);
    tmp = (vvv_tmp8 = this, 'clone', $__.fs.J$__v494107025_798_600.call(vvv_tmp8, (uniforms[u, 4], $__.os.oid42), 14, true, $__.uid));
    vvv_tmp9 = tmp;
    'bumpMap' in vvv_tmp9;
    p = 'bumpMap';
    (merged, $__.os.oid178)[p, 'bumpMap'] = ((tmp, $__.os.oid198)[p, 'bumpMap'], $__.os.oid199);
    'bumpScale' in vvv_tmp9;
    p = 'bumpScale';
    (merged, $__.os.oid178)[p, 'bumpScale'] = ((tmp, $__.os.oid198)[p, 'bumpScale'], $__.os.oid200);
    (u = +u + 1) - 1;
    u < (uniforms.length, 10);
    tmp = (vvv_tmp10 = this, 'clone', $__.fs.J$__v494107025_798_600.call(vvv_tmp10, (uniforms[u, 5], $__.os.oid45), 15, true, $__.uid));
    vvv_tmp11 = tmp;
    'normalMap' in vvv_tmp11;
    p = 'normalMap';
    (merged, $__.os.oid178)[p, 'normalMap'] = ((tmp, $__.os.oid201)[p, 'normalMap'], $__.os.oid202);
    'normalScale' in vvv_tmp11;
    p = 'normalScale';
    (merged, $__.os.oid178)[p, 'normalScale'] = ((tmp, $__.os.oid201)[p, 'normalScale'], $__.os.oid203);
    (u = +u + 1) - 1;
    u < (uniforms.length, 10);
    tmp = (vvv_tmp12 = this, 'clone', $__.fs.J$__v494107025_798_600.call(vvv_tmp12, (uniforms[u, 6], $__.os.oid49), 16, true, $__.uid));
    vvv_tmp13 = tmp;
    'displacementMap' in vvv_tmp13;
    p = 'displacementMap';
    (merged, $__.os.oid178)[p, 'displacementMap'] = ((tmp, $__.os.oid204)[p, 'displacementMap'], $__.os.oid205);
    'displacementScale' in vvv_tmp13;
    p = 'displacementScale';
    (merged, $__.os.oid178)[p, 'displacementScale'] = ((tmp, $__.os.oid204)[p, 'displacementScale'], $__.os.oid206);
    'displacementBias' in vvv_tmp13;
    p = 'displacementBias';
    (merged, $__.os.oid178)[p, 'displacementBias'] = ((tmp, $__.os.oid204)[p, 'displacementBias'], $__.os.oid207);
    (u = +u + 1) - 1;
    u < (uniforms.length, 10);
    tmp = (vvv_tmp14 = this, 'clone', $__.fs.J$__v494107025_798_600.call(vvv_tmp14, (uniforms[u, 7], $__.os.oid58), 17, true, $__.uid));
    vvv_tmp15 = tmp;
    'fogDensity' in vvv_tmp15;
    p = 'fogDensity';
    (merged, $__.os.oid178)[p, 'fogDensity'] = ((tmp, $__.os.oid208)[p, 'fogDensity'], $__.os.oid209);
    'fogNear' in vvv_tmp15;
    p = 'fogNear';
    (merged, $__.os.oid178)[p, 'fogNear'] = ((tmp, $__.os.oid208)[p, 'fogNear'], $__.os.oid210);
    'fogFar' in vvv_tmp15;
    p = 'fogFar';
    (merged, $__.os.oid178)[p, 'fogFar'] = ((tmp, $__.os.oid208)[p, 'fogFar'], $__.os.oid211);
    'fogColor' in vvv_tmp15;
    p = 'fogColor';
    (merged, $__.os.oid178)[p, 'fogColor'] = ((tmp, $__.os.oid208)[p, 'fogColor'], $__.os.oid212);
    (u = +u + 1) - 1;
    u < (uniforms.length, 10);
    tmp = (vvv_tmp16 = this, 'clone', $__.fs.J$__v494107025_798_600.call(vvv_tmp16, (uniforms[u, 8], $__.os.oid102), 18, true, $__.uid));
    vvv_tmp17 = tmp;
    'ambientLightColor' in vvv_tmp17;
    p = 'ambientLightColor';
    (merged, $__.os.oid178)[p, 'ambientLightColor'] = ((tmp, $__.os.oid213)[p, 'ambientLightColor'], $__.os.oid214);
    'directionalLights' in vvv_tmp17;
    p = 'directionalLights';
    (merged, $__.os.oid178)[p, 'directionalLights'] = ((tmp, $__.os.oid213)[p, 'directionalLights'], $__.os.oid215);
    'directionalShadowMap' in vvv_tmp17;
    p = 'directionalShadowMap';
    (merged, $__.os.oid178)[p, 'directionalShadowMap'] = ((tmp, $__.os.oid213)[p, 'directionalShadowMap'], $__.os.oid216);
    'directionalShadowMatrix' in vvv_tmp17;
    p = 'directionalShadowMatrix';
    (merged, $__.os.oid178)[p, 'directionalShadowMatrix'] = ((tmp, $__.os.oid213)[p, 'directionalShadowMatrix'], $__.os.oid217);
    'spotLights' in vvv_tmp17;
    p = 'spotLights';
    (merged, $__.os.oid178)[p, 'spotLights'] = ((tmp, $__.os.oid213)[p, 'spotLights'], $__.os.oid218);
    'spotShadowMap' in vvv_tmp17;
    p = 'spotShadowMap';
    (merged, $__.os.oid178)[p, 'spotShadowMap'] = ((tmp, $__.os.oid213)[p, 'spotShadowMap'], $__.os.oid219);
    'spotShadowMatrix' in vvv_tmp17;
    p = 'spotShadowMatrix';
    (merged, $__.os.oid178)[p, 'spotShadowMatrix'] = ((tmp, $__.os.oid213)[p, 'spotShadowMatrix'], $__.os.oid220);
    'pointLights' in vvv_tmp17;
    p = 'pointLights';
    (merged, $__.os.oid178)[p, 'pointLights'] = ((tmp, $__.os.oid213)[p, 'pointLights'], $__.os.oid221);
    'pointShadowMap' in vvv_tmp17;
    p = 'pointShadowMap';
    (merged, $__.os.oid178)[p, 'pointShadowMap'] = ((tmp, $__.os.oid213)[p, 'pointShadowMap'], $__.os.oid222);
    'pointShadowMatrix' in vvv_tmp17;
    p = 'pointShadowMatrix';
    (merged, $__.os.oid178)[p, 'pointShadowMatrix'] = ((tmp, $__.os.oid213)[p, 'pointShadowMatrix'], $__.os.oid223);
    'hemisphereLights' in vvv_tmp17;
    p = 'hemisphereLights';
    (merged, $__.os.oid178)[p, 'hemisphereLights'] = ((tmp, $__.os.oid213)[p, 'hemisphereLights'], $__.os.oid224);
    (u = +u + 1) - 1;
    u < (uniforms.length, 10);
    tmp = (vvv_tmp18 = this, 'clone', $__.fs.J$__v494107025_798_600.call(vvv_tmp18, (uniforms[u, 9], $__.os.oid177), 19, true, $__.uid));
    vvv_tmp19 = tmp;
    'emissive' in vvv_tmp19;
    p = 'emissive';
    (merged, $__.os.oid178)[p, 'emissive'] = ((tmp, $__.os.oid225)[p, 'emissive'], $__.os.oid226);
    'specular' in vvv_tmp19;
    p = 'specular';
    (merged, $__.os.oid178)[p, 'specular'] = ((tmp, $__.os.oid225)[p, 'specular'], $__.os.oid227);
    'shininess' in vvv_tmp19;
    p = 'shininess';
    (merged, $__.os.oid178)[p, 'shininess'] = ((tmp, $__.os.oid225)[p, 'shininess'], $__.os.oid228);
    (u = +u + 1) - 1;
    u < (uniforms.length, 10);
    return merged;
case 3:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 3);
    merged = $__.os.oid235 = {};
    u = 0;
    u < (uniforms.length, 12);
    tmp = (vvv_tmp0 = this, 'clone', $__.fs.J$__v494107025_798_600.call(vvv_tmp0, (uniforms[u, 0], $__.os.oid31), 20, true, $__.uid));
    vvv_tmp1 = tmp;
    'diffuse' in vvv_tmp1;
    p = 'diffuse';
    (merged, $__.os.oid235)[p, 'diffuse'] = ((tmp, $__.os.oid236)[p, 'diffuse'], $__.os.oid237);
    'opacity' in vvv_tmp1;
    p = 'opacity';
    (merged, $__.os.oid235)[p, 'opacity'] = ((tmp, $__.os.oid236)[p, 'opacity'], $__.os.oid238);
    'map' in vvv_tmp1;
    p = 'map';
    (merged, $__.os.oid235)[p, 'map'] = ((tmp, $__.os.oid236)[p, 'map'], $__.os.oid239);
    'offsetRepeat' in vvv_tmp1;
    p = 'offsetRepeat';
    (merged, $__.os.oid235)[p, 'offsetRepeat'] = ((tmp, $__.os.oid236)[p, 'offsetRepeat'], $__.os.oid240);
    'specularMap' in vvv_tmp1;
    p = 'specularMap';
    (merged, $__.os.oid235)[p, 'specularMap'] = ((tmp, $__.os.oid236)[p, 'specularMap'], $__.os.oid241);
    'alphaMap' in vvv_tmp1;
    p = 'alphaMap';
    (merged, $__.os.oid235)[p, 'alphaMap'] = ((tmp, $__.os.oid236)[p, 'alphaMap'], $__.os.oid242);
    'envMap' in vvv_tmp1;
    p = 'envMap';
    (merged, $__.os.oid235)[p, 'envMap'] = ((tmp, $__.os.oid236)[p, 'envMap'], $__.os.oid243);
    'flipEnvMap' in vvv_tmp1;
    p = 'flipEnvMap';
    (merged, $__.os.oid235)[p, 'flipEnvMap'] = ((tmp, $__.os.oid236)[p, 'flipEnvMap'], $__.os.oid244);
    'reflectivity' in vvv_tmp1;
    p = 'reflectivity';
    (merged, $__.os.oid235)[p, 'reflectivity'] = ((tmp, $__.os.oid236)[p, 'reflectivity'], $__.os.oid245);
    'refractionRatio' in vvv_tmp1;
    p = 'refractionRatio';
    (merged, $__.os.oid235)[p, 'refractionRatio'] = ((tmp, $__.os.oid236)[p, 'refractionRatio'], $__.os.oid246);
    (u = +u + 1) - 1;
    u < (uniforms.length, 12);
    tmp = (vvv_tmp2 = this, 'clone', $__.fs.J$__v494107025_798_600.call(vvv_tmp2, (uniforms[u, 1], $__.os.oid34), 21, true, $__.uid));
    vvv_tmp3 = tmp;
    'aoMap' in vvv_tmp3;
    p = 'aoMap';
    (merged, $__.os.oid235)[p, 'aoMap'] = ((tmp, $__.os.oid247)[p, 'aoMap'], $__.os.oid248);
    'aoMapIntensity' in vvv_tmp3;
    p = 'aoMapIntensity';
    (merged, $__.os.oid235)[p, 'aoMapIntensity'] = ((tmp, $__.os.oid247)[p, 'aoMapIntensity'], $__.os.oid249);
    (u = +u + 1) - 1;
    u < (uniforms.length, 12);
    tmp = (vvv_tmp4 = this, 'clone', $__.fs.J$__v494107025_798_600.call(vvv_tmp4, (uniforms[u, 2], $__.os.oid37), 22, true, $__.uid));
    vvv_tmp5 = tmp;
    'lightMap' in vvv_tmp5;
    p = 'lightMap';
    (merged, $__.os.oid235)[p, 'lightMap'] = ((tmp, $__.os.oid250)[p, 'lightMap'], $__.os.oid251);
    'lightMapIntensity' in vvv_tmp5;
    p = 'lightMapIntensity';
    (merged, $__.os.oid235)[p, 'lightMapIntensity'] = ((tmp, $__.os.oid250)[p, 'lightMapIntensity'], $__.os.oid252);
    (u = +u + 1) - 1;
    u < (uniforms.length, 12);
    tmp = (vvv_tmp6 = this, 'clone', $__.fs.J$__v494107025_798_600.call(vvv_tmp6, (uniforms[u, 3], $__.os.oid39), 23, true, $__.uid));
    vvv_tmp7 = tmp;
    'emissiveMap' in vvv_tmp7;
    p = 'emissiveMap';
    (merged, $__.os.oid235)[p, 'emissiveMap'] = ((tmp, $__.os.oid253)[p, 'emissiveMap'], $__.os.oid254);
    (u = +u + 1) - 1;
    u < (uniforms.length, 12);
    tmp = (vvv_tmp8 = this, 'clone', $__.fs.J$__v494107025_798_600.call(vvv_tmp8, (uniforms[u, 4], $__.os.oid42), 24, true, $__.uid));
    vvv_tmp9 = tmp;
    'bumpMap' in vvv_tmp9;
    p = 'bumpMap';
    (merged, $__.os.oid235)[p, 'bumpMap'] = ((tmp, $__.os.oid255)[p, 'bumpMap'], $__.os.oid256);
    'bumpScale' in vvv_tmp9;
    p = 'bumpScale';
    (merged, $__.os.oid235)[p, 'bumpScale'] = ((tmp, $__.os.oid255)[p, 'bumpScale'], $__.os.oid257);
    (u = +u + 1) - 1;
    u < (uniforms.length, 12);
    tmp = (vvv_tmp10 = this, 'clone', $__.fs.J$__v494107025_798_600.call(vvv_tmp10, (uniforms[u, 5], $__.os.oid45), 25, true, $__.uid));
    vvv_tmp11 = tmp;
    'normalMap' in vvv_tmp11;
    p = 'normalMap';
    (merged, $__.os.oid235)[p, 'normalMap'] = ((tmp, $__.os.oid258)[p, 'normalMap'], $__.os.oid259);
    'normalScale' in vvv_tmp11;
    p = 'normalScale';
    (merged, $__.os.oid235)[p, 'normalScale'] = ((tmp, $__.os.oid258)[p, 'normalScale'], $__.os.oid260);
    (u = +u + 1) - 1;
    u < (uniforms.length, 12);
    tmp = (vvv_tmp12 = this, 'clone', $__.fs.J$__v494107025_798_600.call(vvv_tmp12, (uniforms[u, 6], $__.os.oid49), 26, true, $__.uid));
    vvv_tmp13 = tmp;
    'displacementMap' in vvv_tmp13;
    p = 'displacementMap';
    (merged, $__.os.oid235)[p, 'displacementMap'] = ((tmp, $__.os.oid261)[p, 'displacementMap'], $__.os.oid262);
    'displacementScale' in vvv_tmp13;
    p = 'displacementScale';
    (merged, $__.os.oid235)[p, 'displacementScale'] = ((tmp, $__.os.oid261)[p, 'displacementScale'], $__.os.oid263);
    'displacementBias' in vvv_tmp13;
    p = 'displacementBias';
    (merged, $__.os.oid235)[p, 'displacementBias'] = ((tmp, $__.os.oid261)[p, 'displacementBias'], $__.os.oid264);
    (u = +u + 1) - 1;
    u < (uniforms.length, 12);
    tmp = (vvv_tmp14 = this, 'clone', $__.fs.J$__v494107025_798_600.call(vvv_tmp14, (uniforms[u, 7], $__.os.oid51), 27, true, $__.uid));
    vvv_tmp15 = tmp;
    'roughnessMap' in vvv_tmp15;
    p = 'roughnessMap';
    (merged, $__.os.oid235)[p, 'roughnessMap'] = ((tmp, $__.os.oid265)[p, 'roughnessMap'], $__.os.oid266);
    (u = +u + 1) - 1;
    u < (uniforms.length, 12);
    tmp = (vvv_tmp16 = this, 'clone', $__.fs.J$__v494107025_798_600.call(vvv_tmp16, (uniforms[u, 8], $__.os.oid53), 28, true, $__.uid));
    vvv_tmp17 = tmp;
    'metalnessMap' in vvv_tmp17;
    p = 'metalnessMap';
    (merged, $__.os.oid235)[p, 'metalnessMap'] = ((tmp, $__.os.oid267)[p, 'metalnessMap'], $__.os.oid268);
    (u = +u + 1) - 1;
    u < (uniforms.length, 12);
    tmp = (vvv_tmp18 = this, 'clone', $__.fs.J$__v494107025_798_600.call(vvv_tmp18, (uniforms[u, 9], $__.os.oid58), 29, true, $__.uid));
    vvv_tmp19 = tmp;
    'fogDensity' in vvv_tmp19;
    p = 'fogDensity';
    (merged, $__.os.oid235)[p, 'fogDensity'] = ((tmp, $__.os.oid269)[p, 'fogDensity'], $__.os.oid270);
    'fogNear' in vvv_tmp19;
    p = 'fogNear';
    (merged, $__.os.oid235)[p, 'fogNear'] = ((tmp, $__.os.oid269)[p, 'fogNear'], $__.os.oid271);
    'fogFar' in vvv_tmp19;
    p = 'fogFar';
    (merged, $__.os.oid235)[p, 'fogFar'] = ((tmp, $__.os.oid269)[p, 'fogFar'], $__.os.oid272);
    'fogColor' in vvv_tmp19;
    p = 'fogColor';
    (merged, $__.os.oid235)[p, 'fogColor'] = ((tmp, $__.os.oid269)[p, 'fogColor'], $__.os.oid273);
    (u = +u + 1) - 1;
    u < (uniforms.length, 12);
    tmp = (vvv_tmp20 = this, 'clone', $__.fs.J$__v494107025_798_600.call(vvv_tmp20, (uniforms[u, 10], $__.os.oid102), 30, true, $__.uid));
    vvv_tmp21 = tmp;
    'ambientLightColor' in vvv_tmp21;
    p = 'ambientLightColor';
    (merged, $__.os.oid235)[p, 'ambientLightColor'] = ((tmp, $__.os.oid274)[p, 'ambientLightColor'], $__.os.oid275);
    'directionalLights' in vvv_tmp21;
    p = 'directionalLights';
    (merged, $__.os.oid235)[p, 'directionalLights'] = ((tmp, $__.os.oid274)[p, 'directionalLights'], $__.os.oid276);
    'directionalShadowMap' in vvv_tmp21;
    p = 'directionalShadowMap';
    (merged, $__.os.oid235)[p, 'directionalShadowMap'] = ((tmp, $__.os.oid274)[p, 'directionalShadowMap'], $__.os.oid277);
    'directionalShadowMatrix' in vvv_tmp21;
    p = 'directionalShadowMatrix';
    (merged, $__.os.oid235)[p, 'directionalShadowMatrix'] = ((tmp, $__.os.oid274)[p, 'directionalShadowMatrix'], $__.os.oid278);
    'spotLights' in vvv_tmp21;
    p = 'spotLights';
    (merged, $__.os.oid235)[p, 'spotLights'] = ((tmp, $__.os.oid274)[p, 'spotLights'], $__.os.oid279);
    'spotShadowMap' in vvv_tmp21;
    p = 'spotShadowMap';
    (merged, $__.os.oid235)[p, 'spotShadowMap'] = ((tmp, $__.os.oid274)[p, 'spotShadowMap'], $__.os.oid280);
    'spotShadowMatrix' in vvv_tmp21;
    p = 'spotShadowMatrix';
    (merged, $__.os.oid235)[p, 'spotShadowMatrix'] = ((tmp, $__.os.oid274)[p, 'spotShadowMatrix'], $__.os.oid281);
    'pointLights' in vvv_tmp21;
    p = 'pointLights';
    (merged, $__.os.oid235)[p, 'pointLights'] = ((tmp, $__.os.oid274)[p, 'pointLights'], $__.os.oid282);
    'pointShadowMap' in vvv_tmp21;
    p = 'pointShadowMap';
    (merged, $__.os.oid235)[p, 'pointShadowMap'] = ((tmp, $__.os.oid274)[p, 'pointShadowMap'], $__.os.oid283);
    'pointShadowMatrix' in vvv_tmp21;
    p = 'pointShadowMatrix';
    (merged, $__.os.oid235)[p, 'pointShadowMatrix'] = ((tmp, $__.os.oid274)[p, 'pointShadowMatrix'], $__.os.oid284);
    'hemisphereLights' in vvv_tmp21;
    p = 'hemisphereLights';
    (merged, $__.os.oid235)[p, 'hemisphereLights'] = ((tmp, $__.os.oid274)[p, 'hemisphereLights'], $__.os.oid285);
    (u = +u + 1) - 1;
    u < (uniforms.length, 12);
    tmp = (vvv_tmp22 = this, 'clone', $__.fs.J$__v494107025_798_600.call(vvv_tmp22, (uniforms[u, 11], $__.os.oid234), 31, true, $__.uid));
    vvv_tmp23 = tmp;
    'emissive' in vvv_tmp23;
    p = 'emissive';
    (merged, $__.os.oid235)[p, 'emissive'] = ((tmp, $__.os.oid286)[p, 'emissive'], $__.os.oid287);
    'roughness' in vvv_tmp23;
    p = 'roughness';
    (merged, $__.os.oid235)[p, 'roughness'] = ((tmp, $__.os.oid286)[p, 'roughness'], $__.os.oid288);
    'metalness' in vvv_tmp23;
    p = 'metalness';
    (merged, $__.os.oid235)[p, 'metalness'] = ((tmp, $__.os.oid286)[p, 'metalness'], $__.os.oid289);
    'envMapIntensity' in vvv_tmp23;
    p = 'envMapIntensity';
    (merged, $__.os.oid235)[p, 'envMapIntensity'] = ((tmp, $__.os.oid286)[p, 'envMapIntensity'], $__.os.oid290);
    (u = +u + 1) - 1;
    u < (uniforms.length, 12);
    return merged;
case 4:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 4);
    merged = $__.os.oid292 = {};
    u = 0;
    u < (uniforms.length, 2);
    tmp = (vvv_tmp0 = this, 'clone', $__.fs.J$__v494107025_798_600.call(vvv_tmp0, (uniforms[u, 0], $__.os.oid109), 32, true, $__.uid));
    vvv_tmp1 = tmp;
    'diffuse' in vvv_tmp1;
    p = 'diffuse';
    (merged, $__.os.oid292)[p, 'diffuse'] = ((tmp, $__.os.oid293)[p, 'diffuse'], $__.os.oid294);
    'opacity' in vvv_tmp1;
    p = 'opacity';
    (merged, $__.os.oid292)[p, 'opacity'] = ((tmp, $__.os.oid293)[p, 'opacity'], $__.os.oid295);
    'size' in vvv_tmp1;
    p = 'size';
    (merged, $__.os.oid292)[p, 'size'] = ((tmp, $__.os.oid293)[p, 'size'], $__.os.oid296);
    'scale' in vvv_tmp1;
    p = 'scale';
    (merged, $__.os.oid292)[p, 'scale'] = ((tmp, $__.os.oid293)[p, 'scale'], $__.os.oid297);
    'map' in vvv_tmp1;
    p = 'map';
    (merged, $__.os.oid292)[p, 'map'] = ((tmp, $__.os.oid293)[p, 'map'], $__.os.oid298);
    'offsetRepeat' in vvv_tmp1;
    p = 'offsetRepeat';
    (merged, $__.os.oid292)[p, 'offsetRepeat'] = ((tmp, $__.os.oid293)[p, 'offsetRepeat'], $__.os.oid299);
    (u = +u + 1) - 1;
    u < (uniforms.length, 2);
    tmp = (vvv_tmp2 = this, 'clone', $__.fs.J$__v494107025_798_600.call(vvv_tmp2, (uniforms[u, 1], $__.os.oid58), 33, true, $__.uid));
    vvv_tmp3 = tmp;
    'fogDensity' in vvv_tmp3;
    p = 'fogDensity';
    (merged, $__.os.oid292)[p, 'fogDensity'] = ((tmp, $__.os.oid300)[p, 'fogDensity'], $__.os.oid301);
    'fogNear' in vvv_tmp3;
    p = 'fogNear';
    (merged, $__.os.oid292)[p, 'fogNear'] = ((tmp, $__.os.oid300)[p, 'fogNear'], $__.os.oid302);
    'fogFar' in vvv_tmp3;
    p = 'fogFar';
    (merged, $__.os.oid292)[p, 'fogFar'] = ((tmp, $__.os.oid300)[p, 'fogFar'], $__.os.oid303);
    'fogColor' in vvv_tmp3;
    p = 'fogColor';
    (merged, $__.os.oid292)[p, 'fogColor'] = ((tmp, $__.os.oid300)[p, 'fogColor'], $__.os.oid304);
    (u = +u + 1) - 1;
    u < (uniforms.length, 2);
    return merged;
case 5:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 5);
    merged = $__.os.oid310 = {};
    u = 0;
    u < (uniforms.length, 3);
    tmp = (vvv_tmp0 = this, 'clone', $__.fs.J$__v494107025_798_600.call(vvv_tmp0, (uniforms[u, 0], $__.os.oid31), 34, true, $__.uid));
    vvv_tmp1 = tmp;
    'diffuse' in vvv_tmp1;
    p = 'diffuse';
    (merged, $__.os.oid310)[p, 'diffuse'] = ((tmp, $__.os.oid311)[p, 'diffuse'], $__.os.oid312);
    'opacity' in vvv_tmp1;
    p = 'opacity';
    (merged, $__.os.oid310)[p, 'opacity'] = ((tmp, $__.os.oid311)[p, 'opacity'], $__.os.oid313);
    'map' in vvv_tmp1;
    p = 'map';
    (merged, $__.os.oid310)[p, 'map'] = ((tmp, $__.os.oid311)[p, 'map'], $__.os.oid314);
    'offsetRepeat' in vvv_tmp1;
    p = 'offsetRepeat';
    (merged, $__.os.oid310)[p, 'offsetRepeat'] = ((tmp, $__.os.oid311)[p, 'offsetRepeat'], $__.os.oid315);
    'specularMap' in vvv_tmp1;
    p = 'specularMap';
    (merged, $__.os.oid310)[p, 'specularMap'] = ((tmp, $__.os.oid311)[p, 'specularMap'], $__.os.oid316);
    'alphaMap' in vvv_tmp1;
    p = 'alphaMap';
    (merged, $__.os.oid310)[p, 'alphaMap'] = ((tmp, $__.os.oid311)[p, 'alphaMap'], $__.os.oid317);
    'envMap' in vvv_tmp1;
    p = 'envMap';
    (merged, $__.os.oid310)[p, 'envMap'] = ((tmp, $__.os.oid311)[p, 'envMap'], $__.os.oid318);
    'flipEnvMap' in vvv_tmp1;
    p = 'flipEnvMap';
    (merged, $__.os.oid310)[p, 'flipEnvMap'] = ((tmp, $__.os.oid311)[p, 'flipEnvMap'], $__.os.oid319);
    'reflectivity' in vvv_tmp1;
    p = 'reflectivity';
    (merged, $__.os.oid310)[p, 'reflectivity'] = ((tmp, $__.os.oid311)[p, 'reflectivity'], $__.os.oid320);
    'refractionRatio' in vvv_tmp1;
    p = 'refractionRatio';
    (merged, $__.os.oid310)[p, 'refractionRatio'] = ((tmp, $__.os.oid311)[p, 'refractionRatio'], $__.os.oid321);
    (u = +u + 1) - 1;
    u < (uniforms.length, 3);
    tmp = (vvv_tmp2 = this, 'clone', $__.fs.J$__v494107025_798_600.call(vvv_tmp2, (uniforms[u, 1], $__.os.oid58), 35, true, $__.uid));
    vvv_tmp3 = tmp;
    'fogDensity' in vvv_tmp3;
    p = 'fogDensity';
    (merged, $__.os.oid310)[p, 'fogDensity'] = ((tmp, $__.os.oid322)[p, 'fogDensity'], $__.os.oid323);
    'fogNear' in vvv_tmp3;
    p = 'fogNear';
    (merged, $__.os.oid310)[p, 'fogNear'] = ((tmp, $__.os.oid322)[p, 'fogNear'], $__.os.oid324);
    'fogFar' in vvv_tmp3;
    p = 'fogFar';
    (merged, $__.os.oid310)[p, 'fogFar'] = ((tmp, $__.os.oid322)[p, 'fogFar'], $__.os.oid325);
    'fogColor' in vvv_tmp3;
    p = 'fogColor';
    (merged, $__.os.oid310)[p, 'fogColor'] = ((tmp, $__.os.oid322)[p, 'fogColor'], $__.os.oid326);
    (u = +u + 1) - 1;
    u < (uniforms.length, 3);
    tmp = (vvv_tmp4 = this, 'clone', $__.fs.J$__v494107025_798_600.call(vvv_tmp4, (uniforms[u, 2], $__.os.oid309), 36, true, $__.uid));
    vvv_tmp5 = tmp;
    'scale' in vvv_tmp5;
    p = 'scale';
    (merged, $__.os.oid310)[p, 'scale'] = ((tmp, $__.os.oid327)[p, 'scale'], $__.os.oid328);
    'dashSize' in vvv_tmp5;
    p = 'dashSize';
    (merged, $__.os.oid310)[p, 'dashSize'] = ((tmp, $__.os.oid327)[p, 'dashSize'], $__.os.oid329);
    'totalSize' in vvv_tmp5;
    p = 'totalSize';
    (merged, $__.os.oid310)[p, 'totalSize'] = ((tmp, $__.os.oid327)[p, 'totalSize'], $__.os.oid330);
    (u = +u + 1) - 1;
    u < (uniforms.length, 3);
    return merged;
case 6:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 6);
    merged = $__.os.oid332 = {};
    u = 0;
    u < (uniforms.length, 2);
    tmp = (vvv_tmp0 = this, 'clone', $__.fs.J$__v494107025_798_600.call(vvv_tmp0, (uniforms[u, 0], $__.os.oid31), 37, true, $__.uid));
    vvv_tmp1 = tmp;
    'diffuse' in vvv_tmp1;
    p = 'diffuse';
    (merged, $__.os.oid332)[p, 'diffuse'] = ((tmp, $__.os.oid333)[p, 'diffuse'], $__.os.oid334);
    'opacity' in vvv_tmp1;
    p = 'opacity';
    (merged, $__.os.oid332)[p, 'opacity'] = ((tmp, $__.os.oid333)[p, 'opacity'], $__.os.oid335);
    'map' in vvv_tmp1;
    p = 'map';
    (merged, $__.os.oid332)[p, 'map'] = ((tmp, $__.os.oid333)[p, 'map'], $__.os.oid336);
    'offsetRepeat' in vvv_tmp1;
    p = 'offsetRepeat';
    (merged, $__.os.oid332)[p, 'offsetRepeat'] = ((tmp, $__.os.oid333)[p, 'offsetRepeat'], $__.os.oid337);
    'specularMap' in vvv_tmp1;
    p = 'specularMap';
    (merged, $__.os.oid332)[p, 'specularMap'] = ((tmp, $__.os.oid333)[p, 'specularMap'], $__.os.oid338);
    'alphaMap' in vvv_tmp1;
    p = 'alphaMap';
    (merged, $__.os.oid332)[p, 'alphaMap'] = ((tmp, $__.os.oid333)[p, 'alphaMap'], $__.os.oid339);
    'envMap' in vvv_tmp1;
    p = 'envMap';
    (merged, $__.os.oid332)[p, 'envMap'] = ((tmp, $__.os.oid333)[p, 'envMap'], $__.os.oid340);
    'flipEnvMap' in vvv_tmp1;
    p = 'flipEnvMap';
    (merged, $__.os.oid332)[p, 'flipEnvMap'] = ((tmp, $__.os.oid333)[p, 'flipEnvMap'], $__.os.oid341);
    'reflectivity' in vvv_tmp1;
    p = 'reflectivity';
    (merged, $__.os.oid332)[p, 'reflectivity'] = ((tmp, $__.os.oid333)[p, 'reflectivity'], $__.os.oid342);
    'refractionRatio' in vvv_tmp1;
    p = 'refractionRatio';
    (merged, $__.os.oid332)[p, 'refractionRatio'] = ((tmp, $__.os.oid333)[p, 'refractionRatio'], $__.os.oid343);
    (u = +u + 1) - 1;
    u < (uniforms.length, 2);
    tmp = (vvv_tmp2 = this, 'clone', $__.fs.J$__v494107025_798_600.call(vvv_tmp2, (uniforms[u, 1], $__.os.oid49), 38, true, $__.uid));
    vvv_tmp3 = tmp;
    'displacementMap' in vvv_tmp3;
    p = 'displacementMap';
    (merged, $__.os.oid332)[p, 'displacementMap'] = ((tmp, $__.os.oid344)[p, 'displacementMap'], $__.os.oid345);
    'displacementScale' in vvv_tmp3;
    p = 'displacementScale';
    (merged, $__.os.oid332)[p, 'displacementScale'] = ((tmp, $__.os.oid344)[p, 'displacementScale'], $__.os.oid346);
    'displacementBias' in vvv_tmp3;
    p = 'displacementBias';
    (merged, $__.os.oid332)[p, 'displacementBias'] = ((tmp, $__.os.oid344)[p, 'displacementBias'], $__.os.oid347);
    (u = +u + 1) - 1;
    u < (uniforms.length, 2);
    return merged;
case 7:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 7);
    merged = $__.os.oid368 = {};
    u = 0;
    u < (uniforms.length, 2);
    tmp = (vvv_tmp0 = this, 'clone', $__.fs.J$__v494107025_798_600.call(vvv_tmp0, (uniforms[u, 0], $__.os.oid235), 39, true, $__.uid));
    vvv_tmp1 = tmp;
    'diffuse' in vvv_tmp1;
    p = 'diffuse';
    (merged, $__.os.oid368)[p, 'diffuse'] = ((tmp, $__.os.oid369)[p, 'diffuse'], $__.os.oid370);
    'opacity' in vvv_tmp1;
    p = 'opacity';
    (merged, $__.os.oid368)[p, 'opacity'] = ((tmp, $__.os.oid369)[p, 'opacity'], $__.os.oid371);
    'map' in vvv_tmp1;
    p = 'map';
    (merged, $__.os.oid368)[p, 'map'] = ((tmp, $__.os.oid369)[p, 'map'], $__.os.oid372);
    'offsetRepeat' in vvv_tmp1;
    p = 'offsetRepeat';
    (merged, $__.os.oid368)[p, 'offsetRepeat'] = ((tmp, $__.os.oid369)[p, 'offsetRepeat'], $__.os.oid373);
    'specularMap' in vvv_tmp1;
    p = 'specularMap';
    (merged, $__.os.oid368)[p, 'specularMap'] = ((tmp, $__.os.oid369)[p, 'specularMap'], $__.os.oid374);
    'alphaMap' in vvv_tmp1;
    p = 'alphaMap';
    (merged, $__.os.oid368)[p, 'alphaMap'] = ((tmp, $__.os.oid369)[p, 'alphaMap'], $__.os.oid375);
    'envMap' in vvv_tmp1;
    p = 'envMap';
    (merged, $__.os.oid368)[p, 'envMap'] = ((tmp, $__.os.oid369)[p, 'envMap'], $__.os.oid376);
    'flipEnvMap' in vvv_tmp1;
    p = 'flipEnvMap';
    (merged, $__.os.oid368)[p, 'flipEnvMap'] = ((tmp, $__.os.oid369)[p, 'flipEnvMap'], $__.os.oid377);
    'reflectivity' in vvv_tmp1;
    p = 'reflectivity';
    (merged, $__.os.oid368)[p, 'reflectivity'] = ((tmp, $__.os.oid369)[p, 'reflectivity'], $__.os.oid378);
    'refractionRatio' in vvv_tmp1;
    p = 'refractionRatio';
    (merged, $__.os.oid368)[p, 'refractionRatio'] = ((tmp, $__.os.oid369)[p, 'refractionRatio'], $__.os.oid379);
    'aoMap' in vvv_tmp1;
    p = 'aoMap';
    (merged, $__.os.oid368)[p, 'aoMap'] = ((tmp, $__.os.oid369)[p, 'aoMap'], $__.os.oid380);
    'aoMapIntensity' in vvv_tmp1;
    p = 'aoMapIntensity';
    (merged, $__.os.oid368)[p, 'aoMapIntensity'] = ((tmp, $__.os.oid369)[p, 'aoMapIntensity'], $__.os.oid381);
    'lightMap' in vvv_tmp1;
    p = 'lightMap';
    (merged, $__.os.oid368)[p, 'lightMap'] = ((tmp, $__.os.oid369)[p, 'lightMap'], $__.os.oid382);
    'lightMapIntensity' in vvv_tmp1;
    p = 'lightMapIntensity';
    (merged, $__.os.oid368)[p, 'lightMapIntensity'] = ((tmp, $__.os.oid369)[p, 'lightMapIntensity'], $__.os.oid383);
    'emissiveMap' in vvv_tmp1;
    p = 'emissiveMap';
    (merged, $__.os.oid368)[p, 'emissiveMap'] = ((tmp, $__.os.oid369)[p, 'emissiveMap'], $__.os.oid384);
    'bumpMap' in vvv_tmp1;
    p = 'bumpMap';
    (merged, $__.os.oid368)[p, 'bumpMap'] = ((tmp, $__.os.oid369)[p, 'bumpMap'], $__.os.oid385);
    'bumpScale' in vvv_tmp1;
    p = 'bumpScale';
    (merged, $__.os.oid368)[p, 'bumpScale'] = ((tmp, $__.os.oid369)[p, 'bumpScale'], $__.os.oid386);
    'normalMap' in vvv_tmp1;
    p = 'normalMap';
    (merged, $__.os.oid368)[p, 'normalMap'] = ((tmp, $__.os.oid369)[p, 'normalMap'], $__.os.oid387);
    'normalScale' in vvv_tmp1;
    p = 'normalScale';
    (merged, $__.os.oid368)[p, 'normalScale'] = ((tmp, $__.os.oid369)[p, 'normalScale'], $__.os.oid388);
    'displacementMap' in vvv_tmp1;
    p = 'displacementMap';
    (merged, $__.os.oid368)[p, 'displacementMap'] = ((tmp, $__.os.oid369)[p, 'displacementMap'], $__.os.oid389);
    'displacementScale' in vvv_tmp1;
    p = 'displacementScale';
    (merged, $__.os.oid368)[p, 'displacementScale'] = ((tmp, $__.os.oid369)[p, 'displacementScale'], $__.os.oid390);
    'displacementBias' in vvv_tmp1;
    p = 'displacementBias';
    (merged, $__.os.oid368)[p, 'displacementBias'] = ((tmp, $__.os.oid369)[p, 'displacementBias'], $__.os.oid391);
    'roughnessMap' in vvv_tmp1;
    p = 'roughnessMap';
    (merged, $__.os.oid368)[p, 'roughnessMap'] = ((tmp, $__.os.oid369)[p, 'roughnessMap'], $__.os.oid392);
    'metalnessMap' in vvv_tmp1;
    p = 'metalnessMap';
    (merged, $__.os.oid368)[p, 'metalnessMap'] = ((tmp, $__.os.oid369)[p, 'metalnessMap'], $__.os.oid393);
    'fogDensity' in vvv_tmp1;
    p = 'fogDensity';
    (merged, $__.os.oid368)[p, 'fogDensity'] = ((tmp, $__.os.oid369)[p, 'fogDensity'], $__.os.oid394);
    'fogNear' in vvv_tmp1;
    p = 'fogNear';
    (merged, $__.os.oid368)[p, 'fogNear'] = ((tmp, $__.os.oid369)[p, 'fogNear'], $__.os.oid395);
    'fogFar' in vvv_tmp1;
    p = 'fogFar';
    (merged, $__.os.oid368)[p, 'fogFar'] = ((tmp, $__.os.oid369)[p, 'fogFar'], $__.os.oid396);
    'fogColor' in vvv_tmp1;
    p = 'fogColor';
    (merged, $__.os.oid368)[p, 'fogColor'] = ((tmp, $__.os.oid369)[p, 'fogColor'], $__.os.oid397);
    'ambientLightColor' in vvv_tmp1;
    p = 'ambientLightColor';
    (merged, $__.os.oid368)[p, 'ambientLightColor'] = ((tmp, $__.os.oid369)[p, 'ambientLightColor'], $__.os.oid398);
    'directionalLights' in vvv_tmp1;
    p = 'directionalLights';
    (merged, $__.os.oid368)[p, 'directionalLights'] = ((tmp, $__.os.oid369)[p, 'directionalLights'], $__.os.oid399);
    'directionalShadowMap' in vvv_tmp1;
    p = 'directionalShadowMap';
    (merged, $__.os.oid368)[p, 'directionalShadowMap'] = ((tmp, $__.os.oid369)[p, 'directionalShadowMap'], $__.os.oid400);
    'directionalShadowMatrix' in vvv_tmp1;
    p = 'directionalShadowMatrix';
    (merged, $__.os.oid368)[p, 'directionalShadowMatrix'] = ((tmp, $__.os.oid369)[p, 'directionalShadowMatrix'], $__.os.oid401);
    'spotLights' in vvv_tmp1;
    p = 'spotLights';
    (merged, $__.os.oid368)[p, 'spotLights'] = ((tmp, $__.os.oid369)[p, 'spotLights'], $__.os.oid402);
    'spotShadowMap' in vvv_tmp1;
    p = 'spotShadowMap';
    (merged, $__.os.oid368)[p, 'spotShadowMap'] = ((tmp, $__.os.oid369)[p, 'spotShadowMap'], $__.os.oid403);
    'spotShadowMatrix' in vvv_tmp1;
    p = 'spotShadowMatrix';
    (merged, $__.os.oid368)[p, 'spotShadowMatrix'] = ((tmp, $__.os.oid369)[p, 'spotShadowMatrix'], $__.os.oid404);
    'pointLights' in vvv_tmp1;
    p = 'pointLights';
    (merged, $__.os.oid368)[p, 'pointLights'] = ((tmp, $__.os.oid369)[p, 'pointLights'], $__.os.oid405);
    'pointShadowMap' in vvv_tmp1;
    p = 'pointShadowMap';
    (merged, $__.os.oid368)[p, 'pointShadowMap'] = ((tmp, $__.os.oid369)[p, 'pointShadowMap'], $__.os.oid406);
    'pointShadowMatrix' in vvv_tmp1;
    p = 'pointShadowMatrix';
    (merged, $__.os.oid368)[p, 'pointShadowMatrix'] = ((tmp, $__.os.oid369)[p, 'pointShadowMatrix'], $__.os.oid407);
    'hemisphereLights' in vvv_tmp1;
    p = 'hemisphereLights';
    (merged, $__.os.oid368)[p, 'hemisphereLights'] = ((tmp, $__.os.oid369)[p, 'hemisphereLights'], $__.os.oid408);
    'emissive' in vvv_tmp1;
    p = 'emissive';
    (merged, $__.os.oid368)[p, 'emissive'] = ((tmp, $__.os.oid369)[p, 'emissive'], $__.os.oid409);
    'roughness' in vvv_tmp1;
    p = 'roughness';
    (merged, $__.os.oid368)[p, 'roughness'] = ((tmp, $__.os.oid369)[p, 'roughness'], $__.os.oid410);
    'metalness' in vvv_tmp1;
    p = 'metalness';
    (merged, $__.os.oid368)[p, 'metalness'] = ((tmp, $__.os.oid369)[p, 'metalness'], $__.os.oid411);
    'envMapIntensity' in vvv_tmp1;
    p = 'envMapIntensity';
    (merged, $__.os.oid368)[p, 'envMapIntensity'] = ((tmp, $__.os.oid369)[p, 'envMapIntensity'], $__.os.oid412);
    (u = +u + 1) - 1;
    u < (uniforms.length, 2);
    tmp = (vvv_tmp2 = this, 'clone', $__.fs.J$__v494107025_798_600.call(vvv_tmp2, (uniforms[u, 1], $__.os.oid367), 40, true, $__.uid));
    vvv_tmp3 = tmp;
    'clearCoat' in vvv_tmp3;
    p = 'clearCoat';
    (merged, $__.os.oid368)[p, 'clearCoat'] = ((tmp, $__.os.oid413)[p, 'clearCoat'], $__.os.oid414);
    'clearCoatRoughness' in vvv_tmp3;
    p = 'clearCoatRoughness';
    (merged, $__.os.oid368)[p, 'clearCoatRoughness'] = ((tmp, $__.os.oid413)[p, 'clearCoatRoughness'], $__.os.oid415);
    (u = +u + 1) - 1;
    u < (uniforms.length, 2);
    return merged;
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
merged = {};
for (var u = 0; u < uniforms.length; u++) {
    tmp = this.clone(uniforms[u]);
    for (var p in tmp) {
        merged[p] = tmp[p];
    }
}
return merged;}),
        'clone': ($__.fs.J$__v494107025_798_600 = function J$__v494107025_798(uniforms_src) {
var vvv_return, vvv_switch, vvv_tmp0, vvv_tmp1, vvv_tmp2, vvv_tmp3, vvv_tmp4, vvv_tmp5, vvv_tmp6, vvv_tmp7, vvv_tmp8, vvv_tmp9, vvv_tmp10, vvv_tmp11, vvv_tmp12, uniforms_dst, u, p, parameter_src, vvv_tmp13, vvv_tmp14, vvv_tmp15, vvv_tmp16, vvv_tmp17, vvv_tmp18, vvv_tmp19, vvv_tmp20, vvv_tmp21, vvv_tmp22, vvv_tmp23, vvv_tmp24, vvv_tmp25, vvv_tmp26, vvv_tmp27, vvv_tmp28, vvv_tmp29, vvv_tmp30, vvv_tmp31, vvv_tmp32, vvv_tmp33, vvv_tmp34, vvv_tmp35, vvv_tmp36, vvv_tmp37, vvv_tmp38, vvv_tmp39, vvv_tmp40, vvv_tmp41, vvv_tmp42, vvv_tmp43, vvv_tmp44, vvv_tmp45, vvv_tmp46, vvv_tmp47, vvv_tmp48;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
uniforms_src = arguments[0];
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    uniforms_dst = $__.os.oid112 = {};
    vvv_tmp0 = uniforms_src;
    'diffuse' in vvv_tmp0;
    u = 'diffuse';
    (uniforms_dst, $__.os.oid112)[u, 'diffuse'] = $__.os.oid113 = {};
    vvv_tmp1 = ((uniforms_src, $__.os.oid31)[u, 'diffuse'], $__.os.oid21);
    'value' in vvv_tmp1;
    p = 'value';
    parameter_src = TAJS_restrictToType((((uniforms_src, $__.os.oid31)[u, 'diffuse'], $__.os.oid21), $__.os.oid21)[p, 'value'], 'object');
    parameter_src, (parameter_src.isColor, true);
    (((uniforms_dst, $__.os.oid112)[u, 'diffuse'], $__.os.oid113), $__.os.oid113)[p, 'value'] = (vvv_tmp2 = parameter_src, 'clone', $__.fs.J$__v494107025_821_611.call(vvv_tmp2, 0, true, $__.uid));
    'opacity' in vvv_tmp0;
    u = 'opacity';
    (uniforms_dst, $__.os.oid112)[u, 'opacity'] = $__.os.oid114 = {};
    vvv_tmp3 = ((uniforms_src, $__.os.oid31)[u, 'opacity'], $__.os.oid22);
    'value' in vvv_tmp3;
    p = 'value';
    parameter_src = ((((uniforms_src, $__.os.oid31)[u, 'opacity'], $__.os.oid22), $__.os.oid22)[p, 'value'], 1);
    ((((((parameter_src, TAJS_restrictToType(parameter_src.isColor, 'undefined')), (parameter_src, TAJS_restrictToType(parameter_src.isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isTexture, 'undefined'));
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid112)[u, 'opacity'], $__.os.oid114), $__.os.oid114)[p, 'value'] = parameter_src;
    'map' in vvv_tmp0;
    u = 'map';
    (uniforms_dst, $__.os.oid112)[u, 'map'] = $__.os.oid115 = {};
    vvv_tmp4 = ((uniforms_src, $__.os.oid31)[u, 'map'], $__.os.oid23);
    'value' in vvv_tmp4;
    p = 'value';
    parameter_src = ((((uniforms_src, $__.os.oid31)[u, 'map'], $__.os.oid23), $__.os.oid23)[p, 'value'], null);
    (((((parameter_src, parameter_src), parameter_src), parameter_src), parameter_src), parameter_src), parameter_src;
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid112)[u, 'map'], $__.os.oid115), $__.os.oid115)[p, 'value'] = parameter_src;
    'offsetRepeat' in vvv_tmp0;
    u = 'offsetRepeat';
    (uniforms_dst, $__.os.oid112)[u, 'offsetRepeat'] = $__.os.oid116 = {};
    vvv_tmp5 = ((uniforms_src, $__.os.oid31)[u, 'offsetRepeat'], $__.os.oid24);
    'value' in vvv_tmp5;
    p = 'value';
    parameter_src = TAJS_restrictToType((((uniforms_src, $__.os.oid31)[u, 'offsetRepeat'], $__.os.oid24), $__.os.oid24)[p, 'value'], 'object');
    (((parameter_src, TAJS_restrictToType(parameter_src.isColor, 'undefined')), (parameter_src, TAJS_restrictToType(parameter_src.isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector3, 'undefined'))), (parameter_src, (parameter_src.isVector4, true));
    (((uniforms_dst, $__.os.oid112)[u, 'offsetRepeat'], $__.os.oid116), $__.os.oid116)[p, 'value'] = (vvv_tmp6 = parameter_src, 'clone', $__.fs.J$__v494107025_623_551.call(vvv_tmp6, 0, true, $__.uid));
    'specularMap' in vvv_tmp0;
    u = 'specularMap';
    (uniforms_dst, $__.os.oid112)[u, 'specularMap'] = $__.os.oid117 = {};
    vvv_tmp7 = ((uniforms_src, $__.os.oid31)[u, 'specularMap'], $__.os.oid25);
    'value' in vvv_tmp7;
    p = 'value';
    parameter_src = ((((uniforms_src, $__.os.oid31)[u, 'specularMap'], $__.os.oid25), $__.os.oid25)[p, 'value'], null);
    (((((parameter_src, parameter_src), parameter_src), parameter_src), parameter_src), parameter_src), parameter_src;
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid112)[u, 'specularMap'], $__.os.oid117), $__.os.oid117)[p, 'value'] = parameter_src;
    'alphaMap' in vvv_tmp0;
    u = 'alphaMap';
    (uniforms_dst, $__.os.oid112)[u, 'alphaMap'] = $__.os.oid118 = {};
    vvv_tmp8 = ((uniforms_src, $__.os.oid31)[u, 'alphaMap'], $__.os.oid26);
    'value' in vvv_tmp8;
    p = 'value';
    parameter_src = ((((uniforms_src, $__.os.oid31)[u, 'alphaMap'], $__.os.oid26), $__.os.oid26)[p, 'value'], null);
    (((((parameter_src, parameter_src), parameter_src), parameter_src), parameter_src), parameter_src), parameter_src;
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid112)[u, 'alphaMap'], $__.os.oid118), $__.os.oid118)[p, 'value'] = parameter_src;
    'envMap' in vvv_tmp0;
    u = 'envMap';
    (uniforms_dst, $__.os.oid112)[u, 'envMap'] = $__.os.oid119 = {};
    vvv_tmp9 = ((uniforms_src, $__.os.oid31)[u, 'envMap'], $__.os.oid27);
    'value' in vvv_tmp9;
    p = 'value';
    parameter_src = ((((uniforms_src, $__.os.oid31)[u, 'envMap'], $__.os.oid27), $__.os.oid27)[p, 'value'], null);
    (((((parameter_src, parameter_src), parameter_src), parameter_src), parameter_src), parameter_src), parameter_src;
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid112)[u, 'envMap'], $__.os.oid119), $__.os.oid119)[p, 'value'] = parameter_src;
    'flipEnvMap' in vvv_tmp0;
    u = 'flipEnvMap';
    (uniforms_dst, $__.os.oid112)[u, 'flipEnvMap'] = $__.os.oid120 = {};
    vvv_tmp10 = ((uniforms_src, $__.os.oid31)[u, 'flipEnvMap'], $__.os.oid28);
    'value' in vvv_tmp10;
    p = 'value';
    parameter_src = ((((uniforms_src, $__.os.oid31)[u, 'flipEnvMap'], $__.os.oid28), $__.os.oid28)[p, 'value'], -1);
    ((((((parameter_src, TAJS_restrictToType(parameter_src.isColor, 'undefined')), (parameter_src, TAJS_restrictToType(parameter_src.isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isTexture, 'undefined'));
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid112)[u, 'flipEnvMap'], $__.os.oid120), $__.os.oid120)[p, 'value'] = parameter_src;
    'reflectivity' in vvv_tmp0;
    u = 'reflectivity';
    (uniforms_dst, $__.os.oid112)[u, 'reflectivity'] = $__.os.oid121 = {};
    vvv_tmp11 = ((uniforms_src, $__.os.oid31)[u, 'reflectivity'], $__.os.oid29);
    'value' in vvv_tmp11;
    p = 'value';
    parameter_src = ((((uniforms_src, $__.os.oid31)[u, 'reflectivity'], $__.os.oid29), $__.os.oid29)[p, 'value'], 1);
    ((((((parameter_src, TAJS_restrictToType(parameter_src.isColor, 'undefined')), (parameter_src, TAJS_restrictToType(parameter_src.isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isTexture, 'undefined'));
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid112)[u, 'reflectivity'], $__.os.oid121), $__.os.oid121)[p, 'value'] = parameter_src;
    'refractionRatio' in vvv_tmp0;
    u = 'refractionRatio';
    (uniforms_dst, $__.os.oid112)[u, 'refractionRatio'] = $__.os.oid122 = {};
    vvv_tmp12 = ((uniforms_src, $__.os.oid31)[u, 'refractionRatio'], $__.os.oid30);
    'value' in vvv_tmp12;
    p = 'value';
    parameter_src = ((((uniforms_src, $__.os.oid31)[u, 'refractionRatio'], $__.os.oid30), $__.os.oid30)[p, 'value'], 0.98);
    ((((((parameter_src, TAJS_restrictToType(parameter_src.isColor, 'undefined')), (parameter_src, TAJS_restrictToType(parameter_src.isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isTexture, 'undefined'));
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid112)[u, 'refractionRatio'], $__.os.oid122), $__.os.oid122)[p, 'value'] = parameter_src;
    return uniforms_dst;
case 1:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 1);
    uniforms_dst = $__.os.oid123 = {};
    vvv_tmp0 = uniforms_src;
    'aoMap' in vvv_tmp0;
    u = 'aoMap';
    (uniforms_dst, $__.os.oid123)[u, 'aoMap'] = $__.os.oid124 = {};
    vvv_tmp1 = ((uniforms_src, $__.os.oid34)[u, 'aoMap'], $__.os.oid32);
    'value' in vvv_tmp1;
    p = 'value';
    parameter_src = ((((uniforms_src, $__.os.oid34)[u, 'aoMap'], $__.os.oid32), $__.os.oid32)[p, 'value'], null);
    (((((parameter_src, parameter_src), parameter_src), parameter_src), parameter_src), parameter_src), parameter_src;
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid123)[u, 'aoMap'], $__.os.oid124), $__.os.oid124)[p, 'value'] = parameter_src;
    'aoMapIntensity' in vvv_tmp0;
    u = 'aoMapIntensity';
    (uniforms_dst, $__.os.oid123)[u, 'aoMapIntensity'] = $__.os.oid125 = {};
    vvv_tmp2 = ((uniforms_src, $__.os.oid34)[u, 'aoMapIntensity'], $__.os.oid33);
    'value' in vvv_tmp2;
    p = 'value';
    parameter_src = ((((uniforms_src, $__.os.oid34)[u, 'aoMapIntensity'], $__.os.oid33), $__.os.oid33)[p, 'value'], 1);
    ((((((parameter_src, TAJS_restrictToType(parameter_src.isColor, 'undefined')), (parameter_src, TAJS_restrictToType(parameter_src.isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isTexture, 'undefined'));
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid123)[u, 'aoMapIntensity'], $__.os.oid125), $__.os.oid125)[p, 'value'] = parameter_src;
    return uniforms_dst;
case 2:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 2);
    uniforms_dst = $__.os.oid126 = {};
    vvv_tmp0 = uniforms_src;
    'fogDensity' in vvv_tmp0;
    u = 'fogDensity';
    (uniforms_dst, $__.os.oid126)[u, 'fogDensity'] = $__.os.oid127 = {};
    vvv_tmp1 = ((uniforms_src, $__.os.oid58)[u, 'fogDensity'], $__.os.oid54);
    'value' in vvv_tmp1;
    p = 'value';
    parameter_src = ((((uniforms_src, $__.os.oid58)[u, 'fogDensity'], $__.os.oid54), $__.os.oid54)[p, 'value'], 0.00025);
    ((((((parameter_src, TAJS_restrictToType(parameter_src.isColor, 'undefined')), (parameter_src, TAJS_restrictToType(parameter_src.isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isTexture, 'undefined'));
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid126)[u, 'fogDensity'], $__.os.oid127), $__.os.oid127)[p, 'value'] = parameter_src;
    'fogNear' in vvv_tmp0;
    u = 'fogNear';
    (uniforms_dst, $__.os.oid126)[u, 'fogNear'] = $__.os.oid128 = {};
    vvv_tmp2 = ((uniforms_src, $__.os.oid58)[u, 'fogNear'], $__.os.oid55);
    'value' in vvv_tmp2;
    p = 'value';
    parameter_src = ((((uniforms_src, $__.os.oid58)[u, 'fogNear'], $__.os.oid55), $__.os.oid55)[p, 'value'], 1);
    ((((((parameter_src, TAJS_restrictToType(parameter_src.isColor, 'undefined')), (parameter_src, TAJS_restrictToType(parameter_src.isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isTexture, 'undefined'));
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid126)[u, 'fogNear'], $__.os.oid128), $__.os.oid128)[p, 'value'] = parameter_src;
    'fogFar' in vvv_tmp0;
    u = 'fogFar';
    (uniforms_dst, $__.os.oid126)[u, 'fogFar'] = $__.os.oid129 = {};
    vvv_tmp3 = ((uniforms_src, $__.os.oid58)[u, 'fogFar'], $__.os.oid56);
    'value' in vvv_tmp3;
    p = 'value';
    parameter_src = ((((uniforms_src, $__.os.oid58)[u, 'fogFar'], $__.os.oid56), $__.os.oid56)[p, 'value'], 2000);
    ((((((parameter_src, TAJS_restrictToType(parameter_src.isColor, 'undefined')), (parameter_src, TAJS_restrictToType(parameter_src.isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isTexture, 'undefined'));
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid126)[u, 'fogFar'], $__.os.oid129), $__.os.oid129)[p, 'value'] = parameter_src;
    'fogColor' in vvv_tmp0;
    u = 'fogColor';
    (uniforms_dst, $__.os.oid126)[u, 'fogColor'] = $__.os.oid130 = {};
    vvv_tmp4 = ((uniforms_src, $__.os.oid58)[u, 'fogColor'], $__.os.oid57);
    'value' in vvv_tmp4;
    p = 'value';
    parameter_src = TAJS_restrictToType((((uniforms_src, $__.os.oid58)[u, 'fogColor'], $__.os.oid57), $__.os.oid57)[p, 'value'], 'object');
    parameter_src, (parameter_src.isColor, true);
    (((uniforms_dst, $__.os.oid126)[u, 'fogColor'], $__.os.oid130), $__.os.oid130)[p, 'value'] = (vvv_tmp5 = parameter_src, 'clone', $__.fs.J$__v494107025_821_611.call(vvv_tmp5, 1, true, $__.uid));
    return uniforms_dst;
case 3:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 3);
    uniforms_dst = $__.os.oid135 = {};
    vvv_tmp0 = uniforms_src;
    'diffuse' in vvv_tmp0;
    u = 'diffuse';
    (uniforms_dst, $__.os.oid135)[u, 'diffuse'] = $__.os.oid136 = {};
    vvv_tmp1 = ((uniforms_src, $__.os.oid31)[u, 'diffuse'], $__.os.oid21);
    'value' in vvv_tmp1;
    p = 'value';
    parameter_src = TAJS_restrictToType((((uniforms_src, $__.os.oid31)[u, 'diffuse'], $__.os.oid21), $__.os.oid21)[p, 'value'], 'object');
    parameter_src, (parameter_src.isColor, true);
    (((uniforms_dst, $__.os.oid135)[u, 'diffuse'], $__.os.oid136), $__.os.oid136)[p, 'value'] = (vvv_tmp2 = parameter_src, 'clone', $__.fs.J$__v494107025_821_611.call(vvv_tmp2, 2, true, $__.uid));
    'opacity' in vvv_tmp0;
    u = 'opacity';
    (uniforms_dst, $__.os.oid135)[u, 'opacity'] = $__.os.oid137 = {};
    vvv_tmp3 = ((uniforms_src, $__.os.oid31)[u, 'opacity'], $__.os.oid22);
    'value' in vvv_tmp3;
    p = 'value';
    parameter_src = ((((uniforms_src, $__.os.oid31)[u, 'opacity'], $__.os.oid22), $__.os.oid22)[p, 'value'], 1);
    ((((((parameter_src, TAJS_restrictToType(parameter_src.isColor, 'undefined')), (parameter_src, TAJS_restrictToType(parameter_src.isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isTexture, 'undefined'));
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid135)[u, 'opacity'], $__.os.oid137), $__.os.oid137)[p, 'value'] = parameter_src;
    'map' in vvv_tmp0;
    u = 'map';
    (uniforms_dst, $__.os.oid135)[u, 'map'] = $__.os.oid138 = {};
    vvv_tmp4 = ((uniforms_src, $__.os.oid31)[u, 'map'], $__.os.oid23);
    'value' in vvv_tmp4;
    p = 'value';
    parameter_src = ((((uniforms_src, $__.os.oid31)[u, 'map'], $__.os.oid23), $__.os.oid23)[p, 'value'], null);
    (((((parameter_src, parameter_src), parameter_src), parameter_src), parameter_src), parameter_src), parameter_src;
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid135)[u, 'map'], $__.os.oid138), $__.os.oid138)[p, 'value'] = parameter_src;
    'offsetRepeat' in vvv_tmp0;
    u = 'offsetRepeat';
    (uniforms_dst, $__.os.oid135)[u, 'offsetRepeat'] = $__.os.oid139 = {};
    vvv_tmp5 = ((uniforms_src, $__.os.oid31)[u, 'offsetRepeat'], $__.os.oid24);
    'value' in vvv_tmp5;
    p = 'value';
    parameter_src = TAJS_restrictToType((((uniforms_src, $__.os.oid31)[u, 'offsetRepeat'], $__.os.oid24), $__.os.oid24)[p, 'value'], 'object');
    (((parameter_src, TAJS_restrictToType(parameter_src.isColor, 'undefined')), (parameter_src, TAJS_restrictToType(parameter_src.isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector3, 'undefined'))), (parameter_src, (parameter_src.isVector4, true));
    (((uniforms_dst, $__.os.oid135)[u, 'offsetRepeat'], $__.os.oid139), $__.os.oid139)[p, 'value'] = (vvv_tmp6 = parameter_src, 'clone', $__.fs.J$__v494107025_623_551.call(vvv_tmp6, 1, true, $__.uid));
    'specularMap' in vvv_tmp0;
    u = 'specularMap';
    (uniforms_dst, $__.os.oid135)[u, 'specularMap'] = $__.os.oid140 = {};
    vvv_tmp7 = ((uniforms_src, $__.os.oid31)[u, 'specularMap'], $__.os.oid25);
    'value' in vvv_tmp7;
    p = 'value';
    parameter_src = ((((uniforms_src, $__.os.oid31)[u, 'specularMap'], $__.os.oid25), $__.os.oid25)[p, 'value'], null);
    (((((parameter_src, parameter_src), parameter_src), parameter_src), parameter_src), parameter_src), parameter_src;
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid135)[u, 'specularMap'], $__.os.oid140), $__.os.oid140)[p, 'value'] = parameter_src;
    'alphaMap' in vvv_tmp0;
    u = 'alphaMap';
    (uniforms_dst, $__.os.oid135)[u, 'alphaMap'] = $__.os.oid141 = {};
    vvv_tmp8 = ((uniforms_src, $__.os.oid31)[u, 'alphaMap'], $__.os.oid26);
    'value' in vvv_tmp8;
    p = 'value';
    parameter_src = ((((uniforms_src, $__.os.oid31)[u, 'alphaMap'], $__.os.oid26), $__.os.oid26)[p, 'value'], null);
    (((((parameter_src, parameter_src), parameter_src), parameter_src), parameter_src), parameter_src), parameter_src;
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid135)[u, 'alphaMap'], $__.os.oid141), $__.os.oid141)[p, 'value'] = parameter_src;
    'envMap' in vvv_tmp0;
    u = 'envMap';
    (uniforms_dst, $__.os.oid135)[u, 'envMap'] = $__.os.oid142 = {};
    vvv_tmp9 = ((uniforms_src, $__.os.oid31)[u, 'envMap'], $__.os.oid27);
    'value' in vvv_tmp9;
    p = 'value';
    parameter_src = ((((uniforms_src, $__.os.oid31)[u, 'envMap'], $__.os.oid27), $__.os.oid27)[p, 'value'], null);
    (((((parameter_src, parameter_src), parameter_src), parameter_src), parameter_src), parameter_src), parameter_src;
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid135)[u, 'envMap'], $__.os.oid142), $__.os.oid142)[p, 'value'] = parameter_src;
    'flipEnvMap' in vvv_tmp0;
    u = 'flipEnvMap';
    (uniforms_dst, $__.os.oid135)[u, 'flipEnvMap'] = $__.os.oid143 = {};
    vvv_tmp10 = ((uniforms_src, $__.os.oid31)[u, 'flipEnvMap'], $__.os.oid28);
    'value' in vvv_tmp10;
    p = 'value';
    parameter_src = ((((uniforms_src, $__.os.oid31)[u, 'flipEnvMap'], $__.os.oid28), $__.os.oid28)[p, 'value'], -1);
    ((((((parameter_src, TAJS_restrictToType(parameter_src.isColor, 'undefined')), (parameter_src, TAJS_restrictToType(parameter_src.isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isTexture, 'undefined'));
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid135)[u, 'flipEnvMap'], $__.os.oid143), $__.os.oid143)[p, 'value'] = parameter_src;
    'reflectivity' in vvv_tmp0;
    u = 'reflectivity';
    (uniforms_dst, $__.os.oid135)[u, 'reflectivity'] = $__.os.oid144 = {};
    vvv_tmp11 = ((uniforms_src, $__.os.oid31)[u, 'reflectivity'], $__.os.oid29);
    'value' in vvv_tmp11;
    p = 'value';
    parameter_src = ((((uniforms_src, $__.os.oid31)[u, 'reflectivity'], $__.os.oid29), $__.os.oid29)[p, 'value'], 1);
    ((((((parameter_src, TAJS_restrictToType(parameter_src.isColor, 'undefined')), (parameter_src, TAJS_restrictToType(parameter_src.isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isTexture, 'undefined'));
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid135)[u, 'reflectivity'], $__.os.oid144), $__.os.oid144)[p, 'value'] = parameter_src;
    'refractionRatio' in vvv_tmp0;
    u = 'refractionRatio';
    (uniforms_dst, $__.os.oid135)[u, 'refractionRatio'] = $__.os.oid145 = {};
    vvv_tmp12 = ((uniforms_src, $__.os.oid31)[u, 'refractionRatio'], $__.os.oid30);
    'value' in vvv_tmp12;
    p = 'value';
    parameter_src = ((((uniforms_src, $__.os.oid31)[u, 'refractionRatio'], $__.os.oid30), $__.os.oid30)[p, 'value'], 0.98);
    ((((((parameter_src, TAJS_restrictToType(parameter_src.isColor, 'undefined')), (parameter_src, TAJS_restrictToType(parameter_src.isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isTexture, 'undefined'));
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid135)[u, 'refractionRatio'], $__.os.oid145), $__.os.oid145)[p, 'value'] = parameter_src;
    return uniforms_dst;
case 4:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 4);
    uniforms_dst = $__.os.oid146 = {};
    vvv_tmp0 = uniforms_src;
    'aoMap' in vvv_tmp0;
    u = 'aoMap';
    (uniforms_dst, $__.os.oid146)[u, 'aoMap'] = $__.os.oid147 = {};
    vvv_tmp1 = ((uniforms_src, $__.os.oid34)[u, 'aoMap'], $__.os.oid32);
    'value' in vvv_tmp1;
    p = 'value';
    parameter_src = ((((uniforms_src, $__.os.oid34)[u, 'aoMap'], $__.os.oid32), $__.os.oid32)[p, 'value'], null);
    (((((parameter_src, parameter_src), parameter_src), parameter_src), parameter_src), parameter_src), parameter_src;
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid146)[u, 'aoMap'], $__.os.oid147), $__.os.oid147)[p, 'value'] = parameter_src;
    'aoMapIntensity' in vvv_tmp0;
    u = 'aoMapIntensity';
    (uniforms_dst, $__.os.oid146)[u, 'aoMapIntensity'] = $__.os.oid148 = {};
    vvv_tmp2 = ((uniforms_src, $__.os.oid34)[u, 'aoMapIntensity'], $__.os.oid33);
    'value' in vvv_tmp2;
    p = 'value';
    parameter_src = ((((uniforms_src, $__.os.oid34)[u, 'aoMapIntensity'], $__.os.oid33), $__.os.oid33)[p, 'value'], 1);
    ((((((parameter_src, TAJS_restrictToType(parameter_src.isColor, 'undefined')), (parameter_src, TAJS_restrictToType(parameter_src.isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isTexture, 'undefined'));
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid146)[u, 'aoMapIntensity'], $__.os.oid148), $__.os.oid148)[p, 'value'] = parameter_src;
    return uniforms_dst;
case 5:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 5);
    uniforms_dst = $__.os.oid149 = {};
    vvv_tmp0 = uniforms_src;
    'lightMap' in vvv_tmp0;
    u = 'lightMap';
    (uniforms_dst, $__.os.oid149)[u, 'lightMap'] = $__.os.oid150 = {};
    vvv_tmp1 = ((uniforms_src, $__.os.oid37)[u, 'lightMap'], $__.os.oid35);
    'value' in vvv_tmp1;
    p = 'value';
    parameter_src = ((((uniforms_src, $__.os.oid37)[u, 'lightMap'], $__.os.oid35), $__.os.oid35)[p, 'value'], null);
    (((((parameter_src, parameter_src), parameter_src), parameter_src), parameter_src), parameter_src), parameter_src;
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid149)[u, 'lightMap'], $__.os.oid150), $__.os.oid150)[p, 'value'] = parameter_src;
    'lightMapIntensity' in vvv_tmp0;
    u = 'lightMapIntensity';
    (uniforms_dst, $__.os.oid149)[u, 'lightMapIntensity'] = $__.os.oid151 = {};
    vvv_tmp2 = ((uniforms_src, $__.os.oid37)[u, 'lightMapIntensity'], $__.os.oid36);
    'value' in vvv_tmp2;
    p = 'value';
    parameter_src = ((((uniforms_src, $__.os.oid37)[u, 'lightMapIntensity'], $__.os.oid36), $__.os.oid36)[p, 'value'], 1);
    ((((((parameter_src, TAJS_restrictToType(parameter_src.isColor, 'undefined')), (parameter_src, TAJS_restrictToType(parameter_src.isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isTexture, 'undefined'));
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid149)[u, 'lightMapIntensity'], $__.os.oid151), $__.os.oid151)[p, 'value'] = parameter_src;
    return uniforms_dst;
case 6:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 6);
    uniforms_dst = $__.os.oid152 = {};
    vvv_tmp0 = uniforms_src;
    'emissiveMap' in vvv_tmp0;
    u = 'emissiveMap';
    (uniforms_dst, $__.os.oid152)[u, 'emissiveMap'] = $__.os.oid153 = {};
    vvv_tmp1 = ((uniforms_src, $__.os.oid39)[u, 'emissiveMap'], $__.os.oid38);
    'value' in vvv_tmp1;
    p = 'value';
    parameter_src = ((((uniforms_src, $__.os.oid39)[u, 'emissiveMap'], $__.os.oid38), $__.os.oid38)[p, 'value'], null);
    (((((parameter_src, parameter_src), parameter_src), parameter_src), parameter_src), parameter_src), parameter_src;
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid152)[u, 'emissiveMap'], $__.os.oid153), $__.os.oid153)[p, 'value'] = parameter_src;
    return uniforms_dst;
case 7:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 7);
    uniforms_dst = $__.os.oid154 = {};
    vvv_tmp0 = uniforms_src;
    'fogDensity' in vvv_tmp0;
    u = 'fogDensity';
    (uniforms_dst, $__.os.oid154)[u, 'fogDensity'] = $__.os.oid155 = {};
    vvv_tmp1 = ((uniforms_src, $__.os.oid58)[u, 'fogDensity'], $__.os.oid54);
    'value' in vvv_tmp1;
    p = 'value';
    parameter_src = ((((uniforms_src, $__.os.oid58)[u, 'fogDensity'], $__.os.oid54), $__.os.oid54)[p, 'value'], 0.00025);
    ((((((parameter_src, TAJS_restrictToType(parameter_src.isColor, 'undefined')), (parameter_src, TAJS_restrictToType(parameter_src.isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isTexture, 'undefined'));
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid154)[u, 'fogDensity'], $__.os.oid155), $__.os.oid155)[p, 'value'] = parameter_src;
    'fogNear' in vvv_tmp0;
    u = 'fogNear';
    (uniforms_dst, $__.os.oid154)[u, 'fogNear'] = $__.os.oid156 = {};
    vvv_tmp2 = ((uniforms_src, $__.os.oid58)[u, 'fogNear'], $__.os.oid55);
    'value' in vvv_tmp2;
    p = 'value';
    parameter_src = ((((uniforms_src, $__.os.oid58)[u, 'fogNear'], $__.os.oid55), $__.os.oid55)[p, 'value'], 1);
    ((((((parameter_src, TAJS_restrictToType(parameter_src.isColor, 'undefined')), (parameter_src, TAJS_restrictToType(parameter_src.isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isTexture, 'undefined'));
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid154)[u, 'fogNear'], $__.os.oid156), $__.os.oid156)[p, 'value'] = parameter_src;
    'fogFar' in vvv_tmp0;
    u = 'fogFar';
    (uniforms_dst, $__.os.oid154)[u, 'fogFar'] = $__.os.oid157 = {};
    vvv_tmp3 = ((uniforms_src, $__.os.oid58)[u, 'fogFar'], $__.os.oid56);
    'value' in vvv_tmp3;
    p = 'value';
    parameter_src = ((((uniforms_src, $__.os.oid58)[u, 'fogFar'], $__.os.oid56), $__.os.oid56)[p, 'value'], 2000);
    ((((((parameter_src, TAJS_restrictToType(parameter_src.isColor, 'undefined')), (parameter_src, TAJS_restrictToType(parameter_src.isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isTexture, 'undefined'));
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid154)[u, 'fogFar'], $__.os.oid157), $__.os.oid157)[p, 'value'] = parameter_src;
    'fogColor' in vvv_tmp0;
    u = 'fogColor';
    (uniforms_dst, $__.os.oid154)[u, 'fogColor'] = $__.os.oid158 = {};
    vvv_tmp4 = ((uniforms_src, $__.os.oid58)[u, 'fogColor'], $__.os.oid57);
    'value' in vvv_tmp4;
    p = 'value';
    parameter_src = TAJS_restrictToType((((uniforms_src, $__.os.oid58)[u, 'fogColor'], $__.os.oid57), $__.os.oid57)[p, 'value'], 'object');
    parameter_src, (parameter_src.isColor, true);
    (((uniforms_dst, $__.os.oid154)[u, 'fogColor'], $__.os.oid158), $__.os.oid158)[p, 'value'] = (vvv_tmp5 = parameter_src, 'clone', $__.fs.J$__v494107025_821_611.call(vvv_tmp5, 3, true, $__.uid));
    return uniforms_dst;
case 8:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 8);
    uniforms_dst = $__.os.oid159 = {};
    vvv_tmp0 = uniforms_src;
    'ambientLightColor' in vvv_tmp0;
    u = 'ambientLightColor';
    (uniforms_dst, $__.os.oid159)[u, 'ambientLightColor'] = $__.os.oid160 = {};
    vvv_tmp1 = ((uniforms_src, $__.os.oid102)[u, 'ambientLightColor'], $__.os.oid59);
    'value' in vvv_tmp1;
    p = 'value';
    parameter_src = TAJS_restrictToType((((uniforms_src, $__.os.oid102)[u, 'ambientLightColor'], $__.os.oid59), $__.os.oid59)[p, 'value'], 'object');
    ((((((parameter_src, TAJS_restrictToType(parameter_src.isColor, 'undefined')), (parameter_src, TAJS_restrictToType(parameter_src.isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isTexture, 'undefined'));
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid159)[u, 'ambientLightColor'], $__.os.oid160), $__.os.oid160)[p, 'value'] = function $__lt2(res) {
        res.length = 0;
        if (res.length != 0)
            TAJS_dumpValue('Possible loss of precision');
        return res;
        ;
        TAJS_makeContextSensitive($__lt2, -2);
    }(parameter_src['slice']());
    'directionalLights' in vvv_tmp0;
    u = 'directionalLights';
    (uniforms_dst, $__.os.oid159)[u, 'directionalLights'] = $__.os.oid161 = {};
    vvv_tmp2 = ((uniforms_src, $__.os.oid102)[u, 'directionalLights'], $__.os.oid67);
    'value' in vvv_tmp2;
    p = 'value';
    parameter_src = TAJS_restrictToType((((uniforms_src, $__.os.oid102)[u, 'directionalLights'], $__.os.oid67), $__.os.oid67)[p, 'value'], 'object');
    ((((((parameter_src, TAJS_restrictToType(parameter_src.isColor, 'undefined')), (parameter_src, TAJS_restrictToType(parameter_src.isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isTexture, 'undefined'));
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid159)[u, 'directionalLights'], $__.os.oid161), $__.os.oid161)[p, 'value'] = function $__lt3(res) {
        res.length = 0;
        if (res.length != 0)
            TAJS_dumpValue('Possible loss of precision');
        return res;
        ;
        TAJS_makeContextSensitive($__lt3, -2);
    }(parameter_src['slice']());
    'properties' in vvv_tmp2;
    p = 'properties';
    parameter_src = ((((uniforms_src, $__.os.oid102)[u, 'directionalLights'], $__.os.oid67), $__.os.oid67)[p, 'properties'], $__.os.oid66);
    ((((((parameter_src, TAJS_restrictToType((parameter_src, $__.os.oid66).isColor, 'undefined')), (parameter_src, TAJS_restrictToType((parameter_src, $__.os.oid66).isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType((parameter_src, $__.os.oid66).isVector3, 'undefined'))), (parameter_src, TAJS_restrictToType((parameter_src, $__.os.oid66).isVector4, 'undefined'))), (parameter_src, TAJS_restrictToType((parameter_src, $__.os.oid66).isMatrix3, 'undefined'))), (parameter_src, TAJS_restrictToType((parameter_src, $__.os.oid66).isMatrix4, 'undefined'))), (parameter_src, TAJS_restrictToType((parameter_src, $__.os.oid66).isTexture, 'undefined'));
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid159)[u, 'directionalLights'], $__.os.oid161), $__.os.oid161)[p, 'properties'] = parameter_src;
    'directionalShadowMap' in vvv_tmp0;
    u = 'directionalShadowMap';
    (uniforms_dst, $__.os.oid159)[u, 'directionalShadowMap'] = $__.os.oid162 = {};
    vvv_tmp3 = ((uniforms_src, $__.os.oid102)[u, 'directionalShadowMap'], $__.os.oid68);
    'value' in vvv_tmp3;
    p = 'value';
    parameter_src = TAJS_restrictToType((((uniforms_src, $__.os.oid102)[u, 'directionalShadowMap'], $__.os.oid68), $__.os.oid68)[p, 'value'], 'object');
    ((((((parameter_src, TAJS_restrictToType(parameter_src.isColor, 'undefined')), (parameter_src, TAJS_restrictToType(parameter_src.isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isTexture, 'undefined'));
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid159)[u, 'directionalShadowMap'], $__.os.oid162), $__.os.oid162)[p, 'value'] = function $__lt4(res) {
        res.length = 0;
        if (res.length != 0)
            TAJS_dumpValue('Possible loss of precision');
        return res;
        ;
        TAJS_makeContextSensitive($__lt4, -2);
    }(parameter_src['slice']());
    'directionalShadowMatrix' in vvv_tmp0;
    u = 'directionalShadowMatrix';
    (uniforms_dst, $__.os.oid159)[u, 'directionalShadowMatrix'] = $__.os.oid163 = {};
    vvv_tmp4 = ((uniforms_src, $__.os.oid102)[u, 'directionalShadowMatrix'], $__.os.oid69);
    'value' in vvv_tmp4;
    p = 'value';
    parameter_src = TAJS_restrictToType((((uniforms_src, $__.os.oid102)[u, 'directionalShadowMatrix'], $__.os.oid69), $__.os.oid69)[p, 'value'], 'object');
    ((((((parameter_src, TAJS_restrictToType(parameter_src.isColor, 'undefined')), (parameter_src, TAJS_restrictToType(parameter_src.isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isTexture, 'undefined'));
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid159)[u, 'directionalShadowMatrix'], $__.os.oid163), $__.os.oid163)[p, 'value'] = function $__lt5(res) {
        res.length = 0;
        if (res.length != 0)
            TAJS_dumpValue('Possible loss of precision');
        return res;
        ;
        TAJS_makeContextSensitive($__lt5, -2);
    }(parameter_src['slice']());
    'spotLights' in vvv_tmp0;
    u = 'spotLights';
    (uniforms_dst, $__.os.oid159)[u, 'spotLights'] = $__.os.oid164 = {};
    vvv_tmp5 = ((uniforms_src, $__.os.oid102)[u, 'spotLights'], $__.os.oid82);
    'value' in vvv_tmp5;
    p = 'value';
    parameter_src = TAJS_restrictToType((((uniforms_src, $__.os.oid102)[u, 'spotLights'], $__.os.oid82), $__.os.oid82)[p, 'value'], 'object');
    ((((((parameter_src, TAJS_restrictToType(parameter_src.isColor, 'undefined')), (parameter_src, TAJS_restrictToType(parameter_src.isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isTexture, 'undefined'));
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid159)[u, 'spotLights'], $__.os.oid164), $__.os.oid164)[p, 'value'] = function $__lt6(res) {
        res.length = 0;
        if (res.length != 0)
            TAJS_dumpValue('Possible loss of precision');
        return res;
        ;
        TAJS_makeContextSensitive($__lt6, -2);
    }(parameter_src['slice']());
    'properties' in vvv_tmp5;
    p = 'properties';
    parameter_src = ((((uniforms_src, $__.os.oid102)[u, 'spotLights'], $__.os.oid82), $__.os.oid82)[p, 'properties'], $__.os.oid81);
    ((((((parameter_src, TAJS_restrictToType((parameter_src, $__.os.oid81).isColor, 'undefined')), (parameter_src, TAJS_restrictToType((parameter_src, $__.os.oid81).isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType((parameter_src, $__.os.oid81).isVector3, 'undefined'))), (parameter_src, TAJS_restrictToType((parameter_src, $__.os.oid81).isVector4, 'undefined'))), (parameter_src, TAJS_restrictToType((parameter_src, $__.os.oid81).isMatrix3, 'undefined'))), (parameter_src, TAJS_restrictToType((parameter_src, $__.os.oid81).isMatrix4, 'undefined'))), (parameter_src, TAJS_restrictToType((parameter_src, $__.os.oid81).isTexture, 'undefined'));
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid159)[u, 'spotLights'], $__.os.oid164), $__.os.oid164)[p, 'properties'] = parameter_src;
    'spotShadowMap' in vvv_tmp0;
    u = 'spotShadowMap';
    (uniforms_dst, $__.os.oid159)[u, 'spotShadowMap'] = $__.os.oid165 = {};
    vvv_tmp6 = ((uniforms_src, $__.os.oid102)[u, 'spotShadowMap'], $__.os.oid83);
    'value' in vvv_tmp6;
    p = 'value';
    parameter_src = TAJS_restrictToType((((uniforms_src, $__.os.oid102)[u, 'spotShadowMap'], $__.os.oid83), $__.os.oid83)[p, 'value'], 'object');
    ((((((parameter_src, TAJS_restrictToType(parameter_src.isColor, 'undefined')), (parameter_src, TAJS_restrictToType(parameter_src.isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isTexture, 'undefined'));
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid159)[u, 'spotShadowMap'], $__.os.oid165), $__.os.oid165)[p, 'value'] = function $__lt7(res) {
        res.length = 0;
        if (res.length != 0)
            TAJS_dumpValue('Possible loss of precision');
        return res;
        ;
        TAJS_makeContextSensitive($__lt7, -2);
    }(parameter_src['slice']());
    'spotShadowMatrix' in vvv_tmp0;
    u = 'spotShadowMatrix';
    (uniforms_dst, $__.os.oid159)[u, 'spotShadowMatrix'] = $__.os.oid166 = {};
    vvv_tmp7 = ((uniforms_src, $__.os.oid102)[u, 'spotShadowMatrix'], $__.os.oid84);
    'value' in vvv_tmp7;
    p = 'value';
    parameter_src = TAJS_restrictToType((((uniforms_src, $__.os.oid102)[u, 'spotShadowMatrix'], $__.os.oid84), $__.os.oid84)[p, 'value'], 'object');
    ((((((parameter_src, TAJS_restrictToType(parameter_src.isColor, 'undefined')), (parameter_src, TAJS_restrictToType(parameter_src.isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isTexture, 'undefined'));
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid159)[u, 'spotShadowMatrix'], $__.os.oid166), $__.os.oid166)[p, 'value'] = function $__lt8(res) {
        res.length = 0;
        if (res.length != 0)
            TAJS_dumpValue('Possible loss of precision');
        return res;
        ;
        TAJS_makeContextSensitive($__lt8, -2);
    }(parameter_src['slice']());
    'pointLights' in vvv_tmp0;
    u = 'pointLights';
    (uniforms_dst, $__.os.oid159)[u, 'pointLights'] = $__.os.oid167 = {};
    vvv_tmp8 = ((uniforms_src, $__.os.oid102)[u, 'pointLights'], $__.os.oid94);
    'value' in vvv_tmp8;
    p = 'value';
    parameter_src = TAJS_restrictToType((((uniforms_src, $__.os.oid102)[u, 'pointLights'], $__.os.oid94), $__.os.oid94)[p, 'value'], 'object');
    ((((((parameter_src, TAJS_restrictToType(parameter_src.isColor, 'undefined')), (parameter_src, TAJS_restrictToType(parameter_src.isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isTexture, 'undefined'));
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid159)[u, 'pointLights'], $__.os.oid167), $__.os.oid167)[p, 'value'] = function $__lt9(res) {
        res.length = 0;
        if (res.length != 0)
            TAJS_dumpValue('Possible loss of precision');
        return res;
        ;
        TAJS_makeContextSensitive($__lt9, -2);
    }(parameter_src['slice']());
    'properties' in vvv_tmp8;
    p = 'properties';
    parameter_src = ((((uniforms_src, $__.os.oid102)[u, 'pointLights'], $__.os.oid94), $__.os.oid94)[p, 'properties'], $__.os.oid93);
    ((((((parameter_src, TAJS_restrictToType((parameter_src, $__.os.oid93).isColor, 'undefined')), (parameter_src, TAJS_restrictToType((parameter_src, $__.os.oid93).isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType((parameter_src, $__.os.oid93).isVector3, 'undefined'))), (parameter_src, TAJS_restrictToType((parameter_src, $__.os.oid93).isVector4, 'undefined'))), (parameter_src, TAJS_restrictToType((parameter_src, $__.os.oid93).isMatrix3, 'undefined'))), (parameter_src, TAJS_restrictToType((parameter_src, $__.os.oid93).isMatrix4, 'undefined'))), (parameter_src, TAJS_restrictToType((parameter_src, $__.os.oid93).isTexture, 'undefined'));
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid159)[u, 'pointLights'], $__.os.oid167), $__.os.oid167)[p, 'properties'] = parameter_src;
    'pointShadowMap' in vvv_tmp0;
    u = 'pointShadowMap';
    (uniforms_dst, $__.os.oid159)[u, 'pointShadowMap'] = $__.os.oid168 = {};
    vvv_tmp9 = ((uniforms_src, $__.os.oid102)[u, 'pointShadowMap'], $__.os.oid95);
    'value' in vvv_tmp9;
    p = 'value';
    parameter_src = TAJS_restrictToType((((uniforms_src, $__.os.oid102)[u, 'pointShadowMap'], $__.os.oid95), $__.os.oid95)[p, 'value'], 'object');
    ((((((parameter_src, TAJS_restrictToType(parameter_src.isColor, 'undefined')), (parameter_src, TAJS_restrictToType(parameter_src.isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isTexture, 'undefined'));
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid159)[u, 'pointShadowMap'], $__.os.oid168), $__.os.oid168)[p, 'value'] = function $__lt10(res) {
        res.length = 0;
        if (res.length != 0)
            TAJS_dumpValue('Possible loss of precision');
        return res;
        ;
        TAJS_makeContextSensitive($__lt10, -2);
    }(parameter_src['slice']());
    'pointShadowMatrix' in vvv_tmp0;
    u = 'pointShadowMatrix';
    (uniforms_dst, $__.os.oid159)[u, 'pointShadowMatrix'] = $__.os.oid169 = {};
    vvv_tmp10 = ((uniforms_src, $__.os.oid102)[u, 'pointShadowMatrix'], $__.os.oid96);
    'value' in vvv_tmp10;
    p = 'value';
    parameter_src = TAJS_restrictToType((((uniforms_src, $__.os.oid102)[u, 'pointShadowMatrix'], $__.os.oid96), $__.os.oid96)[p, 'value'], 'object');
    ((((((parameter_src, TAJS_restrictToType(parameter_src.isColor, 'undefined')), (parameter_src, TAJS_restrictToType(parameter_src.isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isTexture, 'undefined'));
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid159)[u, 'pointShadowMatrix'], $__.os.oid169), $__.os.oid169)[p, 'value'] = function $__lt11(res) {
        res.length = 0;
        if (res.length != 0)
            TAJS_dumpValue('Possible loss of precision');
        return res;
        ;
        TAJS_makeContextSensitive($__lt11, -2);
    }(parameter_src['slice']());
    'hemisphereLights' in vvv_tmp0;
    u = 'hemisphereLights';
    (uniforms_dst, $__.os.oid159)[u, 'hemisphereLights'] = $__.os.oid170 = {};
    vvv_tmp11 = ((uniforms_src, $__.os.oid102)[u, 'hemisphereLights'], $__.os.oid101);
    'value' in vvv_tmp11;
    p = 'value';
    parameter_src = TAJS_restrictToType((((uniforms_src, $__.os.oid102)[u, 'hemisphereLights'], $__.os.oid101), $__.os.oid101)[p, 'value'], 'object');
    ((((((parameter_src, TAJS_restrictToType(parameter_src.isColor, 'undefined')), (parameter_src, TAJS_restrictToType(parameter_src.isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isTexture, 'undefined'));
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid159)[u, 'hemisphereLights'], $__.os.oid170), $__.os.oid170)[p, 'value'] = function $__lt12(res) {
        res.length = 0;
        if (res.length != 0)
            TAJS_dumpValue('Possible loss of precision');
        return res;
        ;
        TAJS_makeContextSensitive($__lt12, -2);
    }(parameter_src['slice']());
    'properties' in vvv_tmp11;
    p = 'properties';
    parameter_src = ((((uniforms_src, $__.os.oid102)[u, 'hemisphereLights'], $__.os.oid101), $__.os.oid101)[p, 'properties'], $__.os.oid100);
    ((((((parameter_src, TAJS_restrictToType((parameter_src, $__.os.oid100).isColor, 'undefined')), (parameter_src, TAJS_restrictToType((parameter_src, $__.os.oid100).isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType((parameter_src, $__.os.oid100).isVector3, 'undefined'))), (parameter_src, TAJS_restrictToType((parameter_src, $__.os.oid100).isVector4, 'undefined'))), (parameter_src, TAJS_restrictToType((parameter_src, $__.os.oid100).isMatrix3, 'undefined'))), (parameter_src, TAJS_restrictToType((parameter_src, $__.os.oid100).isMatrix4, 'undefined'))), (parameter_src, TAJS_restrictToType((parameter_src, $__.os.oid100).isTexture, 'undefined'));
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid159)[u, 'hemisphereLights'], $__.os.oid170), $__.os.oid170)[p, 'properties'] = parameter_src;
    return uniforms_dst;
case 9:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 9);
    uniforms_dst = $__.os.oid171 = {};
    vvv_tmp0 = uniforms_src;
    'emissive' in vvv_tmp0;
    u = 'emissive';
    (uniforms_dst, $__.os.oid171)[u, 'emissive'] = $__.os.oid172 = {};
    vvv_tmp1 = ((uniforms_src, $__.os.oid133)[u, 'emissive'], $__.os.oid132);
    'value' in vvv_tmp1;
    p = 'value';
    parameter_src = TAJS_restrictToType((((uniforms_src, $__.os.oid133)[u, 'emissive'], $__.os.oid132), $__.os.oid132)[p, 'value'], 'object');
    parameter_src, (parameter_src.isColor, true);
    (((uniforms_dst, $__.os.oid171)[u, 'emissive'], $__.os.oid172), $__.os.oid172)[p, 'value'] = (vvv_tmp2 = parameter_src, 'clone', $__.fs.J$__v494107025_821_611.call(vvv_tmp2, 4, true, $__.uid));
    return uniforms_dst;
case 10:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 10);
    uniforms_dst = $__.os.oid179 = {};
    vvv_tmp0 = uniforms_src;
    'diffuse' in vvv_tmp0;
    u = 'diffuse';
    (uniforms_dst, $__.os.oid179)[u, 'diffuse'] = $__.os.oid180 = {};
    vvv_tmp1 = ((uniforms_src, $__.os.oid31)[u, 'diffuse'], $__.os.oid21);
    'value' in vvv_tmp1;
    p = 'value';
    parameter_src = TAJS_restrictToType((((uniforms_src, $__.os.oid31)[u, 'diffuse'], $__.os.oid21), $__.os.oid21)[p, 'value'], 'object');
    parameter_src, (parameter_src.isColor, true);
    (((uniforms_dst, $__.os.oid179)[u, 'diffuse'], $__.os.oid180), $__.os.oid180)[p, 'value'] = (vvv_tmp2 = parameter_src, 'clone', $__.fs.J$__v494107025_821_611.call(vvv_tmp2, 5, true, $__.uid));
    'opacity' in vvv_tmp0;
    u = 'opacity';
    (uniforms_dst, $__.os.oid179)[u, 'opacity'] = $__.os.oid181 = {};
    vvv_tmp3 = ((uniforms_src, $__.os.oid31)[u, 'opacity'], $__.os.oid22);
    'value' in vvv_tmp3;
    p = 'value';
    parameter_src = ((((uniforms_src, $__.os.oid31)[u, 'opacity'], $__.os.oid22), $__.os.oid22)[p, 'value'], 1);
    ((((((parameter_src, TAJS_restrictToType(parameter_src.isColor, 'undefined')), (parameter_src, TAJS_restrictToType(parameter_src.isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isTexture, 'undefined'));
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid179)[u, 'opacity'], $__.os.oid181), $__.os.oid181)[p, 'value'] = parameter_src;
    'map' in vvv_tmp0;
    u = 'map';
    (uniforms_dst, $__.os.oid179)[u, 'map'] = $__.os.oid182 = {};
    vvv_tmp4 = ((uniforms_src, $__.os.oid31)[u, 'map'], $__.os.oid23);
    'value' in vvv_tmp4;
    p = 'value';
    parameter_src = ((((uniforms_src, $__.os.oid31)[u, 'map'], $__.os.oid23), $__.os.oid23)[p, 'value'], null);
    (((((parameter_src, parameter_src), parameter_src), parameter_src), parameter_src), parameter_src), parameter_src;
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid179)[u, 'map'], $__.os.oid182), $__.os.oid182)[p, 'value'] = parameter_src;
    'offsetRepeat' in vvv_tmp0;
    u = 'offsetRepeat';
    (uniforms_dst, $__.os.oid179)[u, 'offsetRepeat'] = $__.os.oid183 = {};
    vvv_tmp5 = ((uniforms_src, $__.os.oid31)[u, 'offsetRepeat'], $__.os.oid24);
    'value' in vvv_tmp5;
    p = 'value';
    parameter_src = TAJS_restrictToType((((uniforms_src, $__.os.oid31)[u, 'offsetRepeat'], $__.os.oid24), $__.os.oid24)[p, 'value'], 'object');
    (((parameter_src, TAJS_restrictToType(parameter_src.isColor, 'undefined')), (parameter_src, TAJS_restrictToType(parameter_src.isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector3, 'undefined'))), (parameter_src, (parameter_src.isVector4, true));
    (((uniforms_dst, $__.os.oid179)[u, 'offsetRepeat'], $__.os.oid183), $__.os.oid183)[p, 'value'] = (vvv_tmp6 = parameter_src, 'clone', $__.fs.J$__v494107025_623_551.call(vvv_tmp6, 2, true, $__.uid));
    'specularMap' in vvv_tmp0;
    u = 'specularMap';
    (uniforms_dst, $__.os.oid179)[u, 'specularMap'] = $__.os.oid184 = {};
    vvv_tmp7 = ((uniforms_src, $__.os.oid31)[u, 'specularMap'], $__.os.oid25);
    'value' in vvv_tmp7;
    p = 'value';
    parameter_src = ((((uniforms_src, $__.os.oid31)[u, 'specularMap'], $__.os.oid25), $__.os.oid25)[p, 'value'], null);
    (((((parameter_src, parameter_src), parameter_src), parameter_src), parameter_src), parameter_src), parameter_src;
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid179)[u, 'specularMap'], $__.os.oid184), $__.os.oid184)[p, 'value'] = parameter_src;
    'alphaMap' in vvv_tmp0;
    u = 'alphaMap';
    (uniforms_dst, $__.os.oid179)[u, 'alphaMap'] = $__.os.oid185 = {};
    vvv_tmp8 = ((uniforms_src, $__.os.oid31)[u, 'alphaMap'], $__.os.oid26);
    'value' in vvv_tmp8;
    p = 'value';
    parameter_src = ((((uniforms_src, $__.os.oid31)[u, 'alphaMap'], $__.os.oid26), $__.os.oid26)[p, 'value'], null);
    (((((parameter_src, parameter_src), parameter_src), parameter_src), parameter_src), parameter_src), parameter_src;
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid179)[u, 'alphaMap'], $__.os.oid185), $__.os.oid185)[p, 'value'] = parameter_src;
    'envMap' in vvv_tmp0;
    u = 'envMap';
    (uniforms_dst, $__.os.oid179)[u, 'envMap'] = $__.os.oid186 = {};
    vvv_tmp9 = ((uniforms_src, $__.os.oid31)[u, 'envMap'], $__.os.oid27);
    'value' in vvv_tmp9;
    p = 'value';
    parameter_src = ((((uniforms_src, $__.os.oid31)[u, 'envMap'], $__.os.oid27), $__.os.oid27)[p, 'value'], null);
    (((((parameter_src, parameter_src), parameter_src), parameter_src), parameter_src), parameter_src), parameter_src;
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid179)[u, 'envMap'], $__.os.oid186), $__.os.oid186)[p, 'value'] = parameter_src;
    'flipEnvMap' in vvv_tmp0;
    u = 'flipEnvMap';
    (uniforms_dst, $__.os.oid179)[u, 'flipEnvMap'] = $__.os.oid187 = {};
    vvv_tmp10 = ((uniforms_src, $__.os.oid31)[u, 'flipEnvMap'], $__.os.oid28);
    'value' in vvv_tmp10;
    p = 'value';
    parameter_src = ((((uniforms_src, $__.os.oid31)[u, 'flipEnvMap'], $__.os.oid28), $__.os.oid28)[p, 'value'], -1);
    ((((((parameter_src, TAJS_restrictToType(parameter_src.isColor, 'undefined')), (parameter_src, TAJS_restrictToType(parameter_src.isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isTexture, 'undefined'));
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid179)[u, 'flipEnvMap'], $__.os.oid187), $__.os.oid187)[p, 'value'] = parameter_src;
    'reflectivity' in vvv_tmp0;
    u = 'reflectivity';
    (uniforms_dst, $__.os.oid179)[u, 'reflectivity'] = $__.os.oid188 = {};
    vvv_tmp11 = ((uniforms_src, $__.os.oid31)[u, 'reflectivity'], $__.os.oid29);
    'value' in vvv_tmp11;
    p = 'value';
    parameter_src = ((((uniforms_src, $__.os.oid31)[u, 'reflectivity'], $__.os.oid29), $__.os.oid29)[p, 'value'], 1);
    ((((((parameter_src, TAJS_restrictToType(parameter_src.isColor, 'undefined')), (parameter_src, TAJS_restrictToType(parameter_src.isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isTexture, 'undefined'));
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid179)[u, 'reflectivity'], $__.os.oid188), $__.os.oid188)[p, 'value'] = parameter_src;
    'refractionRatio' in vvv_tmp0;
    u = 'refractionRatio';
    (uniforms_dst, $__.os.oid179)[u, 'refractionRatio'] = $__.os.oid189 = {};
    vvv_tmp12 = ((uniforms_src, $__.os.oid31)[u, 'refractionRatio'], $__.os.oid30);
    'value' in vvv_tmp12;
    p = 'value';
    parameter_src = ((((uniforms_src, $__.os.oid31)[u, 'refractionRatio'], $__.os.oid30), $__.os.oid30)[p, 'value'], 0.98);
    ((((((parameter_src, TAJS_restrictToType(parameter_src.isColor, 'undefined')), (parameter_src, TAJS_restrictToType(parameter_src.isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isTexture, 'undefined'));
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid179)[u, 'refractionRatio'], $__.os.oid189), $__.os.oid189)[p, 'value'] = parameter_src;
    return uniforms_dst;
case 11:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 11);
    uniforms_dst = $__.os.oid190 = {};
    vvv_tmp0 = uniforms_src;
    'aoMap' in vvv_tmp0;
    u = 'aoMap';
    (uniforms_dst, $__.os.oid190)[u, 'aoMap'] = $__.os.oid191 = {};
    vvv_tmp1 = ((uniforms_src, $__.os.oid34)[u, 'aoMap'], $__.os.oid32);
    'value' in vvv_tmp1;
    p = 'value';
    parameter_src = ((((uniforms_src, $__.os.oid34)[u, 'aoMap'], $__.os.oid32), $__.os.oid32)[p, 'value'], null);
    (((((parameter_src, parameter_src), parameter_src), parameter_src), parameter_src), parameter_src), parameter_src;
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid190)[u, 'aoMap'], $__.os.oid191), $__.os.oid191)[p, 'value'] = parameter_src;
    'aoMapIntensity' in vvv_tmp0;
    u = 'aoMapIntensity';
    (uniforms_dst, $__.os.oid190)[u, 'aoMapIntensity'] = $__.os.oid192 = {};
    vvv_tmp2 = ((uniforms_src, $__.os.oid34)[u, 'aoMapIntensity'], $__.os.oid33);
    'value' in vvv_tmp2;
    p = 'value';
    parameter_src = ((((uniforms_src, $__.os.oid34)[u, 'aoMapIntensity'], $__.os.oid33), $__.os.oid33)[p, 'value'], 1);
    ((((((parameter_src, TAJS_restrictToType(parameter_src.isColor, 'undefined')), (parameter_src, TAJS_restrictToType(parameter_src.isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isTexture, 'undefined'));
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid190)[u, 'aoMapIntensity'], $__.os.oid192), $__.os.oid192)[p, 'value'] = parameter_src;
    return uniforms_dst;
case 12:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 12);
    uniforms_dst = $__.os.oid193 = {};
    vvv_tmp0 = uniforms_src;
    'lightMap' in vvv_tmp0;
    u = 'lightMap';
    (uniforms_dst, $__.os.oid193)[u, 'lightMap'] = $__.os.oid194 = {};
    vvv_tmp1 = ((uniforms_src, $__.os.oid37)[u, 'lightMap'], $__.os.oid35);
    'value' in vvv_tmp1;
    p = 'value';
    parameter_src = ((((uniforms_src, $__.os.oid37)[u, 'lightMap'], $__.os.oid35), $__.os.oid35)[p, 'value'], null);
    (((((parameter_src, parameter_src), parameter_src), parameter_src), parameter_src), parameter_src), parameter_src;
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid193)[u, 'lightMap'], $__.os.oid194), $__.os.oid194)[p, 'value'] = parameter_src;
    'lightMapIntensity' in vvv_tmp0;
    u = 'lightMapIntensity';
    (uniforms_dst, $__.os.oid193)[u, 'lightMapIntensity'] = $__.os.oid195 = {};
    vvv_tmp2 = ((uniforms_src, $__.os.oid37)[u, 'lightMapIntensity'], $__.os.oid36);
    'value' in vvv_tmp2;
    p = 'value';
    parameter_src = ((((uniforms_src, $__.os.oid37)[u, 'lightMapIntensity'], $__.os.oid36), $__.os.oid36)[p, 'value'], 1);
    ((((((parameter_src, TAJS_restrictToType(parameter_src.isColor, 'undefined')), (parameter_src, TAJS_restrictToType(parameter_src.isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isTexture, 'undefined'));
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid193)[u, 'lightMapIntensity'], $__.os.oid195), $__.os.oid195)[p, 'value'] = parameter_src;
    return uniforms_dst;
case 13:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 13);
    uniforms_dst = $__.os.oid196 = {};
    vvv_tmp0 = uniforms_src;
    'emissiveMap' in vvv_tmp0;
    u = 'emissiveMap';
    (uniforms_dst, $__.os.oid196)[u, 'emissiveMap'] = $__.os.oid197 = {};
    vvv_tmp1 = ((uniforms_src, $__.os.oid39)[u, 'emissiveMap'], $__.os.oid38);
    'value' in vvv_tmp1;
    p = 'value';
    parameter_src = ((((uniforms_src, $__.os.oid39)[u, 'emissiveMap'], $__.os.oid38), $__.os.oid38)[p, 'value'], null);
    (((((parameter_src, parameter_src), parameter_src), parameter_src), parameter_src), parameter_src), parameter_src;
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid196)[u, 'emissiveMap'], $__.os.oid197), $__.os.oid197)[p, 'value'] = parameter_src;
    return uniforms_dst;
case 14:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 14);
    uniforms_dst = $__.os.oid198 = {};
    vvv_tmp0 = uniforms_src;
    'bumpMap' in vvv_tmp0;
    u = 'bumpMap';
    (uniforms_dst, $__.os.oid198)[u, 'bumpMap'] = $__.os.oid199 = {};
    vvv_tmp1 = ((uniforms_src, $__.os.oid42)[u, 'bumpMap'], $__.os.oid40);
    'value' in vvv_tmp1;
    p = 'value';
    parameter_src = ((((uniforms_src, $__.os.oid42)[u, 'bumpMap'], $__.os.oid40), $__.os.oid40)[p, 'value'], null);
    (((((parameter_src, parameter_src), parameter_src), parameter_src), parameter_src), parameter_src), parameter_src;
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid198)[u, 'bumpMap'], $__.os.oid199), $__.os.oid199)[p, 'value'] = parameter_src;
    'bumpScale' in vvv_tmp0;
    u = 'bumpScale';
    (uniforms_dst, $__.os.oid198)[u, 'bumpScale'] = $__.os.oid200 = {};
    vvv_tmp2 = ((uniforms_src, $__.os.oid42)[u, 'bumpScale'], $__.os.oid41);
    'value' in vvv_tmp2;
    p = 'value';
    parameter_src = ((((uniforms_src, $__.os.oid42)[u, 'bumpScale'], $__.os.oid41), $__.os.oid41)[p, 'value'], 1);
    ((((((parameter_src, TAJS_restrictToType(parameter_src.isColor, 'undefined')), (parameter_src, TAJS_restrictToType(parameter_src.isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isTexture, 'undefined'));
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid198)[u, 'bumpScale'], $__.os.oid200), $__.os.oid200)[p, 'value'] = parameter_src;
    return uniforms_dst;
case 15:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 15);
    uniforms_dst = $__.os.oid201 = {};
    vvv_tmp0 = uniforms_src;
    'normalMap' in vvv_tmp0;
    u = 'normalMap';
    (uniforms_dst, $__.os.oid201)[u, 'normalMap'] = $__.os.oid202 = {};
    vvv_tmp1 = ((uniforms_src, $__.os.oid45)[u, 'normalMap'], $__.os.oid43);
    'value' in vvv_tmp1;
    p = 'value';
    parameter_src = ((((uniforms_src, $__.os.oid45)[u, 'normalMap'], $__.os.oid43), $__.os.oid43)[p, 'value'], null);
    (((((parameter_src, parameter_src), parameter_src), parameter_src), parameter_src), parameter_src), parameter_src;
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid201)[u, 'normalMap'], $__.os.oid202), $__.os.oid202)[p, 'value'] = parameter_src;
    'normalScale' in vvv_tmp0;
    u = 'normalScale';
    (uniforms_dst, $__.os.oid201)[u, 'normalScale'] = $__.os.oid203 = {};
    vvv_tmp2 = ((uniforms_src, $__.os.oid45)[u, 'normalScale'], $__.os.oid44);
    'value' in vvv_tmp2;
    p = 'value';
    parameter_src = TAJS_restrictToType((((uniforms_src, $__.os.oid45)[u, 'normalScale'], $__.os.oid44), $__.os.oid44)[p, 'value'], 'object');
    (parameter_src, TAJS_restrictToType(parameter_src.isColor, 'undefined')), (parameter_src, (parameter_src.isVector2, true));
    (((uniforms_dst, $__.os.oid201)[u, 'normalScale'], $__.os.oid203), $__.os.oid203)[p, 'value'] = (vvv_tmp3 = parameter_src, 'clone', $__.fs.J$__v494107025_85_307.call(vvv_tmp3, 0, true, $__.uid));
    return uniforms_dst;
case 16:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 16);
    uniforms_dst = $__.os.oid204 = {};
    vvv_tmp0 = uniforms_src;
    'displacementMap' in vvv_tmp0;
    u = 'displacementMap';
    (uniforms_dst, $__.os.oid204)[u, 'displacementMap'] = $__.os.oid205 = {};
    vvv_tmp1 = ((uniforms_src, $__.os.oid49)[u, 'displacementMap'], $__.os.oid46);
    'value' in vvv_tmp1;
    p = 'value';
    parameter_src = ((((uniforms_src, $__.os.oid49)[u, 'displacementMap'], $__.os.oid46), $__.os.oid46)[p, 'value'], null);
    (((((parameter_src, parameter_src), parameter_src), parameter_src), parameter_src), parameter_src), parameter_src;
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid204)[u, 'displacementMap'], $__.os.oid205), $__.os.oid205)[p, 'value'] = parameter_src;
    'displacementScale' in vvv_tmp0;
    u = 'displacementScale';
    (uniforms_dst, $__.os.oid204)[u, 'displacementScale'] = $__.os.oid206 = {};
    vvv_tmp2 = ((uniforms_src, $__.os.oid49)[u, 'displacementScale'], $__.os.oid47);
    'value' in vvv_tmp2;
    p = 'value';
    parameter_src = ((((uniforms_src, $__.os.oid49)[u, 'displacementScale'], $__.os.oid47), $__.os.oid47)[p, 'value'], 1);
    ((((((parameter_src, TAJS_restrictToType(parameter_src.isColor, 'undefined')), (parameter_src, TAJS_restrictToType(parameter_src.isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isTexture, 'undefined'));
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid204)[u, 'displacementScale'], $__.os.oid206), $__.os.oid206)[p, 'value'] = parameter_src;
    'displacementBias' in vvv_tmp0;
    u = 'displacementBias';
    (uniforms_dst, $__.os.oid204)[u, 'displacementBias'] = $__.os.oid207 = {};
    vvv_tmp3 = ((uniforms_src, $__.os.oid49)[u, 'displacementBias'], $__.os.oid48);
    'value' in vvv_tmp3;
    p = 'value';
    parameter_src = ((((uniforms_src, $__.os.oid49)[u, 'displacementBias'], $__.os.oid48), $__.os.oid48)[p, 'value'], 0);
    (((((parameter_src, parameter_src), parameter_src), parameter_src), parameter_src), parameter_src), parameter_src;
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid204)[u, 'displacementBias'], $__.os.oid207), $__.os.oid207)[p, 'value'] = parameter_src;
    return uniforms_dst;
case 17:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 17);
    uniforms_dst = $__.os.oid208 = {};
    vvv_tmp0 = uniforms_src;
    'fogDensity' in vvv_tmp0;
    u = 'fogDensity';
    (uniforms_dst, $__.os.oid208)[u, 'fogDensity'] = $__.os.oid209 = {};
    vvv_tmp1 = ((uniforms_src, $__.os.oid58)[u, 'fogDensity'], $__.os.oid54);
    'value' in vvv_tmp1;
    p = 'value';
    parameter_src = ((((uniforms_src, $__.os.oid58)[u, 'fogDensity'], $__.os.oid54), $__.os.oid54)[p, 'value'], 0.00025);
    ((((((parameter_src, TAJS_restrictToType(parameter_src.isColor, 'undefined')), (parameter_src, TAJS_restrictToType(parameter_src.isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isTexture, 'undefined'));
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid208)[u, 'fogDensity'], $__.os.oid209), $__.os.oid209)[p, 'value'] = parameter_src;
    'fogNear' in vvv_tmp0;
    u = 'fogNear';
    (uniforms_dst, $__.os.oid208)[u, 'fogNear'] = $__.os.oid210 = {};
    vvv_tmp2 = ((uniforms_src, $__.os.oid58)[u, 'fogNear'], $__.os.oid55);
    'value' in vvv_tmp2;
    p = 'value';
    parameter_src = ((((uniforms_src, $__.os.oid58)[u, 'fogNear'], $__.os.oid55), $__.os.oid55)[p, 'value'], 1);
    ((((((parameter_src, TAJS_restrictToType(parameter_src.isColor, 'undefined')), (parameter_src, TAJS_restrictToType(parameter_src.isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isTexture, 'undefined'));
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid208)[u, 'fogNear'], $__.os.oid210), $__.os.oid210)[p, 'value'] = parameter_src;
    'fogFar' in vvv_tmp0;
    u = 'fogFar';
    (uniforms_dst, $__.os.oid208)[u, 'fogFar'] = $__.os.oid211 = {};
    vvv_tmp3 = ((uniforms_src, $__.os.oid58)[u, 'fogFar'], $__.os.oid56);
    'value' in vvv_tmp3;
    p = 'value';
    parameter_src = ((((uniforms_src, $__.os.oid58)[u, 'fogFar'], $__.os.oid56), $__.os.oid56)[p, 'value'], 2000);
    ((((((parameter_src, TAJS_restrictToType(parameter_src.isColor, 'undefined')), (parameter_src, TAJS_restrictToType(parameter_src.isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isTexture, 'undefined'));
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid208)[u, 'fogFar'], $__.os.oid211), $__.os.oid211)[p, 'value'] = parameter_src;
    'fogColor' in vvv_tmp0;
    u = 'fogColor';
    (uniforms_dst, $__.os.oid208)[u, 'fogColor'] = $__.os.oid212 = {};
    vvv_tmp4 = ((uniforms_src, $__.os.oid58)[u, 'fogColor'], $__.os.oid57);
    'value' in vvv_tmp4;
    p = 'value';
    parameter_src = TAJS_restrictToType((((uniforms_src, $__.os.oid58)[u, 'fogColor'], $__.os.oid57), $__.os.oid57)[p, 'value'], 'object');
    parameter_src, (parameter_src.isColor, true);
    (((uniforms_dst, $__.os.oid208)[u, 'fogColor'], $__.os.oid212), $__.os.oid212)[p, 'value'] = (vvv_tmp5 = parameter_src, 'clone', $__.fs.J$__v494107025_821_611.call(vvv_tmp5, 6, true, $__.uid));
    return uniforms_dst;
case 18:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 18);
    uniforms_dst = $__.os.oid213 = {};
    vvv_tmp0 = uniforms_src;
    'ambientLightColor' in vvv_tmp0;
    u = 'ambientLightColor';
    (uniforms_dst, $__.os.oid213)[u, 'ambientLightColor'] = $__.os.oid214 = {};
    vvv_tmp1 = ((uniforms_src, $__.os.oid102)[u, 'ambientLightColor'], $__.os.oid59);
    'value' in vvv_tmp1;
    p = 'value';
    parameter_src = TAJS_restrictToType((((uniforms_src, $__.os.oid102)[u, 'ambientLightColor'], $__.os.oid59), $__.os.oid59)[p, 'value'], 'object');
    ((((((parameter_src, TAJS_restrictToType(parameter_src.isColor, 'undefined')), (parameter_src, TAJS_restrictToType(parameter_src.isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isTexture, 'undefined'));
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid213)[u, 'ambientLightColor'], $__.os.oid214), $__.os.oid214)[p, 'value'] = function $__lt13(res) {
        res.length = 0;
        if (res.length != 0)
            TAJS_dumpValue('Possible loss of precision');
        return res;
        ;
        TAJS_makeContextSensitive($__lt13, -2);
    }(parameter_src['slice']());
    'directionalLights' in vvv_tmp0;
    u = 'directionalLights';
    (uniforms_dst, $__.os.oid213)[u, 'directionalLights'] = $__.os.oid215 = {};
    vvv_tmp2 = ((uniforms_src, $__.os.oid102)[u, 'directionalLights'], $__.os.oid67);
    'value' in vvv_tmp2;
    p = 'value';
    parameter_src = TAJS_restrictToType((((uniforms_src, $__.os.oid102)[u, 'directionalLights'], $__.os.oid67), $__.os.oid67)[p, 'value'], 'object');
    ((((((parameter_src, TAJS_restrictToType(parameter_src.isColor, 'undefined')), (parameter_src, TAJS_restrictToType(parameter_src.isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isTexture, 'undefined'));
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid213)[u, 'directionalLights'], $__.os.oid215), $__.os.oid215)[p, 'value'] = function $__lt14(res) {
        res.length = 0;
        if (res.length != 0)
            TAJS_dumpValue('Possible loss of precision');
        return res;
        ;
        TAJS_makeContextSensitive($__lt14, -2);
    }(parameter_src['slice']());
    'properties' in vvv_tmp2;
    p = 'properties';
    parameter_src = ((((uniforms_src, $__.os.oid102)[u, 'directionalLights'], $__.os.oid67), $__.os.oid67)[p, 'properties'], $__.os.oid66);
    ((((((parameter_src, TAJS_restrictToType((parameter_src, $__.os.oid66).isColor, 'undefined')), (parameter_src, TAJS_restrictToType((parameter_src, $__.os.oid66).isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType((parameter_src, $__.os.oid66).isVector3, 'undefined'))), (parameter_src, TAJS_restrictToType((parameter_src, $__.os.oid66).isVector4, 'undefined'))), (parameter_src, TAJS_restrictToType((parameter_src, $__.os.oid66).isMatrix3, 'undefined'))), (parameter_src, TAJS_restrictToType((parameter_src, $__.os.oid66).isMatrix4, 'undefined'))), (parameter_src, TAJS_restrictToType((parameter_src, $__.os.oid66).isTexture, 'undefined'));
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid213)[u, 'directionalLights'], $__.os.oid215), $__.os.oid215)[p, 'properties'] = parameter_src;
    'directionalShadowMap' in vvv_tmp0;
    u = 'directionalShadowMap';
    (uniforms_dst, $__.os.oid213)[u, 'directionalShadowMap'] = $__.os.oid216 = {};
    vvv_tmp3 = ((uniforms_src, $__.os.oid102)[u, 'directionalShadowMap'], $__.os.oid68);
    'value' in vvv_tmp3;
    p = 'value';
    parameter_src = TAJS_restrictToType((((uniforms_src, $__.os.oid102)[u, 'directionalShadowMap'], $__.os.oid68), $__.os.oid68)[p, 'value'], 'object');
    ((((((parameter_src, TAJS_restrictToType(parameter_src.isColor, 'undefined')), (parameter_src, TAJS_restrictToType(parameter_src.isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isTexture, 'undefined'));
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid213)[u, 'directionalShadowMap'], $__.os.oid216), $__.os.oid216)[p, 'value'] = function $__lt15(res) {
        res.length = 0;
        if (res.length != 0)
            TAJS_dumpValue('Possible loss of precision');
        return res;
        ;
        TAJS_makeContextSensitive($__lt15, -2);
    }(parameter_src['slice']());
    'directionalShadowMatrix' in vvv_tmp0;
    u = 'directionalShadowMatrix';
    (uniforms_dst, $__.os.oid213)[u, 'directionalShadowMatrix'] = $__.os.oid217 = {};
    vvv_tmp4 = ((uniforms_src, $__.os.oid102)[u, 'directionalShadowMatrix'], $__.os.oid69);
    'value' in vvv_tmp4;
    p = 'value';
    parameter_src = TAJS_restrictToType((((uniforms_src, $__.os.oid102)[u, 'directionalShadowMatrix'], $__.os.oid69), $__.os.oid69)[p, 'value'], 'object');
    ((((((parameter_src, TAJS_restrictToType(parameter_src.isColor, 'undefined')), (parameter_src, TAJS_restrictToType(parameter_src.isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isTexture, 'undefined'));
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid213)[u, 'directionalShadowMatrix'], $__.os.oid217), $__.os.oid217)[p, 'value'] = function $__lt16(res) {
        res.length = 0;
        if (res.length != 0)
            TAJS_dumpValue('Possible loss of precision');
        return res;
        ;
        TAJS_makeContextSensitive($__lt16, -2);
    }(parameter_src['slice']());
    'spotLights' in vvv_tmp0;
    u = 'spotLights';
    (uniforms_dst, $__.os.oid213)[u, 'spotLights'] = $__.os.oid218 = {};
    vvv_tmp5 = ((uniforms_src, $__.os.oid102)[u, 'spotLights'], $__.os.oid82);
    'value' in vvv_tmp5;
    p = 'value';
    parameter_src = TAJS_restrictToType((((uniforms_src, $__.os.oid102)[u, 'spotLights'], $__.os.oid82), $__.os.oid82)[p, 'value'], 'object');
    ((((((parameter_src, TAJS_restrictToType(parameter_src.isColor, 'undefined')), (parameter_src, TAJS_restrictToType(parameter_src.isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isTexture, 'undefined'));
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid213)[u, 'spotLights'], $__.os.oid218), $__.os.oid218)[p, 'value'] = function $__lt17(res) {
        res.length = 0;
        if (res.length != 0)
            TAJS_dumpValue('Possible loss of precision');
        return res;
        ;
        TAJS_makeContextSensitive($__lt17, -2);
    }(parameter_src['slice']());
    'properties' in vvv_tmp5;
    p = 'properties';
    parameter_src = ((((uniforms_src, $__.os.oid102)[u, 'spotLights'], $__.os.oid82), $__.os.oid82)[p, 'properties'], $__.os.oid81);
    ((((((parameter_src, TAJS_restrictToType((parameter_src, $__.os.oid81).isColor, 'undefined')), (parameter_src, TAJS_restrictToType((parameter_src, $__.os.oid81).isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType((parameter_src, $__.os.oid81).isVector3, 'undefined'))), (parameter_src, TAJS_restrictToType((parameter_src, $__.os.oid81).isVector4, 'undefined'))), (parameter_src, TAJS_restrictToType((parameter_src, $__.os.oid81).isMatrix3, 'undefined'))), (parameter_src, TAJS_restrictToType((parameter_src, $__.os.oid81).isMatrix4, 'undefined'))), (parameter_src, TAJS_restrictToType((parameter_src, $__.os.oid81).isTexture, 'undefined'));
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid213)[u, 'spotLights'], $__.os.oid218), $__.os.oid218)[p, 'properties'] = parameter_src;
    'spotShadowMap' in vvv_tmp0;
    u = 'spotShadowMap';
    (uniforms_dst, $__.os.oid213)[u, 'spotShadowMap'] = $__.os.oid219 = {};
    vvv_tmp6 = ((uniforms_src, $__.os.oid102)[u, 'spotShadowMap'], $__.os.oid83);
    'value' in vvv_tmp6;
    p = 'value';
    parameter_src = TAJS_restrictToType((((uniforms_src, $__.os.oid102)[u, 'spotShadowMap'], $__.os.oid83), $__.os.oid83)[p, 'value'], 'object');
    ((((((parameter_src, TAJS_restrictToType(parameter_src.isColor, 'undefined')), (parameter_src, TAJS_restrictToType(parameter_src.isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isTexture, 'undefined'));
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid213)[u, 'spotShadowMap'], $__.os.oid219), $__.os.oid219)[p, 'value'] = function $__lt18(res) {
        res.length = 0;
        if (res.length != 0)
            TAJS_dumpValue('Possible loss of precision');
        return res;
        ;
        TAJS_makeContextSensitive($__lt18, -2);
    }(parameter_src['slice']());
    'spotShadowMatrix' in vvv_tmp0;
    u = 'spotShadowMatrix';
    (uniforms_dst, $__.os.oid213)[u, 'spotShadowMatrix'] = $__.os.oid220 = {};
    vvv_tmp7 = ((uniforms_src, $__.os.oid102)[u, 'spotShadowMatrix'], $__.os.oid84);
    'value' in vvv_tmp7;
    p = 'value';
    parameter_src = TAJS_restrictToType((((uniforms_src, $__.os.oid102)[u, 'spotShadowMatrix'], $__.os.oid84), $__.os.oid84)[p, 'value'], 'object');
    ((((((parameter_src, TAJS_restrictToType(parameter_src.isColor, 'undefined')), (parameter_src, TAJS_restrictToType(parameter_src.isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isTexture, 'undefined'));
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid213)[u, 'spotShadowMatrix'], $__.os.oid220), $__.os.oid220)[p, 'value'] = function $__lt19(res) {
        res.length = 0;
        if (res.length != 0)
            TAJS_dumpValue('Possible loss of precision');
        return res;
        ;
        TAJS_makeContextSensitive($__lt19, -2);
    }(parameter_src['slice']());
    'pointLights' in vvv_tmp0;
    u = 'pointLights';
    (uniforms_dst, $__.os.oid213)[u, 'pointLights'] = $__.os.oid221 = {};
    vvv_tmp8 = ((uniforms_src, $__.os.oid102)[u, 'pointLights'], $__.os.oid94);
    'value' in vvv_tmp8;
    p = 'value';
    parameter_src = TAJS_restrictToType((((uniforms_src, $__.os.oid102)[u, 'pointLights'], $__.os.oid94), $__.os.oid94)[p, 'value'], 'object');
    ((((((parameter_src, TAJS_restrictToType(parameter_src.isColor, 'undefined')), (parameter_src, TAJS_restrictToType(parameter_src.isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isTexture, 'undefined'));
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid213)[u, 'pointLights'], $__.os.oid221), $__.os.oid221)[p, 'value'] = function $__lt20(res) {
        res.length = 0;
        if (res.length != 0)
            TAJS_dumpValue('Possible loss of precision');
        return res;
        ;
        TAJS_makeContextSensitive($__lt20, -2);
    }(parameter_src['slice']());
    'properties' in vvv_tmp8;
    p = 'properties';
    parameter_src = ((((uniforms_src, $__.os.oid102)[u, 'pointLights'], $__.os.oid94), $__.os.oid94)[p, 'properties'], $__.os.oid93);
    ((((((parameter_src, TAJS_restrictToType((parameter_src, $__.os.oid93).isColor, 'undefined')), (parameter_src, TAJS_restrictToType((parameter_src, $__.os.oid93).isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType((parameter_src, $__.os.oid93).isVector3, 'undefined'))), (parameter_src, TAJS_restrictToType((parameter_src, $__.os.oid93).isVector4, 'undefined'))), (parameter_src, TAJS_restrictToType((parameter_src, $__.os.oid93).isMatrix3, 'undefined'))), (parameter_src, TAJS_restrictToType((parameter_src, $__.os.oid93).isMatrix4, 'undefined'))), (parameter_src, TAJS_restrictToType((parameter_src, $__.os.oid93).isTexture, 'undefined'));
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid213)[u, 'pointLights'], $__.os.oid221), $__.os.oid221)[p, 'properties'] = parameter_src;
    'pointShadowMap' in vvv_tmp0;
    u = 'pointShadowMap';
    (uniforms_dst, $__.os.oid213)[u, 'pointShadowMap'] = $__.os.oid222 = {};
    vvv_tmp9 = ((uniforms_src, $__.os.oid102)[u, 'pointShadowMap'], $__.os.oid95);
    'value' in vvv_tmp9;
    p = 'value';
    parameter_src = TAJS_restrictToType((((uniforms_src, $__.os.oid102)[u, 'pointShadowMap'], $__.os.oid95), $__.os.oid95)[p, 'value'], 'object');
    ((((((parameter_src, TAJS_restrictToType(parameter_src.isColor, 'undefined')), (parameter_src, TAJS_restrictToType(parameter_src.isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isTexture, 'undefined'));
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid213)[u, 'pointShadowMap'], $__.os.oid222), $__.os.oid222)[p, 'value'] = function $__lt21(res) {
        res.length = 0;
        if (res.length != 0)
            TAJS_dumpValue('Possible loss of precision');
        return res;
        ;
        TAJS_makeContextSensitive($__lt21, -2);
    }(parameter_src['slice']());
    'pointShadowMatrix' in vvv_tmp0;
    u = 'pointShadowMatrix';
    (uniforms_dst, $__.os.oid213)[u, 'pointShadowMatrix'] = $__.os.oid223 = {};
    vvv_tmp10 = ((uniforms_src, $__.os.oid102)[u, 'pointShadowMatrix'], $__.os.oid96);
    'value' in vvv_tmp10;
    p = 'value';
    parameter_src = TAJS_restrictToType((((uniforms_src, $__.os.oid102)[u, 'pointShadowMatrix'], $__.os.oid96), $__.os.oid96)[p, 'value'], 'object');
    ((((((parameter_src, TAJS_restrictToType(parameter_src.isColor, 'undefined')), (parameter_src, TAJS_restrictToType(parameter_src.isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isTexture, 'undefined'));
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid213)[u, 'pointShadowMatrix'], $__.os.oid223), $__.os.oid223)[p, 'value'] = function $__lt22(res) {
        res.length = 0;
        if (res.length != 0)
            TAJS_dumpValue('Possible loss of precision');
        return res;
        ;
        TAJS_makeContextSensitive($__lt22, -2);
    }(parameter_src['slice']());
    'hemisphereLights' in vvv_tmp0;
    u = 'hemisphereLights';
    (uniforms_dst, $__.os.oid213)[u, 'hemisphereLights'] = $__.os.oid224 = {};
    vvv_tmp11 = ((uniforms_src, $__.os.oid102)[u, 'hemisphereLights'], $__.os.oid101);
    'value' in vvv_tmp11;
    p = 'value';
    parameter_src = TAJS_restrictToType((((uniforms_src, $__.os.oid102)[u, 'hemisphereLights'], $__.os.oid101), $__.os.oid101)[p, 'value'], 'object');
    ((((((parameter_src, TAJS_restrictToType(parameter_src.isColor, 'undefined')), (parameter_src, TAJS_restrictToType(parameter_src.isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isTexture, 'undefined'));
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid213)[u, 'hemisphereLights'], $__.os.oid224), $__.os.oid224)[p, 'value'] = function $__lt23(res) {
        res.length = 0;
        if (res.length != 0)
            TAJS_dumpValue('Possible loss of precision');
        return res;
        ;
        TAJS_makeContextSensitive($__lt23, -2);
    }(parameter_src['slice']());
    'properties' in vvv_tmp11;
    p = 'properties';
    parameter_src = ((((uniforms_src, $__.os.oid102)[u, 'hemisphereLights'], $__.os.oid101), $__.os.oid101)[p, 'properties'], $__.os.oid100);
    ((((((parameter_src, TAJS_restrictToType((parameter_src, $__.os.oid100).isColor, 'undefined')), (parameter_src, TAJS_restrictToType((parameter_src, $__.os.oid100).isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType((parameter_src, $__.os.oid100).isVector3, 'undefined'))), (parameter_src, TAJS_restrictToType((parameter_src, $__.os.oid100).isVector4, 'undefined'))), (parameter_src, TAJS_restrictToType((parameter_src, $__.os.oid100).isMatrix3, 'undefined'))), (parameter_src, TAJS_restrictToType((parameter_src, $__.os.oid100).isMatrix4, 'undefined'))), (parameter_src, TAJS_restrictToType((parameter_src, $__.os.oid100).isTexture, 'undefined'));
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid213)[u, 'hemisphereLights'], $__.os.oid224), $__.os.oid224)[p, 'properties'] = parameter_src;
    return uniforms_dst;
case 19:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 19);
    uniforms_dst = $__.os.oid225 = {};
    vvv_tmp0 = uniforms_src;
    'emissive' in vvv_tmp0;
    u = 'emissive';
    (uniforms_dst, $__.os.oid225)[u, 'emissive'] = $__.os.oid226 = {};
    vvv_tmp1 = ((uniforms_src, $__.os.oid177)[u, 'emissive'], $__.os.oid174);
    'value' in vvv_tmp1;
    p = 'value';
    parameter_src = TAJS_restrictToType((((uniforms_src, $__.os.oid177)[u, 'emissive'], $__.os.oid174), $__.os.oid174)[p, 'value'], 'object');
    parameter_src, (parameter_src.isColor, true);
    (((uniforms_dst, $__.os.oid225)[u, 'emissive'], $__.os.oid226), $__.os.oid226)[p, 'value'] = (vvv_tmp2 = parameter_src, 'clone', $__.fs.J$__v494107025_821_611.call(vvv_tmp2, 7, true, $__.uid));
    'specular' in vvv_tmp0;
    u = 'specular';
    (uniforms_dst, $__.os.oid225)[u, 'specular'] = $__.os.oid227 = {};
    vvv_tmp3 = ((uniforms_src, $__.os.oid177)[u, 'specular'], $__.os.oid175);
    'value' in vvv_tmp3;
    p = 'value';
    parameter_src = TAJS_restrictToType((((uniforms_src, $__.os.oid177)[u, 'specular'], $__.os.oid175), $__.os.oid175)[p, 'value'], 'object');
    parameter_src, (parameter_src.isColor, true);
    (((uniforms_dst, $__.os.oid225)[u, 'specular'], $__.os.oid227), $__.os.oid227)[p, 'value'] = (vvv_tmp4 = parameter_src, 'clone', $__.fs.J$__v494107025_821_611.call(vvv_tmp4, 8, true, $__.uid));
    'shininess' in vvv_tmp0;
    u = 'shininess';
    (uniforms_dst, $__.os.oid225)[u, 'shininess'] = $__.os.oid228 = {};
    vvv_tmp5 = ((uniforms_src, $__.os.oid177)[u, 'shininess'], $__.os.oid176);
    'value' in vvv_tmp5;
    p = 'value';
    parameter_src = ((((uniforms_src, $__.os.oid177)[u, 'shininess'], $__.os.oid176), $__.os.oid176)[p, 'value'], 30);
    ((((((parameter_src, TAJS_restrictToType(parameter_src.isColor, 'undefined')), (parameter_src, TAJS_restrictToType(parameter_src.isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isTexture, 'undefined'));
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid225)[u, 'shininess'], $__.os.oid228), $__.os.oid228)[p, 'value'] = parameter_src;
    return uniforms_dst;
case 20:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 20);
    uniforms_dst = $__.os.oid236 = {};
    vvv_tmp0 = uniforms_src;
    'diffuse' in vvv_tmp0;
    u = 'diffuse';
    (uniforms_dst, $__.os.oid236)[u, 'diffuse'] = $__.os.oid237 = {};
    vvv_tmp1 = ((uniforms_src, $__.os.oid31)[u, 'diffuse'], $__.os.oid21);
    'value' in vvv_tmp1;
    p = 'value';
    parameter_src = TAJS_restrictToType((((uniforms_src, $__.os.oid31)[u, 'diffuse'], $__.os.oid21), $__.os.oid21)[p, 'value'], 'object');
    parameter_src, (parameter_src.isColor, true);
    (((uniforms_dst, $__.os.oid236)[u, 'diffuse'], $__.os.oid237), $__.os.oid237)[p, 'value'] = (vvv_tmp2 = parameter_src, 'clone', $__.fs.J$__v494107025_821_611.call(vvv_tmp2, 9, true, $__.uid));
    'opacity' in vvv_tmp0;
    u = 'opacity';
    (uniforms_dst, $__.os.oid236)[u, 'opacity'] = $__.os.oid238 = {};
    vvv_tmp3 = ((uniforms_src, $__.os.oid31)[u, 'opacity'], $__.os.oid22);
    'value' in vvv_tmp3;
    p = 'value';
    parameter_src = ((((uniforms_src, $__.os.oid31)[u, 'opacity'], $__.os.oid22), $__.os.oid22)[p, 'value'], 1);
    ((((((parameter_src, TAJS_restrictToType(parameter_src.isColor, 'undefined')), (parameter_src, TAJS_restrictToType(parameter_src.isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isTexture, 'undefined'));
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid236)[u, 'opacity'], $__.os.oid238), $__.os.oid238)[p, 'value'] = parameter_src;
    'map' in vvv_tmp0;
    u = 'map';
    (uniforms_dst, $__.os.oid236)[u, 'map'] = $__.os.oid239 = {};
    vvv_tmp4 = ((uniforms_src, $__.os.oid31)[u, 'map'], $__.os.oid23);
    'value' in vvv_tmp4;
    p = 'value';
    parameter_src = ((((uniforms_src, $__.os.oid31)[u, 'map'], $__.os.oid23), $__.os.oid23)[p, 'value'], null);
    (((((parameter_src, parameter_src), parameter_src), parameter_src), parameter_src), parameter_src), parameter_src;
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid236)[u, 'map'], $__.os.oid239), $__.os.oid239)[p, 'value'] = parameter_src;
    'offsetRepeat' in vvv_tmp0;
    u = 'offsetRepeat';
    (uniforms_dst, $__.os.oid236)[u, 'offsetRepeat'] = $__.os.oid240 = {};
    vvv_tmp5 = ((uniforms_src, $__.os.oid31)[u, 'offsetRepeat'], $__.os.oid24);
    'value' in vvv_tmp5;
    p = 'value';
    parameter_src = TAJS_restrictToType((((uniforms_src, $__.os.oid31)[u, 'offsetRepeat'], $__.os.oid24), $__.os.oid24)[p, 'value'], 'object');
    (((parameter_src, TAJS_restrictToType(parameter_src.isColor, 'undefined')), (parameter_src, TAJS_restrictToType(parameter_src.isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector3, 'undefined'))), (parameter_src, (parameter_src.isVector4, true));
    (((uniforms_dst, $__.os.oid236)[u, 'offsetRepeat'], $__.os.oid240), $__.os.oid240)[p, 'value'] = (vvv_tmp6 = parameter_src, 'clone', $__.fs.J$__v494107025_623_551.call(vvv_tmp6, 3, true, $__.uid));
    'specularMap' in vvv_tmp0;
    u = 'specularMap';
    (uniforms_dst, $__.os.oid236)[u, 'specularMap'] = $__.os.oid241 = {};
    vvv_tmp7 = ((uniforms_src, $__.os.oid31)[u, 'specularMap'], $__.os.oid25);
    'value' in vvv_tmp7;
    p = 'value';
    parameter_src = ((((uniforms_src, $__.os.oid31)[u, 'specularMap'], $__.os.oid25), $__.os.oid25)[p, 'value'], null);
    (((((parameter_src, parameter_src), parameter_src), parameter_src), parameter_src), parameter_src), parameter_src;
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid236)[u, 'specularMap'], $__.os.oid241), $__.os.oid241)[p, 'value'] = parameter_src;
    'alphaMap' in vvv_tmp0;
    u = 'alphaMap';
    (uniforms_dst, $__.os.oid236)[u, 'alphaMap'] = $__.os.oid242 = {};
    vvv_tmp8 = ((uniforms_src, $__.os.oid31)[u, 'alphaMap'], $__.os.oid26);
    'value' in vvv_tmp8;
    p = 'value';
    parameter_src = ((((uniforms_src, $__.os.oid31)[u, 'alphaMap'], $__.os.oid26), $__.os.oid26)[p, 'value'], null);
    (((((parameter_src, parameter_src), parameter_src), parameter_src), parameter_src), parameter_src), parameter_src;
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid236)[u, 'alphaMap'], $__.os.oid242), $__.os.oid242)[p, 'value'] = parameter_src;
    'envMap' in vvv_tmp0;
    u = 'envMap';
    (uniforms_dst, $__.os.oid236)[u, 'envMap'] = $__.os.oid243 = {};
    vvv_tmp9 = ((uniforms_src, $__.os.oid31)[u, 'envMap'], $__.os.oid27);
    'value' in vvv_tmp9;
    p = 'value';
    parameter_src = ((((uniforms_src, $__.os.oid31)[u, 'envMap'], $__.os.oid27), $__.os.oid27)[p, 'value'], null);
    (((((parameter_src, parameter_src), parameter_src), parameter_src), parameter_src), parameter_src), parameter_src;
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid236)[u, 'envMap'], $__.os.oid243), $__.os.oid243)[p, 'value'] = parameter_src;
    'flipEnvMap' in vvv_tmp0;
    u = 'flipEnvMap';
    (uniforms_dst, $__.os.oid236)[u, 'flipEnvMap'] = $__.os.oid244 = {};
    vvv_tmp10 = ((uniforms_src, $__.os.oid31)[u, 'flipEnvMap'], $__.os.oid28);
    'value' in vvv_tmp10;
    p = 'value';
    parameter_src = ((((uniforms_src, $__.os.oid31)[u, 'flipEnvMap'], $__.os.oid28), $__.os.oid28)[p, 'value'], -1);
    ((((((parameter_src, TAJS_restrictToType(parameter_src.isColor, 'undefined')), (parameter_src, TAJS_restrictToType(parameter_src.isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isTexture, 'undefined'));
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid236)[u, 'flipEnvMap'], $__.os.oid244), $__.os.oid244)[p, 'value'] = parameter_src;
    'reflectivity' in vvv_tmp0;
    u = 'reflectivity';
    (uniforms_dst, $__.os.oid236)[u, 'reflectivity'] = $__.os.oid245 = {};
    vvv_tmp11 = ((uniforms_src, $__.os.oid31)[u, 'reflectivity'], $__.os.oid29);
    'value' in vvv_tmp11;
    p = 'value';
    parameter_src = ((((uniforms_src, $__.os.oid31)[u, 'reflectivity'], $__.os.oid29), $__.os.oid29)[p, 'value'], 1);
    ((((((parameter_src, TAJS_restrictToType(parameter_src.isColor, 'undefined')), (parameter_src, TAJS_restrictToType(parameter_src.isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isTexture, 'undefined'));
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid236)[u, 'reflectivity'], $__.os.oid245), $__.os.oid245)[p, 'value'] = parameter_src;
    'refractionRatio' in vvv_tmp0;
    u = 'refractionRatio';
    (uniforms_dst, $__.os.oid236)[u, 'refractionRatio'] = $__.os.oid246 = {};
    vvv_tmp12 = ((uniforms_src, $__.os.oid31)[u, 'refractionRatio'], $__.os.oid30);
    'value' in vvv_tmp12;
    p = 'value';
    parameter_src = ((((uniforms_src, $__.os.oid31)[u, 'refractionRatio'], $__.os.oid30), $__.os.oid30)[p, 'value'], 0.98);
    ((((((parameter_src, TAJS_restrictToType(parameter_src.isColor, 'undefined')), (parameter_src, TAJS_restrictToType(parameter_src.isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isTexture, 'undefined'));
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid236)[u, 'refractionRatio'], $__.os.oid246), $__.os.oid246)[p, 'value'] = parameter_src;
    return uniforms_dst;
case 21:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 21);
    uniforms_dst = $__.os.oid247 = {};
    vvv_tmp0 = uniforms_src;
    'aoMap' in vvv_tmp0;
    u = 'aoMap';
    (uniforms_dst, $__.os.oid247)[u, 'aoMap'] = $__.os.oid248 = {};
    vvv_tmp1 = ((uniforms_src, $__.os.oid34)[u, 'aoMap'], $__.os.oid32);
    'value' in vvv_tmp1;
    p = 'value';
    parameter_src = ((((uniforms_src, $__.os.oid34)[u, 'aoMap'], $__.os.oid32), $__.os.oid32)[p, 'value'], null);
    (((((parameter_src, parameter_src), parameter_src), parameter_src), parameter_src), parameter_src), parameter_src;
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid247)[u, 'aoMap'], $__.os.oid248), $__.os.oid248)[p, 'value'] = parameter_src;
    'aoMapIntensity' in vvv_tmp0;
    u = 'aoMapIntensity';
    (uniforms_dst, $__.os.oid247)[u, 'aoMapIntensity'] = $__.os.oid249 = {};
    vvv_tmp2 = ((uniforms_src, $__.os.oid34)[u, 'aoMapIntensity'], $__.os.oid33);
    'value' in vvv_tmp2;
    p = 'value';
    parameter_src = ((((uniforms_src, $__.os.oid34)[u, 'aoMapIntensity'], $__.os.oid33), $__.os.oid33)[p, 'value'], 1);
    ((((((parameter_src, TAJS_restrictToType(parameter_src.isColor, 'undefined')), (parameter_src, TAJS_restrictToType(parameter_src.isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isTexture, 'undefined'));
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid247)[u, 'aoMapIntensity'], $__.os.oid249), $__.os.oid249)[p, 'value'] = parameter_src;
    return uniforms_dst;
case 22:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 22);
    uniforms_dst = $__.os.oid250 = {};
    vvv_tmp0 = uniforms_src;
    'lightMap' in vvv_tmp0;
    u = 'lightMap';
    (uniforms_dst, $__.os.oid250)[u, 'lightMap'] = $__.os.oid251 = {};
    vvv_tmp1 = ((uniforms_src, $__.os.oid37)[u, 'lightMap'], $__.os.oid35);
    'value' in vvv_tmp1;
    p = 'value';
    parameter_src = ((((uniforms_src, $__.os.oid37)[u, 'lightMap'], $__.os.oid35), $__.os.oid35)[p, 'value'], null);
    (((((parameter_src, parameter_src), parameter_src), parameter_src), parameter_src), parameter_src), parameter_src;
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid250)[u, 'lightMap'], $__.os.oid251), $__.os.oid251)[p, 'value'] = parameter_src;
    'lightMapIntensity' in vvv_tmp0;
    u = 'lightMapIntensity';
    (uniforms_dst, $__.os.oid250)[u, 'lightMapIntensity'] = $__.os.oid252 = {};
    vvv_tmp2 = ((uniforms_src, $__.os.oid37)[u, 'lightMapIntensity'], $__.os.oid36);
    'value' in vvv_tmp2;
    p = 'value';
    parameter_src = ((((uniforms_src, $__.os.oid37)[u, 'lightMapIntensity'], $__.os.oid36), $__.os.oid36)[p, 'value'], 1);
    ((((((parameter_src, TAJS_restrictToType(parameter_src.isColor, 'undefined')), (parameter_src, TAJS_restrictToType(parameter_src.isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isTexture, 'undefined'));
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid250)[u, 'lightMapIntensity'], $__.os.oid252), $__.os.oid252)[p, 'value'] = parameter_src;
    return uniforms_dst;
case 23:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 23);
    uniforms_dst = $__.os.oid253 = {};
    vvv_tmp0 = uniforms_src;
    'emissiveMap' in vvv_tmp0;
    u = 'emissiveMap';
    (uniforms_dst, $__.os.oid253)[u, 'emissiveMap'] = $__.os.oid254 = {};
    vvv_tmp1 = ((uniforms_src, $__.os.oid39)[u, 'emissiveMap'], $__.os.oid38);
    'value' in vvv_tmp1;
    p = 'value';
    parameter_src = ((((uniforms_src, $__.os.oid39)[u, 'emissiveMap'], $__.os.oid38), $__.os.oid38)[p, 'value'], null);
    (((((parameter_src, parameter_src), parameter_src), parameter_src), parameter_src), parameter_src), parameter_src;
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid253)[u, 'emissiveMap'], $__.os.oid254), $__.os.oid254)[p, 'value'] = parameter_src;
    return uniforms_dst;
case 24:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 24);
    uniforms_dst = $__.os.oid255 = {};
    vvv_tmp0 = uniforms_src;
    'bumpMap' in vvv_tmp0;
    u = 'bumpMap';
    (uniforms_dst, $__.os.oid255)[u, 'bumpMap'] = $__.os.oid256 = {};
    vvv_tmp1 = ((uniforms_src, $__.os.oid42)[u, 'bumpMap'], $__.os.oid40);
    'value' in vvv_tmp1;
    p = 'value';
    parameter_src = ((((uniforms_src, $__.os.oid42)[u, 'bumpMap'], $__.os.oid40), $__.os.oid40)[p, 'value'], null);
    (((((parameter_src, parameter_src), parameter_src), parameter_src), parameter_src), parameter_src), parameter_src;
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid255)[u, 'bumpMap'], $__.os.oid256), $__.os.oid256)[p, 'value'] = parameter_src;
    'bumpScale' in vvv_tmp0;
    u = 'bumpScale';
    (uniforms_dst, $__.os.oid255)[u, 'bumpScale'] = $__.os.oid257 = {};
    vvv_tmp2 = ((uniforms_src, $__.os.oid42)[u, 'bumpScale'], $__.os.oid41);
    'value' in vvv_tmp2;
    p = 'value';
    parameter_src = ((((uniforms_src, $__.os.oid42)[u, 'bumpScale'], $__.os.oid41), $__.os.oid41)[p, 'value'], 1);
    ((((((parameter_src, TAJS_restrictToType(parameter_src.isColor, 'undefined')), (parameter_src, TAJS_restrictToType(parameter_src.isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isTexture, 'undefined'));
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid255)[u, 'bumpScale'], $__.os.oid257), $__.os.oid257)[p, 'value'] = parameter_src;
    return uniforms_dst;
case 25:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 25);
    uniforms_dst = $__.os.oid258 = {};
    vvv_tmp0 = uniforms_src;
    'normalMap' in vvv_tmp0;
    u = 'normalMap';
    (uniforms_dst, $__.os.oid258)[u, 'normalMap'] = $__.os.oid259 = {};
    vvv_tmp1 = ((uniforms_src, $__.os.oid45)[u, 'normalMap'], $__.os.oid43);
    'value' in vvv_tmp1;
    p = 'value';
    parameter_src = ((((uniforms_src, $__.os.oid45)[u, 'normalMap'], $__.os.oid43), $__.os.oid43)[p, 'value'], null);
    (((((parameter_src, parameter_src), parameter_src), parameter_src), parameter_src), parameter_src), parameter_src;
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid258)[u, 'normalMap'], $__.os.oid259), $__.os.oid259)[p, 'value'] = parameter_src;
    'normalScale' in vvv_tmp0;
    u = 'normalScale';
    (uniforms_dst, $__.os.oid258)[u, 'normalScale'] = $__.os.oid260 = {};
    vvv_tmp2 = ((uniforms_src, $__.os.oid45)[u, 'normalScale'], $__.os.oid44);
    'value' in vvv_tmp2;
    p = 'value';
    parameter_src = TAJS_restrictToType((((uniforms_src, $__.os.oid45)[u, 'normalScale'], $__.os.oid44), $__.os.oid44)[p, 'value'], 'object');
    (parameter_src, TAJS_restrictToType(parameter_src.isColor, 'undefined')), (parameter_src, (parameter_src.isVector2, true));
    (((uniforms_dst, $__.os.oid258)[u, 'normalScale'], $__.os.oid260), $__.os.oid260)[p, 'value'] = (vvv_tmp3 = parameter_src, 'clone', $__.fs.J$__v494107025_85_307.call(vvv_tmp3, 1, true, $__.uid));
    return uniforms_dst;
case 26:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 26);
    uniforms_dst = $__.os.oid261 = {};
    vvv_tmp0 = uniforms_src;
    'displacementMap' in vvv_tmp0;
    u = 'displacementMap';
    (uniforms_dst, $__.os.oid261)[u, 'displacementMap'] = $__.os.oid262 = {};
    vvv_tmp1 = ((uniforms_src, $__.os.oid49)[u, 'displacementMap'], $__.os.oid46);
    'value' in vvv_tmp1;
    p = 'value';
    parameter_src = ((((uniforms_src, $__.os.oid49)[u, 'displacementMap'], $__.os.oid46), $__.os.oid46)[p, 'value'], null);
    (((((parameter_src, parameter_src), parameter_src), parameter_src), parameter_src), parameter_src), parameter_src;
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid261)[u, 'displacementMap'], $__.os.oid262), $__.os.oid262)[p, 'value'] = parameter_src;
    'displacementScale' in vvv_tmp0;
    u = 'displacementScale';
    (uniforms_dst, $__.os.oid261)[u, 'displacementScale'] = $__.os.oid263 = {};
    vvv_tmp2 = ((uniforms_src, $__.os.oid49)[u, 'displacementScale'], $__.os.oid47);
    'value' in vvv_tmp2;
    p = 'value';
    parameter_src = ((((uniforms_src, $__.os.oid49)[u, 'displacementScale'], $__.os.oid47), $__.os.oid47)[p, 'value'], 1);
    ((((((parameter_src, TAJS_restrictToType(parameter_src.isColor, 'undefined')), (parameter_src, TAJS_restrictToType(parameter_src.isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isTexture, 'undefined'));
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid261)[u, 'displacementScale'], $__.os.oid263), $__.os.oid263)[p, 'value'] = parameter_src;
    'displacementBias' in vvv_tmp0;
    u = 'displacementBias';
    (uniforms_dst, $__.os.oid261)[u, 'displacementBias'] = $__.os.oid264 = {};
    vvv_tmp3 = ((uniforms_src, $__.os.oid49)[u, 'displacementBias'], $__.os.oid48);
    'value' in vvv_tmp3;
    p = 'value';
    parameter_src = ((((uniforms_src, $__.os.oid49)[u, 'displacementBias'], $__.os.oid48), $__.os.oid48)[p, 'value'], 0);
    (((((parameter_src, parameter_src), parameter_src), parameter_src), parameter_src), parameter_src), parameter_src;
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid261)[u, 'displacementBias'], $__.os.oid264), $__.os.oid264)[p, 'value'] = parameter_src;
    return uniforms_dst;
case 27:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 27);
    uniforms_dst = $__.os.oid265 = {};
    vvv_tmp0 = uniforms_src;
    'roughnessMap' in vvv_tmp0;
    u = 'roughnessMap';
    (uniforms_dst, $__.os.oid265)[u, 'roughnessMap'] = $__.os.oid266 = {};
    vvv_tmp1 = ((uniforms_src, $__.os.oid51)[u, 'roughnessMap'], $__.os.oid50);
    'value' in vvv_tmp1;
    p = 'value';
    parameter_src = ((((uniforms_src, $__.os.oid51)[u, 'roughnessMap'], $__.os.oid50), $__.os.oid50)[p, 'value'], null);
    (((((parameter_src, parameter_src), parameter_src), parameter_src), parameter_src), parameter_src), parameter_src;
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid265)[u, 'roughnessMap'], $__.os.oid266), $__.os.oid266)[p, 'value'] = parameter_src;
    return uniforms_dst;
case 28:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 28);
    uniforms_dst = $__.os.oid267 = {};
    vvv_tmp0 = uniforms_src;
    'metalnessMap' in vvv_tmp0;
    u = 'metalnessMap';
    (uniforms_dst, $__.os.oid267)[u, 'metalnessMap'] = $__.os.oid268 = {};
    vvv_tmp1 = ((uniforms_src, $__.os.oid53)[u, 'metalnessMap'], $__.os.oid52);
    'value' in vvv_tmp1;
    p = 'value';
    parameter_src = ((((uniforms_src, $__.os.oid53)[u, 'metalnessMap'], $__.os.oid52), $__.os.oid52)[p, 'value'], null);
    (((((parameter_src, parameter_src), parameter_src), parameter_src), parameter_src), parameter_src), parameter_src;
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid267)[u, 'metalnessMap'], $__.os.oid268), $__.os.oid268)[p, 'value'] = parameter_src;
    return uniforms_dst;
case 29:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 29);
    uniforms_dst = $__.os.oid269 = {};
    vvv_tmp0 = uniforms_src;
    'fogDensity' in vvv_tmp0;
    u = 'fogDensity';
    (uniforms_dst, $__.os.oid269)[u, 'fogDensity'] = $__.os.oid270 = {};
    vvv_tmp1 = ((uniforms_src, $__.os.oid58)[u, 'fogDensity'], $__.os.oid54);
    'value' in vvv_tmp1;
    p = 'value';
    parameter_src = ((((uniforms_src, $__.os.oid58)[u, 'fogDensity'], $__.os.oid54), $__.os.oid54)[p, 'value'], 0.00025);
    ((((((parameter_src, TAJS_restrictToType(parameter_src.isColor, 'undefined')), (parameter_src, TAJS_restrictToType(parameter_src.isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isTexture, 'undefined'));
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid269)[u, 'fogDensity'], $__.os.oid270), $__.os.oid270)[p, 'value'] = parameter_src;
    'fogNear' in vvv_tmp0;
    u = 'fogNear';
    (uniforms_dst, $__.os.oid269)[u, 'fogNear'] = $__.os.oid271 = {};
    vvv_tmp2 = ((uniforms_src, $__.os.oid58)[u, 'fogNear'], $__.os.oid55);
    'value' in vvv_tmp2;
    p = 'value';
    parameter_src = ((((uniforms_src, $__.os.oid58)[u, 'fogNear'], $__.os.oid55), $__.os.oid55)[p, 'value'], 1);
    ((((((parameter_src, TAJS_restrictToType(parameter_src.isColor, 'undefined')), (parameter_src, TAJS_restrictToType(parameter_src.isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isTexture, 'undefined'));
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid269)[u, 'fogNear'], $__.os.oid271), $__.os.oid271)[p, 'value'] = parameter_src;
    'fogFar' in vvv_tmp0;
    u = 'fogFar';
    (uniforms_dst, $__.os.oid269)[u, 'fogFar'] = $__.os.oid272 = {};
    vvv_tmp3 = ((uniforms_src, $__.os.oid58)[u, 'fogFar'], $__.os.oid56);
    'value' in vvv_tmp3;
    p = 'value';
    parameter_src = ((((uniforms_src, $__.os.oid58)[u, 'fogFar'], $__.os.oid56), $__.os.oid56)[p, 'value'], 2000);
    ((((((parameter_src, TAJS_restrictToType(parameter_src.isColor, 'undefined')), (parameter_src, TAJS_restrictToType(parameter_src.isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isTexture, 'undefined'));
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid269)[u, 'fogFar'], $__.os.oid272), $__.os.oid272)[p, 'value'] = parameter_src;
    'fogColor' in vvv_tmp0;
    u = 'fogColor';
    (uniforms_dst, $__.os.oid269)[u, 'fogColor'] = $__.os.oid273 = {};
    vvv_tmp4 = ((uniforms_src, $__.os.oid58)[u, 'fogColor'], $__.os.oid57);
    'value' in vvv_tmp4;
    p = 'value';
    parameter_src = TAJS_restrictToType((((uniforms_src, $__.os.oid58)[u, 'fogColor'], $__.os.oid57), $__.os.oid57)[p, 'value'], 'object');
    parameter_src, (parameter_src.isColor, true);
    (((uniforms_dst, $__.os.oid269)[u, 'fogColor'], $__.os.oid273), $__.os.oid273)[p, 'value'] = (vvv_tmp5 = parameter_src, 'clone', $__.fs.J$__v494107025_821_611.call(vvv_tmp5, 10, true, $__.uid));
    return uniforms_dst;
case 30:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 30);
    uniforms_dst = $__.os.oid274 = {};
    vvv_tmp0 = uniforms_src;
    'ambientLightColor' in vvv_tmp0;
    u = 'ambientLightColor';
    (uniforms_dst, $__.os.oid274)[u, 'ambientLightColor'] = $__.os.oid275 = {};
    vvv_tmp1 = ((uniforms_src, $__.os.oid102)[u, 'ambientLightColor'], $__.os.oid59);
    'value' in vvv_tmp1;
    p = 'value';
    parameter_src = TAJS_restrictToType((((uniforms_src, $__.os.oid102)[u, 'ambientLightColor'], $__.os.oid59), $__.os.oid59)[p, 'value'], 'object');
    ((((((parameter_src, TAJS_restrictToType(parameter_src.isColor, 'undefined')), (parameter_src, TAJS_restrictToType(parameter_src.isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isTexture, 'undefined'));
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid274)[u, 'ambientLightColor'], $__.os.oid275), $__.os.oid275)[p, 'value'] = function $__lt24(res) {
        res.length = 0;
        if (res.length != 0)
            TAJS_dumpValue('Possible loss of precision');
        return res;
        ;
        TAJS_makeContextSensitive($__lt24, -2);
    }(parameter_src['slice']());
    'directionalLights' in vvv_tmp0;
    u = 'directionalLights';
    (uniforms_dst, $__.os.oid274)[u, 'directionalLights'] = $__.os.oid276 = {};
    vvv_tmp2 = ((uniforms_src, $__.os.oid102)[u, 'directionalLights'], $__.os.oid67);
    'value' in vvv_tmp2;
    p = 'value';
    parameter_src = TAJS_restrictToType((((uniforms_src, $__.os.oid102)[u, 'directionalLights'], $__.os.oid67), $__.os.oid67)[p, 'value'], 'object');
    ((((((parameter_src, TAJS_restrictToType(parameter_src.isColor, 'undefined')), (parameter_src, TAJS_restrictToType(parameter_src.isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isTexture, 'undefined'));
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid274)[u, 'directionalLights'], $__.os.oid276), $__.os.oid276)[p, 'value'] = function $__lt25(res) {
        res.length = 0;
        if (res.length != 0)
            TAJS_dumpValue('Possible loss of precision');
        return res;
        ;
        TAJS_makeContextSensitive($__lt25, -2);
    }(parameter_src['slice']());
    'properties' in vvv_tmp2;
    p = 'properties';
    parameter_src = ((((uniforms_src, $__.os.oid102)[u, 'directionalLights'], $__.os.oid67), $__.os.oid67)[p, 'properties'], $__.os.oid66);
    ((((((parameter_src, TAJS_restrictToType((parameter_src, $__.os.oid66).isColor, 'undefined')), (parameter_src, TAJS_restrictToType((parameter_src, $__.os.oid66).isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType((parameter_src, $__.os.oid66).isVector3, 'undefined'))), (parameter_src, TAJS_restrictToType((parameter_src, $__.os.oid66).isVector4, 'undefined'))), (parameter_src, TAJS_restrictToType((parameter_src, $__.os.oid66).isMatrix3, 'undefined'))), (parameter_src, TAJS_restrictToType((parameter_src, $__.os.oid66).isMatrix4, 'undefined'))), (parameter_src, TAJS_restrictToType((parameter_src, $__.os.oid66).isTexture, 'undefined'));
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid274)[u, 'directionalLights'], $__.os.oid276), $__.os.oid276)[p, 'properties'] = parameter_src;
    'directionalShadowMap' in vvv_tmp0;
    u = 'directionalShadowMap';
    (uniforms_dst, $__.os.oid274)[u, 'directionalShadowMap'] = $__.os.oid277 = {};
    vvv_tmp3 = ((uniforms_src, $__.os.oid102)[u, 'directionalShadowMap'], $__.os.oid68);
    'value' in vvv_tmp3;
    p = 'value';
    parameter_src = TAJS_restrictToType((((uniforms_src, $__.os.oid102)[u, 'directionalShadowMap'], $__.os.oid68), $__.os.oid68)[p, 'value'], 'object');
    ((((((parameter_src, TAJS_restrictToType(parameter_src.isColor, 'undefined')), (parameter_src, TAJS_restrictToType(parameter_src.isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isTexture, 'undefined'));
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid274)[u, 'directionalShadowMap'], $__.os.oid277), $__.os.oid277)[p, 'value'] = function $__lt26(res) {
        res.length = 0;
        if (res.length != 0)
            TAJS_dumpValue('Possible loss of precision');
        return res;
        ;
        TAJS_makeContextSensitive($__lt26, -2);
    }(parameter_src['slice']());
    'directionalShadowMatrix' in vvv_tmp0;
    u = 'directionalShadowMatrix';
    (uniforms_dst, $__.os.oid274)[u, 'directionalShadowMatrix'] = $__.os.oid278 = {};
    vvv_tmp4 = ((uniforms_src, $__.os.oid102)[u, 'directionalShadowMatrix'], $__.os.oid69);
    'value' in vvv_tmp4;
    p = 'value';
    parameter_src = TAJS_restrictToType((((uniforms_src, $__.os.oid102)[u, 'directionalShadowMatrix'], $__.os.oid69), $__.os.oid69)[p, 'value'], 'object');
    ((((((parameter_src, TAJS_restrictToType(parameter_src.isColor, 'undefined')), (parameter_src, TAJS_restrictToType(parameter_src.isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isTexture, 'undefined'));
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid274)[u, 'directionalShadowMatrix'], $__.os.oid278), $__.os.oid278)[p, 'value'] = function $__lt27(res) {
        res.length = 0;
        if (res.length != 0)
            TAJS_dumpValue('Possible loss of precision');
        return res;
        ;
        TAJS_makeContextSensitive($__lt27, -2);
    }(parameter_src['slice']());
    'spotLights' in vvv_tmp0;
    u = 'spotLights';
    (uniforms_dst, $__.os.oid274)[u, 'spotLights'] = $__.os.oid279 = {};
    vvv_tmp5 = ((uniforms_src, $__.os.oid102)[u, 'spotLights'], $__.os.oid82);
    'value' in vvv_tmp5;
    p = 'value';
    parameter_src = TAJS_restrictToType((((uniforms_src, $__.os.oid102)[u, 'spotLights'], $__.os.oid82), $__.os.oid82)[p, 'value'], 'object');
    ((((((parameter_src, TAJS_restrictToType(parameter_src.isColor, 'undefined')), (parameter_src, TAJS_restrictToType(parameter_src.isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isTexture, 'undefined'));
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid274)[u, 'spotLights'], $__.os.oid279), $__.os.oid279)[p, 'value'] = function $__lt28(res) {
        res.length = 0;
        if (res.length != 0)
            TAJS_dumpValue('Possible loss of precision');
        return res;
        ;
        TAJS_makeContextSensitive($__lt28, -2);
    }(parameter_src['slice']());
    'properties' in vvv_tmp5;
    p = 'properties';
    parameter_src = ((((uniforms_src, $__.os.oid102)[u, 'spotLights'], $__.os.oid82), $__.os.oid82)[p, 'properties'], $__.os.oid81);
    ((((((parameter_src, TAJS_restrictToType((parameter_src, $__.os.oid81).isColor, 'undefined')), (parameter_src, TAJS_restrictToType((parameter_src, $__.os.oid81).isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType((parameter_src, $__.os.oid81).isVector3, 'undefined'))), (parameter_src, TAJS_restrictToType((parameter_src, $__.os.oid81).isVector4, 'undefined'))), (parameter_src, TAJS_restrictToType((parameter_src, $__.os.oid81).isMatrix3, 'undefined'))), (parameter_src, TAJS_restrictToType((parameter_src, $__.os.oid81).isMatrix4, 'undefined'))), (parameter_src, TAJS_restrictToType((parameter_src, $__.os.oid81).isTexture, 'undefined'));
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid274)[u, 'spotLights'], $__.os.oid279), $__.os.oid279)[p, 'properties'] = parameter_src;
    'spotShadowMap' in vvv_tmp0;
    u = 'spotShadowMap';
    (uniforms_dst, $__.os.oid274)[u, 'spotShadowMap'] = $__.os.oid280 = {};
    vvv_tmp6 = ((uniforms_src, $__.os.oid102)[u, 'spotShadowMap'], $__.os.oid83);
    'value' in vvv_tmp6;
    p = 'value';
    parameter_src = TAJS_restrictToType((((uniforms_src, $__.os.oid102)[u, 'spotShadowMap'], $__.os.oid83), $__.os.oid83)[p, 'value'], 'object');
    ((((((parameter_src, TAJS_restrictToType(parameter_src.isColor, 'undefined')), (parameter_src, TAJS_restrictToType(parameter_src.isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isTexture, 'undefined'));
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid274)[u, 'spotShadowMap'], $__.os.oid280), $__.os.oid280)[p, 'value'] = function $__lt29(res) {
        res.length = 0;
        if (res.length != 0)
            TAJS_dumpValue('Possible loss of precision');
        return res;
        ;
        TAJS_makeContextSensitive($__lt29, -2);
    }(parameter_src['slice']());
    'spotShadowMatrix' in vvv_tmp0;
    u = 'spotShadowMatrix';
    (uniforms_dst, $__.os.oid274)[u, 'spotShadowMatrix'] = $__.os.oid281 = {};
    vvv_tmp7 = ((uniforms_src, $__.os.oid102)[u, 'spotShadowMatrix'], $__.os.oid84);
    'value' in vvv_tmp7;
    p = 'value';
    parameter_src = TAJS_restrictToType((((uniforms_src, $__.os.oid102)[u, 'spotShadowMatrix'], $__.os.oid84), $__.os.oid84)[p, 'value'], 'object');
    ((((((parameter_src, TAJS_restrictToType(parameter_src.isColor, 'undefined')), (parameter_src, TAJS_restrictToType(parameter_src.isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isTexture, 'undefined'));
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid274)[u, 'spotShadowMatrix'], $__.os.oid281), $__.os.oid281)[p, 'value'] = function $__lt30(res) {
        res.length = 0;
        if (res.length != 0)
            TAJS_dumpValue('Possible loss of precision');
        return res;
        ;
        TAJS_makeContextSensitive($__lt30, -2);
    }(parameter_src['slice']());
    'pointLights' in vvv_tmp0;
    u = 'pointLights';
    (uniforms_dst, $__.os.oid274)[u, 'pointLights'] = $__.os.oid282 = {};
    vvv_tmp8 = ((uniforms_src, $__.os.oid102)[u, 'pointLights'], $__.os.oid94);
    'value' in vvv_tmp8;
    p = 'value';
    parameter_src = TAJS_restrictToType((((uniforms_src, $__.os.oid102)[u, 'pointLights'], $__.os.oid94), $__.os.oid94)[p, 'value'], 'object');
    ((((((parameter_src, TAJS_restrictToType(parameter_src.isColor, 'undefined')), (parameter_src, TAJS_restrictToType(parameter_src.isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isTexture, 'undefined'));
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid274)[u, 'pointLights'], $__.os.oid282), $__.os.oid282)[p, 'value'] = function $__lt31(res) {
        res.length = 0;
        if (res.length != 0)
            TAJS_dumpValue('Possible loss of precision');
        return res;
        ;
        TAJS_makeContextSensitive($__lt31, -2);
    }(parameter_src['slice']());
    'properties' in vvv_tmp8;
    p = 'properties';
    parameter_src = ((((uniforms_src, $__.os.oid102)[u, 'pointLights'], $__.os.oid94), $__.os.oid94)[p, 'properties'], $__.os.oid93);
    ((((((parameter_src, TAJS_restrictToType((parameter_src, $__.os.oid93).isColor, 'undefined')), (parameter_src, TAJS_restrictToType((parameter_src, $__.os.oid93).isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType((parameter_src, $__.os.oid93).isVector3, 'undefined'))), (parameter_src, TAJS_restrictToType((parameter_src, $__.os.oid93).isVector4, 'undefined'))), (parameter_src, TAJS_restrictToType((parameter_src, $__.os.oid93).isMatrix3, 'undefined'))), (parameter_src, TAJS_restrictToType((parameter_src, $__.os.oid93).isMatrix4, 'undefined'))), (parameter_src, TAJS_restrictToType((parameter_src, $__.os.oid93).isTexture, 'undefined'));
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid274)[u, 'pointLights'], $__.os.oid282), $__.os.oid282)[p, 'properties'] = parameter_src;
    'pointShadowMap' in vvv_tmp0;
    u = 'pointShadowMap';
    (uniforms_dst, $__.os.oid274)[u, 'pointShadowMap'] = $__.os.oid283 = {};
    vvv_tmp9 = ((uniforms_src, $__.os.oid102)[u, 'pointShadowMap'], $__.os.oid95);
    'value' in vvv_tmp9;
    p = 'value';
    parameter_src = TAJS_restrictToType((((uniforms_src, $__.os.oid102)[u, 'pointShadowMap'], $__.os.oid95), $__.os.oid95)[p, 'value'], 'object');
    ((((((parameter_src, TAJS_restrictToType(parameter_src.isColor, 'undefined')), (parameter_src, TAJS_restrictToType(parameter_src.isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isTexture, 'undefined'));
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid274)[u, 'pointShadowMap'], $__.os.oid283), $__.os.oid283)[p, 'value'] = function $__lt32(res) {
        res.length = 0;
        if (res.length != 0)
            TAJS_dumpValue('Possible loss of precision');
        return res;
        ;
        TAJS_makeContextSensitive($__lt32, -2);
    }(parameter_src['slice']());
    'pointShadowMatrix' in vvv_tmp0;
    u = 'pointShadowMatrix';
    (uniforms_dst, $__.os.oid274)[u, 'pointShadowMatrix'] = $__.os.oid284 = {};
    vvv_tmp10 = ((uniforms_src, $__.os.oid102)[u, 'pointShadowMatrix'], $__.os.oid96);
    'value' in vvv_tmp10;
    p = 'value';
    parameter_src = TAJS_restrictToType((((uniforms_src, $__.os.oid102)[u, 'pointShadowMatrix'], $__.os.oid96), $__.os.oid96)[p, 'value'], 'object');
    ((((((parameter_src, TAJS_restrictToType(parameter_src.isColor, 'undefined')), (parameter_src, TAJS_restrictToType(parameter_src.isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isTexture, 'undefined'));
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid274)[u, 'pointShadowMatrix'], $__.os.oid284), $__.os.oid284)[p, 'value'] = function $__lt33(res) {
        res.length = 0;
        if (res.length != 0)
            TAJS_dumpValue('Possible loss of precision');
        return res;
        ;
        TAJS_makeContextSensitive($__lt33, -2);
    }(parameter_src['slice']());
    'hemisphereLights' in vvv_tmp0;
    u = 'hemisphereLights';
    (uniforms_dst, $__.os.oid274)[u, 'hemisphereLights'] = $__.os.oid285 = {};
    vvv_tmp11 = ((uniforms_src, $__.os.oid102)[u, 'hemisphereLights'], $__.os.oid101);
    'value' in vvv_tmp11;
    p = 'value';
    parameter_src = TAJS_restrictToType((((uniforms_src, $__.os.oid102)[u, 'hemisphereLights'], $__.os.oid101), $__.os.oid101)[p, 'value'], 'object');
    ((((((parameter_src, TAJS_restrictToType(parameter_src.isColor, 'undefined')), (parameter_src, TAJS_restrictToType(parameter_src.isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isTexture, 'undefined'));
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid274)[u, 'hemisphereLights'], $__.os.oid285), $__.os.oid285)[p, 'value'] = function $__lt34(res) {
        res.length = 0;
        if (res.length != 0)
            TAJS_dumpValue('Possible loss of precision');
        return res;
        ;
        TAJS_makeContextSensitive($__lt34, -2);
    }(parameter_src['slice']());
    'properties' in vvv_tmp11;
    p = 'properties';
    parameter_src = ((((uniforms_src, $__.os.oid102)[u, 'hemisphereLights'], $__.os.oid101), $__.os.oid101)[p, 'properties'], $__.os.oid100);
    ((((((parameter_src, TAJS_restrictToType((parameter_src, $__.os.oid100).isColor, 'undefined')), (parameter_src, TAJS_restrictToType((parameter_src, $__.os.oid100).isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType((parameter_src, $__.os.oid100).isVector3, 'undefined'))), (parameter_src, TAJS_restrictToType((parameter_src, $__.os.oid100).isVector4, 'undefined'))), (parameter_src, TAJS_restrictToType((parameter_src, $__.os.oid100).isMatrix3, 'undefined'))), (parameter_src, TAJS_restrictToType((parameter_src, $__.os.oid100).isMatrix4, 'undefined'))), (parameter_src, TAJS_restrictToType((parameter_src, $__.os.oid100).isTexture, 'undefined'));
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid274)[u, 'hemisphereLights'], $__.os.oid285), $__.os.oid285)[p, 'properties'] = parameter_src;
    return uniforms_dst;
case 31:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 31);
    uniforms_dst = $__.os.oid286 = {};
    vvv_tmp0 = uniforms_src;
    'emissive' in vvv_tmp0;
    u = 'emissive';
    (uniforms_dst, $__.os.oid286)[u, 'emissive'] = $__.os.oid287 = {};
    vvv_tmp1 = ((uniforms_src, $__.os.oid234)[u, 'emissive'], $__.os.oid230);
    'value' in vvv_tmp1;
    p = 'value';
    parameter_src = TAJS_restrictToType((((uniforms_src, $__.os.oid234)[u, 'emissive'], $__.os.oid230), $__.os.oid230)[p, 'value'], 'object');
    parameter_src, (parameter_src.isColor, true);
    (((uniforms_dst, $__.os.oid286)[u, 'emissive'], $__.os.oid287), $__.os.oid287)[p, 'value'] = (vvv_tmp2 = parameter_src, 'clone', $__.fs.J$__v494107025_821_611.call(vvv_tmp2, 11, true, $__.uid));
    'roughness' in vvv_tmp0;
    u = 'roughness';
    (uniforms_dst, $__.os.oid286)[u, 'roughness'] = $__.os.oid288 = {};
    vvv_tmp3 = ((uniforms_src, $__.os.oid234)[u, 'roughness'], $__.os.oid231);
    'value' in vvv_tmp3;
    p = 'value';
    parameter_src = ((((uniforms_src, $__.os.oid234)[u, 'roughness'], $__.os.oid231), $__.os.oid231)[p, 'value'], 0.5);
    ((((((parameter_src, TAJS_restrictToType(parameter_src.isColor, 'undefined')), (parameter_src, TAJS_restrictToType(parameter_src.isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isTexture, 'undefined'));
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid286)[u, 'roughness'], $__.os.oid288), $__.os.oid288)[p, 'value'] = parameter_src;
    'metalness' in vvv_tmp0;
    u = 'metalness';
    (uniforms_dst, $__.os.oid286)[u, 'metalness'] = $__.os.oid289 = {};
    vvv_tmp4 = ((uniforms_src, $__.os.oid234)[u, 'metalness'], $__.os.oid232);
    'value' in vvv_tmp4;
    p = 'value';
    parameter_src = ((((uniforms_src, $__.os.oid234)[u, 'metalness'], $__.os.oid232), $__.os.oid232)[p, 'value'], 0);
    (((((parameter_src, parameter_src), parameter_src), parameter_src), parameter_src), parameter_src), parameter_src;
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid286)[u, 'metalness'], $__.os.oid289), $__.os.oid289)[p, 'value'] = parameter_src;
    'envMapIntensity' in vvv_tmp0;
    u = 'envMapIntensity';
    (uniforms_dst, $__.os.oid286)[u, 'envMapIntensity'] = $__.os.oid290 = {};
    vvv_tmp5 = ((uniforms_src, $__.os.oid234)[u, 'envMapIntensity'], $__.os.oid233);
    'value' in vvv_tmp5;
    p = 'value';
    parameter_src = ((((uniforms_src, $__.os.oid234)[u, 'envMapIntensity'], $__.os.oid233), $__.os.oid233)[p, 'value'], 1);
    ((((((parameter_src, TAJS_restrictToType(parameter_src.isColor, 'undefined')), (parameter_src, TAJS_restrictToType(parameter_src.isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isTexture, 'undefined'));
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid286)[u, 'envMapIntensity'], $__.os.oid290), $__.os.oid290)[p, 'value'] = parameter_src;
    return uniforms_dst;
case 32:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 32);
    uniforms_dst = $__.os.oid293 = {};
    vvv_tmp0 = uniforms_src;
    'diffuse' in vvv_tmp0;
    u = 'diffuse';
    (uniforms_dst, $__.os.oid293)[u, 'diffuse'] = $__.os.oid294 = {};
    vvv_tmp1 = ((uniforms_src, $__.os.oid109)[u, 'diffuse'], $__.os.oid103);
    'value' in vvv_tmp1;
    p = 'value';
    parameter_src = TAJS_restrictToType((((uniforms_src, $__.os.oid109)[u, 'diffuse'], $__.os.oid103), $__.os.oid103)[p, 'value'], 'object');
    parameter_src, (parameter_src.isColor, true);
    (((uniforms_dst, $__.os.oid293)[u, 'diffuse'], $__.os.oid294), $__.os.oid294)[p, 'value'] = (vvv_tmp2 = parameter_src, 'clone', $__.fs.J$__v494107025_821_611.call(vvv_tmp2, 12, true, $__.uid));
    'opacity' in vvv_tmp0;
    u = 'opacity';
    (uniforms_dst, $__.os.oid293)[u, 'opacity'] = $__.os.oid295 = {};
    vvv_tmp3 = ((uniforms_src, $__.os.oid109)[u, 'opacity'], $__.os.oid104);
    'value' in vvv_tmp3;
    p = 'value';
    parameter_src = ((((uniforms_src, $__.os.oid109)[u, 'opacity'], $__.os.oid104), $__.os.oid104)[p, 'value'], 1);
    ((((((parameter_src, TAJS_restrictToType(parameter_src.isColor, 'undefined')), (parameter_src, TAJS_restrictToType(parameter_src.isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isTexture, 'undefined'));
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid293)[u, 'opacity'], $__.os.oid295), $__.os.oid295)[p, 'value'] = parameter_src;
    'size' in vvv_tmp0;
    u = 'size';
    (uniforms_dst, $__.os.oid293)[u, 'size'] = $__.os.oid296 = {};
    vvv_tmp4 = ((uniforms_src, $__.os.oid109)[u, 'size'], $__.os.oid105);
    'value' in vvv_tmp4;
    p = 'value';
    parameter_src = ((((uniforms_src, $__.os.oid109)[u, 'size'], $__.os.oid105), $__.os.oid105)[p, 'value'], 1);
    ((((((parameter_src, TAJS_restrictToType(parameter_src.isColor, 'undefined')), (parameter_src, TAJS_restrictToType(parameter_src.isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isTexture, 'undefined'));
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid293)[u, 'size'], $__.os.oid296), $__.os.oid296)[p, 'value'] = parameter_src;
    'scale' in vvv_tmp0;
    u = 'scale';
    (uniforms_dst, $__.os.oid293)[u, 'scale'] = $__.os.oid297 = {};
    vvv_tmp5 = ((uniforms_src, $__.os.oid109)[u, 'scale'], $__.os.oid106);
    'value' in vvv_tmp5;
    p = 'value';
    parameter_src = ((((uniforms_src, $__.os.oid109)[u, 'scale'], $__.os.oid106), $__.os.oid106)[p, 'value'], 1);
    ((((((parameter_src, TAJS_restrictToType(parameter_src.isColor, 'undefined')), (parameter_src, TAJS_restrictToType(parameter_src.isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isTexture, 'undefined'));
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid293)[u, 'scale'], $__.os.oid297), $__.os.oid297)[p, 'value'] = parameter_src;
    'map' in vvv_tmp0;
    u = 'map';
    (uniforms_dst, $__.os.oid293)[u, 'map'] = $__.os.oid298 = {};
    vvv_tmp6 = ((uniforms_src, $__.os.oid109)[u, 'map'], $__.os.oid107);
    'value' in vvv_tmp6;
    p = 'value';
    parameter_src = ((((uniforms_src, $__.os.oid109)[u, 'map'], $__.os.oid107), $__.os.oid107)[p, 'value'], null);
    (((((parameter_src, parameter_src), parameter_src), parameter_src), parameter_src), parameter_src), parameter_src;
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid293)[u, 'map'], $__.os.oid298), $__.os.oid298)[p, 'value'] = parameter_src;
    'offsetRepeat' in vvv_tmp0;
    u = 'offsetRepeat';
    (uniforms_dst, $__.os.oid293)[u, 'offsetRepeat'] = $__.os.oid299 = {};
    vvv_tmp7 = ((uniforms_src, $__.os.oid109)[u, 'offsetRepeat'], $__.os.oid108);
    'value' in vvv_tmp7;
    p = 'value';
    parameter_src = TAJS_restrictToType((((uniforms_src, $__.os.oid109)[u, 'offsetRepeat'], $__.os.oid108), $__.os.oid108)[p, 'value'], 'object');
    (((parameter_src, TAJS_restrictToType(parameter_src.isColor, 'undefined')), (parameter_src, TAJS_restrictToType(parameter_src.isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector3, 'undefined'))), (parameter_src, (parameter_src.isVector4, true));
    (((uniforms_dst, $__.os.oid293)[u, 'offsetRepeat'], $__.os.oid299), $__.os.oid299)[p, 'value'] = (vvv_tmp8 = parameter_src, 'clone', $__.fs.J$__v494107025_623_551.call(vvv_tmp8, 4, true, $__.uid));
    return uniforms_dst;
case 33:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 33);
    uniforms_dst = $__.os.oid300 = {};
    vvv_tmp0 = uniforms_src;
    'fogDensity' in vvv_tmp0;
    u = 'fogDensity';
    (uniforms_dst, $__.os.oid300)[u, 'fogDensity'] = $__.os.oid301 = {};
    vvv_tmp1 = ((uniforms_src, $__.os.oid58)[u, 'fogDensity'], $__.os.oid54);
    'value' in vvv_tmp1;
    p = 'value';
    parameter_src = ((((uniforms_src, $__.os.oid58)[u, 'fogDensity'], $__.os.oid54), $__.os.oid54)[p, 'value'], 0.00025);
    ((((((parameter_src, TAJS_restrictToType(parameter_src.isColor, 'undefined')), (parameter_src, TAJS_restrictToType(parameter_src.isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isTexture, 'undefined'));
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid300)[u, 'fogDensity'], $__.os.oid301), $__.os.oid301)[p, 'value'] = parameter_src;
    'fogNear' in vvv_tmp0;
    u = 'fogNear';
    (uniforms_dst, $__.os.oid300)[u, 'fogNear'] = $__.os.oid302 = {};
    vvv_tmp2 = ((uniforms_src, $__.os.oid58)[u, 'fogNear'], $__.os.oid55);
    'value' in vvv_tmp2;
    p = 'value';
    parameter_src = ((((uniforms_src, $__.os.oid58)[u, 'fogNear'], $__.os.oid55), $__.os.oid55)[p, 'value'], 1);
    ((((((parameter_src, TAJS_restrictToType(parameter_src.isColor, 'undefined')), (parameter_src, TAJS_restrictToType(parameter_src.isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isTexture, 'undefined'));
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid300)[u, 'fogNear'], $__.os.oid302), $__.os.oid302)[p, 'value'] = parameter_src;
    'fogFar' in vvv_tmp0;
    u = 'fogFar';
    (uniforms_dst, $__.os.oid300)[u, 'fogFar'] = $__.os.oid303 = {};
    vvv_tmp3 = ((uniforms_src, $__.os.oid58)[u, 'fogFar'], $__.os.oid56);
    'value' in vvv_tmp3;
    p = 'value';
    parameter_src = ((((uniforms_src, $__.os.oid58)[u, 'fogFar'], $__.os.oid56), $__.os.oid56)[p, 'value'], 2000);
    ((((((parameter_src, TAJS_restrictToType(parameter_src.isColor, 'undefined')), (parameter_src, TAJS_restrictToType(parameter_src.isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isTexture, 'undefined'));
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid300)[u, 'fogFar'], $__.os.oid303), $__.os.oid303)[p, 'value'] = parameter_src;
    'fogColor' in vvv_tmp0;
    u = 'fogColor';
    (uniforms_dst, $__.os.oid300)[u, 'fogColor'] = $__.os.oid304 = {};
    vvv_tmp4 = ((uniforms_src, $__.os.oid58)[u, 'fogColor'], $__.os.oid57);
    'value' in vvv_tmp4;
    p = 'value';
    parameter_src = TAJS_restrictToType((((uniforms_src, $__.os.oid58)[u, 'fogColor'], $__.os.oid57), $__.os.oid57)[p, 'value'], 'object');
    parameter_src, (parameter_src.isColor, true);
    (((uniforms_dst, $__.os.oid300)[u, 'fogColor'], $__.os.oid304), $__.os.oid304)[p, 'value'] = (vvv_tmp5 = parameter_src, 'clone', $__.fs.J$__v494107025_821_611.call(vvv_tmp5, 13, true, $__.uid));
    return uniforms_dst;
case 34:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 34);
    uniforms_dst = $__.os.oid311 = {};
    vvv_tmp0 = uniforms_src;
    'diffuse' in vvv_tmp0;
    u = 'diffuse';
    (uniforms_dst, $__.os.oid311)[u, 'diffuse'] = $__.os.oid312 = {};
    vvv_tmp1 = ((uniforms_src, $__.os.oid31)[u, 'diffuse'], $__.os.oid21);
    'value' in vvv_tmp1;
    p = 'value';
    parameter_src = TAJS_restrictToType((((uniforms_src, $__.os.oid31)[u, 'diffuse'], $__.os.oid21), $__.os.oid21)[p, 'value'], 'object');
    parameter_src, (parameter_src.isColor, true);
    (((uniforms_dst, $__.os.oid311)[u, 'diffuse'], $__.os.oid312), $__.os.oid312)[p, 'value'] = (vvv_tmp2 = parameter_src, 'clone', $__.fs.J$__v494107025_821_611.call(vvv_tmp2, 14, true, $__.uid));
    'opacity' in vvv_tmp0;
    u = 'opacity';
    (uniforms_dst, $__.os.oid311)[u, 'opacity'] = $__.os.oid313 = {};
    vvv_tmp3 = ((uniforms_src, $__.os.oid31)[u, 'opacity'], $__.os.oid22);
    'value' in vvv_tmp3;
    p = 'value';
    parameter_src = ((((uniforms_src, $__.os.oid31)[u, 'opacity'], $__.os.oid22), $__.os.oid22)[p, 'value'], 1);
    ((((((parameter_src, TAJS_restrictToType(parameter_src.isColor, 'undefined')), (parameter_src, TAJS_restrictToType(parameter_src.isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isTexture, 'undefined'));
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid311)[u, 'opacity'], $__.os.oid313), $__.os.oid313)[p, 'value'] = parameter_src;
    'map' in vvv_tmp0;
    u = 'map';
    (uniforms_dst, $__.os.oid311)[u, 'map'] = $__.os.oid314 = {};
    vvv_tmp4 = ((uniforms_src, $__.os.oid31)[u, 'map'], $__.os.oid23);
    'value' in vvv_tmp4;
    p = 'value';
    parameter_src = ((((uniforms_src, $__.os.oid31)[u, 'map'], $__.os.oid23), $__.os.oid23)[p, 'value'], null);
    (((((parameter_src, parameter_src), parameter_src), parameter_src), parameter_src), parameter_src), parameter_src;
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid311)[u, 'map'], $__.os.oid314), $__.os.oid314)[p, 'value'] = parameter_src;
    'offsetRepeat' in vvv_tmp0;
    u = 'offsetRepeat';
    (uniforms_dst, $__.os.oid311)[u, 'offsetRepeat'] = $__.os.oid315 = {};
    vvv_tmp5 = ((uniforms_src, $__.os.oid31)[u, 'offsetRepeat'], $__.os.oid24);
    'value' in vvv_tmp5;
    p = 'value';
    parameter_src = TAJS_restrictToType((((uniforms_src, $__.os.oid31)[u, 'offsetRepeat'], $__.os.oid24), $__.os.oid24)[p, 'value'], 'object');
    (((parameter_src, TAJS_restrictToType(parameter_src.isColor, 'undefined')), (parameter_src, TAJS_restrictToType(parameter_src.isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector3, 'undefined'))), (parameter_src, (parameter_src.isVector4, true));
    (((uniforms_dst, $__.os.oid311)[u, 'offsetRepeat'], $__.os.oid315), $__.os.oid315)[p, 'value'] = (vvv_tmp6 = parameter_src, 'clone', $__.fs.J$__v494107025_623_551.call(vvv_tmp6, 5, true, $__.uid));
    'specularMap' in vvv_tmp0;
    u = 'specularMap';
    (uniforms_dst, $__.os.oid311)[u, 'specularMap'] = $__.os.oid316 = {};
    vvv_tmp7 = ((uniforms_src, $__.os.oid31)[u, 'specularMap'], $__.os.oid25);
    'value' in vvv_tmp7;
    p = 'value';
    parameter_src = ((((uniforms_src, $__.os.oid31)[u, 'specularMap'], $__.os.oid25), $__.os.oid25)[p, 'value'], null);
    (((((parameter_src, parameter_src), parameter_src), parameter_src), parameter_src), parameter_src), parameter_src;
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid311)[u, 'specularMap'], $__.os.oid316), $__.os.oid316)[p, 'value'] = parameter_src;
    'alphaMap' in vvv_tmp0;
    u = 'alphaMap';
    (uniforms_dst, $__.os.oid311)[u, 'alphaMap'] = $__.os.oid317 = {};
    vvv_tmp8 = ((uniforms_src, $__.os.oid31)[u, 'alphaMap'], $__.os.oid26);
    'value' in vvv_tmp8;
    p = 'value';
    parameter_src = ((((uniforms_src, $__.os.oid31)[u, 'alphaMap'], $__.os.oid26), $__.os.oid26)[p, 'value'], null);
    (((((parameter_src, parameter_src), parameter_src), parameter_src), parameter_src), parameter_src), parameter_src;
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid311)[u, 'alphaMap'], $__.os.oid317), $__.os.oid317)[p, 'value'] = parameter_src;
    'envMap' in vvv_tmp0;
    u = 'envMap';
    (uniforms_dst, $__.os.oid311)[u, 'envMap'] = $__.os.oid318 = {};
    vvv_tmp9 = ((uniforms_src, $__.os.oid31)[u, 'envMap'], $__.os.oid27);
    'value' in vvv_tmp9;
    p = 'value';
    parameter_src = ((((uniforms_src, $__.os.oid31)[u, 'envMap'], $__.os.oid27), $__.os.oid27)[p, 'value'], null);
    (((((parameter_src, parameter_src), parameter_src), parameter_src), parameter_src), parameter_src), parameter_src;
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid311)[u, 'envMap'], $__.os.oid318), $__.os.oid318)[p, 'value'] = parameter_src;
    'flipEnvMap' in vvv_tmp0;
    u = 'flipEnvMap';
    (uniforms_dst, $__.os.oid311)[u, 'flipEnvMap'] = $__.os.oid319 = {};
    vvv_tmp10 = ((uniforms_src, $__.os.oid31)[u, 'flipEnvMap'], $__.os.oid28);
    'value' in vvv_tmp10;
    p = 'value';
    parameter_src = ((((uniforms_src, $__.os.oid31)[u, 'flipEnvMap'], $__.os.oid28), $__.os.oid28)[p, 'value'], -1);
    ((((((parameter_src, TAJS_restrictToType(parameter_src.isColor, 'undefined')), (parameter_src, TAJS_restrictToType(parameter_src.isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isTexture, 'undefined'));
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid311)[u, 'flipEnvMap'], $__.os.oid319), $__.os.oid319)[p, 'value'] = parameter_src;
    'reflectivity' in vvv_tmp0;
    u = 'reflectivity';
    (uniforms_dst, $__.os.oid311)[u, 'reflectivity'] = $__.os.oid320 = {};
    vvv_tmp11 = ((uniforms_src, $__.os.oid31)[u, 'reflectivity'], $__.os.oid29);
    'value' in vvv_tmp11;
    p = 'value';
    parameter_src = ((((uniforms_src, $__.os.oid31)[u, 'reflectivity'], $__.os.oid29), $__.os.oid29)[p, 'value'], 1);
    ((((((parameter_src, TAJS_restrictToType(parameter_src.isColor, 'undefined')), (parameter_src, TAJS_restrictToType(parameter_src.isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isTexture, 'undefined'));
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid311)[u, 'reflectivity'], $__.os.oid320), $__.os.oid320)[p, 'value'] = parameter_src;
    'refractionRatio' in vvv_tmp0;
    u = 'refractionRatio';
    (uniforms_dst, $__.os.oid311)[u, 'refractionRatio'] = $__.os.oid321 = {};
    vvv_tmp12 = ((uniforms_src, $__.os.oid31)[u, 'refractionRatio'], $__.os.oid30);
    'value' in vvv_tmp12;
    p = 'value';
    parameter_src = ((((uniforms_src, $__.os.oid31)[u, 'refractionRatio'], $__.os.oid30), $__.os.oid30)[p, 'value'], 0.98);
    ((((((parameter_src, TAJS_restrictToType(parameter_src.isColor, 'undefined')), (parameter_src, TAJS_restrictToType(parameter_src.isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isTexture, 'undefined'));
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid311)[u, 'refractionRatio'], $__.os.oid321), $__.os.oid321)[p, 'value'] = parameter_src;
    return uniforms_dst;
case 35:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 35);
    uniforms_dst = $__.os.oid322 = {};
    vvv_tmp0 = uniforms_src;
    'fogDensity' in vvv_tmp0;
    u = 'fogDensity';
    (uniforms_dst, $__.os.oid322)[u, 'fogDensity'] = $__.os.oid323 = {};
    vvv_tmp1 = ((uniforms_src, $__.os.oid58)[u, 'fogDensity'], $__.os.oid54);
    'value' in vvv_tmp1;
    p = 'value';
    parameter_src = ((((uniforms_src, $__.os.oid58)[u, 'fogDensity'], $__.os.oid54), $__.os.oid54)[p, 'value'], 0.00025);
    ((((((parameter_src, TAJS_restrictToType(parameter_src.isColor, 'undefined')), (parameter_src, TAJS_restrictToType(parameter_src.isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isTexture, 'undefined'));
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid322)[u, 'fogDensity'], $__.os.oid323), $__.os.oid323)[p, 'value'] = parameter_src;
    'fogNear' in vvv_tmp0;
    u = 'fogNear';
    (uniforms_dst, $__.os.oid322)[u, 'fogNear'] = $__.os.oid324 = {};
    vvv_tmp2 = ((uniforms_src, $__.os.oid58)[u, 'fogNear'], $__.os.oid55);
    'value' in vvv_tmp2;
    p = 'value';
    parameter_src = ((((uniforms_src, $__.os.oid58)[u, 'fogNear'], $__.os.oid55), $__.os.oid55)[p, 'value'], 1);
    ((((((parameter_src, TAJS_restrictToType(parameter_src.isColor, 'undefined')), (parameter_src, TAJS_restrictToType(parameter_src.isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isTexture, 'undefined'));
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid322)[u, 'fogNear'], $__.os.oid324), $__.os.oid324)[p, 'value'] = parameter_src;
    'fogFar' in vvv_tmp0;
    u = 'fogFar';
    (uniforms_dst, $__.os.oid322)[u, 'fogFar'] = $__.os.oid325 = {};
    vvv_tmp3 = ((uniforms_src, $__.os.oid58)[u, 'fogFar'], $__.os.oid56);
    'value' in vvv_tmp3;
    p = 'value';
    parameter_src = ((((uniforms_src, $__.os.oid58)[u, 'fogFar'], $__.os.oid56), $__.os.oid56)[p, 'value'], 2000);
    ((((((parameter_src, TAJS_restrictToType(parameter_src.isColor, 'undefined')), (parameter_src, TAJS_restrictToType(parameter_src.isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isTexture, 'undefined'));
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid322)[u, 'fogFar'], $__.os.oid325), $__.os.oid325)[p, 'value'] = parameter_src;
    'fogColor' in vvv_tmp0;
    u = 'fogColor';
    (uniforms_dst, $__.os.oid322)[u, 'fogColor'] = $__.os.oid326 = {};
    vvv_tmp4 = ((uniforms_src, $__.os.oid58)[u, 'fogColor'], $__.os.oid57);
    'value' in vvv_tmp4;
    p = 'value';
    parameter_src = TAJS_restrictToType((((uniforms_src, $__.os.oid58)[u, 'fogColor'], $__.os.oid57), $__.os.oid57)[p, 'value'], 'object');
    parameter_src, (parameter_src.isColor, true);
    (((uniforms_dst, $__.os.oid322)[u, 'fogColor'], $__.os.oid326), $__.os.oid326)[p, 'value'] = (vvv_tmp5 = parameter_src, 'clone', $__.fs.J$__v494107025_821_611.call(vvv_tmp5, 15, true, $__.uid));
    return uniforms_dst;
case 36:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 36);
    uniforms_dst = $__.os.oid327 = {};
    vvv_tmp0 = uniforms_src;
    'scale' in vvv_tmp0;
    u = 'scale';
    (uniforms_dst, $__.os.oid327)[u, 'scale'] = $__.os.oid328 = {};
    vvv_tmp1 = ((uniforms_src, $__.os.oid309)[u, 'scale'], $__.os.oid306);
    'value' in vvv_tmp1;
    p = 'value';
    parameter_src = ((((uniforms_src, $__.os.oid309)[u, 'scale'], $__.os.oid306), $__.os.oid306)[p, 'value'], 1);
    ((((((parameter_src, TAJS_restrictToType(parameter_src.isColor, 'undefined')), (parameter_src, TAJS_restrictToType(parameter_src.isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isTexture, 'undefined'));
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid327)[u, 'scale'], $__.os.oid328), $__.os.oid328)[p, 'value'] = parameter_src;
    'dashSize' in vvv_tmp0;
    u = 'dashSize';
    (uniforms_dst, $__.os.oid327)[u, 'dashSize'] = $__.os.oid329 = {};
    vvv_tmp2 = ((uniforms_src, $__.os.oid309)[u, 'dashSize'], $__.os.oid307);
    'value' in vvv_tmp2;
    p = 'value';
    parameter_src = ((((uniforms_src, $__.os.oid309)[u, 'dashSize'], $__.os.oid307), $__.os.oid307)[p, 'value'], 1);
    ((((((parameter_src, TAJS_restrictToType(parameter_src.isColor, 'undefined')), (parameter_src, TAJS_restrictToType(parameter_src.isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isTexture, 'undefined'));
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid327)[u, 'dashSize'], $__.os.oid329), $__.os.oid329)[p, 'value'] = parameter_src;
    'totalSize' in vvv_tmp0;
    u = 'totalSize';
    (uniforms_dst, $__.os.oid327)[u, 'totalSize'] = $__.os.oid330 = {};
    vvv_tmp3 = ((uniforms_src, $__.os.oid309)[u, 'totalSize'], $__.os.oid308);
    'value' in vvv_tmp3;
    p = 'value';
    parameter_src = ((((uniforms_src, $__.os.oid309)[u, 'totalSize'], $__.os.oid308), $__.os.oid308)[p, 'value'], 2);
    ((((((parameter_src, TAJS_restrictToType(parameter_src.isColor, 'undefined')), (parameter_src, TAJS_restrictToType(parameter_src.isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isTexture, 'undefined'));
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid327)[u, 'totalSize'], $__.os.oid330), $__.os.oid330)[p, 'value'] = parameter_src;
    return uniforms_dst;
case 37:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 37);
    uniforms_dst = $__.os.oid333 = {};
    vvv_tmp0 = uniforms_src;
    'diffuse' in vvv_tmp0;
    u = 'diffuse';
    (uniforms_dst, $__.os.oid333)[u, 'diffuse'] = $__.os.oid334 = {};
    vvv_tmp1 = ((uniforms_src, $__.os.oid31)[u, 'diffuse'], $__.os.oid21);
    'value' in vvv_tmp1;
    p = 'value';
    parameter_src = TAJS_restrictToType((((uniforms_src, $__.os.oid31)[u, 'diffuse'], $__.os.oid21), $__.os.oid21)[p, 'value'], 'object');
    parameter_src, (parameter_src.isColor, true);
    (((uniforms_dst, $__.os.oid333)[u, 'diffuse'], $__.os.oid334), $__.os.oid334)[p, 'value'] = (vvv_tmp2 = parameter_src, 'clone', $__.fs.J$__v494107025_821_611.call(vvv_tmp2, 16, true, $__.uid));
    'opacity' in vvv_tmp0;
    u = 'opacity';
    (uniforms_dst, $__.os.oid333)[u, 'opacity'] = $__.os.oid335 = {};
    vvv_tmp3 = ((uniforms_src, $__.os.oid31)[u, 'opacity'], $__.os.oid22);
    'value' in vvv_tmp3;
    p = 'value';
    parameter_src = ((((uniforms_src, $__.os.oid31)[u, 'opacity'], $__.os.oid22), $__.os.oid22)[p, 'value'], 1);
    ((((((parameter_src, TAJS_restrictToType(parameter_src.isColor, 'undefined')), (parameter_src, TAJS_restrictToType(parameter_src.isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isTexture, 'undefined'));
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid333)[u, 'opacity'], $__.os.oid335), $__.os.oid335)[p, 'value'] = parameter_src;
    'map' in vvv_tmp0;
    u = 'map';
    (uniforms_dst, $__.os.oid333)[u, 'map'] = $__.os.oid336 = {};
    vvv_tmp4 = ((uniforms_src, $__.os.oid31)[u, 'map'], $__.os.oid23);
    'value' in vvv_tmp4;
    p = 'value';
    parameter_src = ((((uniforms_src, $__.os.oid31)[u, 'map'], $__.os.oid23), $__.os.oid23)[p, 'value'], null);
    (((((parameter_src, parameter_src), parameter_src), parameter_src), parameter_src), parameter_src), parameter_src;
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid333)[u, 'map'], $__.os.oid336), $__.os.oid336)[p, 'value'] = parameter_src;
    'offsetRepeat' in vvv_tmp0;
    u = 'offsetRepeat';
    (uniforms_dst, $__.os.oid333)[u, 'offsetRepeat'] = $__.os.oid337 = {};
    vvv_tmp5 = ((uniforms_src, $__.os.oid31)[u, 'offsetRepeat'], $__.os.oid24);
    'value' in vvv_tmp5;
    p = 'value';
    parameter_src = TAJS_restrictToType((((uniforms_src, $__.os.oid31)[u, 'offsetRepeat'], $__.os.oid24), $__.os.oid24)[p, 'value'], 'object');
    (((parameter_src, TAJS_restrictToType(parameter_src.isColor, 'undefined')), (parameter_src, TAJS_restrictToType(parameter_src.isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector3, 'undefined'))), (parameter_src, (parameter_src.isVector4, true));
    (((uniforms_dst, $__.os.oid333)[u, 'offsetRepeat'], $__.os.oid337), $__.os.oid337)[p, 'value'] = (vvv_tmp6 = parameter_src, 'clone', $__.fs.J$__v494107025_623_551.call(vvv_tmp6, 6, true, $__.uid));
    'specularMap' in vvv_tmp0;
    u = 'specularMap';
    (uniforms_dst, $__.os.oid333)[u, 'specularMap'] = $__.os.oid338 = {};
    vvv_tmp7 = ((uniforms_src, $__.os.oid31)[u, 'specularMap'], $__.os.oid25);
    'value' in vvv_tmp7;
    p = 'value';
    parameter_src = ((((uniforms_src, $__.os.oid31)[u, 'specularMap'], $__.os.oid25), $__.os.oid25)[p, 'value'], null);
    (((((parameter_src, parameter_src), parameter_src), parameter_src), parameter_src), parameter_src), parameter_src;
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid333)[u, 'specularMap'], $__.os.oid338), $__.os.oid338)[p, 'value'] = parameter_src;
    'alphaMap' in vvv_tmp0;
    u = 'alphaMap';
    (uniforms_dst, $__.os.oid333)[u, 'alphaMap'] = $__.os.oid339 = {};
    vvv_tmp8 = ((uniforms_src, $__.os.oid31)[u, 'alphaMap'], $__.os.oid26);
    'value' in vvv_tmp8;
    p = 'value';
    parameter_src = ((((uniforms_src, $__.os.oid31)[u, 'alphaMap'], $__.os.oid26), $__.os.oid26)[p, 'value'], null);
    (((((parameter_src, parameter_src), parameter_src), parameter_src), parameter_src), parameter_src), parameter_src;
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid333)[u, 'alphaMap'], $__.os.oid339), $__.os.oid339)[p, 'value'] = parameter_src;
    'envMap' in vvv_tmp0;
    u = 'envMap';
    (uniforms_dst, $__.os.oid333)[u, 'envMap'] = $__.os.oid340 = {};
    vvv_tmp9 = ((uniforms_src, $__.os.oid31)[u, 'envMap'], $__.os.oid27);
    'value' in vvv_tmp9;
    p = 'value';
    parameter_src = ((((uniforms_src, $__.os.oid31)[u, 'envMap'], $__.os.oid27), $__.os.oid27)[p, 'value'], null);
    (((((parameter_src, parameter_src), parameter_src), parameter_src), parameter_src), parameter_src), parameter_src;
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid333)[u, 'envMap'], $__.os.oid340), $__.os.oid340)[p, 'value'] = parameter_src;
    'flipEnvMap' in vvv_tmp0;
    u = 'flipEnvMap';
    (uniforms_dst, $__.os.oid333)[u, 'flipEnvMap'] = $__.os.oid341 = {};
    vvv_tmp10 = ((uniforms_src, $__.os.oid31)[u, 'flipEnvMap'], $__.os.oid28);
    'value' in vvv_tmp10;
    p = 'value';
    parameter_src = ((((uniforms_src, $__.os.oid31)[u, 'flipEnvMap'], $__.os.oid28), $__.os.oid28)[p, 'value'], -1);
    ((((((parameter_src, TAJS_restrictToType(parameter_src.isColor, 'undefined')), (parameter_src, TAJS_restrictToType(parameter_src.isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isTexture, 'undefined'));
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid333)[u, 'flipEnvMap'], $__.os.oid341), $__.os.oid341)[p, 'value'] = parameter_src;
    'reflectivity' in vvv_tmp0;
    u = 'reflectivity';
    (uniforms_dst, $__.os.oid333)[u, 'reflectivity'] = $__.os.oid342 = {};
    vvv_tmp11 = ((uniforms_src, $__.os.oid31)[u, 'reflectivity'], $__.os.oid29);
    'value' in vvv_tmp11;
    p = 'value';
    parameter_src = ((((uniforms_src, $__.os.oid31)[u, 'reflectivity'], $__.os.oid29), $__.os.oid29)[p, 'value'], 1);
    ((((((parameter_src, TAJS_restrictToType(parameter_src.isColor, 'undefined')), (parameter_src, TAJS_restrictToType(parameter_src.isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isTexture, 'undefined'));
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid333)[u, 'reflectivity'], $__.os.oid342), $__.os.oid342)[p, 'value'] = parameter_src;
    'refractionRatio' in vvv_tmp0;
    u = 'refractionRatio';
    (uniforms_dst, $__.os.oid333)[u, 'refractionRatio'] = $__.os.oid343 = {};
    vvv_tmp12 = ((uniforms_src, $__.os.oid31)[u, 'refractionRatio'], $__.os.oid30);
    'value' in vvv_tmp12;
    p = 'value';
    parameter_src = ((((uniforms_src, $__.os.oid31)[u, 'refractionRatio'], $__.os.oid30), $__.os.oid30)[p, 'value'], 0.98);
    ((((((parameter_src, TAJS_restrictToType(parameter_src.isColor, 'undefined')), (parameter_src, TAJS_restrictToType(parameter_src.isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isTexture, 'undefined'));
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid333)[u, 'refractionRatio'], $__.os.oid343), $__.os.oid343)[p, 'value'] = parameter_src;
    return uniforms_dst;
case 38:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 38);
    uniforms_dst = $__.os.oid344 = {};
    vvv_tmp0 = uniforms_src;
    'displacementMap' in vvv_tmp0;
    u = 'displacementMap';
    (uniforms_dst, $__.os.oid344)[u, 'displacementMap'] = $__.os.oid345 = {};
    vvv_tmp1 = ((uniforms_src, $__.os.oid49)[u, 'displacementMap'], $__.os.oid46);
    'value' in vvv_tmp1;
    p = 'value';
    parameter_src = ((((uniforms_src, $__.os.oid49)[u, 'displacementMap'], $__.os.oid46), $__.os.oid46)[p, 'value'], null);
    (((((parameter_src, parameter_src), parameter_src), parameter_src), parameter_src), parameter_src), parameter_src;
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid344)[u, 'displacementMap'], $__.os.oid345), $__.os.oid345)[p, 'value'] = parameter_src;
    'displacementScale' in vvv_tmp0;
    u = 'displacementScale';
    (uniforms_dst, $__.os.oid344)[u, 'displacementScale'] = $__.os.oid346 = {};
    vvv_tmp2 = ((uniforms_src, $__.os.oid49)[u, 'displacementScale'], $__.os.oid47);
    'value' in vvv_tmp2;
    p = 'value';
    parameter_src = ((((uniforms_src, $__.os.oid49)[u, 'displacementScale'], $__.os.oid47), $__.os.oid47)[p, 'value'], 1);
    ((((((parameter_src, TAJS_restrictToType(parameter_src.isColor, 'undefined')), (parameter_src, TAJS_restrictToType(parameter_src.isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isTexture, 'undefined'));
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid344)[u, 'displacementScale'], $__.os.oid346), $__.os.oid346)[p, 'value'] = parameter_src;
    'displacementBias' in vvv_tmp0;
    u = 'displacementBias';
    (uniforms_dst, $__.os.oid344)[u, 'displacementBias'] = $__.os.oid347 = {};
    vvv_tmp3 = ((uniforms_src, $__.os.oid49)[u, 'displacementBias'], $__.os.oid48);
    'value' in vvv_tmp3;
    p = 'value';
    parameter_src = ((((uniforms_src, $__.os.oid49)[u, 'displacementBias'], $__.os.oid48), $__.os.oid48)[p, 'value'], 0);
    (((((parameter_src, parameter_src), parameter_src), parameter_src), parameter_src), parameter_src), parameter_src;
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid344)[u, 'displacementBias'], $__.os.oid347), $__.os.oid347)[p, 'value'] = parameter_src;
    return uniforms_dst;
case 39:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 39);
    uniforms_dst = $__.os.oid369 = {};
    vvv_tmp0 = uniforms_src;
    'diffuse' in vvv_tmp0;
    u = 'diffuse';
    (uniforms_dst, $__.os.oid369)[u, 'diffuse'] = $__.os.oid370 = {};
    vvv_tmp1 = ((uniforms_src, $__.os.oid235)[u, 'diffuse'], $__.os.oid237);
    'value' in vvv_tmp1;
    p = 'value';
    parameter_src = TAJS_restrictToType((((uniforms_src, $__.os.oid235)[u, 'diffuse'], $__.os.oid237), $__.os.oid237)[p, 'value'], 'object');
    parameter_src, (parameter_src.isColor, true);
    (((uniforms_dst, $__.os.oid369)[u, 'diffuse'], $__.os.oid370), $__.os.oid370)[p, 'value'] = (vvv_tmp2 = parameter_src, 'clone', $__.fs.J$__v494107025_821_611.call(vvv_tmp2, 17, true, $__.uid));
    'opacity' in vvv_tmp0;
    u = 'opacity';
    (uniforms_dst, $__.os.oid369)[u, 'opacity'] = $__.os.oid371 = {};
    vvv_tmp3 = ((uniforms_src, $__.os.oid235)[u, 'opacity'], $__.os.oid238);
    'value' in vvv_tmp3;
    p = 'value';
    parameter_src = ((((uniforms_src, $__.os.oid235)[u, 'opacity'], $__.os.oid238), $__.os.oid238)[p, 'value'], 1);
    ((((((parameter_src, TAJS_restrictToType(parameter_src.isColor, 'undefined')), (parameter_src, TAJS_restrictToType(parameter_src.isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isTexture, 'undefined'));
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid369)[u, 'opacity'], $__.os.oid371), $__.os.oid371)[p, 'value'] = parameter_src;
    'map' in vvv_tmp0;
    u = 'map';
    (uniforms_dst, $__.os.oid369)[u, 'map'] = $__.os.oid372 = {};
    vvv_tmp4 = ((uniforms_src, $__.os.oid235)[u, 'map'], $__.os.oid239);
    'value' in vvv_tmp4;
    p = 'value';
    parameter_src = ((((uniforms_src, $__.os.oid235)[u, 'map'], $__.os.oid239), $__.os.oid239)[p, 'value'], null);
    (((((parameter_src, parameter_src), parameter_src), parameter_src), parameter_src), parameter_src), parameter_src;
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid369)[u, 'map'], $__.os.oid372), $__.os.oid372)[p, 'value'] = parameter_src;
    'offsetRepeat' in vvv_tmp0;
    u = 'offsetRepeat';
    (uniforms_dst, $__.os.oid369)[u, 'offsetRepeat'] = $__.os.oid373 = {};
    vvv_tmp5 = ((uniforms_src, $__.os.oid235)[u, 'offsetRepeat'], $__.os.oid240);
    'value' in vvv_tmp5;
    p = 'value';
    parameter_src = TAJS_restrictToType((((uniforms_src, $__.os.oid235)[u, 'offsetRepeat'], $__.os.oid240), $__.os.oid240)[p, 'value'], 'object');
    (((parameter_src, TAJS_restrictToType(parameter_src.isColor, 'undefined')), (parameter_src, TAJS_restrictToType(parameter_src.isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector3, 'undefined'))), (parameter_src, (parameter_src.isVector4, true));
    (((uniforms_dst, $__.os.oid369)[u, 'offsetRepeat'], $__.os.oid373), $__.os.oid373)[p, 'value'] = (vvv_tmp6 = parameter_src, 'clone', $__.fs.J$__v494107025_623_551.call(vvv_tmp6, 7, true, $__.uid));
    'specularMap' in vvv_tmp0;
    u = 'specularMap';
    (uniforms_dst, $__.os.oid369)[u, 'specularMap'] = $__.os.oid374 = {};
    vvv_tmp7 = ((uniforms_src, $__.os.oid235)[u, 'specularMap'], $__.os.oid241);
    'value' in vvv_tmp7;
    p = 'value';
    parameter_src = ((((uniforms_src, $__.os.oid235)[u, 'specularMap'], $__.os.oid241), $__.os.oid241)[p, 'value'], null);
    (((((parameter_src, parameter_src), parameter_src), parameter_src), parameter_src), parameter_src), parameter_src;
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid369)[u, 'specularMap'], $__.os.oid374), $__.os.oid374)[p, 'value'] = parameter_src;
    'alphaMap' in vvv_tmp0;
    u = 'alphaMap';
    (uniforms_dst, $__.os.oid369)[u, 'alphaMap'] = $__.os.oid375 = {};
    vvv_tmp8 = ((uniforms_src, $__.os.oid235)[u, 'alphaMap'], $__.os.oid242);
    'value' in vvv_tmp8;
    p = 'value';
    parameter_src = ((((uniforms_src, $__.os.oid235)[u, 'alphaMap'], $__.os.oid242), $__.os.oid242)[p, 'value'], null);
    (((((parameter_src, parameter_src), parameter_src), parameter_src), parameter_src), parameter_src), parameter_src;
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid369)[u, 'alphaMap'], $__.os.oid375), $__.os.oid375)[p, 'value'] = parameter_src;
    'envMap' in vvv_tmp0;
    u = 'envMap';
    (uniforms_dst, $__.os.oid369)[u, 'envMap'] = $__.os.oid376 = {};
    vvv_tmp9 = ((uniforms_src, $__.os.oid235)[u, 'envMap'], $__.os.oid243);
    'value' in vvv_tmp9;
    p = 'value';
    parameter_src = ((((uniforms_src, $__.os.oid235)[u, 'envMap'], $__.os.oid243), $__.os.oid243)[p, 'value'], null);
    (((((parameter_src, parameter_src), parameter_src), parameter_src), parameter_src), parameter_src), parameter_src;
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid369)[u, 'envMap'], $__.os.oid376), $__.os.oid376)[p, 'value'] = parameter_src;
    'flipEnvMap' in vvv_tmp0;
    u = 'flipEnvMap';
    (uniforms_dst, $__.os.oid369)[u, 'flipEnvMap'] = $__.os.oid377 = {};
    vvv_tmp10 = ((uniforms_src, $__.os.oid235)[u, 'flipEnvMap'], $__.os.oid244);
    'value' in vvv_tmp10;
    p = 'value';
    parameter_src = ((((uniforms_src, $__.os.oid235)[u, 'flipEnvMap'], $__.os.oid244), $__.os.oid244)[p, 'value'], -1);
    ((((((parameter_src, TAJS_restrictToType(parameter_src.isColor, 'undefined')), (parameter_src, TAJS_restrictToType(parameter_src.isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isTexture, 'undefined'));
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid369)[u, 'flipEnvMap'], $__.os.oid377), $__.os.oid377)[p, 'value'] = parameter_src;
    'reflectivity' in vvv_tmp0;
    u = 'reflectivity';
    (uniforms_dst, $__.os.oid369)[u, 'reflectivity'] = $__.os.oid378 = {};
    vvv_tmp11 = ((uniforms_src, $__.os.oid235)[u, 'reflectivity'], $__.os.oid245);
    'value' in vvv_tmp11;
    p = 'value';
    parameter_src = ((((uniforms_src, $__.os.oid235)[u, 'reflectivity'], $__.os.oid245), $__.os.oid245)[p, 'value'], 1);
    ((((((parameter_src, TAJS_restrictToType(parameter_src.isColor, 'undefined')), (parameter_src, TAJS_restrictToType(parameter_src.isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isTexture, 'undefined'));
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid369)[u, 'reflectivity'], $__.os.oid378), $__.os.oid378)[p, 'value'] = parameter_src;
    'refractionRatio' in vvv_tmp0;
    u = 'refractionRatio';
    (uniforms_dst, $__.os.oid369)[u, 'refractionRatio'] = $__.os.oid379 = {};
    vvv_tmp12 = ((uniforms_src, $__.os.oid235)[u, 'refractionRatio'], $__.os.oid246);
    'value' in vvv_tmp12;
    p = 'value';
    parameter_src = ((((uniforms_src, $__.os.oid235)[u, 'refractionRatio'], $__.os.oid246), $__.os.oid246)[p, 'value'], 0.98);
    ((((((parameter_src, TAJS_restrictToType(parameter_src.isColor, 'undefined')), (parameter_src, TAJS_restrictToType(parameter_src.isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isTexture, 'undefined'));
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid369)[u, 'refractionRatio'], $__.os.oid379), $__.os.oid379)[p, 'value'] = parameter_src;
    'aoMap' in vvv_tmp0;
    u = 'aoMap';
    (uniforms_dst, $__.os.oid369)[u, 'aoMap'] = $__.os.oid380 = {};
    vvv_tmp13 = ((uniforms_src, $__.os.oid235)[u, 'aoMap'], $__.os.oid248);
    'value' in vvv_tmp13;
    p = 'value';
    parameter_src = ((((uniforms_src, $__.os.oid235)[u, 'aoMap'], $__.os.oid248), $__.os.oid248)[p, 'value'], null);
    (((((parameter_src, parameter_src), parameter_src), parameter_src), parameter_src), parameter_src), parameter_src;
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid369)[u, 'aoMap'], $__.os.oid380), $__.os.oid380)[p, 'value'] = parameter_src;
    'aoMapIntensity' in vvv_tmp0;
    u = 'aoMapIntensity';
    (uniforms_dst, $__.os.oid369)[u, 'aoMapIntensity'] = $__.os.oid381 = {};
    vvv_tmp14 = ((uniforms_src, $__.os.oid235)[u, 'aoMapIntensity'], $__.os.oid249);
    'value' in vvv_tmp14;
    p = 'value';
    parameter_src = ((((uniforms_src, $__.os.oid235)[u, 'aoMapIntensity'], $__.os.oid249), $__.os.oid249)[p, 'value'], 1);
    ((((((parameter_src, TAJS_restrictToType(parameter_src.isColor, 'undefined')), (parameter_src, TAJS_restrictToType(parameter_src.isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isTexture, 'undefined'));
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid369)[u, 'aoMapIntensity'], $__.os.oid381), $__.os.oid381)[p, 'value'] = parameter_src;
    'lightMap' in vvv_tmp0;
    u = 'lightMap';
    (uniforms_dst, $__.os.oid369)[u, 'lightMap'] = $__.os.oid382 = {};
    vvv_tmp15 = ((uniforms_src, $__.os.oid235)[u, 'lightMap'], $__.os.oid251);
    'value' in vvv_tmp15;
    p = 'value';
    parameter_src = ((((uniforms_src, $__.os.oid235)[u, 'lightMap'], $__.os.oid251), $__.os.oid251)[p, 'value'], null);
    (((((parameter_src, parameter_src), parameter_src), parameter_src), parameter_src), parameter_src), parameter_src;
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid369)[u, 'lightMap'], $__.os.oid382), $__.os.oid382)[p, 'value'] = parameter_src;
    'lightMapIntensity' in vvv_tmp0;
    u = 'lightMapIntensity';
    (uniforms_dst, $__.os.oid369)[u, 'lightMapIntensity'] = $__.os.oid383 = {};
    vvv_tmp16 = ((uniforms_src, $__.os.oid235)[u, 'lightMapIntensity'], $__.os.oid252);
    'value' in vvv_tmp16;
    p = 'value';
    parameter_src = ((((uniforms_src, $__.os.oid235)[u, 'lightMapIntensity'], $__.os.oid252), $__.os.oid252)[p, 'value'], 1);
    ((((((parameter_src, TAJS_restrictToType(parameter_src.isColor, 'undefined')), (parameter_src, TAJS_restrictToType(parameter_src.isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isTexture, 'undefined'));
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid369)[u, 'lightMapIntensity'], $__.os.oid383), $__.os.oid383)[p, 'value'] = parameter_src;
    'emissiveMap' in vvv_tmp0;
    u = 'emissiveMap';
    (uniforms_dst, $__.os.oid369)[u, 'emissiveMap'] = $__.os.oid384 = {};
    vvv_tmp17 = ((uniforms_src, $__.os.oid235)[u, 'emissiveMap'], $__.os.oid254);
    'value' in vvv_tmp17;
    p = 'value';
    parameter_src = ((((uniforms_src, $__.os.oid235)[u, 'emissiveMap'], $__.os.oid254), $__.os.oid254)[p, 'value'], null);
    (((((parameter_src, parameter_src), parameter_src), parameter_src), parameter_src), parameter_src), parameter_src;
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid369)[u, 'emissiveMap'], $__.os.oid384), $__.os.oid384)[p, 'value'] = parameter_src;
    'bumpMap' in vvv_tmp0;
    u = 'bumpMap';
    (uniforms_dst, $__.os.oid369)[u, 'bumpMap'] = $__.os.oid385 = {};
    vvv_tmp18 = ((uniforms_src, $__.os.oid235)[u, 'bumpMap'], $__.os.oid256);
    'value' in vvv_tmp18;
    p = 'value';
    parameter_src = ((((uniforms_src, $__.os.oid235)[u, 'bumpMap'], $__.os.oid256), $__.os.oid256)[p, 'value'], null);
    (((((parameter_src, parameter_src), parameter_src), parameter_src), parameter_src), parameter_src), parameter_src;
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid369)[u, 'bumpMap'], $__.os.oid385), $__.os.oid385)[p, 'value'] = parameter_src;
    'bumpScale' in vvv_tmp0;
    u = 'bumpScale';
    (uniforms_dst, $__.os.oid369)[u, 'bumpScale'] = $__.os.oid386 = {};
    vvv_tmp19 = ((uniforms_src, $__.os.oid235)[u, 'bumpScale'], $__.os.oid257);
    'value' in vvv_tmp19;
    p = 'value';
    parameter_src = ((((uniforms_src, $__.os.oid235)[u, 'bumpScale'], $__.os.oid257), $__.os.oid257)[p, 'value'], 1);
    ((((((parameter_src, TAJS_restrictToType(parameter_src.isColor, 'undefined')), (parameter_src, TAJS_restrictToType(parameter_src.isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isTexture, 'undefined'));
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid369)[u, 'bumpScale'], $__.os.oid386), $__.os.oid386)[p, 'value'] = parameter_src;
    'normalMap' in vvv_tmp0;
    u = 'normalMap';
    (uniforms_dst, $__.os.oid369)[u, 'normalMap'] = $__.os.oid387 = {};
    vvv_tmp20 = ((uniforms_src, $__.os.oid235)[u, 'normalMap'], $__.os.oid259);
    'value' in vvv_tmp20;
    p = 'value';
    parameter_src = ((((uniforms_src, $__.os.oid235)[u, 'normalMap'], $__.os.oid259), $__.os.oid259)[p, 'value'], null);
    (((((parameter_src, parameter_src), parameter_src), parameter_src), parameter_src), parameter_src), parameter_src;
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid369)[u, 'normalMap'], $__.os.oid387), $__.os.oid387)[p, 'value'] = parameter_src;
    'normalScale' in vvv_tmp0;
    u = 'normalScale';
    (uniforms_dst, $__.os.oid369)[u, 'normalScale'] = $__.os.oid388 = {};
    vvv_tmp21 = ((uniforms_src, $__.os.oid235)[u, 'normalScale'], $__.os.oid260);
    'value' in vvv_tmp21;
    p = 'value';
    parameter_src = TAJS_restrictToType((((uniforms_src, $__.os.oid235)[u, 'normalScale'], $__.os.oid260), $__.os.oid260)[p, 'value'], 'object');
    (parameter_src, TAJS_restrictToType(parameter_src.isColor, 'undefined')), (parameter_src, (parameter_src.isVector2, true));
    (((uniforms_dst, $__.os.oid369)[u, 'normalScale'], $__.os.oid388), $__.os.oid388)[p, 'value'] = (vvv_tmp22 = parameter_src, 'clone', $__.fs.J$__v494107025_85_307.call(vvv_tmp22, 2, true, $__.uid));
    'displacementMap' in vvv_tmp0;
    u = 'displacementMap';
    (uniforms_dst, $__.os.oid369)[u, 'displacementMap'] = $__.os.oid389 = {};
    vvv_tmp23 = ((uniforms_src, $__.os.oid235)[u, 'displacementMap'], $__.os.oid262);
    'value' in vvv_tmp23;
    p = 'value';
    parameter_src = ((((uniforms_src, $__.os.oid235)[u, 'displacementMap'], $__.os.oid262), $__.os.oid262)[p, 'value'], null);
    (((((parameter_src, parameter_src), parameter_src), parameter_src), parameter_src), parameter_src), parameter_src;
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid369)[u, 'displacementMap'], $__.os.oid389), $__.os.oid389)[p, 'value'] = parameter_src;
    'displacementScale' in vvv_tmp0;
    u = 'displacementScale';
    (uniforms_dst, $__.os.oid369)[u, 'displacementScale'] = $__.os.oid390 = {};
    vvv_tmp24 = ((uniforms_src, $__.os.oid235)[u, 'displacementScale'], $__.os.oid263);
    'value' in vvv_tmp24;
    p = 'value';
    parameter_src = ((((uniforms_src, $__.os.oid235)[u, 'displacementScale'], $__.os.oid263), $__.os.oid263)[p, 'value'], 1);
    ((((((parameter_src, TAJS_restrictToType(parameter_src.isColor, 'undefined')), (parameter_src, TAJS_restrictToType(parameter_src.isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isTexture, 'undefined'));
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid369)[u, 'displacementScale'], $__.os.oid390), $__.os.oid390)[p, 'value'] = parameter_src;
    'displacementBias' in vvv_tmp0;
    u = 'displacementBias';
    (uniforms_dst, $__.os.oid369)[u, 'displacementBias'] = $__.os.oid391 = {};
    vvv_tmp25 = ((uniforms_src, $__.os.oid235)[u, 'displacementBias'], $__.os.oid264);
    'value' in vvv_tmp25;
    p = 'value';
    parameter_src = ((((uniforms_src, $__.os.oid235)[u, 'displacementBias'], $__.os.oid264), $__.os.oid264)[p, 'value'], 0);
    (((((parameter_src, parameter_src), parameter_src), parameter_src), parameter_src), parameter_src), parameter_src;
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid369)[u, 'displacementBias'], $__.os.oid391), $__.os.oid391)[p, 'value'] = parameter_src;
    'roughnessMap' in vvv_tmp0;
    u = 'roughnessMap';
    (uniforms_dst, $__.os.oid369)[u, 'roughnessMap'] = $__.os.oid392 = {};
    vvv_tmp26 = ((uniforms_src, $__.os.oid235)[u, 'roughnessMap'], $__.os.oid266);
    'value' in vvv_tmp26;
    p = 'value';
    parameter_src = ((((uniforms_src, $__.os.oid235)[u, 'roughnessMap'], $__.os.oid266), $__.os.oid266)[p, 'value'], null);
    (((((parameter_src, parameter_src), parameter_src), parameter_src), parameter_src), parameter_src), parameter_src;
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid369)[u, 'roughnessMap'], $__.os.oid392), $__.os.oid392)[p, 'value'] = parameter_src;
    'metalnessMap' in vvv_tmp0;
    u = 'metalnessMap';
    (uniforms_dst, $__.os.oid369)[u, 'metalnessMap'] = $__.os.oid393 = {};
    vvv_tmp27 = ((uniforms_src, $__.os.oid235)[u, 'metalnessMap'], $__.os.oid268);
    'value' in vvv_tmp27;
    p = 'value';
    parameter_src = ((((uniforms_src, $__.os.oid235)[u, 'metalnessMap'], $__.os.oid268), $__.os.oid268)[p, 'value'], null);
    (((((parameter_src, parameter_src), parameter_src), parameter_src), parameter_src), parameter_src), parameter_src;
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid369)[u, 'metalnessMap'], $__.os.oid393), $__.os.oid393)[p, 'value'] = parameter_src;
    'fogDensity' in vvv_tmp0;
    u = 'fogDensity';
    (uniforms_dst, $__.os.oid369)[u, 'fogDensity'] = $__.os.oid394 = {};
    vvv_tmp28 = ((uniforms_src, $__.os.oid235)[u, 'fogDensity'], $__.os.oid270);
    'value' in vvv_tmp28;
    p = 'value';
    parameter_src = ((((uniforms_src, $__.os.oid235)[u, 'fogDensity'], $__.os.oid270), $__.os.oid270)[p, 'value'], 0.00025);
    ((((((parameter_src, TAJS_restrictToType(parameter_src.isColor, 'undefined')), (parameter_src, TAJS_restrictToType(parameter_src.isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isTexture, 'undefined'));
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid369)[u, 'fogDensity'], $__.os.oid394), $__.os.oid394)[p, 'value'] = parameter_src;
    'fogNear' in vvv_tmp0;
    u = 'fogNear';
    (uniforms_dst, $__.os.oid369)[u, 'fogNear'] = $__.os.oid395 = {};
    vvv_tmp29 = ((uniforms_src, $__.os.oid235)[u, 'fogNear'], $__.os.oid271);
    'value' in vvv_tmp29;
    p = 'value';
    parameter_src = ((((uniforms_src, $__.os.oid235)[u, 'fogNear'], $__.os.oid271), $__.os.oid271)[p, 'value'], 1);
    ((((((parameter_src, TAJS_restrictToType(parameter_src.isColor, 'undefined')), (parameter_src, TAJS_restrictToType(parameter_src.isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isTexture, 'undefined'));
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid369)[u, 'fogNear'], $__.os.oid395), $__.os.oid395)[p, 'value'] = parameter_src;
    'fogFar' in vvv_tmp0;
    u = 'fogFar';
    (uniforms_dst, $__.os.oid369)[u, 'fogFar'] = $__.os.oid396 = {};
    vvv_tmp30 = ((uniforms_src, $__.os.oid235)[u, 'fogFar'], $__.os.oid272);
    'value' in vvv_tmp30;
    p = 'value';
    parameter_src = ((((uniforms_src, $__.os.oid235)[u, 'fogFar'], $__.os.oid272), $__.os.oid272)[p, 'value'], 2000);
    ((((((parameter_src, TAJS_restrictToType(parameter_src.isColor, 'undefined')), (parameter_src, TAJS_restrictToType(parameter_src.isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isTexture, 'undefined'));
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid369)[u, 'fogFar'], $__.os.oid396), $__.os.oid396)[p, 'value'] = parameter_src;
    'fogColor' in vvv_tmp0;
    u = 'fogColor';
    (uniforms_dst, $__.os.oid369)[u, 'fogColor'] = $__.os.oid397 = {};
    vvv_tmp31 = ((uniforms_src, $__.os.oid235)[u, 'fogColor'], $__.os.oid273);
    'value' in vvv_tmp31;
    p = 'value';
    parameter_src = TAJS_restrictToType((((uniforms_src, $__.os.oid235)[u, 'fogColor'], $__.os.oid273), $__.os.oid273)[p, 'value'], 'object');
    parameter_src, (parameter_src.isColor, true);
    (((uniforms_dst, $__.os.oid369)[u, 'fogColor'], $__.os.oid397), $__.os.oid397)[p, 'value'] = (vvv_tmp32 = parameter_src, 'clone', $__.fs.J$__v494107025_821_611.call(vvv_tmp32, 18, true, $__.uid));
    'ambientLightColor' in vvv_tmp0;
    u = 'ambientLightColor';
    (uniforms_dst, $__.os.oid369)[u, 'ambientLightColor'] = $__.os.oid398 = {};
    vvv_tmp33 = ((uniforms_src, $__.os.oid235)[u, 'ambientLightColor'], $__.os.oid275);
    'value' in vvv_tmp33;
    p = 'value';
    parameter_src = TAJS_restrictToType((((uniforms_src, $__.os.oid235)[u, 'ambientLightColor'], $__.os.oid275), $__.os.oid275)[p, 'value'], 'object');
    ((((((parameter_src, TAJS_restrictToType(parameter_src.isColor, 'undefined')), (parameter_src, TAJS_restrictToType(parameter_src.isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isTexture, 'undefined'));
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid369)[u, 'ambientLightColor'], $__.os.oid398), $__.os.oid398)[p, 'value'] = function $__lt35(res) {
        res.length = 0;
        if (res.length != 0)
            TAJS_dumpValue('Possible loss of precision');
        return res;
        ;
        TAJS_makeContextSensitive($__lt35, -2);
    }(parameter_src['slice']());
    'directionalLights' in vvv_tmp0;
    u = 'directionalLights';
    (uniforms_dst, $__.os.oid369)[u, 'directionalLights'] = $__.os.oid399 = {};
    vvv_tmp34 = ((uniforms_src, $__.os.oid235)[u, 'directionalLights'], $__.os.oid276);
    'value' in vvv_tmp34;
    p = 'value';
    parameter_src = TAJS_restrictToType((((uniforms_src, $__.os.oid235)[u, 'directionalLights'], $__.os.oid276), $__.os.oid276)[p, 'value'], 'object');
    ((((((parameter_src, TAJS_restrictToType(parameter_src.isColor, 'undefined')), (parameter_src, TAJS_restrictToType(parameter_src.isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isTexture, 'undefined'));
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid369)[u, 'directionalLights'], $__.os.oid399), $__.os.oid399)[p, 'value'] = function $__lt36(res) {
        res.length = 0;
        if (res.length != 0)
            TAJS_dumpValue('Possible loss of precision');
        return res;
        ;
        TAJS_makeContextSensitive($__lt36, -2);
    }(parameter_src['slice']());
    'properties' in vvv_tmp34;
    p = 'properties';
    parameter_src = ((((uniforms_src, $__.os.oid235)[u, 'directionalLights'], $__.os.oid276), $__.os.oid276)[p, 'properties'], $__.os.oid66);
    ((((((parameter_src, TAJS_restrictToType((parameter_src, $__.os.oid66).isColor, 'undefined')), (parameter_src, TAJS_restrictToType((parameter_src, $__.os.oid66).isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType((parameter_src, $__.os.oid66).isVector3, 'undefined'))), (parameter_src, TAJS_restrictToType((parameter_src, $__.os.oid66).isVector4, 'undefined'))), (parameter_src, TAJS_restrictToType((parameter_src, $__.os.oid66).isMatrix3, 'undefined'))), (parameter_src, TAJS_restrictToType((parameter_src, $__.os.oid66).isMatrix4, 'undefined'))), (parameter_src, TAJS_restrictToType((parameter_src, $__.os.oid66).isTexture, 'undefined'));
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid369)[u, 'directionalLights'], $__.os.oid399), $__.os.oid399)[p, 'properties'] = parameter_src;
    'directionalShadowMap' in vvv_tmp0;
    u = 'directionalShadowMap';
    (uniforms_dst, $__.os.oid369)[u, 'directionalShadowMap'] = $__.os.oid400 = {};
    vvv_tmp35 = ((uniforms_src, $__.os.oid235)[u, 'directionalShadowMap'], $__.os.oid277);
    'value' in vvv_tmp35;
    p = 'value';
    parameter_src = TAJS_restrictToType((((uniforms_src, $__.os.oid235)[u, 'directionalShadowMap'], $__.os.oid277), $__.os.oid277)[p, 'value'], 'object');
    ((((((parameter_src, TAJS_restrictToType(parameter_src.isColor, 'undefined')), (parameter_src, TAJS_restrictToType(parameter_src.isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isTexture, 'undefined'));
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid369)[u, 'directionalShadowMap'], $__.os.oid400), $__.os.oid400)[p, 'value'] = function $__lt37(res) {
        res.length = 0;
        if (res.length != 0)
            TAJS_dumpValue('Possible loss of precision');
        return res;
        ;
        TAJS_makeContextSensitive($__lt37, -2);
    }(parameter_src['slice']());
    'directionalShadowMatrix' in vvv_tmp0;
    u = 'directionalShadowMatrix';
    (uniforms_dst, $__.os.oid369)[u, 'directionalShadowMatrix'] = $__.os.oid401 = {};
    vvv_tmp36 = ((uniforms_src, $__.os.oid235)[u, 'directionalShadowMatrix'], $__.os.oid278);
    'value' in vvv_tmp36;
    p = 'value';
    parameter_src = TAJS_restrictToType((((uniforms_src, $__.os.oid235)[u, 'directionalShadowMatrix'], $__.os.oid278), $__.os.oid278)[p, 'value'], 'object');
    ((((((parameter_src, TAJS_restrictToType(parameter_src.isColor, 'undefined')), (parameter_src, TAJS_restrictToType(parameter_src.isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isTexture, 'undefined'));
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid369)[u, 'directionalShadowMatrix'], $__.os.oid401), $__.os.oid401)[p, 'value'] = function $__lt38(res) {
        res.length = 0;
        if (res.length != 0)
            TAJS_dumpValue('Possible loss of precision');
        return res;
        ;
        TAJS_makeContextSensitive($__lt38, -2);
    }(parameter_src['slice']());
    'spotLights' in vvv_tmp0;
    u = 'spotLights';
    (uniforms_dst, $__.os.oid369)[u, 'spotLights'] = $__.os.oid402 = {};
    vvv_tmp37 = ((uniforms_src, $__.os.oid235)[u, 'spotLights'], $__.os.oid279);
    'value' in vvv_tmp37;
    p = 'value';
    parameter_src = TAJS_restrictToType((((uniforms_src, $__.os.oid235)[u, 'spotLights'], $__.os.oid279), $__.os.oid279)[p, 'value'], 'object');
    ((((((parameter_src, TAJS_restrictToType(parameter_src.isColor, 'undefined')), (parameter_src, TAJS_restrictToType(parameter_src.isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isTexture, 'undefined'));
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid369)[u, 'spotLights'], $__.os.oid402), $__.os.oid402)[p, 'value'] = function $__lt39(res) {
        res.length = 0;
        if (res.length != 0)
            TAJS_dumpValue('Possible loss of precision');
        return res;
        ;
        TAJS_makeContextSensitive($__lt39, -2);
    }(parameter_src['slice']());
    'properties' in vvv_tmp37;
    p = 'properties';
    parameter_src = ((((uniforms_src, $__.os.oid235)[u, 'spotLights'], $__.os.oid279), $__.os.oid279)[p, 'properties'], $__.os.oid81);
    ((((((parameter_src, TAJS_restrictToType((parameter_src, $__.os.oid81).isColor, 'undefined')), (parameter_src, TAJS_restrictToType((parameter_src, $__.os.oid81).isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType((parameter_src, $__.os.oid81).isVector3, 'undefined'))), (parameter_src, TAJS_restrictToType((parameter_src, $__.os.oid81).isVector4, 'undefined'))), (parameter_src, TAJS_restrictToType((parameter_src, $__.os.oid81).isMatrix3, 'undefined'))), (parameter_src, TAJS_restrictToType((parameter_src, $__.os.oid81).isMatrix4, 'undefined'))), (parameter_src, TAJS_restrictToType((parameter_src, $__.os.oid81).isTexture, 'undefined'));
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid369)[u, 'spotLights'], $__.os.oid402), $__.os.oid402)[p, 'properties'] = parameter_src;
    'spotShadowMap' in vvv_tmp0;
    u = 'spotShadowMap';
    (uniforms_dst, $__.os.oid369)[u, 'spotShadowMap'] = $__.os.oid403 = {};
    vvv_tmp38 = ((uniforms_src, $__.os.oid235)[u, 'spotShadowMap'], $__.os.oid280);
    'value' in vvv_tmp38;
    p = 'value';
    parameter_src = TAJS_restrictToType((((uniforms_src, $__.os.oid235)[u, 'spotShadowMap'], $__.os.oid280), $__.os.oid280)[p, 'value'], 'object');
    ((((((parameter_src, TAJS_restrictToType(parameter_src.isColor, 'undefined')), (parameter_src, TAJS_restrictToType(parameter_src.isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isTexture, 'undefined'));
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid369)[u, 'spotShadowMap'], $__.os.oid403), $__.os.oid403)[p, 'value'] = function $__lt40(res) {
        res.length = 0;
        if (res.length != 0)
            TAJS_dumpValue('Possible loss of precision');
        return res;
        ;
        TAJS_makeContextSensitive($__lt40, -2);
    }(parameter_src['slice']());
    'spotShadowMatrix' in vvv_tmp0;
    u = 'spotShadowMatrix';
    (uniforms_dst, $__.os.oid369)[u, 'spotShadowMatrix'] = $__.os.oid404 = {};
    vvv_tmp39 = ((uniforms_src, $__.os.oid235)[u, 'spotShadowMatrix'], $__.os.oid281);
    'value' in vvv_tmp39;
    p = 'value';
    parameter_src = TAJS_restrictToType((((uniforms_src, $__.os.oid235)[u, 'spotShadowMatrix'], $__.os.oid281), $__.os.oid281)[p, 'value'], 'object');
    ((((((parameter_src, TAJS_restrictToType(parameter_src.isColor, 'undefined')), (parameter_src, TAJS_restrictToType(parameter_src.isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isTexture, 'undefined'));
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid369)[u, 'spotShadowMatrix'], $__.os.oid404), $__.os.oid404)[p, 'value'] = function $__lt41(res) {
        res.length = 0;
        if (res.length != 0)
            TAJS_dumpValue('Possible loss of precision');
        return res;
        ;
        TAJS_makeContextSensitive($__lt41, -2);
    }(parameter_src['slice']());
    'pointLights' in vvv_tmp0;
    u = 'pointLights';
    (uniforms_dst, $__.os.oid369)[u, 'pointLights'] = $__.os.oid405 = {};
    vvv_tmp40 = ((uniforms_src, $__.os.oid235)[u, 'pointLights'], $__.os.oid282);
    'value' in vvv_tmp40;
    p = 'value';
    parameter_src = TAJS_restrictToType((((uniforms_src, $__.os.oid235)[u, 'pointLights'], $__.os.oid282), $__.os.oid282)[p, 'value'], 'object');
    ((((((parameter_src, TAJS_restrictToType(parameter_src.isColor, 'undefined')), (parameter_src, TAJS_restrictToType(parameter_src.isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isTexture, 'undefined'));
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid369)[u, 'pointLights'], $__.os.oid405), $__.os.oid405)[p, 'value'] = function $__lt42(res) {
        res.length = 0;
        if (res.length != 0)
            TAJS_dumpValue('Possible loss of precision');
        return res;
        ;
        TAJS_makeContextSensitive($__lt42, -2);
    }(parameter_src['slice']());
    'properties' in vvv_tmp40;
    p = 'properties';
    parameter_src = ((((uniforms_src, $__.os.oid235)[u, 'pointLights'], $__.os.oid282), $__.os.oid282)[p, 'properties'], $__.os.oid93);
    ((((((parameter_src, TAJS_restrictToType((parameter_src, $__.os.oid93).isColor, 'undefined')), (parameter_src, TAJS_restrictToType((parameter_src, $__.os.oid93).isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType((parameter_src, $__.os.oid93).isVector3, 'undefined'))), (parameter_src, TAJS_restrictToType((parameter_src, $__.os.oid93).isVector4, 'undefined'))), (parameter_src, TAJS_restrictToType((parameter_src, $__.os.oid93).isMatrix3, 'undefined'))), (parameter_src, TAJS_restrictToType((parameter_src, $__.os.oid93).isMatrix4, 'undefined'))), (parameter_src, TAJS_restrictToType((parameter_src, $__.os.oid93).isTexture, 'undefined'));
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid369)[u, 'pointLights'], $__.os.oid405), $__.os.oid405)[p, 'properties'] = parameter_src;
    'pointShadowMap' in vvv_tmp0;
    u = 'pointShadowMap';
    (uniforms_dst, $__.os.oid369)[u, 'pointShadowMap'] = $__.os.oid406 = {};
    vvv_tmp41 = ((uniforms_src, $__.os.oid235)[u, 'pointShadowMap'], $__.os.oid283);
    'value' in vvv_tmp41;
    p = 'value';
    parameter_src = TAJS_restrictToType((((uniforms_src, $__.os.oid235)[u, 'pointShadowMap'], $__.os.oid283), $__.os.oid283)[p, 'value'], 'object');
    ((((((parameter_src, TAJS_restrictToType(parameter_src.isColor, 'undefined')), (parameter_src, TAJS_restrictToType(parameter_src.isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isTexture, 'undefined'));
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid369)[u, 'pointShadowMap'], $__.os.oid406), $__.os.oid406)[p, 'value'] = function $__lt43(res) {
        res.length = 0;
        if (res.length != 0)
            TAJS_dumpValue('Possible loss of precision');
        return res;
        ;
        TAJS_makeContextSensitive($__lt43, -2);
    }(parameter_src['slice']());
    'pointShadowMatrix' in vvv_tmp0;
    u = 'pointShadowMatrix';
    (uniforms_dst, $__.os.oid369)[u, 'pointShadowMatrix'] = $__.os.oid407 = {};
    vvv_tmp42 = ((uniforms_src, $__.os.oid235)[u, 'pointShadowMatrix'], $__.os.oid284);
    'value' in vvv_tmp42;
    p = 'value';
    parameter_src = TAJS_restrictToType((((uniforms_src, $__.os.oid235)[u, 'pointShadowMatrix'], $__.os.oid284), $__.os.oid284)[p, 'value'], 'object');
    ((((((parameter_src, TAJS_restrictToType(parameter_src.isColor, 'undefined')), (parameter_src, TAJS_restrictToType(parameter_src.isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isTexture, 'undefined'));
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid369)[u, 'pointShadowMatrix'], $__.os.oid407), $__.os.oid407)[p, 'value'] = function $__lt44(res) {
        res.length = 0;
        if (res.length != 0)
            TAJS_dumpValue('Possible loss of precision');
        return res;
        ;
        TAJS_makeContextSensitive($__lt44, -2);
    }(parameter_src['slice']());
    'hemisphereLights' in vvv_tmp0;
    u = 'hemisphereLights';
    (uniforms_dst, $__.os.oid369)[u, 'hemisphereLights'] = $__.os.oid408 = {};
    vvv_tmp43 = ((uniforms_src, $__.os.oid235)[u, 'hemisphereLights'], $__.os.oid285);
    'value' in vvv_tmp43;
    p = 'value';
    parameter_src = TAJS_restrictToType((((uniforms_src, $__.os.oid235)[u, 'hemisphereLights'], $__.os.oid285), $__.os.oid285)[p, 'value'], 'object');
    ((((((parameter_src, TAJS_restrictToType(parameter_src.isColor, 'undefined')), (parameter_src, TAJS_restrictToType(parameter_src.isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isTexture, 'undefined'));
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid369)[u, 'hemisphereLights'], $__.os.oid408), $__.os.oid408)[p, 'value'] = function $__lt45(res) {
        res.length = 0;
        if (res.length != 0)
            TAJS_dumpValue('Possible loss of precision');
        return res;
        ;
        TAJS_makeContextSensitive($__lt45, -2);
    }(parameter_src['slice']());
    'properties' in vvv_tmp43;
    p = 'properties';
    parameter_src = ((((uniforms_src, $__.os.oid235)[u, 'hemisphereLights'], $__.os.oid285), $__.os.oid285)[p, 'properties'], $__.os.oid100);
    ((((((parameter_src, TAJS_restrictToType((parameter_src, $__.os.oid100).isColor, 'undefined')), (parameter_src, TAJS_restrictToType((parameter_src, $__.os.oid100).isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType((parameter_src, $__.os.oid100).isVector3, 'undefined'))), (parameter_src, TAJS_restrictToType((parameter_src, $__.os.oid100).isVector4, 'undefined'))), (parameter_src, TAJS_restrictToType((parameter_src, $__.os.oid100).isMatrix3, 'undefined'))), (parameter_src, TAJS_restrictToType((parameter_src, $__.os.oid100).isMatrix4, 'undefined'))), (parameter_src, TAJS_restrictToType((parameter_src, $__.os.oid100).isTexture, 'undefined'));
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid369)[u, 'hemisphereLights'], $__.os.oid408), $__.os.oid408)[p, 'properties'] = parameter_src;
    'emissive' in vvv_tmp0;
    u = 'emissive';
    (uniforms_dst, $__.os.oid369)[u, 'emissive'] = $__.os.oid409 = {};
    vvv_tmp44 = ((uniforms_src, $__.os.oid235)[u, 'emissive'], $__.os.oid287);
    'value' in vvv_tmp44;
    p = 'value';
    parameter_src = TAJS_restrictToType((((uniforms_src, $__.os.oid235)[u, 'emissive'], $__.os.oid287), $__.os.oid287)[p, 'value'], 'object');
    parameter_src, (parameter_src.isColor, true);
    (((uniforms_dst, $__.os.oid369)[u, 'emissive'], $__.os.oid409), $__.os.oid409)[p, 'value'] = (vvv_tmp45 = parameter_src, 'clone', $__.fs.J$__v494107025_821_611.call(vvv_tmp45, 19, true, $__.uid));
    'roughness' in vvv_tmp0;
    u = 'roughness';
    (uniforms_dst, $__.os.oid369)[u, 'roughness'] = $__.os.oid410 = {};
    vvv_tmp46 = ((uniforms_src, $__.os.oid235)[u, 'roughness'], $__.os.oid288);
    'value' in vvv_tmp46;
    p = 'value';
    parameter_src = ((((uniforms_src, $__.os.oid235)[u, 'roughness'], $__.os.oid288), $__.os.oid288)[p, 'value'], 0.5);
    ((((((parameter_src, TAJS_restrictToType(parameter_src.isColor, 'undefined')), (parameter_src, TAJS_restrictToType(parameter_src.isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isTexture, 'undefined'));
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid369)[u, 'roughness'], $__.os.oid410), $__.os.oid410)[p, 'value'] = parameter_src;
    'metalness' in vvv_tmp0;
    u = 'metalness';
    (uniforms_dst, $__.os.oid369)[u, 'metalness'] = $__.os.oid411 = {};
    vvv_tmp47 = ((uniforms_src, $__.os.oid235)[u, 'metalness'], $__.os.oid289);
    'value' in vvv_tmp47;
    p = 'value';
    parameter_src = ((((uniforms_src, $__.os.oid235)[u, 'metalness'], $__.os.oid289), $__.os.oid289)[p, 'value'], 0);
    (((((parameter_src, parameter_src), parameter_src), parameter_src), parameter_src), parameter_src), parameter_src;
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid369)[u, 'metalness'], $__.os.oid411), $__.os.oid411)[p, 'value'] = parameter_src;
    'envMapIntensity' in vvv_tmp0;
    u = 'envMapIntensity';
    (uniforms_dst, $__.os.oid369)[u, 'envMapIntensity'] = $__.os.oid412 = {};
    vvv_tmp48 = ((uniforms_src, $__.os.oid235)[u, 'envMapIntensity'], $__.os.oid290);
    'value' in vvv_tmp48;
    p = 'value';
    parameter_src = ((((uniforms_src, $__.os.oid235)[u, 'envMapIntensity'], $__.os.oid290), $__.os.oid290)[p, 'value'], 1);
    ((((((parameter_src, TAJS_restrictToType(parameter_src.isColor, 'undefined')), (parameter_src, TAJS_restrictToType(parameter_src.isVector2, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isVector4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix3, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isMatrix4, 'undefined'))), (parameter_src, TAJS_restrictToType(parameter_src.isTexture, 'undefined'));
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid369)[u, 'envMapIntensity'], $__.os.oid412), $__.os.oid412)[p, 'value'] = parameter_src;
    return uniforms_dst;
case 40:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 40);
    uniforms_dst = $__.os.oid413 = {};
    vvv_tmp0 = uniforms_src;
    'clearCoat' in vvv_tmp0;
    u = 'clearCoat';
    (uniforms_dst, $__.os.oid413)[u, 'clearCoat'] = $__.os.oid414 = {};
    vvv_tmp1 = ((uniforms_src, $__.os.oid367)[u, 'clearCoat'], $__.os.oid365);
    'value' in vvv_tmp1;
    p = 'value';
    parameter_src = ((((uniforms_src, $__.os.oid367)[u, 'clearCoat'], $__.os.oid365), $__.os.oid365)[p, 'value'], 0);
    (((((parameter_src, parameter_src), parameter_src), parameter_src), parameter_src), parameter_src), parameter_src;
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid413)[u, 'clearCoat'], $__.os.oid414), $__.os.oid414)[p, 'value'] = parameter_src;
    'clearCoatRoughness' in vvv_tmp0;
    u = 'clearCoatRoughness';
    (uniforms_dst, $__.os.oid413)[u, 'clearCoatRoughness'] = $__.os.oid415 = {};
    vvv_tmp2 = ((uniforms_src, $__.os.oid367)[u, 'clearCoatRoughness'], $__.os.oid366);
    'value' in vvv_tmp2;
    p = 'value';
    parameter_src = ((((uniforms_src, $__.os.oid367)[u, 'clearCoatRoughness'], $__.os.oid366), $__.os.oid366)[p, 'value'], 0);
    (((((parameter_src, parameter_src), parameter_src), parameter_src), parameter_src), parameter_src), parameter_src;
    Array['isArray'](parameter_src);
    (((uniforms_dst, $__.os.oid413)[u, 'clearCoatRoughness'], $__.os.oid415), $__.os.oid415)[p, 'value'] = parameter_src;
    return uniforms_dst;
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
uniforms_dst = {};
for (var u in uniforms_src) {
    uniforms_dst[u] = {};
    for (var p in uniforms_src[u]) {
        parameter_src = uniforms_src[u][p];
        if (parameter_src && parameter_src.isColor || parameter_src && parameter_src.isVector2 || parameter_src && parameter_src.isVector3 || parameter_src && parameter_src.isVector4 || parameter_src && parameter_src.isMatrix3 || parameter_src && parameter_src.isMatrix4 || parameter_src && parameter_src.isTexture) {
            uniforms_dst[u][p] = parameter_src.clone();
        } else if (Array.isArray(parameter_src)) {
            uniforms_dst[u][p] = parameter_src.slice();
        } else {
            uniforms_dst[u][p] = parameter_src;
        }
    }
}
return uniforms_dst;})
    };
    ShaderMaterial.prototype = Object['create']((Material.prototype, $__.os.oid16));
    TAJS_restrictToType(ShaderMaterial.prototype, 'object').constructor = ShaderMaterial;
    TAJS_restrictToType(ShaderMaterial.prototype, 'object').isShaderMaterial = true;
    TAJS_restrictToType(ShaderMaterial.prototype, 'object').copy = ($__.fs.J$__v494107025_801_601 = function J$__v494107025_801(source) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
source = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
Material.prototype.copy.call(this, source);
this.fragmentShader = source.fragmentShader;
this.vertexShader = source.vertexShader;
this.uniforms = exports.UniformsUtils.clone(source.uniforms);
this.defines = source.defines;
this.wireframe = source.wireframe;
this.wireframeLinewidth = source.wireframeLinewidth;
this.lights = source.lights;
this.clipping = source.clipping;
this.skinning = source.skinning;
this.morphTargets = source.morphTargets;
this.morphNormals = source.morphNormals;
this.extensions = source.extensions;
return this;});
    TAJS_restrictToType(ShaderMaterial.prototype, 'object').toJSON = ($__.fs.J$__v494107025_803_602 = function J$__v494107025_803(meta) {
var vvv_return, vvv_switch, data;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
meta = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
data = Material.prototype.toJSON.call(this, meta);
data.uniforms = this.uniforms;
data.vertexShader = this.vertexShader;
data.fragmentShader = this.fragmentShader;
return data;});
    alphamap_fragment = '#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n';
    alphamap_pars_fragment = '#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif\n';
    alphatest_fragment = '#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif\n';
    aomap_fragment = '#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif\n';
    aomap_pars_fragment = '#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif';
    begin_vertex = '\nvec3 transformed = vec3( position );\n';
    beginnormal_vertex = '\nvec3 objectNormal = vec3( normal );\n';
    bsdfs = 'bool testLightInRange( const in float lightDistance, const in float cutoffDistance ) {\n\treturn any( bvec2( cutoffDistance == 0.0, lightDistance < cutoffDistance ) );\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t\tif( decayExponent > 0.0 ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\t\tfloat maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t\treturn distanceFalloff * maxDistanceCutoffFactor;\n#else\n\t\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n#endif\n\t\t}\n\t\treturn 1.0;\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\treturn specularColor * AB.x + AB.y;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n';
    bumpmap_pars_fragment = '#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = dFdx( surf_pos );\n\t\tvec3 vSigmaY = dFdy( surf_pos );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif\n';
    clipping_planes_fragment = '#if NUM_CLIPPING_PLANES > 0\n\tfor ( int i = 0; i < NUM_CLIPPING_PLANES; ++ i ) {\n\t\tvec4 plane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n#endif\n';
    clipping_planes_pars_fragment = '#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( PHYSICAL ) && ! defined( PHONG )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif\n';
    clipping_planes_pars_vertex = '#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvarying vec3 vViewPosition;\n#endif\n';
    clipping_planes_vertex = '#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n';
    color_fragment = '#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif';
    color_pars_fragment = '#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif\n';
    color_pars_vertex = '#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif';
    color_vertex = '#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif';
    common = '#define PI 3.14159265359\n#define PI2 6.28318530718\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\n';
    cube_uv_reflection_fragment = '#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction);\n\tint face = -1;\n\tif( absDirection.x > absDirection.z ) {\n\t\tif(absDirection.x > absDirection.y )\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z > absDirection.y )\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes && (scale < a) ? a : scale;\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\tfloat rcpPowScale = 1.0 / powScale;\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV(vec3 reflectedDirection, float roughness ) {\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n\tfloat s = mipInfo.y;\n\tfloat level0 = mipInfo.x;\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\tvec4 result = mix(color10, color20, t);\n\treturn vec4(result.rgb, 1.0);\n}\n#endif\n';
    defaultnormal_vertex = '#ifdef FLIP_SIDED\n\tobjectNormal = -objectNormal;\n#endif\nvec3 transformedNormal = normalMatrix * objectNormal;\n';
    displacementmap_pars_vertex = '#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif\n';
    displacementmap_vertex = '#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normal * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif\n';
    emissivemap_fragment = '#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif\n';
    emissivemap_pars_fragment = '#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif\n';
    encodings_fragment = '  gl_FragColor = linearToOutputTexel( gl_FragColor );\n';
    encodings_pars_fragment = '\nvec4 LinearToLinear( in vec4 value ) {\n  return value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n  return vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n  return vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n  return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n  return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n  return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n  float maxComponent = max( max( value.r, value.g ), value.b );\n  float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n  return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n  return vec4( value.xyz * value.w * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n  float maxRGB = max( value.x, max( value.g, value.b ) );\n  float M      = clamp( maxRGB / maxRange, 0.0, 1.0 );\n  M            = ceil( M * 255.0 ) / 255.0;\n  return vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n    return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n    float maxRGB = max( value.x, max( value.g, value.b ) );\n    float D      = max( maxRange / maxRGB, 1.0 );\n    D            = min( floor( D ) / 255.0, 1.0 );\n    return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n  vec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\n  Xp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\n  vec4 vResult;\n  vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n  float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n  vResult.w = fract(Le);\n  vResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;\n  return vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n  float Le = value.z * 255.0 + value.w;\n  vec3 Xp_Y_XYZp;\n  Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\n  Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n  Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n  vec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\n  return vec4( max(vRGB, 0.0), 1.0 );\n}\n';
    envmap_fragment = '#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\tsampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\n\t\tsampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\tvec3 reflectView = flipNormal * normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\tenvColor = envMapTexelToLinear( envColor );\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif\n';
    envmap_pars_fragment = '#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n\tuniform float reflectivity;\n\tuniform float envMapIntenstiy;\n#endif\n#ifdef USE_ENVMAP\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n\t\tvarying vec3 vWorldPosition;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\tuniform float flipEnvMap;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif\n';
    envmap_pars_vertex = '#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif\n';
    envmap_vertex = '#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif\n';
    fog_fragment = '#ifdef USE_FOG\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tfloat depth = gl_FragDepthEXT / gl_FragCoord.w;\n\t#else\n\t\tfloat depth = gl_FragCoord.z / gl_FragCoord.w;\n\t#endif\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * depth * depth * LOG2 ) );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, depth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n';
    fog_pars_fragment = '#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif';
    lightmap_fragment = '#ifdef USE_LIGHTMAP\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif\n';
    lightmap_pars_fragment = '#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif';
    lights_lambert_vertex = 'vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif\n';
    lights_pars = 'uniform vec3 ambientLightColor;\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tif ( testLightInRange( lightDistance, pointLight.distance ) ) {\n\t\t\tdirectLight.color = pointLight.color;\n\t\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( all( bvec2( angleCos > spotLight.coneCos, testLightInRange( lightDistance, spotLight.distance ) ) ) ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif\n#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\t#include <normal_flip>\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = flipNormal * vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = flipNormal * vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar - 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\t\t#endif\n\t\t#include <normal_flip>\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryReflectVec = flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV(queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent));\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\n\t\t\tsampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = flipNormal * normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif\n';
    lights_phong_fragment = 'BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;\n';
    lights_phong_pars_fragment = 'varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)\n';
    lights_physical_fragment = 'PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.clearCoat = saturate( clearCoat );\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n#endif\n';
    lights_physical_pars_fragment = 'struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n\t#ifndef STANDARD\n\t\tfloat clearCoat;\n\t\tfloat clearCoatRoughness;\n\t#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifndef STANDARD\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#ifndef STANDARD\n\t\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifndef STANDARD\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\tfloat dotNL = dotNV;\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR ) * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n\t#ifndef STANDARD\n\t\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}\n';
    lights_template = '\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#ifdef USE_LIGHTMAP\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t \tirradiance += getLightProbeIndirectIrradiance( geometry, 8 );\n\t#endif\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tvec3 radiance = getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), 8 );\n\t#ifndef STANDARD\n\t\tvec3 clearCoatRadiance = getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), 8 );\n\t#else\n\t\tvec3 clearCoatRadiance = vec3( 0.0 );\n\t#endif\n\t\t\n\tRE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );\n#endif\n';
    logdepthbuf_fragment = '#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n\tgl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n#endif';
    logdepthbuf_pars_fragment = '#ifdef USE_LOGDEPTHBUF\n\tuniform float logDepthBufFC;\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n#endif\n';
    logdepthbuf_pars_vertex = '#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n\tuniform float logDepthBufFC;\n#endif';
    logdepthbuf_vertex = '#ifdef USE_LOGDEPTHBUF\n\tgl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t#else\n\t\tgl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\n\t#endif\n#endif\n';
    map_fragment = '#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif\n';
    map_pars_fragment = '#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n';
    map_particle_fragment = '#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) * offsetRepeat.zw + offsetRepeat.xy );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n';
    map_particle_pars_fragment = '#ifdef USE_MAP\n\tuniform vec4 offsetRepeat;\n\tuniform sampler2D map;\n#endif\n';
    metalnessmap_fragment = 'float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.r;\n#endif\n';
    metalnessmap_pars_fragment = '#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif';
    morphnormal_vertex = '#ifdef USE_MORPHNORMALS\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif\n';
    morphtarget_pars_vertex = '#ifdef USE_MORPHTARGETS\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif';
    morphtarget_vertex = '#ifdef USE_MORPHTARGETS\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\t#endif\n#endif\n';
    normal_flip = '#ifdef DOUBLE_SIDED\n\tfloat flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n#else\n\tfloat flipNormal = 1.0;\n#endif\n';
    normal_fragment = '#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal ) * flipNormal;\n#endif\n#ifdef USE_NORMALMAP\n\tnormal = perturbNormal2Arb( -vViewPosition, normal );\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif\n';
    normalmap_pars_fragment = '#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 S = normalize( q0 * st1.t - q1 * st0.t );\n\t\tvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\n\t\tvec3 N = normalize( surf_norm );\n\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\tmapN.xy = normalScale * mapN.xy;\n\t\tmat3 tsn = mat3( S, T, N );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif\n';
    packing = 'vec3 packNormalToRGB( const in vec3 normal ) {\n  return normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n  return 1.0 - 2.0 * rgb.xyz;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n  return ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n  return linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n  return (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n  return ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n';
    premultiplied_alpha_fragment = '#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif\n';
    project_vertex = '#ifdef USE_SKINNING\n\tvec4 mvPosition = modelViewMatrix * skinned;\n#else\n\tvec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\n#endif\ngl_Position = projectionMatrix * mvPosition;\n';
    roughnessmap_fragment = 'float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.r;\n#endif\n';
    roughnessmap_pars_fragment = '#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif';
    shadowmap_pars_fragment = '#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\treturn (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn 1.0;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\tfloat dp = ( length( lightToPosition ) - shadowBias ) / 1000.0;\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif\n';
    shadowmap_pars_vertex = '#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n#endif\n';
    shadowmap_vertex = '#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif\n';
    shadowmask_pars_fragment = 'float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tDirectionalLight directionalLight;\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tSpotLight spotLight;\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tPointLight pointLight;\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}\n';
    skinbase_vertex = '#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif';
    skinning_pars_vertex = '#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform sampler2D boneTexture;\n\t\tuniform int boneTextureWidth;\n\t\tuniform int boneTextureHeight;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureWidth ) );\n\t\t\tfloat y = floor( j / float( boneTextureWidth ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureWidth );\n\t\t\tfloat dy = 1.0 / float( boneTextureHeight );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif\n';
    skinning_vertex = '#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\tskinned  = bindMatrixInverse * skinned;\n#endif\n';
    skinnormal_vertex = '#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n#endif\n';
    specularmap_fragment = 'float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif';
    specularmap_pars_fragment = '#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif';
    tonemapping_fragment = '#if defined( TONE_MAPPING )\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif\n';
    tonemapping_pars_fragment = '#define saturate(a) clamp( a, 0.0, 1.0 )\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n  return toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n  color *= toneMappingExposure;\n  return saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n  color *= toneMappingExposure;\n  return saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n  color *= toneMappingExposure;\n  color = max( vec3( 0.0 ), color - 0.004 );\n  return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\n';
    uv_pars_fragment = '#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n#endif';
    uv_pars_vertex = '#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n\tuniform vec4 offsetRepeat;\n#endif\n';
    uv_vertex = '#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvUv = uv * offsetRepeat.zw + offsetRepeat.xy;\n#endif';
    uv2_pars_fragment = '#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif';
    uv2_pars_vertex = '#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n#endif';
    uv2_vertex = '#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = uv2;\n#endif';
    worldpos_vertex = '#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( PHYSICAL ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\n\t#ifdef USE_SKINNING\n\t\tvec4 worldPosition = modelMatrix * skinned;\n\t#else\n\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n\t#endif\n#endif\n';
    cube_frag = 'uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\n\tgl_FragColor.a *= opacity;\n}\n';
    cube_vert = 'varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}\n';
    depth_frag = '#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( gl_FragCoord.z ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\t#endif\n}\n';
    depth_vert = '#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}\n';
    distanceRGBA_frag = 'uniform vec3 lightPos;\nvarying vec4 vWorldPosition;\n#include <common>\n#include <packing>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tgl_FragColor = packDepthToRGBA( length( vWorldPosition.xyz - lightPos.xyz ) / 1000.0 );\n}\n';
    distanceRGBA_vert = 'varying vec4 vWorldPosition;\n#include <common>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <skinbase_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition;\n}\n';
    equirect_frag = 'uniform sampler2D tEquirect;\nuniform float tFlip;\nvarying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldPosition );\n\tvec2 sampleUV;\n\tsampleUV.y = saturate( tFlip * direction.y * -0.5 + 0.5 );\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n}\n';
    equirect_vert = 'varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}\n';
    linedashed_frag = 'uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n';
    linedashed_vert = 'uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}\n';
    meshbasic_frag = 'uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight;\n\treflectedLight.directDiffuse = vec3( 0.0 );\n\treflectedLight.directSpecular = vec3( 0.0 );\n\treflectedLight.indirectDiffuse = diffuseColor.rgb;\n\treflectedLight.indirectSpecular = vec3( 0.0 );\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <normal_flip>\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n';
    meshbasic_vert = '#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n}\n';
    meshlambert_frag = 'uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <normal_flip>\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n';
    meshlambert_vert = '#define LAMBERT\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars>\n#include <color_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n}\n';
    meshphong_frag = '#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_flip>\n\t#include <normal_fragment>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_template>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n';
    meshphong_vert = '#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n}\n';
    meshphysical_frag = '#define PHYSICAL\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifndef STANDARD\n\tuniform float clearCoat;\n\tuniform float clearCoatRoughness;\n#endif\nuniform float envMapIntensity;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <lights_pars>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_flip>\n\t#include <normal_fragment>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_template>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n';
    meshphysical_vert = '#define PHYSICAL\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n}\n';
    normal_frag = 'uniform float opacity;\nvarying vec3 vNormal;\n#include <common>\n#include <packing>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tgl_FragColor = vec4( packNormalToRGB( vNormal ), opacity );\n\t#include <logdepthbuf_fragment>\n}\n';
    normal_vert = 'varying vec3 vNormal;\n#include <common>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvNormal = normalize( normalMatrix * normal );\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}\n';
    points_frag = 'uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n';
    points_vert = 'uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#ifdef USE_SIZEATTENUATION\n\t\tgl_PointSize = size * ( scale / - mvPosition.z );\n\t#else\n\t\tgl_PointSize = size;\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n}\n';
    shadow_frag = 'uniform float opacity;\n#include <common>\n#include <packing>\n#include <bsdfs>\n#include <lights_pars>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( 0.0, 0.0, 0.0, opacity * ( 1.0  - getShadowMask() ) );\n}\n';
    shadow_vert = '#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n}\n';
    ShaderChunk = $__.os.oid18 = {
        'alphamap_fragment': alphamap_fragment,
        'alphamap_pars_fragment': alphamap_pars_fragment,
        'alphatest_fragment': alphatest_fragment,
        'aomap_fragment': aomap_fragment,
        'aomap_pars_fragment': aomap_pars_fragment,
        'begin_vertex': begin_vertex,
        'beginnormal_vertex': beginnormal_vertex,
        'bsdfs': bsdfs,
        'bumpmap_pars_fragment': bumpmap_pars_fragment,
        'clipping_planes_fragment': clipping_planes_fragment,
        'clipping_planes_pars_fragment': clipping_planes_pars_fragment,
        'clipping_planes_pars_vertex': clipping_planes_pars_vertex,
        'clipping_planes_vertex': clipping_planes_vertex,
        'color_fragment': color_fragment,
        'color_pars_fragment': color_pars_fragment,
        'color_pars_vertex': color_pars_vertex,
        'color_vertex': color_vertex,
        'common': common,
        'cube_uv_reflection_fragment': cube_uv_reflection_fragment,
        'defaultnormal_vertex': defaultnormal_vertex,
        'displacementmap_pars_vertex': displacementmap_pars_vertex,
        'displacementmap_vertex': displacementmap_vertex,
        'emissivemap_fragment': emissivemap_fragment,
        'emissivemap_pars_fragment': emissivemap_pars_fragment,
        'encodings_fragment': encodings_fragment,
        'encodings_pars_fragment': encodings_pars_fragment,
        'envmap_fragment': envmap_fragment,
        'envmap_pars_fragment': envmap_pars_fragment,
        'envmap_pars_vertex': envmap_pars_vertex,
        'envmap_vertex': envmap_vertex,
        'fog_fragment': fog_fragment,
        'fog_pars_fragment': fog_pars_fragment,
        'lightmap_fragment': lightmap_fragment,
        'lightmap_pars_fragment': lightmap_pars_fragment,
        'lights_lambert_vertex': lights_lambert_vertex,
        'lights_pars': lights_pars,
        'lights_phong_fragment': lights_phong_fragment,
        'lights_phong_pars_fragment': lights_phong_pars_fragment,
        'lights_physical_fragment': lights_physical_fragment,
        'lights_physical_pars_fragment': lights_physical_pars_fragment,
        'lights_template': lights_template,
        'logdepthbuf_fragment': logdepthbuf_fragment,
        'logdepthbuf_pars_fragment': logdepthbuf_pars_fragment,
        'logdepthbuf_pars_vertex': logdepthbuf_pars_vertex,
        'logdepthbuf_vertex': logdepthbuf_vertex,
        'map_fragment': map_fragment,
        'map_pars_fragment': map_pars_fragment,
        'map_particle_fragment': map_particle_fragment,
        'map_particle_pars_fragment': map_particle_pars_fragment,
        'metalnessmap_fragment': metalnessmap_fragment,
        'metalnessmap_pars_fragment': metalnessmap_pars_fragment,
        'morphnormal_vertex': morphnormal_vertex,
        'morphtarget_pars_vertex': morphtarget_pars_vertex,
        'morphtarget_vertex': morphtarget_vertex,
        'normal_flip': normal_flip,
        'normal_fragment': normal_fragment,
        'normalmap_pars_fragment': normalmap_pars_fragment,
        'packing': packing,
        'premultiplied_alpha_fragment': premultiplied_alpha_fragment,
        'project_vertex': project_vertex,
        'roughnessmap_fragment': roughnessmap_fragment,
        'roughnessmap_pars_fragment': roughnessmap_pars_fragment,
        'shadowmap_pars_fragment': shadowmap_pars_fragment,
        'shadowmap_pars_vertex': shadowmap_pars_vertex,
        'shadowmap_vertex': shadowmap_vertex,
        'shadowmask_pars_fragment': shadowmask_pars_fragment,
        'skinbase_vertex': skinbase_vertex,
        'skinning_pars_vertex': skinning_pars_vertex,
        'skinning_vertex': skinning_vertex,
        'skinnormal_vertex': skinnormal_vertex,
        'specularmap_fragment': specularmap_fragment,
        'specularmap_pars_fragment': specularmap_pars_fragment,
        'tonemapping_fragment': tonemapping_fragment,
        'tonemapping_pars_fragment': tonemapping_pars_fragment,
        'uv_pars_fragment': uv_pars_fragment,
        'uv_pars_vertex': uv_pars_vertex,
        'uv_vertex': uv_vertex,
        'uv2_pars_fragment': uv2_pars_fragment,
        'uv2_pars_vertex': uv2_pars_vertex,
        'uv2_vertex': uv2_vertex,
        'worldpos_vertex': worldpos_vertex,
        'cube_frag': cube_frag,
        'cube_vert': cube_vert,
        'depth_frag': depth_frag,
        'depth_vert': depth_vert,
        'distanceRGBA_frag': distanceRGBA_frag,
        'distanceRGBA_vert': distanceRGBA_vert,
        'equirect_frag': equirect_frag,
        'equirect_vert': equirect_vert,
        'linedashed_frag': linedashed_frag,
        'linedashed_vert': linedashed_vert,
        'meshbasic_frag': meshbasic_frag,
        'meshbasic_vert': meshbasic_vert,
        'meshlambert_frag': meshlambert_frag,
        'meshlambert_vert': meshlambert_vert,
        'meshphong_frag': meshphong_frag,
        'meshphong_vert': meshphong_vert,
        'meshphysical_frag': meshphysical_frag,
        'meshphysical_vert': meshphysical_vert,
        'normal_frag': normal_frag,
        'normal_vert': normal_vert,
        'points_frag': points_frag,
        'points_vert': points_vert,
        'shadow_frag': shadow_frag,
        'shadow_vert': shadow_vert
    };
    Color.prototype = $__.os.oid19 = {
        'constructor': Color,
        'isColor': true,
        'r': 1,
        'g': 1,
        'b': 1,
        'set': ($__.fs.J$__v494107025_806_603 = function J$__v494107025_806(value) {
var vvv_return, vvv_switch, vvv_tmp0;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
value = arguments[0];
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    value, TAJS_restrictToType(value.isColor, 'undefined');
    typeof value === 'number';
    vvv_tmp0 = this, 'setHex', $__.fs.J$__v494107025_810_605.call(vvv_tmp0, value, 0, true, $__.uid);
    return this;
case 1:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 1);
    value, TAJS_restrictToType(value.isColor, 'undefined');
    typeof value === 'number';
    vvv_tmp0 = this, 'setHex', $__.fs.J$__v494107025_810_605.call(vvv_tmp0, value, 1, true, $__.uid);
    return this;
case 2:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 2);
    value, TAJS_restrictToType(value.isColor, 'undefined');
    typeof value === 'number';
    vvv_tmp0 = this, 'setHex', $__.fs.J$__v494107025_810_605.call(vvv_tmp0, value, 2, true, $__.uid);
    return this;
case 3:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 3);
    value;
    typeof value === 'number';
    vvv_tmp0 = this, 'setHex', $__.fs.J$__v494107025_810_605.call(vvv_tmp0, value, 3, true, $__.uid);
    return this;
case 4:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 4);
    value;
    typeof value === 'number';
    vvv_tmp0 = this, 'setHex', $__.fs.J$__v494107025_810_605.call(vvv_tmp0, value, 4, true, $__.uid);
    return this;
case 5:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 5);
    value, TAJS_restrictToType(value.isColor, 'undefined');
    typeof value === 'number';
    vvv_tmp0 = this, 'setHex', $__.fs.J$__v494107025_810_605.call(vvv_tmp0, value, 5, true, $__.uid);
    return this;
case 6:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 6);
    value;
    typeof value === 'number';
    vvv_tmp0 = this, 'setHex', $__.fs.J$__v494107025_810_605.call(vvv_tmp0, value, 6, true, $__.uid);
    return this;
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (value && value.isColor) {
    this.copy(value);
} else if (typeof value === 'number') {
    this.setHex(value);
} else if (typeof value === 'string') {
    this.setStyle(value);
}
return this;}),
        'setScalar': ($__.fs.J$__v494107025_808_604 = function J$__v494107025_808(scalar) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
scalar = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.r = scalar;
this.g = scalar;
this.b = scalar;}),
        'setHex': ($__.fs.J$__v494107025_810_605 = function J$__v494107025_810(hex) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
hex = arguments[0];
switch (vvv_switch) {
case 0:
case 1:
case 2:
case 3:
case 4:
case 5:
case 6:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(0 <= vvv_switch && vvv_switch <= 6);
    hex = Math['floor'](hex);
    this.r = (hex >> 16 & 255) / 255;
    this.g = (hex >> 8 & 255) / 255;
    this.b = (hex & 255) / 255;
    return this;
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
hex = Math.floor(hex);
this.r = (hex >> 16 & 255) / 255;
this.g = (hex >> 8 & 255) / 255;
this.b = (hex & 255) / 255;
return this;}),
        'setRGB': ($__.fs.J$__v494107025_812_606 = function J$__v494107025_812(r, g, b) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
r = arguments[0], g = arguments[1], b = arguments[2];
switch (vvv_switch) {
case 0:
case 1:
case 2:
case 3:
case 4:
case 5:
case 6:
case 7:
case 8:
case 9:
case 10:
case 11:
case 12:
case 13:
case 14:
case 15:
case 16:
case 17:
case 18:
case 19:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(0 <= vvv_switch && vvv_switch <= 19);
    this.r = r;
    this.g = g;
    this.b = b;
    return this;
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.r = r;
this.g = g;
this.b = b;
return this;}),
        'setHSL': (($__.fs.J$__v494107025_816_607 = function J$__v494107025_816() {
var vvv_return, vvv_switch, hue2rgb;
hue2rgb = function hue2rgb(p, q, t) {
    if (t < 0)
        t += 1;
    if (t > 1)
        t -= 1;
    if (t < 1 / 6)
        return p + (q - p) * 6 * t;
    if (t < 1 / 2)
        return q;
    if (t < 2 / 3)
        return p + (q - p) * 6 * (2 / 3 - t);
    return p;
};
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    hue2rgb = ($__.fs.hue2rgb_608 = function hue2rgb(p, q, t) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
p = arguments[0], q = arguments[1], t = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (t < 0)
    t += 1;
if (t > 1)
    t -= 1;
if (t < 1 / 6)
    return p + (q - p) * 6 * t;
if (t < 1 / 2)
    return q;
if (t < 2 / 3)
    return p + (q - p) * 6 * (2 / 3 - t);
return p;});
    return ($__.fs.setHSL_609 = function setHSL(h, s, l) {
var vvv_return, vvv_switch, p, q;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
h = arguments[0], s = arguments[1], l = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
h = exports.Math.euclideanModulo(h, 1);
s = exports.Math.clamp(s, 0, 1);
l = exports.Math.clamp(l, 0, 1);
if (s === 0) {
    this.r = this.g = this.b = l;
} else {
    p = l <= 0.5 ? l * (1 + s) : l + s - l * s;
    q = 2 * l - p;
    this.r = hue2rgb(q, p, h + 1 / 3);
    this.g = hue2rgb(q, p, h);
    this.b = hue2rgb(q, p, h - 1 / 3);
}
return this;});
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return function setHSL(h, s, l) {
    h = exports.Math.euclideanModulo(h, 1);
    s = exports.Math.clamp(s, 0, 1);
    l = exports.Math.clamp(l, 0, 1);
    if (s === 0) {
        this.r = this.g = this.b = l;
    } else {
        var p = l <= 0.5 ? l * (1 + s) : l + s - l * s;
        var q = 2 * l - p;
        this.r = hue2rgb(q, p, h + 1 / 3);
        this.g = hue2rgb(q, p, h);
        this.b = hue2rgb(q, p, h - 1 / 3);
    }
    return this;
};}), $__.fs.J$__v494107025_816_607)(0, true, $__.uid),
        'setStyle': ($__.fs.J$__v494107025_819_610 = function J$__v494107025_819(style) {
var vvv_return, vvv_switch, handleAlpha, m, color, name, components, h, s, l, hex, size;
handleAlpha = function handleAlpha(string) {
    if (string === undefined)
        return;
    if (parseFloat(string) < 1) {
        console.warn('THREE.Color: Alpha component of ' + style + ' will be ignored.');
    }
};
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
style = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (m = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(style)) {
    name = m[1];
    components = m[2];
    switch (name) {
    case 'rgb':
    case 'rgba':
        if (color = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)) {
            this.r = Math.min(255, parseInt(color[1], 10)) / 255;
            this.g = Math.min(255, parseInt(color[2], 10)) / 255;
            this.b = Math.min(255, parseInt(color[3], 10)) / 255;
            handleAlpha(color[5]);
            return this;
        }
        if (color = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)) {
            this.r = Math.min(100, parseInt(color[1], 10)) / 100;
            this.g = Math.min(100, parseInt(color[2], 10)) / 100;
            this.b = Math.min(100, parseInt(color[3], 10)) / 100;
            handleAlpha(color[5]);
            return this;
        }
        break;
    case 'hsl':
    case 'hsla':
        if (color = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)) {
            h = parseFloat(color[1]) / 360;
            s = parseInt(color[2], 10) / 100;
            l = parseInt(color[3], 10) / 100;
            handleAlpha(color[5]);
            return this.setHSL(h, s, l);
        }
        break;
    }
} else if (m = /^\#([A-Fa-f0-9]+)$/.exec(style)) {
    hex = m[1];
    size = hex.length;
    if (size === 3) {
        this.r = parseInt(hex.charAt(0) + hex.charAt(0), 16) / 255;
        this.g = parseInt(hex.charAt(1) + hex.charAt(1), 16) / 255;
        this.b = parseInt(hex.charAt(2) + hex.charAt(2), 16) / 255;
        return this;
    } else if (size === 6) {
        this.r = parseInt(hex.charAt(0) + hex.charAt(1), 16) / 255;
        this.g = parseInt(hex.charAt(2) + hex.charAt(3), 16) / 255;
        this.b = parseInt(hex.charAt(4) + hex.charAt(5), 16) / 255;
        return this;
    }
}
if (style && style.length > 0) {
    hex = exports.ColorKeywords[style];
    if (hex !== undefined) {
        this.setHex(hex);
    } else {
        console.warn('THREE.Color: Unknown color ' + style);
    }
}
return this;}),
        'clone': ($__.fs.J$__v494107025_821_611 = function J$__v494107025_821() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    return new $__.fs.Color_57((this.r, 0.9333333333333333), (this.g, 0.9333333333333333), (this.b, 0.9333333333333333), 3, true, $__.uid);
case 1:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 1);
    return new $__.fs.Color_57((this.r, 1), (this.g, 1), (this.b, 1), 4, true, $__.uid);
case 2:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 2);
    return new $__.fs.Color_57((this.r, 0.9333333333333333), (this.g, 0.9333333333333333), (this.b, 0.9333333333333333), 6, true, $__.uid);
case 3:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 3);
    return new $__.fs.Color_57((this.r, 1), (this.g, 1), (this.b, 1), 7, true, $__.uid);
case 4:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 4);
    return new $__.fs.Color_57((this.r, 0), (this.g, 0), (this.b, 0), 8, true, $__.uid);
case 5:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 5);
    return new $__.fs.Color_57((this.r, 0.9333333333333333), (this.g, 0.9333333333333333), (this.b, 0.9333333333333333), 11, true, $__.uid);
case 6:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 6);
    return new $__.fs.Color_57((this.r, 1), (this.g, 1), (this.b, 1), 12, true, $__.uid);
case 7:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 7);
    return new $__.fs.Color_57((this.r, 0), (this.g, 0), (this.b, 0), 13, true, $__.uid);
case 8:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 8);
    return new $__.fs.Color_57((this.r, 0.06666666666666667), (this.g, 0.06666666666666667), (this.b, 0.06666666666666667), 14, true, $__.uid);
case 9:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 9);
    return new $__.fs.Color_57((this.r, 0.9333333333333333), (this.g, 0.9333333333333333), (this.b, 0.9333333333333333), 16, true, $__.uid);
case 10:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 10);
    return new $__.fs.Color_57((this.r, 1), (this.g, 1), (this.b, 1), 17, true, $__.uid);
case 11:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 11);
    return new $__.fs.Color_57((this.r, 0), (this.g, 0), (this.b, 0), 18, true, $__.uid);
case 12:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 12);
    return new $__.fs.Color_57((this.r, 0.9333333333333333), (this.g, 0.9333333333333333), (this.b, 0.9333333333333333), 19, true, $__.uid);
case 13:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 13);
    return new $__.fs.Color_57((this.r, 1), (this.g, 1), (this.b, 1), 20, true, $__.uid);
case 14:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 14);
    return new $__.fs.Color_57((this.r, 0.9333333333333333), (this.g, 0.9333333333333333), (this.b, 0.9333333333333333), 21, true, $__.uid);
case 15:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 15);
    return new $__.fs.Color_57((this.r, 1), (this.g, 1), (this.b, 1), 22, true, $__.uid);
case 16:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 16);
    return new $__.fs.Color_57((this.r, 0.9333333333333333), (this.g, 0.9333333333333333), (this.b, 0.9333333333333333), 23, true, $__.uid);
case 17:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 17);
    return new $__.fs.Color_57((this.r, 0.9333333333333333), (this.g, 0.9333333333333333), (this.b, 0.9333333333333333), 24, true, $__.uid);
case 18:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 18);
    return new $__.fs.Color_57((this.r, 1), (this.g, 1), (this.b, 1), 25, true, $__.uid);
case 19:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 19);
    return new $__.fs.Color_57((this.r, 0), (this.g, 0), (this.b, 0), 26, true, $__.uid);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return new this.constructor(this.r, this.g, this.b);}),
        'copy': ($__.fs.J$__v494107025_823_612 = function J$__v494107025_823(color) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
color = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.r = color.r;
this.g = color.g;
this.b = color.b;
return this;}),
        'copyGammaToLinear': ($__.fs.J$__v494107025_825_613 = function J$__v494107025_825(color, gammaFactor) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
color = arguments[0], gammaFactor = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (gammaFactor === undefined)
    gammaFactor = 2;
this.r = Math.pow(color.r, gammaFactor);
this.g = Math.pow(color.g, gammaFactor);
this.b = Math.pow(color.b, gammaFactor);
return this;}),
        'copyLinearToGamma': ($__.fs.J$__v494107025_827_614 = function J$__v494107025_827(color, gammaFactor) {
var vvv_return, vvv_switch, safeInverse;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
color = arguments[0], gammaFactor = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (gammaFactor === undefined)
    gammaFactor = 2;
safeInverse = gammaFactor > 0 ? 1 / gammaFactor : 1;
this.r = Math.pow(color.r, safeInverse);
this.g = Math.pow(color.g, safeInverse);
this.b = Math.pow(color.b, safeInverse);
return this;}),
        'convertGammaToLinear': ($__.fs.J$__v494107025_829_615 = function J$__v494107025_829() {
var vvv_return, vvv_switch, r, g, b;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
r = this.r;
g = this.g;
b = this.b;
this.r = r * r;
this.g = g * g;
this.b = b * b;
return this;}),
        'convertLinearToGamma': ($__.fs.J$__v494107025_831_616 = function J$__v494107025_831() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.r = Math.sqrt(this.r);
this.g = Math.sqrt(this.g);
this.b = Math.sqrt(this.b);
return this;}),
        'getHex': ($__.fs.J$__v494107025_833_617 = function J$__v494107025_833() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return this.r * 255 << 16 ^ this.g * 255 << 8 ^ this.b * 255 << 0;}),
        'getHexString': ($__.fs.J$__v494107025_835_618 = function J$__v494107025_835() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return ('000000' + this.getHex().toString(16)).slice(-6);}),
        'getHSL': ($__.fs.J$__v494107025_837_619 = function J$__v494107025_837(optionalTarget) {
var vvv_return, vvv_switch, hsl, r, g, b, max, min, hue, saturation, lightness, delta;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
optionalTarget = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
hsl = optionalTarget || {
    h: 0,
    s: 0,
    l: 0
};
r = this.r;
g = this.g;
b = this.b;
max = Math.max(r, g, b);
min = Math.min(r, g, b);
lightness = (min + max) / 2;
if (min === max) {
    hue = 0;
    saturation = 0;
} else {
    delta = max - min;
    saturation = lightness <= 0.5 ? delta / (max + min) : delta / (2 - max - min);
    switch (max) {
    case r:
        hue = (g - b) / delta + (g < b ? 6 : 0);
        break;
    case g:
        hue = (b - r) / delta + 2;
        break;
    case b:
        hue = (r - g) / delta + 4;
        break;
    }
    hue /= 6;
}
hsl.h = hue;
hsl.s = saturation;
hsl.l = lightness;
return hsl;}),
        'getStyle': ($__.fs.J$__v494107025_839_620 = function J$__v494107025_839() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return 'rgb(' + (this.r * 255 | 0) + ',' + (this.g * 255 | 0) + ',' + (this.b * 255 | 0) + ')';}),
        'offsetHSL': ($__.fs.J$__v494107025_841_621 = function J$__v494107025_841(h, s, l) {
var vvv_return, vvv_switch, hsl;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
h = arguments[0], s = arguments[1], l = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
hsl = this.getHSL();
hsl.h += h;
hsl.s += s;
hsl.l += l;
this.setHSL(hsl.h, hsl.s, hsl.l);
return this;}),
        'add': ($__.fs.J$__v494107025_843_622 = function J$__v494107025_843(color) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
color = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.r += color.r;
this.g += color.g;
this.b += color.b;
return this;}),
        'addColors': ($__.fs.J$__v494107025_845_623 = function J$__v494107025_845(color1, color2) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
color1 = arguments[0], color2 = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.r = color1.r + color2.r;
this.g = color1.g + color2.g;
this.b = color1.b + color2.b;
return this;}),
        'addScalar': ($__.fs.J$__v494107025_847_624 = function J$__v494107025_847(s) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
s = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.r += s;
this.g += s;
this.b += s;
return this;}),
        'sub': ($__.fs.J$__v494107025_849_625 = function J$__v494107025_849(color) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
color = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.r = Math.max(0, this.r - color.r);
this.g = Math.max(0, this.g - color.g);
this.b = Math.max(0, this.b - color.b);
return this;}),
        'multiply': ($__.fs.J$__v494107025_851_626 = function J$__v494107025_851(color) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
color = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.r *= color.r;
this.g *= color.g;
this.b *= color.b;
return this;}),
        'multiplyScalar': ($__.fs.J$__v494107025_853_627 = function J$__v494107025_853(s) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
s = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.r *= s;
this.g *= s;
this.b *= s;
return this;}),
        'lerp': ($__.fs.J$__v494107025_855_628 = function J$__v494107025_855(color, alpha) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
color = arguments[0], alpha = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.r += (color.r - this.r) * alpha;
this.g += (color.g - this.g) * alpha;
this.b += (color.b - this.b) * alpha;
return this;}),
        'equals': ($__.fs.J$__v494107025_857_629 = function J$__v494107025_857(c) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
c = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return c.r === this.r && c.g === this.g && c.b === this.b;}),
        'fromArray': ($__.fs.J$__v494107025_859_630 = function J$__v494107025_859(array, offset) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
array = arguments[0], offset = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (offset === undefined)
    offset = 0;
this.r = array[offset];
this.g = array[offset + 1];
this.b = array[offset + 2];
return this;}),
        'toArray': ($__.fs.J$__v494107025_861_631 = function J$__v494107025_861(array, offset) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
array = arguments[0], offset = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (array === undefined)
    array = [];
if (offset === undefined)
    offset = 0;
array[offset] = this.r;
array[offset + 1] = this.g;
array[offset + 2] = this.b;
return array;}),
        'toJSON': ($__.fs.J$__v494107025_863_632 = function J$__v494107025_863() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return this.getHex();})
    };
    (exports, $__.os.oid0).ColorKeywords = $__.os.oid20 = {
        'aliceblue': 15792383,
        'antiquewhite': 16444375,
        'aqua': 65535,
        'aquamarine': 8388564,
        'azure': 15794175,
        'beige': 16119260,
        'bisque': 16770244,
        'black': 0,
        'blanchedalmond': 16772045,
        'blue': 255,
        'blueviolet': 9055202,
        'brown': 10824234,
        'burlywood': 14596231,
        'cadetblue': 6266528,
        'chartreuse': 8388352,
        'chocolate': 13789470,
        'coral': 16744272,
        'cornflowerblue': 6591981,
        'cornsilk': 16775388,
        'crimson': 14423100,
        'cyan': 65535,
        'darkblue': 139,
        'darkcyan': 35723,
        'darkgoldenrod': 12092939,
        'darkgray': 11119017,
        'darkgreen': 25600,
        'darkgrey': 11119017,
        'darkkhaki': 12433259,
        'darkmagenta': 9109643,
        'darkolivegreen': 5597999,
        'darkorange': 16747520,
        'darkorchid': 10040012,
        'darkred': 9109504,
        'darksalmon': 15308410,
        'darkseagreen': 9419919,
        'darkslateblue': 4734347,
        'darkslategray': 3100495,
        'darkslategrey': 3100495,
        'darkturquoise': 52945,
        'darkviolet': 9699539,
        'deeppink': 16716947,
        'deepskyblue': 49151,
        'dimgray': 6908265,
        'dimgrey': 6908265,
        'dodgerblue': 2003199,
        'firebrick': 11674146,
        'floralwhite': 16775920,
        'forestgreen': 2263842,
        'fuchsia': 16711935,
        'gainsboro': 14474460,
        'ghostwhite': 16316671,
        'gold': 16766720,
        'goldenrod': 14329120,
        'gray': 8421504,
        'green': 32768,
        'greenyellow': 11403055,
        'grey': 8421504,
        'honeydew': 15794160,
        'hotpink': 16738740,
        'indianred': 13458524,
        'indigo': 4915330,
        'ivory': 16777200,
        'khaki': 15787660,
        'lavender': 15132410,
        'lavenderblush': 16773365,
        'lawngreen': 8190976,
        'lemonchiffon': 16775885,
        'lightblue': 11393254,
        'lightcoral': 15761536,
        'lightcyan': 14745599,
        'lightgoldenrodyellow': 16448210,
        'lightgray': 13882323,
        'lightgreen': 9498256,
        'lightgrey': 13882323,
        'lightpink': 16758465,
        'lightsalmon': 16752762,
        'lightseagreen': 2142890,
        'lightskyblue': 8900346,
        'lightslategray': 7833753,
        'lightslategrey': 7833753,
        'lightsteelblue': 11584734,
        'lightyellow': 16777184,
        'lime': 65280,
        'limegreen': 3329330,
        'linen': 16445670,
        'magenta': 16711935,
        'maroon': 8388608,
        'mediumaquamarine': 6737322,
        'mediumblue': 205,
        'mediumorchid': 12211667,
        'mediumpurple': 9662683,
        'mediumseagreen': 3978097,
        'mediumslateblue': 8087790,
        'mediumspringgreen': 64154,
        'mediumturquoise': 4772300,
        'mediumvioletred': 13047173,
        'midnightblue': 1644912,
        'mintcream': 16121850,
        'mistyrose': 16770273,
        'moccasin': 16770229,
        'navajowhite': 16768685,
        'navy': 128,
        'oldlace': 16643558,
        'olive': 8421376,
        'olivedrab': 7048739,
        'orange': 16753920,
        'orangered': 16729344,
        'orchid': 14315734,
        'palegoldenrod': 15657130,
        'palegreen': 10025880,
        'paleturquoise': 11529966,
        'palevioletred': 14381203,
        'papayawhip': 16773077,
        'peachpuff': 16767673,
        'peru': 13468991,
        'pink': 16761035,
        'plum': 14524637,
        'powderblue': 11591910,
        'purple': 8388736,
        'red': 16711680,
        'rosybrown': 12357519,
        'royalblue': 4286945,
        'saddlebrown': 9127187,
        'salmon': 16416882,
        'sandybrown': 16032864,
        'seagreen': 3050327,
        'seashell': 16774638,
        'sienna': 10506797,
        'silver': 12632256,
        'skyblue': 8900331,
        'slateblue': 6970061,
        'slategray': 7372944,
        'slategrey': 7372944,
        'snow': 16775930,
        'springgreen': 65407,
        'steelblue': 4620980,
        'tan': 13808780,
        'teal': 32896,
        'thistle': 14204888,
        'tomato': 16737095,
        'turquoise': 4251856,
        'violet': 15631086,
        'wheat': 16113331,
        'white': 16777215,
        'whitesmoke': 16119285,
        'yellow': 16776960,
        'yellowgreen': 10145074
    };
    UniformsLib = $__.os.oid110 = {
        'common': $__.os.oid31 = {
            'diffuse': $__.os.oid21 = {
                'value': new (Color, $__.fs.Color_57)(15658734, 0, true, $__.uid)
            },
            'opacity': $__.os.oid22 = {
                'value': 1
            },
            'map': $__.os.oid23 = {
                'value': null
            },
            'offsetRepeat': $__.os.oid24 = {
                'value': new (Vector4, $__.fs.Vector4_51)(0, 0, 1, 1, 0, true, $__.uid)
            },
            'specularMap': $__.os.oid25 = {
                'value': null
            },
            'alphaMap': $__.os.oid26 = {
                'value': null
            },
            'envMap': $__.os.oid27 = {
                'value': null
            },
            'flipEnvMap': $__.os.oid28 = {
                'value': -1
            },
            'reflectivity': $__.os.oid29 = {
                'value': 1
            },
            'refractionRatio': $__.os.oid30 = {
                'value': 0.98
            }
        },
        'aomap': $__.os.oid34 = {
            'aoMap': $__.os.oid32 = {
                'value': null
            },
            'aoMapIntensity': $__.os.oid33 = {
                'value': 1
            }
        },
        'lightmap': $__.os.oid37 = {
            'lightMap': $__.os.oid35 = {
                'value': null
            },
            'lightMapIntensity': $__.os.oid36 = {
                'value': 1
            }
        },
        'emissivemap': $__.os.oid39 = {
            'emissiveMap': $__.os.oid38 = {
                'value': null
            }
        },
        'bumpmap': $__.os.oid42 = {
            'bumpMap': $__.os.oid40 = {
                'value': null
            },
            'bumpScale': $__.os.oid41 = {
                'value': 1
            }
        },
        'normalmap': $__.os.oid45 = {
            'normalMap': $__.os.oid43 = {
                'value': null
            },
            'normalScale': $__.os.oid44 = {
                'value': new (Vector2, $__.fs.Vector2_6)(1, 1, 6, true, $__.uid)
            }
        },
        'displacementmap': $__.os.oid49 = {
            'displacementMap': $__.os.oid46 = {
                'value': null
            },
            'displacementScale': $__.os.oid47 = {
                'value': 1
            },
            'displacementBias': $__.os.oid48 = {
                'value': 0
            }
        },
        'roughnessmap': $__.os.oid51 = {
            'roughnessMap': $__.os.oid50 = {
                'value': null
            }
        },
        'metalnessmap': $__.os.oid53 = {
            'metalnessMap': $__.os.oid52 = {
                'value': null
            }
        },
        'fog': $__.os.oid58 = {
            'fogDensity': $__.os.oid54 = {
                'value': 0.00025
            },
            'fogNear': $__.os.oid55 = {
                'value': 1
            },
            'fogFar': $__.os.oid56 = {
                'value': 2000
            },
            'fogColor': $__.os.oid57 = {
                'value': new (Color, $__.fs.Color_57)(16777215, 1, true, $__.uid)
            }
        },
        'lights': $__.os.oid102 = {
            'ambientLightColor': $__.os.oid59 = {
                'value': []
            },
            'directionalLights': $__.os.oid67 = {
                'value': [],
                'properties': $__.os.oid66 = {
                    'direction': $__.os.oid60 = {},
                    'color': $__.os.oid61 = {},
                    'shadow': $__.os.oid62 = {},
                    'shadowBias': $__.os.oid63 = {},
                    'shadowRadius': $__.os.oid64 = {},
                    'shadowMapSize': $__.os.oid65 = {}
                }
            },
            'directionalShadowMap': $__.os.oid68 = {
                'value': []
            },
            'directionalShadowMatrix': $__.os.oid69 = {
                'value': []
            },
            'spotLights': $__.os.oid82 = {
                'value': [],
                'properties': $__.os.oid81 = {
                    'color': $__.os.oid70 = {},
                    'position': $__.os.oid71 = {},
                    'direction': $__.os.oid72 = {},
                    'distance': $__.os.oid73 = {},
                    'coneCos': $__.os.oid74 = {},
                    'penumbraCos': $__.os.oid75 = {},
                    'decay': $__.os.oid76 = {},
                    'shadow': $__.os.oid77 = {},
                    'shadowBias': $__.os.oid78 = {},
                    'shadowRadius': $__.os.oid79 = {},
                    'shadowMapSize': $__.os.oid80 = {}
                }
            },
            'spotShadowMap': $__.os.oid83 = {
                'value': []
            },
            'spotShadowMatrix': $__.os.oid84 = {
                'value': []
            },
            'pointLights': $__.os.oid94 = {
                'value': [],
                'properties': $__.os.oid93 = {
                    'color': $__.os.oid85 = {},
                    'position': $__.os.oid86 = {},
                    'decay': $__.os.oid87 = {},
                    'distance': $__.os.oid88 = {},
                    'shadow': $__.os.oid89 = {},
                    'shadowBias': $__.os.oid90 = {},
                    'shadowRadius': $__.os.oid91 = {},
                    'shadowMapSize': $__.os.oid92 = {}
                }
            },
            'pointShadowMap': $__.os.oid95 = {
                'value': []
            },
            'pointShadowMatrix': $__.os.oid96 = {
                'value': []
            },
            'hemisphereLights': $__.os.oid101 = {
                'value': [],
                'properties': $__.os.oid100 = {
                    'direction': $__.os.oid97 = {},
                    'skyColor': $__.os.oid98 = {},
                    'groundColor': $__.os.oid99 = {}
                }
            }
        },
        'points': $__.os.oid109 = {
            'diffuse': $__.os.oid103 = {
                'value': new (Color, $__.fs.Color_57)(15658734, 2, true, $__.uid)
            },
            'opacity': $__.os.oid104 = {
                'value': 1
            },
            'size': $__.os.oid105 = {
                'value': 1
            },
            'scale': $__.os.oid106 = {
                'value': 1
            },
            'map': $__.os.oid107 = {
                'value': null
            },
            'offsetRepeat': $__.os.oid108 = {
                'value': new (Vector4, $__.fs.Vector4_51)(0, 0, 1, 1, 1, true, $__.uid)
            }
        }
    };
    ShaderLib = $__.os.oid364 = {
        'basic': $__.os.oid131 = {
            'uniforms': (vvv_tmp4 = ((exports, $__.os.oid0).UniformsUtils, $__.os.oid17), 'merge', $__.fs.J$__v494107025_796_599.call(vvv_tmp4, [
                ((UniformsLib, $__.os.oid110).common, $__.os.oid31),
                ((UniformsLib, $__.os.oid110).aomap, $__.os.oid34),
                ((UniformsLib, $__.os.oid110).fog, $__.os.oid58)
            ], 0, true, $__.uid)),
            'vertexShader': TAJS_restrictToType((ShaderChunk, $__.os.oid18).meshbasic_vert, 'string'),
            'fragmentShader': TAJS_restrictToType((ShaderChunk, $__.os.oid18).meshbasic_frag, 'string')
        },
        'lambert': $__.os.oid173 = {
            'uniforms': (vvv_tmp5 = ((exports, $__.os.oid0).UniformsUtils, $__.os.oid17), 'merge', $__.fs.J$__v494107025_796_599.call(vvv_tmp5, [
                ((UniformsLib, $__.os.oid110).common, $__.os.oid31),
                ((UniformsLib, $__.os.oid110).aomap, $__.os.oid34),
                ((UniformsLib, $__.os.oid110).lightmap, $__.os.oid37),
                ((UniformsLib, $__.os.oid110).emissivemap, $__.os.oid39),
                ((UniformsLib, $__.os.oid110).fog, $__.os.oid58),
                ((UniformsLib, $__.os.oid110).lights, $__.os.oid102),
                $__.os.oid133 = {
                    'emissive': $__.os.oid132 = {
                        'value': new (Color, $__.fs.Color_57)(0, 5, true, $__.uid)
                    }
                }
            ], 1, true, $__.uid)),
            'vertexShader': TAJS_restrictToType((ShaderChunk, $__.os.oid18).meshlambert_vert, 'string'),
            'fragmentShader': TAJS_restrictToType((ShaderChunk, $__.os.oid18).meshlambert_frag, 'string')
        },
        'phong': $__.os.oid229 = {
            'uniforms': (vvv_tmp6 = ((exports, $__.os.oid0).UniformsUtils, $__.os.oid17), 'merge', $__.fs.J$__v494107025_796_599.call(vvv_tmp6, [
                ((UniformsLib, $__.os.oid110).common, $__.os.oid31),
                ((UniformsLib, $__.os.oid110).aomap, $__.os.oid34),
                ((UniformsLib, $__.os.oid110).lightmap, $__.os.oid37),
                ((UniformsLib, $__.os.oid110).emissivemap, $__.os.oid39),
                ((UniformsLib, $__.os.oid110).bumpmap, $__.os.oid42),
                ((UniformsLib, $__.os.oid110).normalmap, $__.os.oid45),
                ((UniformsLib, $__.os.oid110).displacementmap, $__.os.oid49),
                ((UniformsLib, $__.os.oid110).fog, $__.os.oid58),
                ((UniformsLib, $__.os.oid110).lights, $__.os.oid102),
                $__.os.oid177 = {
                    'emissive': $__.os.oid174 = {
                        'value': new (Color, $__.fs.Color_57)(0, 9, true, $__.uid)
                    },
                    'specular': $__.os.oid175 = {
                        'value': new (Color, $__.fs.Color_57)(1118481, 10, true, $__.uid)
                    },
                    'shininess': $__.os.oid176 = {
                        'value': 30
                    }
                }
            ], 2, true, $__.uid)),
            'vertexShader': TAJS_restrictToType((ShaderChunk, $__.os.oid18).meshphong_vert, 'string'),
            'fragmentShader': TAJS_restrictToType((ShaderChunk, $__.os.oid18).meshphong_frag, 'string')
        },
        'standard': $__.os.oid291 = {
            'uniforms': (vvv_tmp7 = ((exports, $__.os.oid0).UniformsUtils, $__.os.oid17), 'merge', $__.fs.J$__v494107025_796_599.call(vvv_tmp7, [
                ((UniformsLib, $__.os.oid110).common, $__.os.oid31),
                ((UniformsLib, $__.os.oid110).aomap, $__.os.oid34),
                ((UniformsLib, $__.os.oid110).lightmap, $__.os.oid37),
                ((UniformsLib, $__.os.oid110).emissivemap, $__.os.oid39),
                ((UniformsLib, $__.os.oid110).bumpmap, $__.os.oid42),
                ((UniformsLib, $__.os.oid110).normalmap, $__.os.oid45),
                ((UniformsLib, $__.os.oid110).displacementmap, $__.os.oid49),
                ((UniformsLib, $__.os.oid110).roughnessmap, $__.os.oid51),
                ((UniformsLib, $__.os.oid110).metalnessmap, $__.os.oid53),
                ((UniformsLib, $__.os.oid110).fog, $__.os.oid58),
                ((UniformsLib, $__.os.oid110).lights, $__.os.oid102),
                $__.os.oid234 = {
                    'emissive': $__.os.oid230 = {
                        'value': new (Color, $__.fs.Color_57)(0, 15, true, $__.uid)
                    },
                    'roughness': $__.os.oid231 = {
                        'value': 0.5
                    },
                    'metalness': $__.os.oid232 = {
                        'value': 0
                    },
                    'envMapIntensity': $__.os.oid233 = {
                        'value': 1
                    }
                }
            ], 3, true, $__.uid)),
            'vertexShader': TAJS_restrictToType((ShaderChunk, $__.os.oid18).meshphysical_vert, 'string'),
            'fragmentShader': TAJS_restrictToType((ShaderChunk, $__.os.oid18).meshphysical_frag, 'string')
        },
        'points': $__.os.oid305 = {
            'uniforms': (vvv_tmp8 = ((exports, $__.os.oid0).UniformsUtils, $__.os.oid17), 'merge', $__.fs.J$__v494107025_796_599.call(vvv_tmp8, [
                ((UniformsLib, $__.os.oid110).points, $__.os.oid109),
                ((UniformsLib, $__.os.oid110).fog, $__.os.oid58)
            ], 4, true, $__.uid)),
            'vertexShader': TAJS_restrictToType((ShaderChunk, $__.os.oid18).points_vert, 'string'),
            'fragmentShader': TAJS_restrictToType((ShaderChunk, $__.os.oid18).points_frag, 'string')
        },
        'dashed': $__.os.oid331 = {
            'uniforms': (vvv_tmp9 = ((exports, $__.os.oid0).UniformsUtils, $__.os.oid17), 'merge', $__.fs.J$__v494107025_796_599.call(vvv_tmp9, [
                ((UniformsLib, $__.os.oid110).common, $__.os.oid31),
                ((UniformsLib, $__.os.oid110).fog, $__.os.oid58),
                $__.os.oid309 = {
                    'scale': $__.os.oid306 = {
                        'value': 1
                    },
                    'dashSize': $__.os.oid307 = {
                        'value': 1
                    },
                    'totalSize': $__.os.oid308 = {
                        'value': 2
                    }
                }
            ], 5, true, $__.uid)),
            'vertexShader': TAJS_restrictToType((ShaderChunk, $__.os.oid18).linedashed_vert, 'string'),
            'fragmentShader': TAJS_restrictToType((ShaderChunk, $__.os.oid18).linedashed_frag, 'string')
        },
        'depth': $__.os.oid348 = {
            'uniforms': (vvv_tmp10 = ((exports, $__.os.oid0).UniformsUtils, $__.os.oid17), 'merge', $__.fs.J$__v494107025_796_599.call(vvv_tmp10, [
                ((UniformsLib, $__.os.oid110).common, $__.os.oid31),
                ((UniformsLib, $__.os.oid110).displacementmap, $__.os.oid49)
            ], 6, true, $__.uid)),
            'vertexShader': TAJS_restrictToType((ShaderChunk, $__.os.oid18).depth_vert, 'string'),
            'fragmentShader': TAJS_restrictToType((ShaderChunk, $__.os.oid18).depth_frag, 'string')
        },
        'normal': $__.os.oid351 = {
            'uniforms': $__.os.oid350 = {
                'opacity': $__.os.oid349 = {
                    'value': 1
                }
            },
            'vertexShader': TAJS_restrictToType((ShaderChunk, $__.os.oid18).normal_vert, 'string'),
            'fragmentShader': TAJS_restrictToType((ShaderChunk, $__.os.oid18).normal_frag, 'string')
        },
        'cube': $__.os.oid356 = {
            'uniforms': $__.os.oid355 = {
                'tCube': $__.os.oid352 = {
                    'value': null
                },
                'tFlip': $__.os.oid353 = {
                    'value': -1
                },
                'opacity': $__.os.oid354 = {
                    'value': 1
                }
            },
            'vertexShader': TAJS_restrictToType((ShaderChunk, $__.os.oid18).cube_vert, 'string'),
            'fragmentShader': TAJS_restrictToType((ShaderChunk, $__.os.oid18).cube_frag, 'string')
        },
        'equirect': $__.os.oid360 = {
            'uniforms': $__.os.oid359 = {
                'tEquirect': $__.os.oid357 = {
                    'value': null
                },
                'tFlip': $__.os.oid358 = {
                    'value': -1
                }
            },
            'vertexShader': TAJS_restrictToType((ShaderChunk, $__.os.oid18).equirect_vert, 'string'),
            'fragmentShader': TAJS_restrictToType((ShaderChunk, $__.os.oid18).equirect_frag, 'string')
        },
        'distanceRGBA': $__.os.oid363 = {
            'uniforms': $__.os.oid362 = {
                'lightPos': $__.os.oid361 = {
                    'value': new (Vector3, $__.fs.Vector3_11)(0, true, $__.uid)
                }
            },
            'vertexShader': TAJS_restrictToType((ShaderChunk, $__.os.oid18).distanceRGBA_vert, 'string'),
            'fragmentShader': TAJS_restrictToType((ShaderChunk, $__.os.oid18).distanceRGBA_frag, 'string')
        }
    };
    (ShaderLib, $__.os.oid364).physical = $__.os.oid416 = {
        'uniforms': (vvv_tmp11 = ((exports, $__.os.oid0).UniformsUtils, $__.os.oid17), 'merge', $__.fs.J$__v494107025_796_599.call(vvv_tmp11, [
            ((((ShaderLib, $__.os.oid364).standard, $__.os.oid291), $__.os.oid291).uniforms, $__.os.oid235),
            $__.os.oid367 = {
                'clearCoat': $__.os.oid365 = {
                    'value': 0
                },
                'clearCoatRoughness': $__.os.oid366 = {
                    'value': 0
                }
            }
        ], 7, true, $__.uid)),
        'vertexShader': TAJS_restrictToType((ShaderChunk, $__.os.oid18).meshphysical_vert, 'string'),
        'fragmentShader': TAJS_restrictToType((ShaderChunk, $__.os.oid18).meshphysical_frag, 'string')
    };
    MeshDepthMaterial.prototype = Object['create']((Material.prototype, $__.os.oid16));
    TAJS_restrictToType(MeshDepthMaterial.prototype, 'object').constructor = MeshDepthMaterial;
    TAJS_restrictToType(MeshDepthMaterial.prototype, 'object').isMeshDepthMaterial = true;
    TAJS_restrictToType(MeshDepthMaterial.prototype, 'object').copy = ($__.fs.J$__v494107025_866_633 = function J$__v494107025_866(source) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
source = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
Material.prototype.copy.call(this, source);
this.depthPacking = source.depthPacking;
this.skinning = source.skinning;
this.morphTargets = source.morphTargets;
this.map = source.map;
this.alphaMap = source.alphaMap;
this.displacementMap = source.displacementMap;
this.displacementScale = source.displacementScale;
this.displacementBias = source.displacementBias;
this.wireframe = source.wireframe;
this.wireframeLinewidth = source.wireframeLinewidth;
return this;});
    Box3.prototype = $__.os.oid417 = {
        'constructor': Box3,
        'isBox3': true,
        'set': ($__.fs.J$__v494107025_869_634 = function J$__v494107025_869(min, max) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
min = arguments[0], max = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.min.copy(min);
this.max.copy(max);
return this;}),
        'setFromArray': ($__.fs.J$__v494107025_871_635 = function J$__v494107025_871(array) {
var vvv_return, vvv_switch, minX, minY, minZ, maxX, maxY, maxZ, x, y, z;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
array = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
minX = +Infinity;
minY = +Infinity;
minZ = +Infinity;
maxX = -Infinity;
maxY = -Infinity;
maxZ = -Infinity;
for (var i = 0, l = array.length; i < l; i += 3) {
    x = array[i];
    y = array[i + 1];
    z = array[i + 2];
    if (x < minX)
        minX = x;
    if (y < minY)
        minY = y;
    if (z < minZ)
        minZ = z;
    if (x > maxX)
        maxX = x;
    if (y > maxY)
        maxY = y;
    if (z > maxZ)
        maxZ = z;
}
this.min.set(minX, minY, minZ);
this.max.set(maxX, maxY, maxZ);}),
        'setFromPoints': ($__.fs.J$__v494107025_873_636 = function J$__v494107025_873(points) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
points = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.makeEmpty();
for (var i = 0, il = points.length; i < il; i++) {
    this.expandByPoint(points[i]);
}
return this;}),
        'setFromCenterAndSize': (($__.fs.J$__v494107025_876_637 = function J$__v494107025_876() {
var vvv_return, vvv_switch, v1;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    v1 = new (Vector3, $__.fs.Vector3_11)(1, true, $__.uid);
    return ($__.fs.setFromCenterAndSize_638 = function setFromCenterAndSize(center, size) {
var vvv_return, vvv_switch, halfSize;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
center = arguments[0], size = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
halfSize = v1.copy(size).multiplyScalar(0.5);
this.min.copy(center).sub(halfSize);
this.max.copy(center).add(halfSize);
return this;});
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
v1 = new Vector3();
return function setFromCenterAndSize(center, size) {
    var halfSize = v1.copy(size).multiplyScalar(0.5);
    this.min.copy(center).sub(halfSize);
    this.max.copy(center).add(halfSize);
    return this;
};}), $__.fs.J$__v494107025_876_637)(0, true, $__.uid),
        'setFromObject': (($__.fs.J$__v494107025_881_639 = function J$__v494107025_881() {
var vvv_return, vvv_switch, v1;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    v1 = new (Vector3, $__.fs.Vector3_11)(2, true, $__.uid);
    return ($__.fs.setFromObject_640 = function setFromObject(object) {
var vvv_return, vvv_switch, scope;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
object = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
scope = this;
object.updateMatrixWorld(true);
this.makeEmpty();
object.traverse(function (node) {
    var geometry = node.geometry;
    if (geometry !== undefined) {
        if (geometry && geometry.isGeometry) {
            var vertices = geometry.vertices;
            for (var i = 0, il = vertices.length; i < il; i++) {
                v1.copy(vertices[i]);
                v1.applyMatrix4(node.matrixWorld);
                scope.expandByPoint(v1);
            }
        } else if (geometry && geometry.isBufferGeometry) {
            var attribute = geometry.attributes.position;
            if (attribute !== undefined) {
                var array, offset, stride;
                if (attribute && attribute.isInterleavedBufferAttribute) {
                    array = attribute.data.array;
                    offset = attribute.offset;
                    stride = attribute.data.stride;
                } else {
                    array = attribute.array;
                    offset = 0;
                    stride = 3;
                }
                for (var i = offset, il = array.length; i < il; i += stride) {
                    v1.fromArray(array, i);
                    v1.applyMatrix4(node.matrixWorld);
                    scope.expandByPoint(v1);
                }
            }
        }
    }
});
return this;});
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
v1 = new Vector3();
return function setFromObject(object) {
    var scope = this;
    object.updateMatrixWorld(true);
    this.makeEmpty();
    object.traverse(function (node) {
        var geometry = node.geometry;
        if (geometry !== undefined) {
            if (geometry && geometry.isGeometry) {
                var vertices = geometry.vertices;
                for (var i = 0, il = vertices.length; i < il; i++) {
                    v1.copy(vertices[i]);
                    v1.applyMatrix4(node.matrixWorld);
                    scope.expandByPoint(v1);
                }
            } else if (geometry && geometry.isBufferGeometry) {
                var attribute = geometry.attributes.position;
                if (attribute !== undefined) {
                    var array, offset, stride;
                    if (attribute && attribute.isInterleavedBufferAttribute) {
                        array = attribute.data.array;
                        offset = attribute.offset;
                        stride = attribute.data.stride;
                    } else {
                        array = attribute.array;
                        offset = 0;
                        stride = 3;
                    }
                    for (var i = offset, il = array.length; i < il; i += stride) {
                        v1.fromArray(array, i);
                        v1.applyMatrix4(node.matrixWorld);
                        scope.expandByPoint(v1);
                    }
                }
            }
        }
    });
    return this;
};}), $__.fs.J$__v494107025_881_639)(0, true, $__.uid),
        'clone': ($__.fs.J$__v494107025_883_641 = function J$__v494107025_883() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return new this.constructor().copy(this);}),
        'copy': ($__.fs.J$__v494107025_885_642 = function J$__v494107025_885(box) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
box = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.min.copy(box.min);
this.max.copy(box.max);
return this;}),
        'makeEmpty': ($__.fs.J$__v494107025_887_643 = function J$__v494107025_887() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.min.x = this.min.y = this.min.z = +Infinity;
this.max.x = this.max.y = this.max.z = -Infinity;
return this;}),
        'isEmpty': ($__.fs.J$__v494107025_889_644 = function J$__v494107025_889() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;}),
        'center': ($__.fs.J$__v494107025_891_645 = function J$__v494107025_891(optionalTarget) {
var vvv_return, vvv_switch, result;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
optionalTarget = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
result = optionalTarget || new Vector3();
return result.addVectors(this.min, this.max).multiplyScalar(0.5);}),
        'size': ($__.fs.J$__v494107025_893_646 = function J$__v494107025_893(optionalTarget) {
var vvv_return, vvv_switch, result;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
optionalTarget = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
result = optionalTarget || new Vector3();
return result.subVectors(this.max, this.min);}),
        'expandByPoint': ($__.fs.J$__v494107025_895_647 = function J$__v494107025_895(point) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
point = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.min.min(point);
this.max.max(point);
return this;}),
        'expandByVector': ($__.fs.J$__v494107025_897_648 = function J$__v494107025_897(vector) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
vector = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.min.sub(vector);
this.max.add(vector);
return this;}),
        'expandByScalar': ($__.fs.J$__v494107025_899_649 = function J$__v494107025_899(scalar) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
scalar = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.min.addScalar(-scalar);
this.max.addScalar(scalar);
return this;}),
        'containsPoint': ($__.fs.J$__v494107025_901_650 = function J$__v494107025_901(point) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
point = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y || point.z < this.min.z || point.z > this.max.z) {
    return false;
}
return true;}),
        'containsBox': ($__.fs.J$__v494107025_903_651 = function J$__v494107025_903(box) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
box = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z) {
    return true;
}
return false;}),
        'getParameter': ($__.fs.J$__v494107025_905_652 = function J$__v494107025_905(point, optionalTarget) {
var vvv_return, vvv_switch, result;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
point = arguments[0], optionalTarget = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
result = optionalTarget || new Vector3();
return result.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y), (point.z - this.min.z) / (this.max.z - this.min.z));}),
        'intersectsBox': ($__.fs.J$__v494107025_907_653 = function J$__v494107025_907(box) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
box = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y || box.max.z < this.min.z || box.min.z > this.max.z) {
    return false;
}
return true;}),
        'intersectsSphere': (($__.fs.J$__v494107025_910_654 = function J$__v494107025_910() {
var vvv_return, vvv_switch, closestPoint;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    return ($__.fs.intersectsSphere_655 = function intersectsSphere(sphere) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
sphere = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (closestPoint === undefined)
    closestPoint = new Vector3();
this.clampPoint(sphere.center, closestPoint);
return closestPoint.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;});
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return function intersectsSphere(sphere) {
    if (closestPoint === undefined)
        closestPoint = new Vector3();
    this.clampPoint(sphere.center, closestPoint);
    return closestPoint.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;
};}), $__.fs.J$__v494107025_910_654)(0, true, $__.uid),
        'intersectsPlane': ($__.fs.J$__v494107025_912_656 = function J$__v494107025_912(plane) {
var vvv_return, vvv_switch, min, max;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
plane = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (plane.normal.x > 0) {
    min = plane.normal.x * this.min.x;
    max = plane.normal.x * this.max.x;
} else {
    min = plane.normal.x * this.max.x;
    max = plane.normal.x * this.min.x;
}
if (plane.normal.y > 0) {
    min += plane.normal.y * this.min.y;
    max += plane.normal.y * this.max.y;
} else {
    min += plane.normal.y * this.max.y;
    max += plane.normal.y * this.min.y;
}
if (plane.normal.z > 0) {
    min += plane.normal.z * this.min.z;
    max += plane.normal.z * this.max.z;
} else {
    min += plane.normal.z * this.max.z;
    max += plane.normal.z * this.min.z;
}
return min <= plane.constant && max >= plane.constant;}),
        'clampPoint': ($__.fs.J$__v494107025_914_657 = function J$__v494107025_914(point, optionalTarget) {
var vvv_return, vvv_switch, result;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
point = arguments[0], optionalTarget = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
result = optionalTarget || new Vector3();
return result.copy(point).clamp(this.min, this.max);}),
        'distanceToPoint': (($__.fs.J$__v494107025_917_658 = function J$__v494107025_917() {
var vvv_return, vvv_switch, v1;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    v1 = new (Vector3, $__.fs.Vector3_11)(3, true, $__.uid);
    return ($__.fs.distanceToPoint_659 = function distanceToPoint(point) {
var vvv_return, vvv_switch, clampedPoint;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
point = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
clampedPoint = v1.copy(point).clamp(this.min, this.max);
return clampedPoint.sub(point).length();});
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
v1 = new Vector3();
return function distanceToPoint(point) {
    var clampedPoint = v1.copy(point).clamp(this.min, this.max);
    return clampedPoint.sub(point).length();
};}), $__.fs.J$__v494107025_917_658)(0, true, $__.uid),
        'getBoundingSphere': (($__.fs.J$__v494107025_920_660 = function J$__v494107025_920() {
var vvv_return, vvv_switch, v1;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    v1 = new (Vector3, $__.fs.Vector3_11)(4, true, $__.uid);
    return ($__.fs.getBoundingSphere_661 = function getBoundingSphere(optionalTarget) {
var vvv_return, vvv_switch, result;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
optionalTarget = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
result = optionalTarget || new Sphere();
result.center = this.center();
result.radius = this.size(v1).length() * 0.5;
return result;});
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
v1 = new Vector3();
return function getBoundingSphere(optionalTarget) {
    var result = optionalTarget || new Sphere();
    result.center = this.center();
    result.radius = this.size(v1).length() * 0.5;
    return result;
};}), $__.fs.J$__v494107025_920_660)(0, true, $__.uid),
        'intersect': ($__.fs.J$__v494107025_922_662 = function J$__v494107025_922(box) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
box = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.min.max(box.min);
this.max.min(box.max);
if (this.isEmpty())
    this.makeEmpty();
return this;}),
        'union': ($__.fs.J$__v494107025_924_663 = function J$__v494107025_924(box) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
box = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.min.min(box.min);
this.max.max(box.max);
return this;}),
        'applyMatrix4': (($__.fs.J$__v494107025_927_664 = function J$__v494107025_927() {
var vvv_return, vvv_switch, points;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    points = [
        new (Vector3, $__.fs.Vector3_11)(5, true, $__.uid),
        new (Vector3, $__.fs.Vector3_11)(6, true, $__.uid),
        new (Vector3, $__.fs.Vector3_11)(7, true, $__.uid),
        new (Vector3, $__.fs.Vector3_11)(8, true, $__.uid),
        new (Vector3, $__.fs.Vector3_11)(9, true, $__.uid),
        new (Vector3, $__.fs.Vector3_11)(10, true, $__.uid),
        new (Vector3, $__.fs.Vector3_11)(11, true, $__.uid),
        new (Vector3, $__.fs.Vector3_11)(12, true, $__.uid)
    ];
    return ($__.fs.applyMatrix4_665 = function applyMatrix4(matrix) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
matrix = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (this.isEmpty())
    return this;
points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix);
points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix);
points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix);
points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix);
points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix);
points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix);
points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix);
points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix);
this.setFromPoints(points);
return this;});
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
points = [
    new Vector3(),
    new Vector3(),
    new Vector3(),
    new Vector3(),
    new Vector3(),
    new Vector3(),
    new Vector3(),
    new Vector3()
];
return function applyMatrix4(matrix) {
    if (this.isEmpty())
        return this;
    points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix);
    points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix);
    points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix);
    points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix);
    points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix);
    points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix);
    points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix);
    points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix);
    this.setFromPoints(points);
    return this;
};}), $__.fs.J$__v494107025_927_664)(0, true, $__.uid),
        'translate': ($__.fs.J$__v494107025_929_666 = function J$__v494107025_929(offset) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
offset = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.min.add(offset);
this.max.add(offset);
return this;}),
        'equals': ($__.fs.J$__v494107025_931_667 = function J$__v494107025_931(box) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
box = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return box.min.equals(this.min) && box.max.equals(this.max);})
    };
    Sphere.prototype = $__.os.oid418 = {
        'constructor': Sphere,
        'set': ($__.fs.J$__v494107025_934_668 = function J$__v494107025_934(center, radius) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
center = arguments[0], radius = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.center.copy(center);
this.radius = radius;
return this;}),
        'setFromPoints': (($__.fs.J$__v494107025_937_669 = function J$__v494107025_937() {
var vvv_return, vvv_switch, box;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    box = new (Box3, $__.fs.Box3_59)(0, true, $__.uid);
    return ($__.fs.setFromPoints_670 = function setFromPoints(points, optionalCenter) {
var vvv_return, vvv_switch, center, maxRadiusSq;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
points = arguments[0], optionalCenter = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
center = this.center;
if (optionalCenter !== undefined) {
    center.copy(optionalCenter);
} else {
    box.setFromPoints(points).center(center);
}
maxRadiusSq = 0;
for (var i = 0, il = points.length; i < il; i++) {
    maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i]));
}
this.radius = Math.sqrt(maxRadiusSq);
return this;});
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
box = new Box3();
return function setFromPoints(points, optionalCenter) {
    var center = this.center;
    if (optionalCenter !== undefined) {
        center.copy(optionalCenter);
    } else {
        box.setFromPoints(points).center(center);
    }
    var maxRadiusSq = 0;
    for (var i = 0, il = points.length; i < il; i++) {
        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i]));
    }
    this.radius = Math.sqrt(maxRadiusSq);
    return this;
};}), $__.fs.J$__v494107025_937_669)(0, true, $__.uid),
        'clone': ($__.fs.J$__v494107025_939_671 = function J$__v494107025_939() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return new this.constructor().copy(this);}),
        'copy': ($__.fs.J$__v494107025_941_672 = function J$__v494107025_941(sphere) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
sphere = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.center.copy(sphere.center);
this.radius = sphere.radius;
return this;}),
        'empty': ($__.fs.J$__v494107025_943_673 = function J$__v494107025_943() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return this.radius <= 0;}),
        'containsPoint': ($__.fs.J$__v494107025_945_674 = function J$__v494107025_945(point) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
point = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return point.distanceToSquared(this.center) <= this.radius * this.radius;}),
        'distanceToPoint': ($__.fs.J$__v494107025_947_675 = function J$__v494107025_947(point) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
point = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return point.distanceTo(this.center) - this.radius;}),
        'intersectsSphere': ($__.fs.J$__v494107025_949_676 = function J$__v494107025_949(sphere) {
var vvv_return, vvv_switch, radiusSum;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
sphere = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
radiusSum = this.radius + sphere.radius;
return sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum;}),
        'intersectsBox': ($__.fs.J$__v494107025_951_677 = function J$__v494107025_951(box) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
box = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return box.intersectsSphere(this);}),
        'intersectsPlane': ($__.fs.J$__v494107025_953_678 = function J$__v494107025_953(plane) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
plane = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return Math.abs(this.center.dot(plane.normal) - plane.constant) <= this.radius;}),
        'clampPoint': ($__.fs.J$__v494107025_955_679 = function J$__v494107025_955(point, optionalTarget) {
var vvv_return, vvv_switch, deltaLengthSq, result;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
point = arguments[0], optionalTarget = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
deltaLengthSq = this.center.distanceToSquared(point);
result = optionalTarget || new Vector3();
result.copy(point);
if (deltaLengthSq > this.radius * this.radius) {
    result.sub(this.center).normalize();
    result.multiplyScalar(this.radius).add(this.center);
}
return result;}),
        'getBoundingBox': ($__.fs.J$__v494107025_957_680 = function J$__v494107025_957(optionalTarget) {
var vvv_return, vvv_switch, box;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
optionalTarget = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
box = optionalTarget || new Box3();
box.set(this.center, this.center);
box.expandByScalar(this.radius);
return box;}),
        'applyMatrix4': ($__.fs.J$__v494107025_959_681 = function J$__v494107025_959(matrix) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
matrix = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.center.applyMatrix4(matrix);
this.radius = this.radius * matrix.getMaxScaleOnAxis();
return this;}),
        'translate': ($__.fs.J$__v494107025_961_682 = function J$__v494107025_961(offset) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
offset = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.center.add(offset);
return this;}),
        'equals': ($__.fs.J$__v494107025_963_683 = function J$__v494107025_963(sphere) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
sphere = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return sphere.center.equals(this.center) && sphere.radius === this.radius;})
    };
    Matrix3.prototype = $__.os.oid419 = {
        'constructor': Matrix3,
        'isMatrix3': true,
        'set': ($__.fs.J$__v494107025_966_684 = function J$__v494107025_966(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
var vvv_return, vvv_switch, te;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
n11 = arguments[0], n12 = arguments[1], n13 = arguments[2], n21 = arguments[3], n22 = arguments[4], n23 = arguments[5], n31 = arguments[6], n32 = arguments[7], n33 = arguments[8];
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    te = TAJS_restrictToType(this.elements, 'object');
    te[0, 0] = n11;
    te[1, 1] = n21;
    te[2, 2] = n31;
    te[3, 3] = n12;
    te[4, 4] = n22;
    te[5, 5] = n32;
    te[6, 6] = n13;
    te[7, 7] = n23;
    te[8, 8] = n33;
    return this;
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
te = this.elements;
te[0] = n11;
te[1] = n21;
te[2] = n31;
te[3] = n12;
te[4] = n22;
te[5] = n32;
te[6] = n13;
te[7] = n23;
te[8] = n33;
return this;}),
        'identity': ($__.fs.J$__v494107025_968_685 = function J$__v494107025_968() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);
return this;}),
        'clone': ($__.fs.J$__v494107025_970_686 = function J$__v494107025_970() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return new this.constructor().fromArray(this.elements);}),
        'copy': ($__.fs.J$__v494107025_972_687 = function J$__v494107025_972(m) {
var vvv_return, vvv_switch, me;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
m = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
me = m.elements;
this.set(me[0], me[3], me[6], me[1], me[4], me[7], me[2], me[5], me[8]);
return this;}),
        'setFromMatrix4': ($__.fs.J$__v494107025_974_688 = function J$__v494107025_974(m) {
var vvv_return, vvv_switch, vvv_tmp0, me;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
m = arguments[0];
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    me = TAJS_restrictToType(m.elements, 'object');
    vvv_tmp0 = this, 'set', $__.fs.J$__v494107025_966_684.call(vvv_tmp0, (me[0, 0], 1), (me[4, 4], 0), (me[8, 8], 0), (me[1, 1], 0), (me[5, 5], 1), (me[9, 9], 0), (me[2, 2], 0), (me[6, 6], 0), (me[10, 10], 1), 0, true, $__.uid);
    return this;
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
me = m.elements;
this.set(me[0], me[4], me[8], me[1], me[5], me[9], me[2], me[6], me[10]);
return this;}),
        'applyToVector3Array': (($__.fs.J$__v494107025_977_689 = function J$__v494107025_977() {
var vvv_return, vvv_switch, v1;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    return ($__.fs.applyToVector3Array_690 = function applyToVector3Array(array, offset, length) {
var vvv_return, vvv_switch, vvv_tmp0, vvv_tmp1, vvv_tmp2, vvv_tmp3, vvv_tmp4, vvv_tmp5, vvv_tmp6, vvv_tmp7, vvv_tmp8, vvv_tmp9, vvv_tmp10, vvv_tmp11, vvv_tmp12, vvv_tmp13, vvv_tmp14, vvv_tmp15, vvv_tmp16, vvv_tmp17, vvv_tmp18, vvv_tmp19, vvv_tmp20, vvv_tmp21, vvv_tmp22, vvv_tmp23, vvv_tmp24, vvv_tmp25, vvv_tmp26, vvv_tmp27, vvv_tmp28, vvv_tmp29, vvv_tmp30, vvv_tmp31, vvv_tmp32, vvv_tmp33, vvv_tmp34, vvv_tmp35, vvv_tmp36, vvv_tmp37, vvv_tmp38, vvv_tmp39, vvv_tmp40, vvv_tmp41, vvv_tmp42, vvv_tmp43, vvv_tmp44, vvv_tmp45, vvv_tmp46, vvv_tmp47, vvv_tmp48, vvv_tmp49, vvv_tmp50, vvv_tmp51, vvv_tmp52, vvv_tmp53, vvv_tmp54, vvv_tmp55, vvv_tmp56, vvv_tmp57, vvv_tmp58, vvv_tmp59, vvv_tmp60, vvv_tmp61, vvv_tmp62, vvv_tmp63, vvv_tmp64, vvv_tmp65, vvv_tmp66, vvv_tmp67, vvv_tmp68, i, j;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
array = arguments[0], offset = arguments[1], length = arguments[2];
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    v1 === undefined;
    v1 = new (Vector3, $__.fs.Vector3_11)(103, true, $__.uid);
    offset === undefined;
    offset = 0;
    length === undefined;
    length = (array.length, 69);
    i = 0;
    j = offset;
    i < length;
    vvv_tmp0 = v1, 'fromArray', $__.fs.J$__v494107025_466_506.call(vvv_tmp0, array, j, 23, true, $__.uid);
    vvv_tmp1 = v1, 'applyMatrix3', $__.fs.J$__v494107025_379_460.call(vvv_tmp1, this, 0, true, $__.uid);
    vvv_tmp2 = v1, 'toArray', $__.fs.J$__v494107025_468_507.call(vvv_tmp2, array, j, 23, true, $__.uid);
    i = i + 3, j = j + 3;
    i < length;
    vvv_tmp3 = v1, 'fromArray', $__.fs.J$__v494107025_466_506.call(vvv_tmp3, array, j, 24, true, $__.uid);
    vvv_tmp4 = v1, 'applyMatrix3', $__.fs.J$__v494107025_379_460.call(vvv_tmp4, this, 1, true, $__.uid);
    vvv_tmp5 = v1, 'toArray', $__.fs.J$__v494107025_468_507.call(vvv_tmp5, array, j, 24, true, $__.uid);
    i = i + 3, j = j + 3;
    i < length;
    vvv_tmp6 = v1, 'fromArray', $__.fs.J$__v494107025_466_506.call(vvv_tmp6, array, j, 25, true, $__.uid);
    vvv_tmp7 = v1, 'applyMatrix3', $__.fs.J$__v494107025_379_460.call(vvv_tmp7, this, 2, true, $__.uid);
    vvv_tmp8 = v1, 'toArray', $__.fs.J$__v494107025_468_507.call(vvv_tmp8, array, j, 25, true, $__.uid);
    i = i + 3, j = j + 3;
    i < length;
    vvv_tmp9 = v1, 'fromArray', $__.fs.J$__v494107025_466_506.call(vvv_tmp9, array, j, 26, true, $__.uid);
    vvv_tmp10 = v1, 'applyMatrix3', $__.fs.J$__v494107025_379_460.call(vvv_tmp10, this, 3, true, $__.uid);
    vvv_tmp11 = v1, 'toArray', $__.fs.J$__v494107025_468_507.call(vvv_tmp11, array, j, 26, true, $__.uid);
    i = i + 3, j = j + 3;
    i < length;
    vvv_tmp12 = v1, 'fromArray', $__.fs.J$__v494107025_466_506.call(vvv_tmp12, array, j, 27, true, $__.uid);
    vvv_tmp13 = v1, 'applyMatrix3', $__.fs.J$__v494107025_379_460.call(vvv_tmp13, this, 4, true, $__.uid);
    vvv_tmp14 = v1, 'toArray', $__.fs.J$__v494107025_468_507.call(vvv_tmp14, array, j, 27, true, $__.uid);
    i = i + 3, j = j + 3;
    i < length;
    vvv_tmp15 = v1, 'fromArray', $__.fs.J$__v494107025_466_506.call(vvv_tmp15, array, j, 28, true, $__.uid);
    vvv_tmp16 = v1, 'applyMatrix3', $__.fs.J$__v494107025_379_460.call(vvv_tmp16, this, 5, true, $__.uid);
    vvv_tmp17 = v1, 'toArray', $__.fs.J$__v494107025_468_507.call(vvv_tmp17, array, j, 28, true, $__.uid);
    i = i + 3, j = j + 3;
    i < length;
    vvv_tmp18 = v1, 'fromArray', $__.fs.J$__v494107025_466_506.call(vvv_tmp18, array, j, 29, true, $__.uid);
    vvv_tmp19 = v1, 'applyMatrix3', $__.fs.J$__v494107025_379_460.call(vvv_tmp19, this, 6, true, $__.uid);
    vvv_tmp20 = v1, 'toArray', $__.fs.J$__v494107025_468_507.call(vvv_tmp20, array, j, 29, true, $__.uid);
    i = i + 3, j = j + 3;
    i < length;
    vvv_tmp21 = v1, 'fromArray', $__.fs.J$__v494107025_466_506.call(vvv_tmp21, array, j, 30, true, $__.uid);
    vvv_tmp22 = v1, 'applyMatrix3', $__.fs.J$__v494107025_379_460.call(vvv_tmp22, this, 7, true, $__.uid);
    vvv_tmp23 = v1, 'toArray', $__.fs.J$__v494107025_468_507.call(vvv_tmp23, array, j, 30, true, $__.uid);
    i = i + 3, j = j + 3;
    i < length;
    vvv_tmp24 = v1, 'fromArray', $__.fs.J$__v494107025_466_506.call(vvv_tmp24, array, j, 31, true, $__.uid);
    vvv_tmp25 = v1, 'applyMatrix3', $__.fs.J$__v494107025_379_460.call(vvv_tmp25, this, 8, true, $__.uid);
    vvv_tmp26 = v1, 'toArray', $__.fs.J$__v494107025_468_507.call(vvv_tmp26, array, j, 31, true, $__.uid);
    i = i + 3, j = j + 3;
    i < length;
    vvv_tmp27 = v1, 'fromArray', $__.fs.J$__v494107025_466_506.call(vvv_tmp27, array, j, 32, true, $__.uid);
    vvv_tmp28 = v1, 'applyMatrix3', $__.fs.J$__v494107025_379_460.call(vvv_tmp28, this, 9, true, $__.uid);
    vvv_tmp29 = v1, 'toArray', $__.fs.J$__v494107025_468_507.call(vvv_tmp29, array, j, 32, true, $__.uid);
    i = i + 3, j = j + 3;
    i < length;
    vvv_tmp30 = v1, 'fromArray', $__.fs.J$__v494107025_466_506.call(vvv_tmp30, array, j, 33, true, $__.uid);
    vvv_tmp31 = v1, 'applyMatrix3', $__.fs.J$__v494107025_379_460.call(vvv_tmp31, this, 10, true, $__.uid);
    vvv_tmp32 = v1, 'toArray', $__.fs.J$__v494107025_468_507.call(vvv_tmp32, array, j, 33, true, $__.uid);
    i = i + 3, j = j + 3;
    i < length;
    vvv_tmp33 = v1, 'fromArray', $__.fs.J$__v494107025_466_506.call(vvv_tmp33, array, j, 34, true, $__.uid);
    vvv_tmp34 = v1, 'applyMatrix3', $__.fs.J$__v494107025_379_460.call(vvv_tmp34, this, 11, true, $__.uid);
    vvv_tmp35 = v1, 'toArray', $__.fs.J$__v494107025_468_507.call(vvv_tmp35, array, j, 34, true, $__.uid);
    i = i + 3, j = j + 3;
    i < length;
    vvv_tmp36 = v1, 'fromArray', $__.fs.J$__v494107025_466_506.call(vvv_tmp36, array, j, 35, true, $__.uid);
    vvv_tmp37 = v1, 'applyMatrix3', $__.fs.J$__v494107025_379_460.call(vvv_tmp37, this, 12, true, $__.uid);
    vvv_tmp38 = v1, 'toArray', $__.fs.J$__v494107025_468_507.call(vvv_tmp38, array, j, 35, true, $__.uid);
    i = i + 3, j = j + 3;
    i < length;
    vvv_tmp39 = v1, 'fromArray', $__.fs.J$__v494107025_466_506.call(vvv_tmp39, array, j, 36, true, $__.uid);
    vvv_tmp40 = v1, 'applyMatrix3', $__.fs.J$__v494107025_379_460.call(vvv_tmp40, this, 13, true, $__.uid);
    vvv_tmp41 = v1, 'toArray', $__.fs.J$__v494107025_468_507.call(vvv_tmp41, array, j, 36, true, $__.uid);
    i = i + 3, j = j + 3;
    i < length;
    vvv_tmp42 = v1, 'fromArray', $__.fs.J$__v494107025_466_506.call(vvv_tmp42, array, j, 37, true, $__.uid);
    vvv_tmp43 = v1, 'applyMatrix3', $__.fs.J$__v494107025_379_460.call(vvv_tmp43, this, 14, true, $__.uid);
    vvv_tmp44 = v1, 'toArray', $__.fs.J$__v494107025_468_507.call(vvv_tmp44, array, j, 37, true, $__.uid);
    i = i + 3, j = j + 3;
    i < length;
    vvv_tmp45 = v1, 'fromArray', $__.fs.J$__v494107025_466_506.call(vvv_tmp45, array, j, 38, true, $__.uid);
    vvv_tmp46 = v1, 'applyMatrix3', $__.fs.J$__v494107025_379_460.call(vvv_tmp46, this, 15, true, $__.uid);
    vvv_tmp47 = v1, 'toArray', $__.fs.J$__v494107025_468_507.call(vvv_tmp47, array, j, 38, true, $__.uid);
    i = i + 3, j = j + 3;
    i < length;
    vvv_tmp48 = v1, 'fromArray', $__.fs.J$__v494107025_466_506.call(vvv_tmp48, array, j, 39, true, $__.uid);
    vvv_tmp49 = v1, 'applyMatrix3', $__.fs.J$__v494107025_379_460.call(vvv_tmp49, this, 16, true, $__.uid);
    vvv_tmp50 = v1, 'toArray', $__.fs.J$__v494107025_468_507.call(vvv_tmp50, array, j, 39, true, $__.uid);
    i = i + 3, j = j + 3;
    i < length;
    vvv_tmp51 = v1, 'fromArray', $__.fs.J$__v494107025_466_506.call(vvv_tmp51, array, j, 40, true, $__.uid);
    vvv_tmp52 = v1, 'applyMatrix3', $__.fs.J$__v494107025_379_460.call(vvv_tmp52, this, 17, true, $__.uid);
    vvv_tmp53 = v1, 'toArray', $__.fs.J$__v494107025_468_507.call(vvv_tmp53, array, j, 40, true, $__.uid);
    i = i + 3, j = j + 3;
    i < length;
    vvv_tmp54 = v1, 'fromArray', $__.fs.J$__v494107025_466_506.call(vvv_tmp54, array, j, 41, true, $__.uid);
    vvv_tmp55 = v1, 'applyMatrix3', $__.fs.J$__v494107025_379_460.call(vvv_tmp55, this, 18, true, $__.uid);
    vvv_tmp56 = v1, 'toArray', $__.fs.J$__v494107025_468_507.call(vvv_tmp56, array, j, 41, true, $__.uid);
    i = i + 3, j = j + 3;
    i < length;
    vvv_tmp57 = v1, 'fromArray', $__.fs.J$__v494107025_466_506.call(vvv_tmp57, array, j, 42, true, $__.uid);
    vvv_tmp58 = v1, 'applyMatrix3', $__.fs.J$__v494107025_379_460.call(vvv_tmp58, this, 19, true, $__.uid);
    vvv_tmp59 = v1, 'toArray', $__.fs.J$__v494107025_468_507.call(vvv_tmp59, array, j, 42, true, $__.uid);
    i = i + 3, j = j + 3;
    i < length;
    vvv_tmp60 = v1, 'fromArray', $__.fs.J$__v494107025_466_506.call(vvv_tmp60, array, j, 43, true, $__.uid);
    vvv_tmp61 = v1, 'applyMatrix3', $__.fs.J$__v494107025_379_460.call(vvv_tmp61, this, 20, true, $__.uid);
    vvv_tmp62 = v1, 'toArray', $__.fs.J$__v494107025_468_507.call(vvv_tmp62, array, j, 43, true, $__.uid);
    i = i + 3, j = j + 3;
    i < length;
    vvv_tmp63 = v1, 'fromArray', $__.fs.J$__v494107025_466_506.call(vvv_tmp63, array, j, 44, true, $__.uid);
    vvv_tmp64 = v1, 'applyMatrix3', $__.fs.J$__v494107025_379_460.call(vvv_tmp64, this, 21, true, $__.uid);
    vvv_tmp65 = v1, 'toArray', $__.fs.J$__v494107025_468_507.call(vvv_tmp65, array, j, 44, true, $__.uid);
    i = i + 3, j = j + 3;
    i < length;
    vvv_tmp66 = v1, 'fromArray', $__.fs.J$__v494107025_466_506.call(vvv_tmp66, array, j, 45, true, $__.uid);
    vvv_tmp67 = v1, 'applyMatrix3', $__.fs.J$__v494107025_379_460.call(vvv_tmp67, this, 22, true, $__.uid);
    vvv_tmp68 = v1, 'toArray', $__.fs.J$__v494107025_468_507.call(vvv_tmp68, array, j, 45, true, $__.uid);
    i = i + 3, j = j + 3;
    i < length;
    return array;
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (v1 === undefined)
    v1 = new Vector3();
if (offset === undefined)
    offset = 0;
if (length === undefined)
    length = array.length;
for (var i = 0, j = offset; i < length; i += 3, j += 3) {
    v1.fromArray(array, j);
    v1.applyMatrix3(this);
    v1.toArray(array, j);
}
return array;});
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return function applyToVector3Array(array, offset, length) {
    if (v1 === undefined)
        v1 = new Vector3();
    if (offset === undefined)
        offset = 0;
    if (length === undefined)
        length = array.length;
    for (var i = 0, j = offset; i < length; i += 3, j += 3) {
        v1.fromArray(array, j);
        v1.applyMatrix3(this);
        v1.toArray(array, j);
    }
    return array;
};}), $__.fs.J$__v494107025_977_689)(0, true, $__.uid),
        'applyToBuffer': (($__.fs.J$__v494107025_980_691 = function J$__v494107025_980() {
var vvv_return, vvv_switch, v1;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    return ($__.fs.applyToBuffer_692 = function applyToBuffer(buffer, offset, length) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
buffer = arguments[0], offset = arguments[1], length = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (v1 === undefined)
    v1 = new Vector3();
if (offset === undefined)
    offset = 0;
if (length === undefined)
    length = buffer.length / buffer.itemSize;
for (var i = 0, j = offset; i < length; i++, j++) {
    v1.x = buffer.getX(j);
    v1.y = buffer.getY(j);
    v1.z = buffer.getZ(j);
    v1.applyMatrix3(this);
    buffer.setXYZ(v1.x, v1.y, v1.z);
}
return buffer;});
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return function applyToBuffer(buffer, offset, length) {
    if (v1 === undefined)
        v1 = new Vector3();
    if (offset === undefined)
        offset = 0;
    if (length === undefined)
        length = buffer.length / buffer.itemSize;
    for (var i = 0, j = offset; i < length; i++, j++) {
        v1.x = buffer.getX(j);
        v1.y = buffer.getY(j);
        v1.z = buffer.getZ(j);
        v1.applyMatrix3(this);
        buffer.setXYZ(v1.x, v1.y, v1.z);
    }
    return buffer;
};}), $__.fs.J$__v494107025_980_691)(0, true, $__.uid),
        'multiplyScalar': ($__.fs.J$__v494107025_982_693 = function J$__v494107025_982(s) {
var vvv_return, vvv_switch, te;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
s = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
te = this.elements;
te[0] *= s;
te[3] *= s;
te[6] *= s;
te[1] *= s;
te[4] *= s;
te[7] *= s;
te[2] *= s;
te[5] *= s;
te[8] *= s;
return this;}),
        'determinant': ($__.fs.J$__v494107025_984_694 = function J$__v494107025_984() {
var vvv_return, vvv_switch, te, a, b, c, d, e, f, g, h, i;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
te = this.elements;
a = te[0];
b = te[1];
c = te[2];
d = te[3];
e = te[4];
f = te[5];
g = te[6];
h = te[7];
i = te[8];
return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;}),
        'getInverse': ($__.fs.J$__v494107025_986_695 = function J$__v494107025_986(matrix, throwOnDegenerate) {
var vvv_return, vvv_switch, me, te, n11, n21, n31, n12, n22, n32, n13, n23, n33, t11, t12, t13, det, msg, detInv;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
matrix = arguments[0], throwOnDegenerate = arguments[1];
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    matrix, TAJS_restrictToType(matrix.isMatrix4, 'undefined');
    me = TAJS_restrictToType(matrix.elements, 'object');
    te = TAJS_restrictToType(this.elements, 'object');
    n11 = (me[0, 0], 1);
    n21 = (me[1, 1], 0);
    n31 = (me[2, 2], 0);
    n12 = (me[3, 3], 0);
    n22 = (me[4, 4], 1);
    n32 = (me[5, 5], 0);
    n13 = (me[6, 6], 0);
    n23 = (me[7, 7], 0);
    n33 = (me[8, 8], 1);
    t11 = n33 * n22 - n32 * n23;
    t12 = n32 * n13 - n33 * n12;
    t13 = n23 * n12 - n22 * n13;
    det = n11 * t11 + n21 * t12 + n31 * t13;
    det === 0;
    detInv = 1 / det;
    te[0, 0] = t11 * detInv;
    te[1, 1] = (n31 * n23 - n33 * n21) * detInv;
    te[2, 2] = (n32 * n21 - n31 * n22) * detInv;
    te[3, 3] = t12 * detInv;
    te[4, 4] = (n33 * n11 - n31 * n13) * detInv;
    te[5, 5] = (n31 * n12 - n32 * n11) * detInv;
    te[6, 6] = t13 * detInv;
    te[7, 7] = (n21 * n13 - n23 * n11) * detInv;
    te[8, 8] = (n22 * n11 - n21 * n12) * detInv;
    return this;
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (matrix && matrix.isMatrix4) {
    console.error('THREE.Matrix3.getInverse no longer takes a Matrix4 argument.');
}
me = matrix.elements;
te = this.elements;
n11 = me[0];
n21 = me[1];
n31 = me[2];
n12 = me[3];
n22 = me[4];
n32 = me[5];
n13 = me[6];
n23 = me[7];
n33 = me[8];
t11 = n33 * n22 - n32 * n23;
t12 = n32 * n13 - n33 * n12;
t13 = n23 * n12 - n22 * n13;
det = n11 * t11 + n21 * t12 + n31 * t13;
if (det === 0) {
    msg = 'THREE.Matrix3.getInverse(): can\'t invert matrix, determinant is 0';
    if (throwOnDegenerate === true) {
        throw new Error(msg);
    } else {
        console.warn(msg);
    }
    return this.identity();
}
detInv = 1 / det;
te[0] = t11 * detInv;
te[1] = (n31 * n23 - n33 * n21) * detInv;
te[2] = (n32 * n21 - n31 * n22) * detInv;
te[3] = t12 * detInv;
te[4] = (n33 * n11 - n31 * n13) * detInv;
te[5] = (n31 * n12 - n32 * n11) * detInv;
te[6] = t13 * detInv;
te[7] = (n21 * n13 - n23 * n11) * detInv;
te[8] = (n22 * n11 - n21 * n12) * detInv;
return this;}),
        'transpose': ($__.fs.J$__v494107025_988_696 = function J$__v494107025_988() {
var vvv_return, vvv_switch, tmp, m;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    m = TAJS_restrictToType(this.elements, 'object');
    tmp = (m[1, 1], 0);
    m[1, 1] = (m[3, 3], 0);
    m[3, 3] = tmp;
    tmp = (m[2, 2], 0);
    m[2, 2] = (m[6, 6], 0);
    m[6, 6] = tmp;
    tmp = (m[5, 5], 0);
    m[5, 5] = (m[7, 7], 0);
    m[7, 7] = tmp;
    return this;
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
m = this.elements;
tmp = m[1];
m[1] = m[3];
m[3] = tmp;
tmp = m[2];
m[2] = m[6];
m[6] = tmp;
tmp = m[5];
m[5] = m[7];
m[7] = tmp;
return this;}),
        'flattenToArrayOffset': ($__.fs.J$__v494107025_990_697 = function J$__v494107025_990(array, offset) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
array = arguments[0], offset = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
console.warn('THREE.Matrix3: .flattenToArrayOffset is deprecated ' + '- just use .toArray instead.');
return this.toArray(array, offset);}),
        'getNormalMatrix': ($__.fs.J$__v494107025_992_698 = function J$__v494107025_992(matrix4) {
var vvv_return, vvv_switch, vvv_tmp0, vvv_tmp1, vvv_tmp2;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
matrix4 = arguments[0];
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    return vvv_tmp2 = (vvv_tmp1 = (vvv_tmp0 = this, 'setFromMatrix4', $__.fs.J$__v494107025_974_688.call(vvv_tmp0, matrix4, 0, true, $__.uid)), 'getInverse', $__.fs.J$__v494107025_986_695.call(vvv_tmp1, this, 0, true, $__.uid)), 'transpose', $__.fs.J$__v494107025_988_696.call(vvv_tmp2, 0, true, $__.uid);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return this.setFromMatrix4(matrix4).getInverse(this).transpose();}),
        'transposeIntoArray': ($__.fs.J$__v494107025_994_699 = function J$__v494107025_994(r) {
var vvv_return, vvv_switch, m;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
r = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
m = this.elements;
r[0] = m[0];
r[1] = m[3];
r[2] = m[6];
r[3] = m[1];
r[4] = m[4];
r[5] = m[7];
r[6] = m[2];
r[7] = m[5];
r[8] = m[8];
return this;}),
        'fromArray': ($__.fs.J$__v494107025_996_700 = function J$__v494107025_996(array) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
array = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.elements.set(array);
return this;}),
        'toArray': ($__.fs.J$__v494107025_998_701 = function J$__v494107025_998(array, offset) {
var vvv_return, vvv_switch, te;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
array = arguments[0], offset = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (array === undefined)
    array = [];
if (offset === undefined)
    offset = 0;
te = this.elements;
array[offset] = te[0];
array[offset + 1] = te[1];
array[offset + 2] = te[2];
array[offset + 3] = te[3];
array[offset + 4] = te[4];
array[offset + 5] = te[5];
array[offset + 6] = te[6];
array[offset + 7] = te[7];
array[offset + 8] = te[8];
return array;})
    };
    Plane.prototype = $__.os.oid420 = {
        'constructor': Plane,
        'set': ($__.fs.J$__v494107025_1001_702 = function J$__v494107025_1001(normal, constant) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
normal = arguments[0], constant = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.normal.copy(normal);
this.constant = constant;
return this;}),
        'setComponents': ($__.fs.J$__v494107025_1003_703 = function J$__v494107025_1003(x, y, z, w) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
x = arguments[0], y = arguments[1], z = arguments[2], w = arguments[3];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.normal.set(x, y, z);
this.constant = w;
return this;}),
        'setFromNormalAndCoplanarPoint': ($__.fs.J$__v494107025_1005_704 = function J$__v494107025_1005(normal, point) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
normal = arguments[0], point = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.normal.copy(normal);
this.constant = -point.dot(this.normal);
return this;}),
        'setFromCoplanarPoints': (($__.fs.J$__v494107025_1008_705 = function J$__v494107025_1008() {
var vvv_return, vvv_switch, v1, v2;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    v1 = new (Vector3, $__.fs.Vector3_11)(15, true, $__.uid);
    v2 = new (Vector3, $__.fs.Vector3_11)(16, true, $__.uid);
    return ($__.fs.setFromCoplanarPoints_706 = function setFromCoplanarPoints(a, b, c) {
var vvv_return, vvv_switch, normal;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
a = arguments[0], b = arguments[1], c = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
normal = v1.subVectors(c, b).cross(v2.subVectors(a, b)).normalize();
this.setFromNormalAndCoplanarPoint(normal, a);
return this;});
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
v1 = new Vector3();
v2 = new Vector3();
return function setFromCoplanarPoints(a, b, c) {
    var normal = v1.subVectors(c, b).cross(v2.subVectors(a, b)).normalize();
    this.setFromNormalAndCoplanarPoint(normal, a);
    return this;
};}), $__.fs.J$__v494107025_1008_705)(0, true, $__.uid),
        'clone': ($__.fs.J$__v494107025_1010_707 = function J$__v494107025_1010() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return new this.constructor().copy(this);}),
        'copy': ($__.fs.J$__v494107025_1012_708 = function J$__v494107025_1012(plane) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
plane = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.normal.copy(plane.normal);
this.constant = plane.constant;
return this;}),
        'normalize': ($__.fs.J$__v494107025_1014_709 = function J$__v494107025_1014() {
var vvv_return, vvv_switch, inverseNormalLength;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
inverseNormalLength = 1 / this.normal.length();
this.normal.multiplyScalar(inverseNormalLength);
this.constant *= inverseNormalLength;
return this;}),
        'negate': ($__.fs.J$__v494107025_1016_710 = function J$__v494107025_1016() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.constant *= -1;
this.normal.negate();
return this;}),
        'distanceToPoint': ($__.fs.J$__v494107025_1018_711 = function J$__v494107025_1018(point) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
point = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return this.normal.dot(point) + this.constant;}),
        'distanceToSphere': ($__.fs.J$__v494107025_1020_712 = function J$__v494107025_1020(sphere) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
sphere = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return this.distanceToPoint(sphere.center) - sphere.radius;}),
        'projectPoint': ($__.fs.J$__v494107025_1022_713 = function J$__v494107025_1022(point, optionalTarget) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
point = arguments[0], optionalTarget = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return this.orthoPoint(point, optionalTarget).sub(point).negate();}),
        'orthoPoint': ($__.fs.J$__v494107025_1024_714 = function J$__v494107025_1024(point, optionalTarget) {
var vvv_return, vvv_switch, perpendicularMagnitude, result;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
point = arguments[0], optionalTarget = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
perpendicularMagnitude = this.distanceToPoint(point);
result = optionalTarget || new Vector3();
return result.copy(this.normal).multiplyScalar(perpendicularMagnitude);}),
        'intersectLine': (($__.fs.J$__v494107025_1027_715 = function J$__v494107025_1027() {
var vvv_return, vvv_switch, v1;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    v1 = new (Vector3, $__.fs.Vector3_11)(17, true, $__.uid);
    return ($__.fs.intersectLine_716 = function intersectLine(line, optionalTarget) {
var vvv_return, vvv_switch, result, direction, denominator, t;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
line = arguments[0], optionalTarget = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
result = optionalTarget || new Vector3();
direction = line.delta(v1);
denominator = this.normal.dot(direction);
if (denominator === 0) {
    if (this.distanceToPoint(line.start) === 0) {
        return result.copy(line.start);
    }
    return undefined;
}
t = -(line.start.dot(this.normal) + this.constant) / denominator;
if (t < 0 || t > 1) {
    return undefined;
}
return result.copy(direction).multiplyScalar(t).add(line.start);});
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
v1 = new Vector3();
return function intersectLine(line, optionalTarget) {
    var result = optionalTarget || new Vector3();
    var direction = line.delta(v1);
    var denominator = this.normal.dot(direction);
    if (denominator === 0) {
        if (this.distanceToPoint(line.start) === 0) {
            return result.copy(line.start);
        }
        return undefined;
    }
    var t = -(line.start.dot(this.normal) + this.constant) / denominator;
    if (t < 0 || t > 1) {
        return undefined;
    }
    return result.copy(direction).multiplyScalar(t).add(line.start);
};}), $__.fs.J$__v494107025_1027_715)(0, true, $__.uid),
        'intersectsLine': ($__.fs.J$__v494107025_1029_717 = function J$__v494107025_1029(line) {
var vvv_return, vvv_switch, startSign, endSign;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
line = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
startSign = this.distanceToPoint(line.start);
endSign = this.distanceToPoint(line.end);
return startSign < 0 && endSign > 0 || endSign < 0 && startSign > 0;}),
        'intersectsBox': ($__.fs.J$__v494107025_1031_718 = function J$__v494107025_1031(box) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
box = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return box.intersectsPlane(this);}),
        'intersectsSphere': ($__.fs.J$__v494107025_1033_719 = function J$__v494107025_1033(sphere) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
sphere = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return sphere.intersectsPlane(this);}),
        'coplanarPoint': ($__.fs.J$__v494107025_1035_720 = function J$__v494107025_1035(optionalTarget) {
var vvv_return, vvv_switch, result;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
optionalTarget = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
result = optionalTarget || new Vector3();
return result.copy(this.normal).multiplyScalar(-this.constant);}),
        'applyMatrix4': (($__.fs.J$__v494107025_1038_721 = function J$__v494107025_1038() {
var vvv_return, vvv_switch, v1, m1;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    v1 = new (Vector3, $__.fs.Vector3_11)(18, true, $__.uid);
    m1 = new (Matrix3, $__.fs.Matrix3_61)(0, true, $__.uid);
    return ($__.fs.applyMatrix4_722 = function applyMatrix4(matrix, optionalNormalMatrix) {
var vvv_return, vvv_switch, referencePoint, normalMatrix, normal;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
matrix = arguments[0], optionalNormalMatrix = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
referencePoint = this.coplanarPoint(v1).applyMatrix4(matrix);
normalMatrix = optionalNormalMatrix || m1.getNormalMatrix(matrix);
normal = this.normal.applyMatrix3(normalMatrix).normalize();
this.constant = -referencePoint.dot(normal);
return this;});
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
v1 = new Vector3();
m1 = new Matrix3();
return function applyMatrix4(matrix, optionalNormalMatrix) {
    var referencePoint = this.coplanarPoint(v1).applyMatrix4(matrix);
    var normalMatrix = optionalNormalMatrix || m1.getNormalMatrix(matrix);
    var normal = this.normal.applyMatrix3(normalMatrix).normalize();
    this.constant = -referencePoint.dot(normal);
    return this;
};}), $__.fs.J$__v494107025_1038_721)(0, true, $__.uid),
        'translate': ($__.fs.J$__v494107025_1040_723 = function J$__v494107025_1040(offset) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
offset = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.constant = this.constant - offset.dot(this.normal);
return this;}),
        'equals': ($__.fs.J$__v494107025_1042_724 = function J$__v494107025_1042(plane) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
plane = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return plane.normal.equals(this.normal) && plane.constant === this.constant;})
    };
    Frustum.prototype = $__.os.oid421 = {
        'constructor': Frustum,
        'set': ($__.fs.J$__v494107025_1045_725 = function J$__v494107025_1045(p0, p1, p2, p3, p4, p5) {
var vvv_return, vvv_switch, planes;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
p0 = arguments[0], p1 = arguments[1], p2 = arguments[2], p3 = arguments[3], p4 = arguments[4], p5 = arguments[5];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
planes = this.planes;
planes[0].copy(p0);
planes[1].copy(p1);
planes[2].copy(p2);
planes[3].copy(p3);
planes[4].copy(p4);
planes[5].copy(p5);
return this;}),
        'clone': ($__.fs.J$__v494107025_1047_726 = function J$__v494107025_1047() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return new this.constructor().copy(this);}),
        'copy': ($__.fs.J$__v494107025_1049_727 = function J$__v494107025_1049(frustum) {
var vvv_return, vvv_switch, planes;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
frustum = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
planes = this.planes;
for (var i = 0; i < 6; i++) {
    planes[i].copy(frustum.planes[i]);
}
return this;}),
        'setFromMatrix': ($__.fs.J$__v494107025_1051_728 = function J$__v494107025_1051(m) {
var vvv_return, vvv_switch, planes, me, me0, me1, me2, me3, me4, me5, me6, me7, me8, me9, me10, me11, me12, me13, me14, me15;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
m = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
planes = this.planes;
me = m.elements;
me0 = me[0];
me1 = me[1];
me2 = me[2];
me3 = me[3];
me4 = me[4];
me5 = me[5];
me6 = me[6];
me7 = me[7];
me8 = me[8];
me9 = me[9];
me10 = me[10];
me11 = me[11];
me12 = me[12];
me13 = me[13];
me14 = me[14];
me15 = me[15];
planes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize();
planes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize();
planes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize();
planes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize();
planes[4].setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14).normalize();
planes[5].setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14).normalize();
return this;}),
        'intersectsObject': (($__.fs.J$__v494107025_1054_729 = function J$__v494107025_1054() {
var vvv_return, vvv_switch, sphere;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    sphere = new (Sphere, $__.fs.Sphere_60)(0, true, $__.uid);
    return ($__.fs.intersectsObject_730 = function intersectsObject(object) {
var vvv_return, vvv_switch, geometry;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
object = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
geometry = object.geometry;
if (geometry.boundingSphere === null)
    geometry.computeBoundingSphere();
sphere.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld);
return this.intersectsSphere(sphere);});
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
sphere = new Sphere();
return function intersectsObject(object) {
    var geometry = object.geometry;
    if (geometry.boundingSphere === null)
        geometry.computeBoundingSphere();
    sphere.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld);
    return this.intersectsSphere(sphere);
};}), $__.fs.J$__v494107025_1054_729)(0, true, $__.uid),
        'intersectsSprite': (($__.fs.J$__v494107025_1057_731 = function J$__v494107025_1057() {
var vvv_return, vvv_switch, sphere;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    sphere = new (Sphere, $__.fs.Sphere_60)(1, true, $__.uid);
    return ($__.fs.intersectsSprite_732 = function intersectsSprite(sprite) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
sprite = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
sphere.center.set(0, 0, 0);
sphere.radius = 0.7071067811865476;
sphere.applyMatrix4(sprite.matrixWorld);
return this.intersectsSphere(sphere);});
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
sphere = new Sphere();
return function intersectsSprite(sprite) {
    sphere.center.set(0, 0, 0);
    sphere.radius = 0.7071067811865476;
    sphere.applyMatrix4(sprite.matrixWorld);
    return this.intersectsSphere(sphere);
};}), $__.fs.J$__v494107025_1057_731)(0, true, $__.uid),
        'intersectsSphere': ($__.fs.J$__v494107025_1059_733 = function J$__v494107025_1059(sphere) {
var vvv_return, vvv_switch, planes, center, negRadius, distance;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
sphere = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
planes = this.planes;
center = sphere.center;
negRadius = -sphere.radius;
for (var i = 0; i < 6; i++) {
    distance = planes[i].distanceToPoint(center);
    if (distance < negRadius) {
        return false;
    }
}
return true;}),
        'intersectsBox': (($__.fs.J$__v494107025_1062_734 = function J$__v494107025_1062() {
var vvv_return, vvv_switch, p1, p2;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    p1 = new (Vector3, $__.fs.Vector3_11)(21, true, $__.uid);
    p2 = new (Vector3, $__.fs.Vector3_11)(22, true, $__.uid);
    return ($__.fs.intersectsBox_735 = function intersectsBox(box) {
var vvv_return, vvv_switch, planes, plane, d1, d2;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
box = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
planes = this.planes;
for (var i = 0; i < 6; i++) {
    plane = planes[i];
    p1.x = plane.normal.x > 0 ? box.min.x : box.max.x;
    p2.x = plane.normal.x > 0 ? box.max.x : box.min.x;
    p1.y = plane.normal.y > 0 ? box.min.y : box.max.y;
    p2.y = plane.normal.y > 0 ? box.max.y : box.min.y;
    p1.z = plane.normal.z > 0 ? box.min.z : box.max.z;
    p2.z = plane.normal.z > 0 ? box.max.z : box.min.z;
    d1 = plane.distanceToPoint(p1);
    d2 = plane.distanceToPoint(p2);
    if (d1 < 0 && d2 < 0) {
        return false;
    }
}
return true;});
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
p1 = new Vector3();
p2 = new Vector3();
return function intersectsBox(box) {
    var planes = this.planes;
    for (var i = 0; i < 6; i++) {
        var plane = planes[i];
        p1.x = plane.normal.x > 0 ? box.min.x : box.max.x;
        p2.x = plane.normal.x > 0 ? box.max.x : box.min.x;
        p1.y = plane.normal.y > 0 ? box.min.y : box.max.y;
        p2.y = plane.normal.y > 0 ? box.max.y : box.min.y;
        p1.z = plane.normal.z > 0 ? box.min.z : box.max.z;
        p2.z = plane.normal.z > 0 ? box.max.z : box.min.z;
        var d1 = plane.distanceToPoint(p1);
        var d2 = plane.distanceToPoint(p2);
        if (d1 < 0 && d2 < 0) {
            return false;
        }
    }
    return true;
};}), $__.fs.J$__v494107025_1062_734)(0, true, $__.uid),
        'containsPoint': ($__.fs.J$__v494107025_1064_736 = function J$__v494107025_1064(point) {
var vvv_return, vvv_switch, planes;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
point = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
planes = this.planes;
for (var i = 0; i < 6; i++) {
    if (planes[i].distanceToPoint(point) < 0) {
        return false;
    }
}
return true;})
    };
    programIdCount = 0;
    BufferAttribute.prototype = (vvv_tmp12 = {
        'constructor': BufferAttribute,
        'isBufferAttribute': true,
        'setDynamic': ($__.fs.J$__v494107025_1121_737 = function J$__v494107025_1121(value) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
value = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.dynamic = value;
return this;}),
        'copy': ($__.fs.J$__v494107025_1123_738 = function J$__v494107025_1123(source) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
source = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.array = new source.array.constructor(source.array);
this.itemSize = source.itemSize;
this.normalized = source.normalized;
this.dynamic = source.dynamic;
return this;}),
        'copyAt': ($__.fs.J$__v494107025_1125_739 = function J$__v494107025_1125(index1, attribute, index2) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
index1 = arguments[0], attribute = arguments[1], index2 = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
index1 *= this.itemSize;
index2 *= attribute.itemSize;
for (var i = 0, l = this.itemSize; i < l; i++) {
    this.array[index1 + i] = attribute.array[index2 + i];
}
return this;}),
        'copyArray': ($__.fs.J$__v494107025_1127_740 = function J$__v494107025_1127(array) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
array = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.array.set(array);
return this;}),
        'copyColorsArray': ($__.fs.J$__v494107025_1129_741 = function J$__v494107025_1129(colors) {
var vvv_return, vvv_switch, array, offset, color;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
colors = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
array = this.array;
offset = 0;
for (var i = 0, l = colors.length; i < l; i++) {
    color = colors[i];
    if (color === undefined) {
        console.warn('THREE.BufferAttribute.copyColorsArray(): color is undefined', i);
        color = new Color();
    }
    array[offset++] = color.r;
    array[offset++] = color.g;
    array[offset++] = color.b;
}
return this;}),
        'copyIndicesArray': ($__.fs.J$__v494107025_1131_742 = function J$__v494107025_1131(indices) {
var vvv_return, vvv_switch, array, offset, index;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
indices = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
array = this.array;
offset = 0;
for (var i = 0, l = indices.length; i < l; i++) {
    index = indices[i];
    array[offset++] = index.a;
    array[offset++] = index.b;
    array[offset++] = index.c;
}
return this;}),
        'copyVector2sArray': ($__.fs.J$__v494107025_1133_743 = function J$__v494107025_1133(vectors) {
var vvv_return, vvv_switch, array, offset, vector;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
vectors = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
array = this.array;
offset = 0;
for (var i = 0, l = vectors.length; i < l; i++) {
    vector = vectors[i];
    if (vector === undefined) {
        console.warn('THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i);
        vector = new Vector2();
    }
    array[offset++] = vector.x;
    array[offset++] = vector.y;
}
return this;}),
        'copyVector3sArray': ($__.fs.J$__v494107025_1135_744 = function J$__v494107025_1135(vectors) {
var vvv_return, vvv_switch, array, offset, vector;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
vectors = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
array = this.array;
offset = 0;
for (var i = 0, l = vectors.length; i < l; i++) {
    vector = vectors[i];
    if (vector === undefined) {
        console.warn('THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i);
        vector = new Vector3();
    }
    array[offset++] = vector.x;
    array[offset++] = vector.y;
    array[offset++] = vector.z;
}
return this;}),
        'copyVector4sArray': ($__.fs.J$__v494107025_1137_745 = function J$__v494107025_1137(vectors) {
var vvv_return, vvv_switch, array, offset, vector;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
vectors = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
array = this.array;
offset = 0;
for (var i = 0, l = vectors.length; i < l; i++) {
    vector = vectors[i];
    if (vector === undefined) {
        console.warn('THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i);
        vector = new Vector4();
    }
    array[offset++] = vector.x;
    array[offset++] = vector.y;
    array[offset++] = vector.z;
    array[offset++] = vector.w;
}
return this;}),
        'set': ($__.fs.J$__v494107025_1139_746 = function J$__v494107025_1139(value, offset) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
value = arguments[0], offset = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (offset === undefined)
    offset = 0;
this.array.set(value, offset);
return this;}),
        'getX': ($__.fs.J$__v494107025_1141_747 = function J$__v494107025_1141(index) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
index = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return this.array[index * this.itemSize];}),
        'setX': ($__.fs.J$__v494107025_1143_748 = function J$__v494107025_1143(index, x) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
index = arguments[0], x = arguments[1];
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    TAJS_restrictToType(this.array, 'object')[index * (this.itemSize, 1), 0] = x;
    return this;
case 1:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 1);
    TAJS_restrictToType(this.array, 'object')[index * (this.itemSize, 1), 1] = x;
    return this;
case 2:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 2);
    TAJS_restrictToType(this.array, 'object')[index * (this.itemSize, 1), 2] = x;
    return this;
case 3:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 3);
    TAJS_restrictToType(this.array, 'object')[index * (this.itemSize, 1), 3] = x;
    return this;
case 4:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 4);
    TAJS_restrictToType(this.array, 'object')[index * (this.itemSize, 1), 4] = x;
    return this;
case 5:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 5);
    TAJS_restrictToType(this.array, 'object')[index * (this.itemSize, 1), 5] = x;
    return this;
case 6:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 6);
    TAJS_restrictToType(this.array, 'object')[index * (this.itemSize, 1), 6] = x;
    return this;
case 7:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 7);
    TAJS_restrictToType(this.array, 'object')[index * (this.itemSize, 1), 7] = x;
    return this;
case 8:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 8);
    TAJS_restrictToType(this.array, 'object')[index * (this.itemSize, 1), 8] = x;
    return this;
case 9:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 9);
    TAJS_restrictToType(this.array, 'object')[index * (this.itemSize, 1), 9] = x;
    return this;
case 10:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 10);
    TAJS_restrictToType(this.array, 'object')[index * (this.itemSize, 1), 10] = x;
    return this;
case 11:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 11);
    TAJS_restrictToType(this.array, 'object')[index * (this.itemSize, 1), 11] = x;
    return this;
case 12:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 12);
    TAJS_restrictToType(this.array, 'object')[index * (this.itemSize, 1), 12] = x;
    return this;
case 13:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 13);
    TAJS_restrictToType(this.array, 'object')[index * (this.itemSize, 1), 13] = x;
    return this;
case 14:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 14);
    TAJS_restrictToType(this.array, 'object')[index * (this.itemSize, 1), 14] = x;
    return this;
case 15:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 15);
    TAJS_restrictToType(this.array, 'object')[index * (this.itemSize, 1), 15] = x;
    return this;
case 16:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 16);
    TAJS_restrictToType(this.array, 'object')[index * (this.itemSize, 1), 16] = x;
    return this;
case 17:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 17);
    TAJS_restrictToType(this.array, 'object')[index * (this.itemSize, 1), 17] = x;
    return this;
case 18:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 18);
    TAJS_restrictToType(this.array, 'object')[index * (this.itemSize, 1), 18] = x;
    return this;
case 19:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 19);
    TAJS_restrictToType(this.array, 'object')[index * (this.itemSize, 1), 19] = x;
    return this;
case 20:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 20);
    TAJS_restrictToType(this.array, 'object')[index * (this.itemSize, 1), 20] = x;
    return this;
case 21:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 21);
    TAJS_restrictToType(this.array, 'object')[index * (this.itemSize, 1), 21] = x;
    return this;
case 22:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 22);
    TAJS_restrictToType(this.array, 'object')[index * (this.itemSize, 1), 22] = x;
    return this;
case 23:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 23);
    TAJS_restrictToType(this.array, 'object')[index * (this.itemSize, 1), 23] = x;
    return this;
case 24:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 24);
    TAJS_restrictToType(this.array, 'object')[index * (this.itemSize, 1), 24] = x;
    return this;
case 25:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 25);
    TAJS_restrictToType(this.array, 'object')[index * (this.itemSize, 1), 25] = x;
    return this;
case 26:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 26);
    TAJS_restrictToType(this.array, 'object')[index * (this.itemSize, 1), 26] = x;
    return this;
case 27:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 27);
    TAJS_restrictToType(this.array, 'object')[index * (this.itemSize, 1), 27] = x;
    return this;
case 28:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 28);
    TAJS_restrictToType(this.array, 'object')[index * (this.itemSize, 1), 28] = x;
    return this;
case 29:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 29);
    TAJS_restrictToType(this.array, 'object')[index * (this.itemSize, 1), 29] = x;
    return this;
case 30:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 30);
    TAJS_restrictToType(this.array, 'object')[index * (this.itemSize, 1), 30] = x;
    return this;
case 31:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 31);
    TAJS_restrictToType(this.array, 'object')[index * (this.itemSize, 1), 31] = x;
    return this;
case 32:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 32);
    TAJS_restrictToType(this.array, 'object')[index * (this.itemSize, 1), 32] = x;
    return this;
case 33:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 33);
    TAJS_restrictToType(this.array, 'object')[index * (this.itemSize, 1), 33] = x;
    return this;
case 34:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 34);
    TAJS_restrictToType(this.array, 'object')[index * (this.itemSize, 1), 34] = x;
    return this;
case 35:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 35);
    TAJS_restrictToType(this.array, 'object')[index * (this.itemSize, 1), 35] = x;
    return this;
case 36:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 36);
    TAJS_restrictToType(this.array, 'object')[index * (this.itemSize, 1), 36] = x;
    return this;
case 37:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 37);
    TAJS_restrictToType(this.array, 'object')[index * (this.itemSize, 1), 37] = x;
    return this;
case 38:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 38);
    TAJS_restrictToType(this.array, 'object')[index * (this.itemSize, 1), 38] = x;
    return this;
case 39:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 39);
    TAJS_restrictToType(this.array, 'object')[index * (this.itemSize, 1), 39] = x;
    return this;
case 40:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 40);
    TAJS_restrictToType(this.array, 'object')[index * (this.itemSize, 1), 40] = x;
    return this;
case 41:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 41);
    TAJS_restrictToType(this.array, 'object')[index * (this.itemSize, 1), 41] = x;
    return this;
case 42:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 42);
    TAJS_restrictToType(this.array, 'object')[index * (this.itemSize, 1), 42] = x;
    return this;
case 43:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 43);
    TAJS_restrictToType(this.array, 'object')[index * (this.itemSize, 1), 43] = x;
    return this;
case 44:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 44);
    TAJS_restrictToType(this.array, 'object')[index * (this.itemSize, 1), 44] = x;
    return this;
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.array[index * this.itemSize] = x;
return this;}),
        'getY': ($__.fs.J$__v494107025_1145_749 = function J$__v494107025_1145(index) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
index = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return this.array[index * this.itemSize + 1];}),
        'setY': ($__.fs.J$__v494107025_1147_750 = function J$__v494107025_1147(index, y) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
index = arguments[0], y = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.array[index * this.itemSize + 1] = y;
return this;}),
        'getZ': ($__.fs.J$__v494107025_1149_751 = function J$__v494107025_1149(index) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
index = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return this.array[index * this.itemSize + 2];}),
        'setZ': ($__.fs.J$__v494107025_1151_752 = function J$__v494107025_1151(index, z) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
index = arguments[0], z = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.array[index * this.itemSize + 2] = z;
return this;}),
        'getW': ($__.fs.J$__v494107025_1153_753 = function J$__v494107025_1153(index) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
index = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return this.array[index * this.itemSize + 3];}),
        'setW': ($__.fs.J$__v494107025_1155_754 = function J$__v494107025_1155(index, w) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
index = arguments[0], w = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.array[index * this.itemSize + 3] = w;
return this;}),
        'setXY': ($__.fs.J$__v494107025_1157_755 = function J$__v494107025_1157(index, x, y) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
index = arguments[0], x = arguments[1], y = arguments[2];
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    index = index * (this.itemSize, 2);
    TAJS_restrictToType(this.array, 'object')[index + 0, 0] = x;
    TAJS_restrictToType(this.array, 'object')[index + 1, 1] = y;
    return this;
case 1:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 1);
    index = index * (this.itemSize, 2);
    TAJS_restrictToType(this.array, 'object')[index + 0, 2] = x;
    TAJS_restrictToType(this.array, 'object')[index + 1, 3] = y;
    return this;
case 2:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 2);
    index = index * (this.itemSize, 2);
    TAJS_restrictToType(this.array, 'object')[index + 0, 4] = x;
    TAJS_restrictToType(this.array, 'object')[index + 1, 5] = y;
    return this;
case 3:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 3);
    index = index * (this.itemSize, 2);
    TAJS_restrictToType(this.array, 'object')[index + 0, 6] = x;
    TAJS_restrictToType(this.array, 'object')[index + 1, 7] = y;
    return this;
case 4:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 4);
    index = index * (this.itemSize, 2);
    TAJS_restrictToType(this.array, 'object')[index + 0, 8] = x;
    TAJS_restrictToType(this.array, 'object')[index + 1, 9] = y;
    return this;
case 5:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 5);
    index = index * (this.itemSize, 2);
    TAJS_restrictToType(this.array, 'object')[index + 0, 10] = x;
    TAJS_restrictToType(this.array, 'object')[index + 1, 11] = y;
    return this;
case 6:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 6);
    index = index * (this.itemSize, 2);
    TAJS_restrictToType(this.array, 'object')[index + 0, 12] = x;
    TAJS_restrictToType(this.array, 'object')[index + 1, 13] = y;
    return this;
case 7:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 7);
    index = index * (this.itemSize, 2);
    TAJS_restrictToType(this.array, 'object')[index + 0, 14] = x;
    TAJS_restrictToType(this.array, 'object')[index + 1, 15] = y;
    return this;
case 8:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 8);
    index = index * (this.itemSize, 2);
    TAJS_restrictToType(this.array, 'object')[index + 0, 16] = x;
    TAJS_restrictToType(this.array, 'object')[index + 1, 17] = y;
    return this;
case 9:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 9);
    index = index * (this.itemSize, 2);
    TAJS_restrictToType(this.array, 'object')[index + 0, 18] = x;
    TAJS_restrictToType(this.array, 'object')[index + 1, 19] = y;
    return this;
case 10:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 10);
    index = index * (this.itemSize, 2);
    TAJS_restrictToType(this.array, 'object')[index + 0, 20] = x;
    TAJS_restrictToType(this.array, 'object')[index + 1, 21] = y;
    return this;
case 11:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 11);
    index = index * (this.itemSize, 2);
    TAJS_restrictToType(this.array, 'object')[index + 0, 22] = x;
    TAJS_restrictToType(this.array, 'object')[index + 1, 23] = y;
    return this;
case 12:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 12);
    index = index * (this.itemSize, 2);
    TAJS_restrictToType(this.array, 'object')[index + 0, 24] = x;
    TAJS_restrictToType(this.array, 'object')[index + 1, 25] = y;
    return this;
case 13:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 13);
    index = index * (this.itemSize, 2);
    TAJS_restrictToType(this.array, 'object')[index + 0, 26] = x;
    TAJS_restrictToType(this.array, 'object')[index + 1, 27] = y;
    return this;
case 14:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 14);
    index = index * (this.itemSize, 2);
    TAJS_restrictToType(this.array, 'object')[index + 0, 28] = x;
    TAJS_restrictToType(this.array, 'object')[index + 1, 29] = y;
    return this;
case 15:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 15);
    index = index * (this.itemSize, 2);
    TAJS_restrictToType(this.array, 'object')[index + 0, 30] = x;
    TAJS_restrictToType(this.array, 'object')[index + 1, 31] = y;
    return this;
case 16:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 16);
    index = index * (this.itemSize, 2);
    TAJS_restrictToType(this.array, 'object')[index + 0, 32] = x;
    TAJS_restrictToType(this.array, 'object')[index + 1, 33] = y;
    return this;
case 17:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 17);
    index = index * (this.itemSize, 2);
    TAJS_restrictToType(this.array, 'object')[index + 0, 34] = x;
    TAJS_restrictToType(this.array, 'object')[index + 1, 35] = y;
    return this;
case 18:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 18);
    index = index * (this.itemSize, 2);
    TAJS_restrictToType(this.array, 'object')[index + 0, 36] = x;
    TAJS_restrictToType(this.array, 'object')[index + 1, 37] = y;
    return this;
case 19:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 19);
    index = index * (this.itemSize, 2);
    TAJS_restrictToType(this.array, 'object')[index + 0, 38] = x;
    TAJS_restrictToType(this.array, 'object')[index + 1, 39] = y;
    return this;
case 20:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 20);
    index = index * (this.itemSize, 2);
    TAJS_restrictToType(this.array, 'object')[index + 0, 40] = x;
    TAJS_restrictToType(this.array, 'object')[index + 1, 41] = y;
    return this;
case 21:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 21);
    index = index * (this.itemSize, 2);
    TAJS_restrictToType(this.array, 'object')[index + 0, 42] = x;
    TAJS_restrictToType(this.array, 'object')[index + 1, 43] = y;
    return this;
case 22:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 22);
    index = index * (this.itemSize, 2);
    TAJS_restrictToType(this.array, 'object')[index + 0, 44] = x;
    TAJS_restrictToType(this.array, 'object')[index + 1, 45] = y;
    return this;
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
index *= this.itemSize;
this.array[index + 0] = x;
this.array[index + 1] = y;
return this;}),
        'setXYZ': ($__.fs.J$__v494107025_1159_756 = function J$__v494107025_1159(index, x, y, z) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
index = arguments[0], x = arguments[1], y = arguments[2], z = arguments[3];
switch (vvv_switch) {
case 0:
case 1:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(0 <= vvv_switch && vvv_switch <= 1);
    index = index * (this.itemSize, 3);
    TAJS_restrictToType(this.array, 'object')[index + 0, 0] = x;
    TAJS_restrictToType(this.array, 'object')[index + 1, 1] = y;
    TAJS_restrictToType(this.array, 'object')[index + 2, 2] = z;
    return this;
case 2:
case 3:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(2 <= vvv_switch && vvv_switch <= 3);
    index = index * (this.itemSize, 3);
    TAJS_restrictToType(this.array, 'object')[index + 0, 3] = x;
    TAJS_restrictToType(this.array, 'object')[index + 1, 4] = y;
    TAJS_restrictToType(this.array, 'object')[index + 2, 5] = z;
    return this;
case 4:
case 5:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(4 <= vvv_switch && vvv_switch <= 5);
    index = index * (this.itemSize, 3);
    TAJS_restrictToType(this.array, 'object')[index + 0, 6] = x;
    TAJS_restrictToType(this.array, 'object')[index + 1, 7] = y;
    TAJS_restrictToType(this.array, 'object')[index + 2, 8] = z;
    return this;
case 6:
case 7:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(6 <= vvv_switch && vvv_switch <= 7);
    index = index * (this.itemSize, 3);
    TAJS_restrictToType(this.array, 'object')[index + 0, 9] = x;
    TAJS_restrictToType(this.array, 'object')[index + 1, 10] = y;
    TAJS_restrictToType(this.array, 'object')[index + 2, 11] = z;
    return this;
case 8:
case 9:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(8 <= vvv_switch && vvv_switch <= 9);
    index = index * (this.itemSize, 3);
    TAJS_restrictToType(this.array, 'object')[index + 0, 12] = x;
    TAJS_restrictToType(this.array, 'object')[index + 1, 13] = y;
    TAJS_restrictToType(this.array, 'object')[index + 2, 14] = z;
    return this;
case 10:
case 11:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(10 <= vvv_switch && vvv_switch <= 11);
    index = index * (this.itemSize, 3);
    TAJS_restrictToType(this.array, 'object')[index + 0, 15] = x;
    TAJS_restrictToType(this.array, 'object')[index + 1, 16] = y;
    TAJS_restrictToType(this.array, 'object')[index + 2, 17] = z;
    return this;
case 12:
case 13:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(12 <= vvv_switch && vvv_switch <= 13);
    index = index * (this.itemSize, 3);
    TAJS_restrictToType(this.array, 'object')[index + 0, 18] = x;
    TAJS_restrictToType(this.array, 'object')[index + 1, 19] = y;
    TAJS_restrictToType(this.array, 'object')[index + 2, 20] = z;
    return this;
case 14:
case 15:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(14 <= vvv_switch && vvv_switch <= 15);
    index = index * (this.itemSize, 3);
    TAJS_restrictToType(this.array, 'object')[index + 0, 21] = x;
    TAJS_restrictToType(this.array, 'object')[index + 1, 22] = y;
    TAJS_restrictToType(this.array, 'object')[index + 2, 23] = z;
    return this;
case 16:
case 17:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(16 <= vvv_switch && vvv_switch <= 17);
    index = index * (this.itemSize, 3);
    TAJS_restrictToType(this.array, 'object')[index + 0, 24] = x;
    TAJS_restrictToType(this.array, 'object')[index + 1, 25] = y;
    TAJS_restrictToType(this.array, 'object')[index + 2, 26] = z;
    return this;
case 18:
case 19:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(18 <= vvv_switch && vvv_switch <= 19);
    index = index * (this.itemSize, 3);
    TAJS_restrictToType(this.array, 'object')[index + 0, 27] = x;
    TAJS_restrictToType(this.array, 'object')[index + 1, 28] = y;
    TAJS_restrictToType(this.array, 'object')[index + 2, 29] = z;
    return this;
case 20:
case 21:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(20 <= vvv_switch && vvv_switch <= 21);
    index = index * (this.itemSize, 3);
    TAJS_restrictToType(this.array, 'object')[index + 0, 30] = x;
    TAJS_restrictToType(this.array, 'object')[index + 1, 31] = y;
    TAJS_restrictToType(this.array, 'object')[index + 2, 32] = z;
    return this;
case 22:
case 23:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(22 <= vvv_switch && vvv_switch <= 23);
    index = index * (this.itemSize, 3);
    TAJS_restrictToType(this.array, 'object')[index + 0, 33] = x;
    TAJS_restrictToType(this.array, 'object')[index + 1, 34] = y;
    TAJS_restrictToType(this.array, 'object')[index + 2, 35] = z;
    return this;
case 24:
case 25:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(24 <= vvv_switch && vvv_switch <= 25);
    index = index * (this.itemSize, 3);
    TAJS_restrictToType(this.array, 'object')[index + 0, 36] = x;
    TAJS_restrictToType(this.array, 'object')[index + 1, 37] = y;
    TAJS_restrictToType(this.array, 'object')[index + 2, 38] = z;
    return this;
case 26:
case 27:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(26 <= vvv_switch && vvv_switch <= 27);
    index = index * (this.itemSize, 3);
    TAJS_restrictToType(this.array, 'object')[index + 0, 39] = x;
    TAJS_restrictToType(this.array, 'object')[index + 1, 40] = y;
    TAJS_restrictToType(this.array, 'object')[index + 2, 41] = z;
    return this;
case 28:
case 29:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(28 <= vvv_switch && vvv_switch <= 29);
    index = index * (this.itemSize, 3);
    TAJS_restrictToType(this.array, 'object')[index + 0, 42] = x;
    TAJS_restrictToType(this.array, 'object')[index + 1, 43] = y;
    TAJS_restrictToType(this.array, 'object')[index + 2, 44] = z;
    return this;
case 30:
case 31:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(30 <= vvv_switch && vvv_switch <= 31);
    index = index * (this.itemSize, 3);
    TAJS_restrictToType(this.array, 'object')[index + 0, 45] = x;
    TAJS_restrictToType(this.array, 'object')[index + 1, 46] = y;
    TAJS_restrictToType(this.array, 'object')[index + 2, 47] = z;
    return this;
case 32:
case 33:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(32 <= vvv_switch && vvv_switch <= 33);
    index = index * (this.itemSize, 3);
    TAJS_restrictToType(this.array, 'object')[index + 0, 48] = x;
    TAJS_restrictToType(this.array, 'object')[index + 1, 49] = y;
    TAJS_restrictToType(this.array, 'object')[index + 2, 50] = z;
    return this;
case 34:
case 35:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(34 <= vvv_switch && vvv_switch <= 35);
    index = index * (this.itemSize, 3);
    TAJS_restrictToType(this.array, 'object')[index + 0, 51] = x;
    TAJS_restrictToType(this.array, 'object')[index + 1, 52] = y;
    TAJS_restrictToType(this.array, 'object')[index + 2, 53] = z;
    return this;
case 36:
case 37:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(36 <= vvv_switch && vvv_switch <= 37);
    index = index * (this.itemSize, 3);
    TAJS_restrictToType(this.array, 'object')[index + 0, 54] = x;
    TAJS_restrictToType(this.array, 'object')[index + 1, 55] = y;
    TAJS_restrictToType(this.array, 'object')[index + 2, 56] = z;
    return this;
case 38:
case 39:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(38 <= vvv_switch && vvv_switch <= 39);
    index = index * (this.itemSize, 3);
    TAJS_restrictToType(this.array, 'object')[index + 0, 57] = x;
    TAJS_restrictToType(this.array, 'object')[index + 1, 58] = y;
    TAJS_restrictToType(this.array, 'object')[index + 2, 59] = z;
    return this;
case 40:
case 41:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(40 <= vvv_switch && vvv_switch <= 41);
    index = index * (this.itemSize, 3);
    TAJS_restrictToType(this.array, 'object')[index + 0, 60] = x;
    TAJS_restrictToType(this.array, 'object')[index + 1, 61] = y;
    TAJS_restrictToType(this.array, 'object')[index + 2, 62] = z;
    return this;
case 42:
case 43:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(42 <= vvv_switch && vvv_switch <= 43);
    index = index * (this.itemSize, 3);
    TAJS_restrictToType(this.array, 'object')[index + 0, 63] = x;
    TAJS_restrictToType(this.array, 'object')[index + 1, 64] = y;
    TAJS_restrictToType(this.array, 'object')[index + 2, 65] = z;
    return this;
case 44:
case 45:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(44 <= vvv_switch && vvv_switch <= 45);
    index = index * (this.itemSize, 3);
    TAJS_restrictToType(this.array, 'object')[index + 0, 66] = x;
    TAJS_restrictToType(this.array, 'object')[index + 1, 67] = y;
    TAJS_restrictToType(this.array, 'object')[index + 2, 68] = z;
    return this;
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
index *= this.itemSize;
this.array[index + 0] = x;
this.array[index + 1] = y;
this.array[index + 2] = z;
return this;}),
        'setXYZW': ($__.fs.J$__v494107025_1161_757 = function J$__v494107025_1161(index, x, y, z, w) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
index = arguments[0], x = arguments[1], y = arguments[2], z = arguments[3], w = arguments[4];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
index *= this.itemSize;
this.array[index + 0] = x;
this.array[index + 1] = y;
this.array[index + 2] = z;
this.array[index + 3] = w;
return this;}),
        'clone': ($__.fs.J$__v494107025_1163_758 = function J$__v494107025_1163() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return new this.constructor().copy(this);}),
        get count() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return this.array.length / this.itemSize;},
        set needsUpdate(value) {
var vvv_return, vvv_switch, vvv_tmp0;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
value = arguments[0];
switch (vvv_switch) {
case 0:
case 1:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(0 <= vvv_switch && vvv_switch <= 1);
    value === true;
    ((vvv_tmp0 = this).version = (vvv_tmp0.version, 0) + 1) - 1;
    return;
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (value === true)
    this.version++;}
    }, $__.fs.count_759 = Object.getOwnPropertyDescriptor(vvv_tmp12, 'count').get, $__.fs.needsUpdate_760 = Object.getOwnPropertyDescriptor(vvv_tmp12, 'needsUpdate').set, $__.os.oid422 = vvv_tmp12);
    Face3.prototype = $__.os.oid423 = {
        'constructor': Face3,
        'clone': ($__.fs.J$__v494107025_1176_761 = function J$__v494107025_1176() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return new this.constructor().copy(this);}),
        'copy': ($__.fs.J$__v494107025_1178_762 = function J$__v494107025_1178(source) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
source = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.a = source.a;
this.b = source.b;
this.c = source.c;
this.normal.copy(source.normal);
this.color.copy(source.color);
this.materialIndex = source.materialIndex;
for (var i = 0, il = source.vertexNormals.length; i < il; i++) {
    this.vertexNormals[i] = source.vertexNormals[i].clone();
}
for (var i = 0, il = source.vertexColors.length; i < il; i++) {
    this.vertexColors[i] = source.vertexColors[i].clone();
}
return this;})
    };
    Euler.RotationOrders = [
        'XYZ',
        'YZX',
        'ZXY',
        'XZY',
        'YXZ',
        'ZYX'
    ];
    Euler.DefaultOrder = 'XYZ';
    Euler.prototype = (vvv_tmp13 = {
        'constructor': Euler,
        'isEuler': true,
        'set': ($__.fs.J$__v494107025_1197_763 = function J$__v494107025_1197(x, y, z, order) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
x = arguments[0], y = arguments[1], z = arguments[2], order = arguments[3];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this._x = x;
this._y = y;
this._z = z;
this._order = order || this._order;
this.onChangeCallback();
return this;}),
        'clone': ($__.fs.J$__v494107025_1199_764 = function J$__v494107025_1199() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return new this.constructor(this._x, this._y, this._z, this._order);}),
        'copy': ($__.fs.J$__v494107025_1201_765 = function J$__v494107025_1201(euler) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
euler = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this._x = euler._x;
this._y = euler._y;
this._z = euler._z;
this._order = euler._order;
this.onChangeCallback();
return this;}),
        'setFromRotationMatrix': ($__.fs.J$__v494107025_1203_766 = function J$__v494107025_1203(m, order, update) {
var vvv_return, vvv_switch, clamp, te, m11, m12, m13, m21, m22, m23, m31, m32, m33;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
m = arguments[0], order = arguments[1], update = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
clamp = exports.Math.clamp;
te = m.elements;
m11 = te[0];
m12 = te[4];
m13 = te[8];
m21 = te[1];
m22 = te[5];
m23 = te[9];
m31 = te[2];
m32 = te[6];
m33 = te[10];
order = order || this._order;
if (order === 'XYZ') {
    this._y = Math.asin(clamp(m13, -1, 1));
    if (Math.abs(m13) < 0.99999) {
        this._x = Math.atan2(-m23, m33);
        this._z = Math.atan2(-m12, m11);
    } else {
        this._x = Math.atan2(m32, m22);
        this._z = 0;
    }
} else if (order === 'YXZ') {
    this._x = Math.asin(-clamp(m23, -1, 1));
    if (Math.abs(m23) < 0.99999) {
        this._y = Math.atan2(m13, m33);
        this._z = Math.atan2(m21, m22);
    } else {
        this._y = Math.atan2(-m31, m11);
        this._z = 0;
    }
} else if (order === 'ZXY') {
    this._x = Math.asin(clamp(m32, -1, 1));
    if (Math.abs(m32) < 0.99999) {
        this._y = Math.atan2(-m31, m33);
        this._z = Math.atan2(-m12, m22);
    } else {
        this._y = 0;
        this._z = Math.atan2(m21, m11);
    }
} else if (order === 'ZYX') {
    this._y = Math.asin(-clamp(m31, -1, 1));
    if (Math.abs(m31) < 0.99999) {
        this._x = Math.atan2(m32, m33);
        this._z = Math.atan2(m21, m11);
    } else {
        this._x = 0;
        this._z = Math.atan2(-m12, m22);
    }
} else if (order === 'YZX') {
    this._z = Math.asin(clamp(m21, -1, 1));
    if (Math.abs(m21) < 0.99999) {
        this._x = Math.atan2(-m23, m22);
        this._y = Math.atan2(-m31, m11);
    } else {
        this._x = 0;
        this._y = Math.atan2(m13, m33);
    }
} else if (order === 'XZY') {
    this._z = Math.asin(-clamp(m12, -1, 1));
    if (Math.abs(m12) < 0.99999) {
        this._x = Math.atan2(m32, m22);
        this._y = Math.atan2(m13, m11);
    } else {
        this._x = Math.atan2(-m23, m33);
        this._y = 0;
    }
} else {
    console.warn('THREE.Euler: .setFromRotationMatrix() given unsupported order: ' + order);
}
this._order = order;
if (update !== false)
    this.onChangeCallback();
return this;}),
        'setFromQuaternion': (($__.fs.J$__v494107025_1206_767 = function J$__v494107025_1206() {
var vvv_return, vvv_switch, matrix;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    return ($__.fs.setFromQuaternion_768 = function setFromQuaternion(q, order, update) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
q = arguments[0], order = arguments[1], update = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (matrix === undefined)
    matrix = new Matrix4();
matrix.makeRotationFromQuaternion(q);
return this.setFromRotationMatrix(matrix, order, update);});
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return function setFromQuaternion(q, order, update) {
    if (matrix === undefined)
        matrix = new Matrix4();
    matrix.makeRotationFromQuaternion(q);
    return this.setFromRotationMatrix(matrix, order, update);
};}), $__.fs.J$__v494107025_1206_767)(0, true, $__.uid),
        'setFromVector3': ($__.fs.J$__v494107025_1208_769 = function J$__v494107025_1208(v, order) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
v = arguments[0], order = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return this.set(v.x, v.y, v.z, order || this._order);}),
        'reorder': (($__.fs.J$__v494107025_1211_770 = function J$__v494107025_1211() {
var vvv_return, vvv_switch, q;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    q = new (Quaternion, $__.fs.Quaternion_10)(0, true, $__.uid);
    return ($__.fs.reorder_771 = function reorder(newOrder) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
newOrder = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
q.setFromEuler(this);
return this.setFromQuaternion(q, newOrder);});
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
q = new Quaternion();
return function reorder(newOrder) {
    q.setFromEuler(this);
    return this.setFromQuaternion(q, newOrder);
};}), $__.fs.J$__v494107025_1211_770)(0, true, $__.uid),
        'equals': ($__.fs.J$__v494107025_1213_772 = function J$__v494107025_1213(euler) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
euler = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return euler._x === this._x && euler._y === this._y && euler._z === this._z && euler._order === this._order;}),
        'fromArray': ($__.fs.J$__v494107025_1215_773 = function J$__v494107025_1215(array) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
array = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this._x = array[0];
this._y = array[1];
this._z = array[2];
if (array[3] !== undefined)
    this._order = array[3];
this.onChangeCallback();
return this;}),
        'toArray': ($__.fs.J$__v494107025_1217_774 = function J$__v494107025_1217(array, offset) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
array = arguments[0], offset = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (array === undefined)
    array = [];
if (offset === undefined)
    offset = 0;
array[offset] = this._x;
array[offset + 1] = this._y;
array[offset + 2] = this._z;
array[offset + 3] = this._order;
return array;}),
        'toVector3': ($__.fs.J$__v494107025_1219_775 = function J$__v494107025_1219(optionalResult) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
optionalResult = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (optionalResult) {
    return optionalResult.set(this._x, this._y, this._z);
} else {
    return new Vector3(this._x, this._y, this._z);
}}),
        'onChange': ($__.fs.J$__v494107025_1221_776 = function J$__v494107025_1221(callback) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
callback = arguments[0];
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    this.onChangeCallback = callback;
    return this;
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.onChangeCallback = callback;
return this;}),
        'onChangeCallback': ($__.fs.J$__v494107025_1223_777 = function J$__v494107025_1223() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');}),
        get x() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return this._x;},
        set x(value) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
value = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this._x = value;
this.onChangeCallback();},
        get y() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return this._y;},
        set y(value) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
value = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this._y = value;
this.onChangeCallback();},
        get z() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return this._z;},
        set z(value) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
value = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this._z = value;
this.onChangeCallback();},
        get order() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return this._order;},
        set order(value) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
value = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this._order = value;
this.onChangeCallback();}
    }, $__.fs.x_778 = Object.getOwnPropertyDescriptor(vvv_tmp13, 'x').get, $__.fs.x_779 = Object.getOwnPropertyDescriptor(vvv_tmp13, 'x').set, $__.fs.y_780 = Object.getOwnPropertyDescriptor(vvv_tmp13, 'y').get, $__.fs.y_781 = Object.getOwnPropertyDescriptor(vvv_tmp13, 'y').set, $__.fs.z_782 = Object.getOwnPropertyDescriptor(vvv_tmp13, 'z').get, $__.fs.z_783 = Object.getOwnPropertyDescriptor(vvv_tmp13, 'z').set, $__.fs.order_784 = Object.getOwnPropertyDescriptor(vvv_tmp13, 'order').get, $__.fs.order_785 = Object.getOwnPropertyDescriptor(vvv_tmp13, 'order').set, $__.os.oid424 = vvv_tmp13);
    Layers.prototype = $__.os.oid425 = {
        'constructor': Layers,
        'set': ($__.fs.J$__v494107025_1226_786 = function J$__v494107025_1226(channel) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
channel = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.mask = 1 << channel;}),
        'enable': ($__.fs.J$__v494107025_1228_787 = function J$__v494107025_1228(channel) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
channel = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.mask |= 1 << channel;}),
        'toggle': ($__.fs.J$__v494107025_1230_788 = function J$__v494107025_1230(channel) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
channel = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.mask ^= 1 << channel;}),
        'disable': ($__.fs.J$__v494107025_1232_789 = function J$__v494107025_1232(channel) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
channel = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.mask &= ~(1 << channel);}),
        'test': ($__.fs.J$__v494107025_1234_790 = function J$__v494107025_1234(layers) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
layers = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return (this.mask & layers.mask) !== 0;})
    };
    Object3D.DefaultUp = new (Vector3, $__.fs.Vector3_11)(0, 1, 0, 23, true, $__.uid);
    Object3D.DefaultMatrixAutoUpdate = true;
    Object['assign'](TAJS_restrictToType(Object3D.prototype, 'object'), TAJS_restrictToType(EventDispatcher.prototype, 'object'), $__.os.oid426 = {
        'isObject3D': true,
        'applyMatrix': ($__.fs.J$__v494107025_1239_791 = function J$__v494107025_1239(matrix) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
matrix = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.matrix.multiplyMatrices(matrix, this.matrix);
this.matrix.decompose(this.position, this.quaternion, this.scale);}),
        'setRotationFromAxisAngle': ($__.fs.J$__v494107025_1241_792 = function J$__v494107025_1241(axis, angle) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
axis = arguments[0], angle = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.quaternion.setFromAxisAngle(axis, angle);}),
        'setRotationFromEuler': ($__.fs.J$__v494107025_1243_793 = function J$__v494107025_1243(euler) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
euler = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.quaternion.setFromEuler(euler, true);}),
        'setRotationFromMatrix': ($__.fs.J$__v494107025_1245_794 = function J$__v494107025_1245(m) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
m = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.quaternion.setFromRotationMatrix(m);}),
        'setRotationFromQuaternion': ($__.fs.J$__v494107025_1247_795 = function J$__v494107025_1247(q) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
q = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.quaternion.copy(q);}),
        'rotateOnAxis': (($__.fs.J$__v494107025_1250_796 = function J$__v494107025_1250() {
var vvv_return, vvv_switch, q1;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    q1 = new (Quaternion, $__.fs.Quaternion_10)(1, true, $__.uid);
    return ($__.fs.rotateOnAxis_797 = function rotateOnAxis(axis, angle) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
axis = arguments[0], angle = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
q1.setFromAxisAngle(axis, angle);
this.quaternion.multiply(q1);
return this;});
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
q1 = new Quaternion();
return function rotateOnAxis(axis, angle) {
    q1.setFromAxisAngle(axis, angle);
    this.quaternion.multiply(q1);
    return this;
};}), $__.fs.J$__v494107025_1250_796)(0, true, $__.uid),
        'rotateX': (($__.fs.J$__v494107025_1253_798 = function J$__v494107025_1253() {
var vvv_return, vvv_switch, v1;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    v1 = new (Vector3, $__.fs.Vector3_11)(1, 0, 0, 24, true, $__.uid);
    return ($__.fs.rotateX_799 = function rotateX(angle) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
angle = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return this.rotateOnAxis(v1, angle);});
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
v1 = new Vector3(1, 0, 0);
return function rotateX(angle) {
    return this.rotateOnAxis(v1, angle);
};}), $__.fs.J$__v494107025_1253_798)(0, true, $__.uid),
        'rotateY': (($__.fs.J$__v494107025_1256_800 = function J$__v494107025_1256() {
var vvv_return, vvv_switch, v1;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    v1 = new (Vector3, $__.fs.Vector3_11)(0, 1, 0, 25, true, $__.uid);
    return ($__.fs.rotateY_801 = function rotateY(angle) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
angle = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return this.rotateOnAxis(v1, angle);});
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
v1 = new Vector3(0, 1, 0);
return function rotateY(angle) {
    return this.rotateOnAxis(v1, angle);
};}), $__.fs.J$__v494107025_1256_800)(0, true, $__.uid),
        'rotateZ': (($__.fs.J$__v494107025_1259_802 = function J$__v494107025_1259() {
var vvv_return, vvv_switch, v1;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    v1 = new (Vector3, $__.fs.Vector3_11)(0, 0, 1, 26, true, $__.uid);
    return ($__.fs.rotateZ_803 = function rotateZ(angle) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
angle = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return this.rotateOnAxis(v1, angle);});
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
v1 = new Vector3(0, 0, 1);
return function rotateZ(angle) {
    return this.rotateOnAxis(v1, angle);
};}), $__.fs.J$__v494107025_1259_802)(0, true, $__.uid),
        'translateOnAxis': (($__.fs.J$__v494107025_1262_804 = function J$__v494107025_1262() {
var vvv_return, vvv_switch, v1;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    v1 = new (Vector3, $__.fs.Vector3_11)(27, true, $__.uid);
    return ($__.fs.translateOnAxis_805 = function translateOnAxis(axis, distance) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
axis = arguments[0], distance = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
v1.copy(axis).applyQuaternion(this.quaternion);
this.position.add(v1.multiplyScalar(distance));
return this;});
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
v1 = new Vector3();
return function translateOnAxis(axis, distance) {
    v1.copy(axis).applyQuaternion(this.quaternion);
    this.position.add(v1.multiplyScalar(distance));
    return this;
};}), $__.fs.J$__v494107025_1262_804)(0, true, $__.uid),
        'translateX': (($__.fs.J$__v494107025_1265_806 = function J$__v494107025_1265() {
var vvv_return, vvv_switch, v1;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    v1 = new (Vector3, $__.fs.Vector3_11)(1, 0, 0, 28, true, $__.uid);
    return ($__.fs.translateX_807 = function translateX(distance) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
distance = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return this.translateOnAxis(v1, distance);});
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
v1 = new Vector3(1, 0, 0);
return function translateX(distance) {
    return this.translateOnAxis(v1, distance);
};}), $__.fs.J$__v494107025_1265_806)(0, true, $__.uid),
        'translateY': (($__.fs.J$__v494107025_1268_808 = function J$__v494107025_1268() {
var vvv_return, vvv_switch, v1;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    v1 = new (Vector3, $__.fs.Vector3_11)(0, 1, 0, 29, true, $__.uid);
    return ($__.fs.translateY_809 = function translateY(distance) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
distance = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return this.translateOnAxis(v1, distance);});
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
v1 = new Vector3(0, 1, 0);
return function translateY(distance) {
    return this.translateOnAxis(v1, distance);
};}), $__.fs.J$__v494107025_1268_808)(0, true, $__.uid),
        'translateZ': (($__.fs.J$__v494107025_1271_810 = function J$__v494107025_1271() {
var vvv_return, vvv_switch, v1;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    v1 = new (Vector3, $__.fs.Vector3_11)(0, 0, 1, 30, true, $__.uid);
    return ($__.fs.translateZ_811 = function translateZ(distance) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
distance = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return this.translateOnAxis(v1, distance);});
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
v1 = new Vector3(0, 0, 1);
return function translateZ(distance) {
    return this.translateOnAxis(v1, distance);
};}), $__.fs.J$__v494107025_1271_810)(0, true, $__.uid),
        'localToWorld': ($__.fs.J$__v494107025_1273_812 = function J$__v494107025_1273(vector) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
vector = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return vector.applyMatrix4(this.matrixWorld);}),
        'worldToLocal': (($__.fs.J$__v494107025_1276_813 = function J$__v494107025_1276() {
var vvv_return, vvv_switch, m1;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    m1 = new (Matrix4, $__.fs.Matrix4_9)(0, true, $__.uid);
    return ($__.fs.worldToLocal_814 = function worldToLocal(vector) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
vector = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return vector.applyMatrix4(m1.getInverse(this.matrixWorld));});
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
m1 = new Matrix4();
return function worldToLocal(vector) {
    return vector.applyMatrix4(m1.getInverse(this.matrixWorld));
};}), $__.fs.J$__v494107025_1276_813)(0, true, $__.uid),
        'lookAt': (($__.fs.J$__v494107025_1279_815 = function J$__v494107025_1279() {
var vvv_return, vvv_switch, m1;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    m1 = new (Matrix4, $__.fs.Matrix4_9)(1, true, $__.uid);
    return ($__.fs.lookAt_816 = function lookAt(vector) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
vector = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
m1.lookAt(vector, this.position, this.up);
this.quaternion.setFromRotationMatrix(m1);});
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
m1 = new Matrix4();
return function lookAt(vector) {
    m1.lookAt(vector, this.position, this.up);
    this.quaternion.setFromRotationMatrix(m1);
};}), $__.fs.J$__v494107025_1279_815)(0, true, $__.uid),
        'add': ($__.fs.J$__v494107025_1281_817 = function J$__v494107025_1281(object) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
object = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (arguments.length > 1) {
    for (var i = 0; i < arguments.length; i++) {
        this.add(arguments[i]);
    }
    return this;
}
if (object === this) {
    console.error('THREE.Object3D.add: object can\'t be added as a child of itself.', object);
    return this;
}
if (object && object.isObject3D) {
    if (object.parent !== null) {
        object.parent.remove(object);
    }
    object.parent = this;
    object.dispatchEvent({
        type: 'added'
    });
    this.children.push(object);
} else {
    console.error('THREE.Object3D.add: object not an instance of THREE.Object3D.', object);
}
return this;}),
        'remove': ($__.fs.J$__v494107025_1283_818 = function J$__v494107025_1283(object) {
var vvv_return, vvv_switch, index;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
object = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (arguments.length > 1) {
    for (var i = 0; i < arguments.length; i++) {
        this.remove(arguments[i]);
    }
}
index = this.children.indexOf(object);
if (index !== -1) {
    object.parent = null;
    object.dispatchEvent({
        type: 'removed'
    });
    this.children.splice(index, 1);
}}),
        'getObjectById': ($__.fs.J$__v494107025_1285_819 = function J$__v494107025_1285(id) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
id = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return this.getObjectByProperty('id', id);}),
        'getObjectByName': ($__.fs.J$__v494107025_1287_820 = function J$__v494107025_1287(name) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
name = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return this.getObjectByProperty('name', name);}),
        'getObjectByProperty': ($__.fs.J$__v494107025_1289_821 = function J$__v494107025_1289(name, value) {
var vvv_return, vvv_switch, child, object;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
name = arguments[0], value = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (this[name] === value)
    return this;
for (var i = 0, l = this.children.length; i < l; i++) {
    child = this.children[i];
    object = child.getObjectByProperty(name, value);
    if (object !== undefined) {
        return object;
    }
}
return undefined;}),
        'getWorldPosition': ($__.fs.J$__v494107025_1291_822 = function J$__v494107025_1291(optionalTarget) {
var vvv_return, vvv_switch, result;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
optionalTarget = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
result = optionalTarget || new Vector3();
this.updateMatrixWorld(true);
return result.setFromMatrixPosition(this.matrixWorld);}),
        'getWorldQuaternion': (($__.fs.J$__v494107025_1294_823 = function J$__v494107025_1294() {
var vvv_return, vvv_switch, position, scale;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    position = new (Vector3, $__.fs.Vector3_11)(31, true, $__.uid);
    scale = new (Vector3, $__.fs.Vector3_11)(32, true, $__.uid);
    return ($__.fs.getWorldQuaternion_824 = function getWorldQuaternion(optionalTarget) {
var vvv_return, vvv_switch, result;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
optionalTarget = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
result = optionalTarget || new Quaternion();
this.updateMatrixWorld(true);
this.matrixWorld.decompose(position, result, scale);
return result;});
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
position = new Vector3();
scale = new Vector3();
return function getWorldQuaternion(optionalTarget) {
    var result = optionalTarget || new Quaternion();
    this.updateMatrixWorld(true);
    this.matrixWorld.decompose(position, result, scale);
    return result;
};}), $__.fs.J$__v494107025_1294_823)(0, true, $__.uid),
        'getWorldRotation': (($__.fs.J$__v494107025_1297_825 = function J$__v494107025_1297() {
var vvv_return, vvv_switch, quaternion;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    quaternion = new (Quaternion, $__.fs.Quaternion_10)(2, true, $__.uid);
    return ($__.fs.getWorldRotation_826 = function getWorldRotation(optionalTarget) {
var vvv_return, vvv_switch, result;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
optionalTarget = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
result = optionalTarget || new Euler();
this.getWorldQuaternion(quaternion);
return result.setFromQuaternion(quaternion, this.rotation.order, false);});
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
quaternion = new Quaternion();
return function getWorldRotation(optionalTarget) {
    var result = optionalTarget || new Euler();
    this.getWorldQuaternion(quaternion);
    return result.setFromQuaternion(quaternion, this.rotation.order, false);
};}), $__.fs.J$__v494107025_1297_825)(0, true, $__.uid),
        'getWorldScale': (($__.fs.J$__v494107025_1300_827 = function J$__v494107025_1300() {
var vvv_return, vvv_switch, position, quaternion;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    position = new (Vector3, $__.fs.Vector3_11)(33, true, $__.uid);
    quaternion = new (Quaternion, $__.fs.Quaternion_10)(3, true, $__.uid);
    return ($__.fs.getWorldScale_828 = function getWorldScale(optionalTarget) {
var vvv_return, vvv_switch, result;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
optionalTarget = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
result = optionalTarget || new Vector3();
this.updateMatrixWorld(true);
this.matrixWorld.decompose(position, quaternion, result);
return result;});
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
position = new Vector3();
quaternion = new Quaternion();
return function getWorldScale(optionalTarget) {
    var result = optionalTarget || new Vector3();
    this.updateMatrixWorld(true);
    this.matrixWorld.decompose(position, quaternion, result);
    return result;
};}), $__.fs.J$__v494107025_1300_827)(0, true, $__.uid),
        'getWorldDirection': (($__.fs.J$__v494107025_1303_829 = function J$__v494107025_1303() {
var vvv_return, vvv_switch, quaternion;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    quaternion = new (Quaternion, $__.fs.Quaternion_10)(4, true, $__.uid);
    return ($__.fs.getWorldDirection_830 = function getWorldDirection(optionalTarget) {
var vvv_return, vvv_switch, result;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
optionalTarget = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
result = optionalTarget || new Vector3();
this.getWorldQuaternion(quaternion);
return result.set(0, 0, 1).applyQuaternion(quaternion);});
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
quaternion = new Quaternion();
return function getWorldDirection(optionalTarget) {
    var result = optionalTarget || new Vector3();
    this.getWorldQuaternion(quaternion);
    return result.set(0, 0, 1).applyQuaternion(quaternion);
};}), $__.fs.J$__v494107025_1303_829)(0, true, $__.uid),
        'raycast': ($__.fs.J$__v494107025_1305_831 = function J$__v494107025_1305() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');}),
        'traverse': ($__.fs.J$__v494107025_1307_832 = function J$__v494107025_1307(callback) {
var vvv_return, vvv_switch, children;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
callback = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
callback(this);
children = this.children;
for (var i = 0, l = children.length; i < l; i++) {
    children[i].traverse(callback);
}}),
        'traverseVisible': ($__.fs.J$__v494107025_1309_833 = function J$__v494107025_1309(callback) {
var vvv_return, vvv_switch, children;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
callback = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (this.visible === false)
    return;
callback(this);
children = this.children;
for (var i = 0, l = children.length; i < l; i++) {
    children[i].traverseVisible(callback);
}}),
        'traverseAncestors': ($__.fs.J$__v494107025_1311_834 = function J$__v494107025_1311(callback) {
var vvv_return, vvv_switch, parent;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
callback = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
parent = this.parent;
if (parent !== null) {
    callback(parent);
    parent.traverseAncestors(callback);
}}),
        'updateMatrix': ($__.fs.J$__v494107025_1313_835 = function J$__v494107025_1313() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.matrix.compose(this.position, this.quaternion, this.scale);
this.matrixWorldNeedsUpdate = true;}),
        'updateMatrixWorld': ($__.fs.J$__v494107025_1315_836 = function J$__v494107025_1315(force) {
var vvv_return, vvv_switch, children;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
force = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (this.matrixAutoUpdate === true)
    this.updateMatrix();
if (this.matrixWorldNeedsUpdate === true || force === true) {
    if (this.parent === null) {
        this.matrixWorld.copy(this.matrix);
    } else {
        this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
    }
    this.matrixWorldNeedsUpdate = false;
    force = true;
}
children = this.children;
for (var i = 0, l = children.length; i < l; i++) {
    children[i].updateMatrixWorld(force);
}}),
        'toJSON': ($__.fs.J$__v494107025_1318_837 = function J$__v494107025_1318(meta) {
var vvv_return, vvv_switch, isRootObject, output, object, geometries, materials, textures, images, extractFromCache;
extractFromCache = function extractFromCache(cache) {
    var values = [];
    for (var key in cache) {
        var data = cache[key];
        delete data.metadata;
        values.push(data);
    }
    return values;
};
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
meta = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
isRootObject = meta === undefined || meta === '';
output = {};
if (isRootObject) {
    meta = {
        geometries: {},
        materials: {},
        textures: {},
        images: {}
    };
    output.metadata = {
        version: 4.4,
        type: 'Object',
        generator: 'Object3D.toJSON'
    };
}
object = {};
object.uuid = this.uuid;
object.type = this.type;
if (this.name !== '')
    object.name = this.name;
if (JSON.stringify(this.userData) !== '{}')
    object.userData = this.userData;
if (this.castShadow === true)
    object.castShadow = true;
if (this.receiveShadow === true)
    object.receiveShadow = true;
if (this.visible === false)
    object.visible = false;
object.matrix = this.matrix.toArray();
if (this.geometry !== undefined) {
    if (meta.geometries[this.geometry.uuid] === undefined) {
        meta.geometries[this.geometry.uuid] = this.geometry.toJSON(meta);
    }
    object.geometry = this.geometry.uuid;
}
if (this.material !== undefined) {
    if (meta.materials[this.material.uuid] === undefined) {
        meta.materials[this.material.uuid] = this.material.toJSON(meta);
    }
    object.material = this.material.uuid;
}
if (this.children.length > 0) {
    object.children = [];
    for (var i = 0; i < this.children.length; i++) {
        object.children.push(this.children[i].toJSON(meta).object);
    }
}
if (isRootObject) {
    geometries = extractFromCache(meta.geometries);
    materials = extractFromCache(meta.materials);
    textures = extractFromCache(meta.textures);
    images = extractFromCache(meta.images);
    if (geometries.length > 0)
        output.geometries = geometries;
    if (materials.length > 0)
        output.materials = materials;
    if (textures.length > 0)
        output.textures = textures;
    if (images.length > 0)
        output.images = images;
}
output.object = object;
return output;}),
        'clone': ($__.fs.J$__v494107025_1320_838 = function J$__v494107025_1320(recursive) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
recursive = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return new this.constructor().copy(this, recursive);}),
        'copy': ($__.fs.J$__v494107025_1322_839 = function J$__v494107025_1322(source, recursive) {
var vvv_return, vvv_switch, child;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
source = arguments[0], recursive = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (recursive === undefined)
    recursive = true;
this.name = source.name;
this.up.copy(source.up);
this.position.copy(source.position);
this.quaternion.copy(source.quaternion);
this.scale.copy(source.scale);
this.matrix.copy(source.matrix);
this.matrixWorld.copy(source.matrixWorld);
this.matrixAutoUpdate = source.matrixAutoUpdate;
this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;
this.visible = source.visible;
this.castShadow = source.castShadow;
this.receiveShadow = source.receiveShadow;
this.frustumCulled = source.frustumCulled;
this.renderOrder = source.renderOrder;
this.userData = JSON.parse(JSON.stringify(source.userData));
if (recursive === true) {
    for (var i = 0; i < source.children.length; i++) {
        child = source.children[i];
        this.add(child.clone());
    }
}
return this;})
    });
    count$3 = 0;
    Object['assign'](TAJS_restrictToType(Geometry.prototype, 'object'), TAJS_restrictToType(EventDispatcher.prototype, 'object'), $__.os.oid427 = {
        'isGeometry': true,
        'applyMatrix': ($__.fs.J$__v494107025_1326_840 = function J$__v494107025_1326(matrix) {
var vvv_return, vvv_switch, normalMatrix, vertex, face;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
matrix = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
normalMatrix = new Matrix3().getNormalMatrix(matrix);
for (var i = 0, il = this.vertices.length; i < il; i++) {
    vertex = this.vertices[i];
    vertex.applyMatrix4(matrix);
}
for (var i = 0, il = this.faces.length; i < il; i++) {
    face = this.faces[i];
    face.normal.applyMatrix3(normalMatrix).normalize();
    for (var j = 0, jl = face.vertexNormals.length; j < jl; j++) {
        face.vertexNormals[j].applyMatrix3(normalMatrix).normalize();
    }
}
if (this.boundingBox !== null) {
    this.computeBoundingBox();
}
if (this.boundingSphere !== null) {
    this.computeBoundingSphere();
}
this.verticesNeedUpdate = true;
this.normalsNeedUpdate = true;
return this;}),
        'rotateX': (($__.fs.J$__v494107025_1329_841 = function J$__v494107025_1329() {
var vvv_return, vvv_switch, m1;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    return ($__.fs.rotateX_842 = function rotateX(angle) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
angle = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (m1 === undefined)
    m1 = new Matrix4();
m1.makeRotationX(angle);
this.applyMatrix(m1);
return this;});
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return function rotateX(angle) {
    if (m1 === undefined)
        m1 = new Matrix4();
    m1.makeRotationX(angle);
    this.applyMatrix(m1);
    return this;
};}), $__.fs.J$__v494107025_1329_841)(0, true, $__.uid),
        'rotateY': (($__.fs.J$__v494107025_1332_843 = function J$__v494107025_1332() {
var vvv_return, vvv_switch, m1;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    return ($__.fs.rotateY_844 = function rotateY(angle) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
angle = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (m1 === undefined)
    m1 = new Matrix4();
m1.makeRotationY(angle);
this.applyMatrix(m1);
return this;});
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return function rotateY(angle) {
    if (m1 === undefined)
        m1 = new Matrix4();
    m1.makeRotationY(angle);
    this.applyMatrix(m1);
    return this;
};}), $__.fs.J$__v494107025_1332_843)(0, true, $__.uid),
        'rotateZ': (($__.fs.J$__v494107025_1335_845 = function J$__v494107025_1335() {
var vvv_return, vvv_switch, m1;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    return ($__.fs.rotateZ_846 = function rotateZ(angle) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
angle = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (m1 === undefined)
    m1 = new Matrix4();
m1.makeRotationZ(angle);
this.applyMatrix(m1);
return this;});
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return function rotateZ(angle) {
    if (m1 === undefined)
        m1 = new Matrix4();
    m1.makeRotationZ(angle);
    this.applyMatrix(m1);
    return this;
};}), $__.fs.J$__v494107025_1335_845)(0, true, $__.uid),
        'translate': (($__.fs.J$__v494107025_1338_847 = function J$__v494107025_1338() {
var vvv_return, vvv_switch, m1;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    return ($__.fs.translate_848 = function translate(x, y, z) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
x = arguments[0], y = arguments[1], z = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (m1 === undefined)
    m1 = new Matrix4();
m1.makeTranslation(x, y, z);
this.applyMatrix(m1);
return this;});
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return function translate(x, y, z) {
    if (m1 === undefined)
        m1 = new Matrix4();
    m1.makeTranslation(x, y, z);
    this.applyMatrix(m1);
    return this;
};}), $__.fs.J$__v494107025_1338_847)(0, true, $__.uid),
        'scale': (($__.fs.J$__v494107025_1341_849 = function J$__v494107025_1341() {
var vvv_return, vvv_switch, m1;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    return ($__.fs.scale_850 = function scale(x, y, z) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
x = arguments[0], y = arguments[1], z = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (m1 === undefined)
    m1 = new Matrix4();
m1.makeScale(x, y, z);
this.applyMatrix(m1);
return this;});
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return function scale(x, y, z) {
    if (m1 === undefined)
        m1 = new Matrix4();
    m1.makeScale(x, y, z);
    this.applyMatrix(m1);
    return this;
};}), $__.fs.J$__v494107025_1341_849)(0, true, $__.uid),
        'lookAt': (($__.fs.J$__v494107025_1344_851 = function J$__v494107025_1344() {
var vvv_return, vvv_switch, obj;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    return ($__.fs.lookAt_852 = function lookAt(vector) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
vector = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (obj === undefined)
    obj = new Object3D();
obj.lookAt(vector);
obj.updateMatrix();
this.applyMatrix(obj.matrix);});
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return function lookAt(vector) {
    if (obj === undefined)
        obj = new Object3D();
    obj.lookAt(vector);
    obj.updateMatrix();
    this.applyMatrix(obj.matrix);
};}), $__.fs.J$__v494107025_1344_851)(0, true, $__.uid),
        'fromBufferGeometry': ($__.fs.J$__v494107025_1347_853 = function J$__v494107025_1347(geometry) {
var vvv_return, vvv_switch, scope, indices, attributes, positions, normals, colors, uvs, uvs2, tempNormals, tempUVs, tempUVs2, addFace, groups, group, start, count;
addFace = function addFace(a, b, c, materialIndex) {
    var vertexNormals = normals !== undefined ? [
        tempNormals[a].clone(),
        tempNormals[b].clone(),
        tempNormals[c].clone()
    ] : [];
    var vertexColors = colors !== undefined ? [
        scope.colors[a].clone(),
        scope.colors[b].clone(),
        scope.colors[c].clone()
    ] : [];
    var face = new Face3(a, b, c, vertexNormals, vertexColors, materialIndex);
    scope.faces.push(face);
    if (uvs !== undefined) {
        scope.faceVertexUvs[0].push([
            tempUVs[a].clone(),
            tempUVs[b].clone(),
            tempUVs[c].clone()
        ]);
    }
    if (uvs2 !== undefined) {
        scope.faceVertexUvs[1].push([
            tempUVs2[a].clone(),
            tempUVs2[b].clone(),
            tempUVs2[c].clone()
        ]);
    }
};
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
geometry = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
scope = this;
indices = geometry.index !== null ? geometry.index.array : undefined;
attributes = geometry.attributes;
positions = attributes.position.array;
normals = attributes.normal !== undefined ? attributes.normal.array : undefined;
colors = attributes.color !== undefined ? attributes.color.array : undefined;
uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;
uvs2 = attributes.uv2 !== undefined ? attributes.uv2.array : undefined;
if (uvs2 !== undefined)
    this.faceVertexUvs[1] = [];
tempNormals = [];
tempUVs = [];
tempUVs2 = [];
for (var i = 0, j = 0; i < positions.length; i += 3, j += 2) {
    scope.vertices.push(new Vector3(positions[i], positions[i + 1], positions[i + 2]));
    if (normals !== undefined) {
        tempNormals.push(new Vector3(normals[i], normals[i + 1], normals[i + 2]));
    }
    if (colors !== undefined) {
        scope.colors.push(new Color(colors[i], colors[i + 1], colors[i + 2]));
    }
    if (uvs !== undefined) {
        tempUVs.push(new Vector2(uvs[j], uvs[j + 1]));
    }
    if (uvs2 !== undefined) {
        tempUVs2.push(new Vector2(uvs2[j], uvs2[j + 1]));
    }
}
if (indices !== undefined) {
    groups = geometry.groups;
    if (groups.length > 0) {
        for (var i = 0; i < groups.length; i++) {
            group = groups[i];
            start = group.start;
            count = group.count;
            for (var j = start, jl = start + count; j < jl; j += 3) {
                addFace(indices[j], indices[j + 1], indices[j + 2], group.materialIndex);
            }
        }
    } else {
        for (var i = 0; i < indices.length; i += 3) {
            addFace(indices[i], indices[i + 1], indices[i + 2]);
        }
    }
} else {
    for (var i = 0; i < positions.length / 3; i += 3) {
        addFace(i, i + 1, i + 2);
    }
}
this.computeFaceNormals();
if (geometry.boundingBox !== null) {
    this.boundingBox = geometry.boundingBox.clone();
}
if (geometry.boundingSphere !== null) {
    this.boundingSphere = geometry.boundingSphere.clone();
}
return this;}),
        'center': ($__.fs.J$__v494107025_1349_854 = function J$__v494107025_1349() {
var vvv_return, vvv_switch, offset;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.computeBoundingBox();
offset = this.boundingBox.center().negate();
this.translate(offset.x, offset.y, offset.z);
return offset;}),
        'normalize': ($__.fs.J$__v494107025_1351_855 = function J$__v494107025_1351() {
var vvv_return, vvv_switch, center, radius, s, matrix;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.computeBoundingSphere();
center = this.boundingSphere.center;
radius = this.boundingSphere.radius;
s = radius === 0 ? 1 : 1 / radius;
matrix = new Matrix4();
matrix.set(s, 0, 0, -s * center.x, 0, s, 0, -s * center.y, 0, 0, s, -s * center.z, 0, 0, 0, 1);
this.applyMatrix(matrix);
return this;}),
        'computeFaceNormals': ($__.fs.J$__v494107025_1353_856 = function J$__v494107025_1353() {
var vvv_return, vvv_switch, cb, ab, face, vA, vB, vC;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
cb = new Vector3();
ab = new Vector3();
for (var f = 0, fl = this.faces.length; f < fl; f++) {
    face = this.faces[f];
    vA = this.vertices[face.a];
    vB = this.vertices[face.b];
    vC = this.vertices[face.c];
    cb.subVectors(vC, vB);
    ab.subVectors(vA, vB);
    cb.cross(ab);
    cb.normalize();
    face.normal.copy(cb);
}}),
        'computeVertexNormals': ($__.fs.J$__v494107025_1355_857 = function J$__v494107025_1355(areaWeighted) {
var vvv_return, vvv_switch, v, vl, f, fl, face, vertices, vA, vB, vC, cb, ab, vertexNormals;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
areaWeighted = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (areaWeighted === undefined)
    areaWeighted = true;
vertices = new Array(this.vertices.length);
for (v = 0, vl = this.vertices.length; v < vl; v++) {
    vertices[v] = new Vector3();
}
if (areaWeighted) {
    cb = new Vector3();
    ab = new Vector3();
    for (f = 0, fl = this.faces.length; f < fl; f++) {
        face = this.faces[f];
        vA = this.vertices[face.a];
        vB = this.vertices[face.b];
        vC = this.vertices[face.c];
        cb.subVectors(vC, vB);
        ab.subVectors(vA, vB);
        cb.cross(ab);
        vertices[face.a].add(cb);
        vertices[face.b].add(cb);
        vertices[face.c].add(cb);
    }
} else {
    for (f = 0, fl = this.faces.length; f < fl; f++) {
        face = this.faces[f];
        vertices[face.a].add(face.normal);
        vertices[face.b].add(face.normal);
        vertices[face.c].add(face.normal);
    }
}
for (v = 0, vl = this.vertices.length; v < vl; v++) {
    vertices[v].normalize();
}
for (f = 0, fl = this.faces.length; f < fl; f++) {
    face = this.faces[f];
    vertexNormals = face.vertexNormals;
    if (vertexNormals.length === 3) {
        vertexNormals[0].copy(vertices[face.a]);
        vertexNormals[1].copy(vertices[face.b]);
        vertexNormals[2].copy(vertices[face.c]);
    } else {
        vertexNormals[0] = vertices[face.a].clone();
        vertexNormals[1] = vertices[face.b].clone();
        vertexNormals[2] = vertices[face.c].clone();
    }
}
if (this.faces.length > 0) {
    this.normalsNeedUpdate = true;
}}),
        'computeMorphNormals': ($__.fs.J$__v494107025_1357_858 = function J$__v494107025_1357() {
var vvv_return, vvv_switch, i, il, f, fl, face, tmpGeo, dstNormalsFace, dstNormalsVertex, faceNormal, vertexNormals, morphNormals;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
for (f = 0, fl = this.faces.length; f < fl; f++) {
    face = this.faces[f];
    if (!face.__originalFaceNormal) {
        face.__originalFaceNormal = face.normal.clone();
    } else {
        face.__originalFaceNormal.copy(face.normal);
    }
    if (!face.__originalVertexNormals)
        face.__originalVertexNormals = [];
    for (i = 0, il = face.vertexNormals.length; i < il; i++) {
        if (!face.__originalVertexNormals[i]) {
            face.__originalVertexNormals[i] = face.vertexNormals[i].clone();
        } else {
            face.__originalVertexNormals[i].copy(face.vertexNormals[i]);
        }
    }
}
tmpGeo = new Geometry();
tmpGeo.faces = this.faces;
for (i = 0, il = this.morphTargets.length; i < il; i++) {
    if (!this.morphNormals[i]) {
        this.morphNormals[i] = {};
        this.morphNormals[i].faceNormals = [];
        this.morphNormals[i].vertexNormals = [];
        dstNormalsFace = this.morphNormals[i].faceNormals;
        dstNormalsVertex = this.morphNormals[i].vertexNormals;
        for (f = 0, fl = this.faces.length; f < fl; f++) {
            faceNormal = new Vector3();
            vertexNormals = {
                a: new Vector3(),
                b: new Vector3(),
                c: new Vector3()
            };
            dstNormalsFace.push(faceNormal);
            dstNormalsVertex.push(vertexNormals);
        }
    }
    morphNormals = this.morphNormals[i];
    tmpGeo.vertices = this.morphTargets[i].vertices;
    tmpGeo.computeFaceNormals();
    tmpGeo.computeVertexNormals();
    for (f = 0, fl = this.faces.length; f < fl; f++) {
        face = this.faces[f];
        faceNormal = morphNormals.faceNormals[f];
        vertexNormals = morphNormals.vertexNormals[f];
        faceNormal.copy(face.normal);
        vertexNormals.a.copy(face.vertexNormals[0]);
        vertexNormals.b.copy(face.vertexNormals[1]);
        vertexNormals.c.copy(face.vertexNormals[2]);
    }
}
for (f = 0, fl = this.faces.length; f < fl; f++) {
    face = this.faces[f];
    face.normal = face.__originalFaceNormal;
    face.vertexNormals = face.__originalVertexNormals;
}}),
        'computeTangents': ($__.fs.J$__v494107025_1359_859 = function J$__v494107025_1359() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
console.warn('THREE.Geometry: .computeTangents() has been removed.');}),
        'computeLineDistances': ($__.fs.J$__v494107025_1361_860 = function J$__v494107025_1361() {
var vvv_return, vvv_switch, d, vertices;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
d = 0;
vertices = this.vertices;
for (var i = 0, il = vertices.length; i < il; i++) {
    if (i > 0) {
        d += vertices[i].distanceTo(vertices[i - 1]);
    }
    this.lineDistances[i] = d;
}}),
        'computeBoundingBox': ($__.fs.J$__v494107025_1363_861 = function J$__v494107025_1363() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (this.boundingBox === null) {
    this.boundingBox = new Box3();
}
this.boundingBox.setFromPoints(this.vertices);}),
        'computeBoundingSphere': ($__.fs.J$__v494107025_1365_862 = function J$__v494107025_1365() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (this.boundingSphere === null) {
    this.boundingSphere = new Sphere();
}
this.boundingSphere.setFromPoints(this.vertices);}),
        'merge': ($__.fs.J$__v494107025_1367_863 = function J$__v494107025_1367(geometry, matrix, materialIndexOffset) {
var vvv_return, vvv_switch, normalMatrix, vertexOffset, vertices1, vertices2, faces1, faces2, uvs1, uvs2, vertex, vertexCopy, face, faceCopy, normal, color, faceVertexNormals, faceVertexColors, uv, uvCopy;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
geometry = arguments[0], matrix = arguments[1], materialIndexOffset = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if ((geometry && geometry.isGeometry) === false) {
    console.error('THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry);
    return;
}
vertexOffset = this.vertices.length;
vertices1 = this.vertices;
vertices2 = geometry.vertices;
faces1 = this.faces;
faces2 = geometry.faces;
uvs1 = this.faceVertexUvs[0];
uvs2 = geometry.faceVertexUvs[0];
if (materialIndexOffset === undefined)
    materialIndexOffset = 0;
if (matrix !== undefined) {
    normalMatrix = new Matrix3().getNormalMatrix(matrix);
}
for (var i = 0, il = vertices2.length; i < il; i++) {
    vertex = vertices2[i];
    vertexCopy = vertex.clone();
    if (matrix !== undefined)
        vertexCopy.applyMatrix4(matrix);
    vertices1.push(vertexCopy);
}
for (i = 0, il = faces2.length; i < il; i++) {
    face = faces2[i];
    faceVertexNormals = face.vertexNormals;
    faceVertexColors = face.vertexColors;
    faceCopy = new Face3(face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset);
    faceCopy.normal.copy(face.normal);
    if (normalMatrix !== undefined) {
        faceCopy.normal.applyMatrix3(normalMatrix).normalize();
    }
    for (var j = 0, jl = faceVertexNormals.length; j < jl; j++) {
        normal = faceVertexNormals[j].clone();
        if (normalMatrix !== undefined) {
            normal.applyMatrix3(normalMatrix).normalize();
        }
        faceCopy.vertexNormals.push(normal);
    }
    faceCopy.color.copy(face.color);
    for (var j = 0, jl = faceVertexColors.length; j < jl; j++) {
        color = faceVertexColors[j];
        faceCopy.vertexColors.push(color.clone());
    }
    faceCopy.materialIndex = face.materialIndex + materialIndexOffset;
    faces1.push(faceCopy);
}
for (i = 0, il = uvs2.length; i < il; i++) {
    uv = uvs2[i];
    uvCopy = [];
    if (uv === undefined) {
        continue;
    }
    for (var j = 0, jl = uv.length; j < jl; j++) {
        uvCopy.push(uv[j].clone());
    }
    uvs1.push(uvCopy);
}}),
        'mergeMesh': ($__.fs.J$__v494107025_1369_864 = function J$__v494107025_1369(mesh) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
mesh = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if ((mesh && mesh.isMesh) === false) {
    console.error('THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh);
    return;
}
mesh.matrixAutoUpdate && mesh.updateMatrix();
this.merge(mesh.geometry, mesh.matrix);}),
        'mergeVertices': ($__.fs.J$__v494107025_1371_865 = function J$__v494107025_1371() {
var vvv_return, vvv_switch, verticesMap, unique, changes, v, key, precisionPoints, precision, i, il, face, indices, j, jl, faceIndicesToRemove, dupIndex, idx, diff;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
verticesMap = {};
unique = [];
changes = [];
precisionPoints = 4;
precision = Math.pow(10, precisionPoints);
for (i = 0, il = this.vertices.length; i < il; i++) {
    v = this.vertices[i];
    key = Math.round(v.x * precision) + '_' + Math.round(v.y * precision) + '_' + Math.round(v.z * precision);
    if (verticesMap[key] === undefined) {
        verticesMap[key] = i;
        unique.push(this.vertices[i]);
        changes[i] = unique.length - 1;
    } else {
        changes[i] = changes[verticesMap[key]];
    }
}
faceIndicesToRemove = [];
for (i = 0, il = this.faces.length; i < il; i++) {
    face = this.faces[i];
    face.a = changes[face.a];
    face.b = changes[face.b];
    face.c = changes[face.c];
    indices = [
        face.a,
        face.b,
        face.c
    ];
    dupIndex = -1;
    for (var n = 0; n < 3; n++) {
        if (indices[n] === indices[(n + 1) % 3]) {
            dupIndex = n;
            faceIndicesToRemove.push(i);
            break;
        }
    }
}
for (i = faceIndicesToRemove.length - 1; i >= 0; i--) {
    idx = faceIndicesToRemove[i];
    this.faces.splice(idx, 1);
    for (j = 0, jl = this.faceVertexUvs.length; j < jl; j++) {
        this.faceVertexUvs[j].splice(idx, 1);
    }
}
diff = this.vertices.length - unique.length;
this.vertices = unique;
return diff;}),
        'sortFacesByMaterialIndex': ($__.fs.J$__v494107025_1374_866 = function J$__v494107025_1374() {
var vvv_return, vvv_switch, faces, length, materialIndexSort, uvs1, uvs2, newUvs1, newUvs2, id;
materialIndexSort = function materialIndexSort(a, b) {
    return a.materialIndex - b.materialIndex;
};
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
faces = this.faces;
length = faces.length;
for (var i = 0; i < length; i++) {
    faces[i]._id = i;
}
faces.sort(materialIndexSort);
uvs1 = this.faceVertexUvs[0];
uvs2 = this.faceVertexUvs[1];
if (uvs1 && uvs1.length === length)
    newUvs1 = [];
if (uvs2 && uvs2.length === length)
    newUvs2 = [];
for (var i = 0; i < length; i++) {
    id = faces[i]._id;
    if (newUvs1)
        newUvs1.push(uvs1[id]);
    if (newUvs2)
        newUvs2.push(uvs2[id]);
}
if (newUvs1)
    this.faceVertexUvs[0] = newUvs1;
if (newUvs2)
    this.faceVertexUvs[1] = newUvs2;}),
        'toJSON': ($__.fs.J$__v494107025_1380_867 = function J$__v494107025_1380() {
var vvv_return, vvv_switch, data, parameters, vertices, vertex, faces, normals, normalsHash, colors, colorsHash, uvs, uvsHash, face, hasMaterial, hasFaceUv, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor, faceType, faceVertexUvs, vertexNormals, vertexColors, setBit, getNormalIndex, getColorIndex, getUvIndex;
setBit = function setBit(value, position, enabled) {
    return enabled ? value | 1 << position : value & ~(1 << position);
};
getNormalIndex = function getNormalIndex(normal) {
    var hash = normal.x.toString() + normal.y.toString() + normal.z.toString();
    if (normalsHash[hash] !== undefined) {
        return normalsHash[hash];
    }
    normalsHash[hash] = normals.length / 3;
    normals.push(normal.x, normal.y, normal.z);
    return normalsHash[hash];
};
getColorIndex = function getColorIndex(color) {
    var hash = color.r.toString() + color.g.toString() + color.b.toString();
    if (colorsHash[hash] !== undefined) {
        return colorsHash[hash];
    }
    colorsHash[hash] = colors.length;
    colors.push(color.getHex());
    return colorsHash[hash];
};
getUvIndex = function getUvIndex(uv) {
    var hash = uv.x.toString() + uv.y.toString();
    if (uvsHash[hash] !== undefined) {
        return uvsHash[hash];
    }
    uvsHash[hash] = uvs.length / 2;
    uvs.push(uv.x, uv.y);
    return uvsHash[hash];
};
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
data = {
    metadata: {
        version: 4.4,
        type: 'Geometry',
        generator: 'Geometry.toJSON'
    }
};
data.uuid = this.uuid;
data.type = this.type;
if (this.name !== '')
    data.name = this.name;
if (this.parameters !== undefined) {
    parameters = this.parameters;
    for (var key in parameters) {
        if (parameters[key] !== undefined)
            data[key] = parameters[key];
    }
    return data;
}
vertices = [];
for (var i = 0; i < this.vertices.length; i++) {
    vertex = this.vertices[i];
    vertices.push(vertex.x, vertex.y, vertex.z);
}
faces = [];
normals = [];
normalsHash = {};
colors = [];
colorsHash = {};
uvs = [];
uvsHash = {};
for (var i = 0; i < this.faces.length; i++) {
    face = this.faces[i];
    hasMaterial = true;
    hasFaceUv = false;
    hasFaceVertexUv = this.faceVertexUvs[0][i] !== undefined;
    hasFaceNormal = face.normal.length() > 0;
    hasFaceVertexNormal = face.vertexNormals.length > 0;
    hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;
    hasFaceVertexColor = face.vertexColors.length > 0;
    faceType = 0;
    faceType = setBit(faceType, 0, 0);
    faceType = setBit(faceType, 1, hasMaterial);
    faceType = setBit(faceType, 2, hasFaceUv);
    faceType = setBit(faceType, 3, hasFaceVertexUv);
    faceType = setBit(faceType, 4, hasFaceNormal);
    faceType = setBit(faceType, 5, hasFaceVertexNormal);
    faceType = setBit(faceType, 6, hasFaceColor);
    faceType = setBit(faceType, 7, hasFaceVertexColor);
    faces.push(faceType);
    faces.push(face.a, face.b, face.c);
    faces.push(face.materialIndex);
    if (hasFaceVertexUv) {
        faceVertexUvs = this.faceVertexUvs[0][i];
        faces.push(getUvIndex(faceVertexUvs[0]), getUvIndex(faceVertexUvs[1]), getUvIndex(faceVertexUvs[2]));
    }
    if (hasFaceNormal) {
        faces.push(getNormalIndex(face.normal));
    }
    if (hasFaceVertexNormal) {
        vertexNormals = face.vertexNormals;
        faces.push(getNormalIndex(vertexNormals[0]), getNormalIndex(vertexNormals[1]), getNormalIndex(vertexNormals[2]));
    }
    if (hasFaceColor) {
        faces.push(getColorIndex(face.color));
    }
    if (hasFaceVertexColor) {
        vertexColors = face.vertexColors;
        faces.push(getColorIndex(vertexColors[0]), getColorIndex(vertexColors[1]), getColorIndex(vertexColors[2]));
    }
}
data.data = {};
data.data.vertices = vertices;
data.data.normals = normals;
if (colors.length > 0)
    data.data.colors = colors;
if (uvs.length > 0)
    data.data.uvs = [uvs];
data.data.faces = faces;
return data;}),
        'clone': ($__.fs.J$__v494107025_1382_868 = function J$__v494107025_1382() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return new Geometry().copy(this);}),
        'copy': ($__.fs.J$__v494107025_1384_869 = function J$__v494107025_1384(source) {
var vvv_return, vvv_switch, vertices, faces, faceVertexUvs, uvs, uvsCopy, uv;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
source = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.vertices = [];
this.faces = [];
this.faceVertexUvs = [[]];
vertices = source.vertices;
for (var i = 0, il = vertices.length; i < il; i++) {
    this.vertices.push(vertices[i].clone());
}
faces = source.faces;
for (var i = 0, il = faces.length; i < il; i++) {
    this.faces.push(faces[i].clone());
}
for (var i = 0, il = source.faceVertexUvs.length; i < il; i++) {
    faceVertexUvs = source.faceVertexUvs[i];
    if (this.faceVertexUvs[i] === undefined) {
        this.faceVertexUvs[i] = [];
    }
    for (var j = 0, jl = faceVertexUvs.length; j < jl; j++) {
        uvs = faceVertexUvs[j];
        uvsCopy = [];
        for (var k = 0, kl = uvs.length; k < kl; k++) {
            uv = uvs[k];
            uvsCopy.push(uv.clone());
        }
        this.faceVertexUvs[i].push(uvsCopy);
    }
}
return this;}),
        'dispose': ($__.fs.J$__v494107025_1386_870 = function J$__v494107025_1386() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.dispatchEvent({
    type: 'dispose'
});})
    });
    count$2 = 0;
    Object['assign'](TAJS_restrictToType(DirectGeometry.prototype, 'object'), TAJS_restrictToType(EventDispatcher.prototype, 'object'), $__.os.oid428 = {
        'computeBoundingBox': TAJS_restrictToType(TAJS_restrictToType(Geometry.prototype, 'object').computeBoundingBox, 'function'),
        'computeBoundingSphere': TAJS_restrictToType(TAJS_restrictToType(Geometry.prototype, 'object').computeBoundingSphere, 'function'),
        'computeFaceNormals': ($__.fs.J$__v494107025_1390_871 = function J$__v494107025_1390() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
console.warn('THREE.DirectGeometry: computeFaceNormals() is not a method of this type of geometry.');}),
        'computeVertexNormals': ($__.fs.J$__v494107025_1392_872 = function J$__v494107025_1392() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
console.warn('THREE.DirectGeometry: computeVertexNormals() is not a method of this type of geometry.');}),
        'computeGroups': ($__.fs.J$__v494107025_1394_873 = function J$__v494107025_1394(geometry) {
var vvv_return, vvv_switch, group, groups, materialIndex, faces, face;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
geometry = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
groups = [];
faces = geometry.faces;
for (var i = 0; i < faces.length; i++) {
    face = faces[i];
    if (face.materialIndex !== materialIndex) {
        materialIndex = face.materialIndex;
        if (group !== undefined) {
            group.count = i * 3 - group.start;
            groups.push(group);
        }
        group = {
            start: i * 3,
            materialIndex: materialIndex
        };
    }
}
if (group !== undefined) {
    group.count = i * 3 - group.start;
    groups.push(group);
}
this.groups = groups;}),
        'fromGeometry': ($__.fs.J$__v494107025_1396_874 = function J$__v494107025_1396(geometry) {
var vvv_return, vvv_switch, faces, vertices, faceVertexUvs, hasFaceVertexUv, hasFaceVertexUv2, morphTargets, morphTargetsLength, morphTargetsPosition, morphNormals, morphNormalsLength, morphTargetsNormal, skinIndices, skinWeights, hasSkinIndices, hasSkinWeights, face, vertexNormals, normal, vertexColors, color, vertexUvs, morphTarget, morphNormal;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
geometry = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
faces = geometry.faces;
vertices = geometry.vertices;
faceVertexUvs = geometry.faceVertexUvs;
hasFaceVertexUv = faceVertexUvs[0] && faceVertexUvs[0].length > 0;
hasFaceVertexUv2 = faceVertexUvs[1] && faceVertexUvs[1].length > 0;
morphTargets = geometry.morphTargets;
morphTargetsLength = morphTargets.length;
if (morphTargetsLength > 0) {
    morphTargetsPosition = [];
    for (var i = 0; i < morphTargetsLength; i++) {
        morphTargetsPosition[i] = [];
    }
    this.morphTargets.position = morphTargetsPosition;
}
morphNormals = geometry.morphNormals;
morphNormalsLength = morphNormals.length;
if (morphNormalsLength > 0) {
    morphTargetsNormal = [];
    for (var i = 0; i < morphNormalsLength; i++) {
        morphTargetsNormal[i] = [];
    }
    this.morphTargets.normal = morphTargetsNormal;
}
skinIndices = geometry.skinIndices;
skinWeights = geometry.skinWeights;
hasSkinIndices = skinIndices.length === vertices.length;
hasSkinWeights = skinWeights.length === vertices.length;
for (var i = 0; i < faces.length; i++) {
    face = faces[i];
    this.vertices.push(vertices[face.a], vertices[face.b], vertices[face.c]);
    vertexNormals = face.vertexNormals;
    if (vertexNormals.length === 3) {
        this.normals.push(vertexNormals[0], vertexNormals[1], vertexNormals[2]);
    } else {
        normal = face.normal;
        this.normals.push(normal, normal, normal);
    }
    vertexColors = face.vertexColors;
    if (vertexColors.length === 3) {
        this.colors.push(vertexColors[0], vertexColors[1], vertexColors[2]);
    } else {
        color = face.color;
        this.colors.push(color, color, color);
    }
    if (hasFaceVertexUv === true) {
        vertexUvs = faceVertexUvs[0][i];
        if (vertexUvs !== undefined) {
            this.uvs.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);
        } else {
            console.warn('THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i);
            this.uvs.push(new Vector2(), new Vector2(), new Vector2());
        }
    }
    if (hasFaceVertexUv2 === true) {
        vertexUvs = faceVertexUvs[1][i];
        if (vertexUvs !== undefined) {
            this.uvs2.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);
        } else {
            console.warn('THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i);
            this.uvs2.push(new Vector2(), new Vector2(), new Vector2());
        }
    }
    for (var j = 0; j < morphTargetsLength; j++) {
        morphTarget = morphTargets[j].vertices;
        morphTargetsPosition[j].push(morphTarget[face.a], morphTarget[face.b], morphTarget[face.c]);
    }
    for (var j = 0; j < morphNormalsLength; j++) {
        morphNormal = morphNormals[j].vertexNormals[i];
        morphTargetsNormal[j].push(morphNormal.a, morphNormal.b, morphNormal.c);
    }
    if (hasSkinIndices) {
        this.skinIndices.push(skinIndices[face.a], skinIndices[face.b], skinIndices[face.c]);
    }
    if (hasSkinWeights) {
        this.skinWeights.push(skinWeights[face.a], skinWeights[face.b], skinWeights[face.c]);
    }
}
this.computeGroups(geometry);
this.verticesNeedUpdate = geometry.verticesNeedUpdate;
this.normalsNeedUpdate = geometry.normalsNeedUpdate;
this.colorsNeedUpdate = geometry.colorsNeedUpdate;
this.uvsNeedUpdate = geometry.uvsNeedUpdate;
this.groupsNeedUpdate = geometry.groupsNeedUpdate;
return this;}),
        'dispose': ($__.fs.J$__v494107025_1398_875 = function J$__v494107025_1398() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.dispatchEvent({
    type: 'dispose'
});})
    });
    Object['assign'](TAJS_restrictToType(BufferGeometry.prototype, 'object'), TAJS_restrictToType(EventDispatcher.prototype, 'object'), $__.os.oid429 = {
        'isBufferGeometry': true,
        'getIndex': ($__.fs.J$__v494107025_1401_876 = function J$__v494107025_1401() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return this.index;}),
        'setIndex': ($__.fs.J$__v494107025_1403_877 = function J$__v494107025_1403(index) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
index = arguments[0];
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    this.index = index;
    return;
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.index = index;}),
        'addAttribute': ($__.fs.J$__v494107025_1405_878 = function J$__v494107025_1405(name, attribute) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
name = arguments[0], attribute = arguments[1];
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    (attribute, (attribute.isBufferAttribute, true)) === false;
    name === 'index';
    ((this.attributes, $__.os.oid531), $__.os.oid531)[name, 'position'] = attribute;
    return this;
case 1:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 1);
    (attribute, (attribute.isBufferAttribute, true)) === false;
    name === 'index';
    ((this.attributes, $__.os.oid536), $__.os.oid536)[name, 'position'] = attribute;
    return this;
case 2:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 2);
    (attribute, (attribute.isBufferAttribute, true)) === false;
    name === 'index';
    ((this.attributes, $__.os.oid536), $__.os.oid536)[name, 'normal'] = attribute;
    return this;
case 3:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 3);
    (attribute, (attribute.isBufferAttribute, true)) === false;
    name === 'index';
    ((this.attributes, $__.os.oid536), $__.os.oid536)[name, 'uv'] = attribute;
    return this;
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if ((attribute && attribute.isBufferAttribute) === false && (attribute && attribute.isInterleavedBufferAttribute) === false) {
    console.warn('THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).');
    this.addAttribute(name, new BufferAttribute(arguments[1], arguments[2]));
    return;
}
if (name === 'index') {
    console.warn('THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.');
    this.setIndex(attribute);
    return;
}
this.attributes[name] = attribute;
return this;}),
        'getAttribute': ($__.fs.J$__v494107025_1407_879 = function J$__v494107025_1407(name) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
name = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return this.attributes[name];}),
        'removeAttribute': ($__.fs.J$__v494107025_1409_880 = function J$__v494107025_1409(name) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
name = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
delete this.attributes[name];
return this;}),
        'addGroup': ($__.fs.J$__v494107025_1411_881 = function J$__v494107025_1411(start, count, materialIndex) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
start = arguments[0], count = arguments[1], materialIndex = arguments[2];
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    TAJS_restrictToType(this.groups, 'object')['push']($__.os.oid544 = {
        'start': start,
        'count': count,
        'materialIndex': (materialIndex !== undefined, materialIndex)
    });
    return;
case 1:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 1);
    TAJS_restrictToType(this.groups, 'object')['push']($__.os.oid545 = {
        'start': start,
        'count': count,
        'materialIndex': (materialIndex !== undefined, materialIndex)
    });
    return;
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.groups.push({
    start: start,
    count: count,
    materialIndex: materialIndex !== undefined ? materialIndex : 0
});}),
        'clearGroups': ($__.fs.J$__v494107025_1413_882 = function J$__v494107025_1413() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.groups = [];}),
        'setDrawRange': ($__.fs.J$__v494107025_1415_883 = function J$__v494107025_1415(start, count) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
start = arguments[0], count = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.drawRange.start = start;
this.drawRange.count = count;}),
        'applyMatrix': ($__.fs.J$__v494107025_1417_884 = function J$__v494107025_1417(matrix) {
var vvv_return, vvv_switch, vvv_tmp0, vvv_tmp1, vvv_tmp2, vvv_tmp3, vvv_tmp4, position, normal, normalMatrix;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
matrix = arguments[0];
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    position = TAJS_restrictToType(((this.attributes, $__.os.oid536), $__.os.oid536).position, 'object');
    position !== undefined;
    vvv_tmp0 = matrix, 'applyToVector3Array', $__.fs.applyToVector3Array_377.call(vvv_tmp0, TAJS_restrictToType(position.array, 'object'), 0, true, $__.uid);
    vvv_tmp1 = position, 'needsUpdate', (null, $__.fs.needsUpdate_760).call(vvv_tmp1, true, 0, true, $__.uid);
    normal = TAJS_restrictToType(((this.attributes, $__.os.oid536), $__.os.oid536).normal, 'object');
    normal !== undefined;
    normalMatrix = (vvv_tmp2 = new (Matrix3, $__.fs.Matrix3_61)(4, true, $__.uid), 'getNormalMatrix', $__.fs.J$__v494107025_992_698.call(vvv_tmp2, matrix, 0, true, $__.uid));
    vvv_tmp3 = normalMatrix, 'applyToVector3Array', $__.fs.applyToVector3Array_690.call(vvv_tmp3, TAJS_restrictToType(normal.array, 'object'), 0, true, $__.uid);
    vvv_tmp4 = normal, 'needsUpdate', (null, $__.fs.needsUpdate_760).call(vvv_tmp4, true, 1, true, $__.uid);
    (this.boundingBox, null) !== null;
    (this.boundingSphere, null) !== null;
    return this;
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
position = this.attributes.position;
if (position !== undefined) {
    matrix.applyToVector3Array(position.array);
    position.needsUpdate = true;
}
normal = this.attributes.normal;
if (normal !== undefined) {
    normalMatrix = new Matrix3().getNormalMatrix(matrix);
    normalMatrix.applyToVector3Array(normal.array);
    normal.needsUpdate = true;
}
if (this.boundingBox !== null) {
    this.computeBoundingBox();
}
if (this.boundingSphere !== null) {
    this.computeBoundingSphere();
}
return this;}),
        'rotateX': (($__.fs.J$__v494107025_1420_885 = function J$__v494107025_1420() {
var vvv_return, vvv_switch, m1;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    return ($__.fs.rotateX_886 = function rotateX(angle) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
angle = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (m1 === undefined)
    m1 = new Matrix4();
m1.makeRotationX(angle);
this.applyMatrix(m1);
return this;});
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return function rotateX(angle) {
    if (m1 === undefined)
        m1 = new Matrix4();
    m1.makeRotationX(angle);
    this.applyMatrix(m1);
    return this;
};}), $__.fs.J$__v494107025_1420_885)(0, true, $__.uid),
        'rotateY': (($__.fs.J$__v494107025_1423_887 = function J$__v494107025_1423() {
var vvv_return, vvv_switch, m1;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    return ($__.fs.rotateY_888 = function rotateY(angle) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
angle = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (m1 === undefined)
    m1 = new Matrix4();
m1.makeRotationY(angle);
this.applyMatrix(m1);
return this;});
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return function rotateY(angle) {
    if (m1 === undefined)
        m1 = new Matrix4();
    m1.makeRotationY(angle);
    this.applyMatrix(m1);
    return this;
};}), $__.fs.J$__v494107025_1423_887)(0, true, $__.uid),
        'rotateZ': (($__.fs.J$__v494107025_1426_889 = function J$__v494107025_1426() {
var vvv_return, vvv_switch, m1;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    return ($__.fs.rotateZ_890 = function rotateZ(angle) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
angle = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (m1 === undefined)
    m1 = new Matrix4();
m1.makeRotationZ(angle);
this.applyMatrix(m1);
return this;});
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return function rotateZ(angle) {
    if (m1 === undefined)
        m1 = new Matrix4();
    m1.makeRotationZ(angle);
    this.applyMatrix(m1);
    return this;
};}), $__.fs.J$__v494107025_1426_889)(0, true, $__.uid),
        'translate': (($__.fs.J$__v494107025_1429_891 = function J$__v494107025_1429() {
var vvv_return, vvv_switch, m1;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    return ($__.fs.translate_892 = function translate(x, y, z) {
var vvv_return, vvv_switch, vvv_tmp0, vvv_tmp1;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
x = arguments[0], y = arguments[1], z = arguments[2];
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    m1 === undefined;
    m1 = new (Matrix4, $__.fs.Matrix4_9)(15, true, $__.uid);
    vvv_tmp0 = m1, 'makeTranslation', $__.fs.J$__v494107025_239_389.call(vvv_tmp0, x, y, z, 0, true, $__.uid);
    vvv_tmp1 = this, 'applyMatrix', $__.fs.J$__v494107025_1417_884.call(vvv_tmp1, m1, 0, true, $__.uid);
    return this;
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (m1 === undefined)
    m1 = new Matrix4();
m1.makeTranslation(x, y, z);
this.applyMatrix(m1);
return this;});
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return function translate(x, y, z) {
    if (m1 === undefined)
        m1 = new Matrix4();
    m1.makeTranslation(x, y, z);
    this.applyMatrix(m1);
    return this;
};}), $__.fs.J$__v494107025_1429_891)(0, true, $__.uid),
        'scale': (($__.fs.J$__v494107025_1432_893 = function J$__v494107025_1432() {
var vvv_return, vvv_switch, m1;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    return ($__.fs.scale_894 = function scale(x, y, z) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
x = arguments[0], y = arguments[1], z = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (m1 === undefined)
    m1 = new Matrix4();
m1.makeScale(x, y, z);
this.applyMatrix(m1);
return this;});
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return function scale(x, y, z) {
    if (m1 === undefined)
        m1 = new Matrix4();
    m1.makeScale(x, y, z);
    this.applyMatrix(m1);
    return this;
};}), $__.fs.J$__v494107025_1432_893)(0, true, $__.uid),
        'lookAt': (($__.fs.J$__v494107025_1435_895 = function J$__v494107025_1435() {
var vvv_return, vvv_switch, obj;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    return ($__.fs.lookAt_896 = function lookAt(vector) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
vector = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (obj === undefined)
    obj = new Object3D();
obj.lookAt(vector);
obj.updateMatrix();
this.applyMatrix(obj.matrix);});
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return function lookAt(vector) {
    if (obj === undefined)
        obj = new Object3D();
    obj.lookAt(vector);
    obj.updateMatrix();
    this.applyMatrix(obj.matrix);
};}), $__.fs.J$__v494107025_1435_895)(0, true, $__.uid),
        'center': ($__.fs.J$__v494107025_1437_897 = function J$__v494107025_1437() {
var vvv_return, vvv_switch, offset;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.computeBoundingBox();
offset = this.boundingBox.center().negate();
this.translate(offset.x, offset.y, offset.z);
return offset;}),
        'setFromObject': ($__.fs.J$__v494107025_1439_898 = function J$__v494107025_1439(object) {
var vvv_return, vvv_switch, geometry, positions, colors, lineDistances;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
object = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
geometry = object.geometry;
if (object && object.isPoints || object && object.isLine) {
    positions = new Float32Attribute(geometry.vertices.length * 3, 3);
    colors = new Float32Attribute(geometry.colors.length * 3, 3);
    this.addAttribute('position', positions.copyVector3sArray(geometry.vertices));
    this.addAttribute('color', colors.copyColorsArray(geometry.colors));
    if (geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length) {
        lineDistances = new Float32Attribute(geometry.lineDistances.length, 1);
        this.addAttribute('lineDistance', lineDistances.copyArray(geometry.lineDistances));
    }
    if (geometry.boundingSphere !== null) {
        this.boundingSphere = geometry.boundingSphere.clone();
    }
    if (geometry.boundingBox !== null) {
        this.boundingBox = geometry.boundingBox.clone();
    }
} else if (object && object.isMesh) {
    if (geometry && geometry.isGeometry) {
        this.fromGeometry(geometry);
    }
}
return this;}),
        'updateFromObject': ($__.fs.J$__v494107025_1441_899 = function J$__v494107025_1441(object) {
var vvv_return, vvv_switch, geometry, direct, attribute;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
object = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
geometry = object.geometry;
if (object && object.isMesh) {
    direct = geometry.__directGeometry;
    if (geometry.elementsNeedUpdate === true) {
        direct = undefined;
        geometry.elementsNeedUpdate = false;
    }
    if (direct === undefined) {
        return this.fromGeometry(geometry);
    }
    direct.verticesNeedUpdate = geometry.verticesNeedUpdate;
    direct.normalsNeedUpdate = geometry.normalsNeedUpdate;
    direct.colorsNeedUpdate = geometry.colorsNeedUpdate;
    direct.uvsNeedUpdate = geometry.uvsNeedUpdate;
    direct.groupsNeedUpdate = geometry.groupsNeedUpdate;
    geometry.verticesNeedUpdate = false;
    geometry.normalsNeedUpdate = false;
    geometry.colorsNeedUpdate = false;
    geometry.uvsNeedUpdate = false;
    geometry.groupsNeedUpdate = false;
    geometry = direct;
}
if (geometry.verticesNeedUpdate === true) {
    attribute = this.attributes.position;
    if (attribute !== undefined) {
        attribute.copyVector3sArray(geometry.vertices);
        attribute.needsUpdate = true;
    }
    geometry.verticesNeedUpdate = false;
}
if (geometry.normalsNeedUpdate === true) {
    attribute = this.attributes.normal;
    if (attribute !== undefined) {
        attribute.copyVector3sArray(geometry.normals);
        attribute.needsUpdate = true;
    }
    geometry.normalsNeedUpdate = false;
}
if (geometry.colorsNeedUpdate === true) {
    attribute = this.attributes.color;
    if (attribute !== undefined) {
        attribute.copyColorsArray(geometry.colors);
        attribute.needsUpdate = true;
    }
    geometry.colorsNeedUpdate = false;
}
if (geometry.uvsNeedUpdate) {
    attribute = this.attributes.uv;
    if (attribute !== undefined) {
        attribute.copyVector2sArray(geometry.uvs);
        attribute.needsUpdate = true;
    }
    geometry.uvsNeedUpdate = false;
}
if (geometry.lineDistancesNeedUpdate) {
    attribute = this.attributes.lineDistance;
    if (attribute !== undefined) {
        attribute.copyArray(geometry.lineDistances);
        attribute.needsUpdate = true;
    }
    geometry.lineDistancesNeedUpdate = false;
}
if (geometry.groupsNeedUpdate) {
    geometry.computeGroups(object.geometry);
    this.groups = geometry.groups;
    geometry.groupsNeedUpdate = false;
}
return this;}),
        'fromGeometry': ($__.fs.J$__v494107025_1443_900 = function J$__v494107025_1443(geometry) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
geometry = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
geometry.__directGeometry = new DirectGeometry().fromGeometry(geometry);
return this.fromDirectGeometry(geometry.__directGeometry);}),
        'fromDirectGeometry': ($__.fs.J$__v494107025_1445_901 = function J$__v494107025_1445(geometry) {
var vvv_return, vvv_switch, positions, normals, colors, uvs, uvs2, TypeArray, indices, array, morphTargets, morphTarget, attribute, skinIndices, skinWeights;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
geometry = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
positions = new Float32Array(geometry.vertices.length * 3);
this.addAttribute('position', new BufferAttribute(positions, 3).copyVector3sArray(geometry.vertices));
if (geometry.normals.length > 0) {
    normals = new Float32Array(geometry.normals.length * 3);
    this.addAttribute('normal', new BufferAttribute(normals, 3).copyVector3sArray(geometry.normals));
}
if (geometry.colors.length > 0) {
    colors = new Float32Array(geometry.colors.length * 3);
    this.addAttribute('color', new BufferAttribute(colors, 3).copyColorsArray(geometry.colors));
}
if (geometry.uvs.length > 0) {
    uvs = new Float32Array(geometry.uvs.length * 2);
    this.addAttribute('uv', new BufferAttribute(uvs, 2).copyVector2sArray(geometry.uvs));
}
if (geometry.uvs2.length > 0) {
    uvs2 = new Float32Array(geometry.uvs2.length * 2);
    this.addAttribute('uv2', new BufferAttribute(uvs2, 2).copyVector2sArray(geometry.uvs2));
}
if (geometry.indices.length > 0) {
    TypeArray = geometry.vertices.length > 65535 ? Uint32Array : Uint16Array;
    indices = new TypeArray(geometry.indices.length * 3);
    this.setIndex(new BufferAttribute(indices, 1).copyIndicesArray(geometry.indices));
}
this.groups = geometry.groups;
for (var name in geometry.morphTargets) {
    array = [];
    morphTargets = geometry.morphTargets[name];
    for (var i = 0, l = morphTargets.length; i < l; i++) {
        morphTarget = morphTargets[i];
        attribute = new Float32Attribute(morphTarget.length * 3, 3);
        array.push(attribute.copyVector3sArray(morphTarget));
    }
    this.morphAttributes[name] = array;
}
if (geometry.skinIndices.length > 0) {
    skinIndices = new Float32Attribute(geometry.skinIndices.length * 4, 4);
    this.addAttribute('skinIndex', skinIndices.copyVector4sArray(geometry.skinIndices));
}
if (geometry.skinWeights.length > 0) {
    skinWeights = new Float32Attribute(geometry.skinWeights.length * 4, 4);
    this.addAttribute('skinWeight', skinWeights.copyVector4sArray(geometry.skinWeights));
}
if (geometry.boundingSphere !== null) {
    this.boundingSphere = geometry.boundingSphere.clone();
}
if (geometry.boundingBox !== null) {
    this.boundingBox = geometry.boundingBox.clone();
}
return this;}),
        'computeBoundingBox': ($__.fs.J$__v494107025_1447_902 = function J$__v494107025_1447() {
var vvv_return, vvv_switch, positions;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (this.boundingBox === null) {
    this.boundingBox = new Box3();
}
positions = this.attributes.position.array;
if (positions !== undefined) {
    this.boundingBox.setFromArray(positions);
} else {
    this.boundingBox.makeEmpty();
}
if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) {
    console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
}}),
        'computeBoundingSphere': (($__.fs.J$__v494107025_1450_903 = function J$__v494107025_1450() {
var vvv_return, vvv_switch, box, vector;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    box = new (Box3, $__.fs.Box3_59)(1, true, $__.uid);
    vector = new (Vector3, $__.fs.Vector3_11)(36, true, $__.uid);
    return ($__.fs.computeBoundingSphere_904 = function computeBoundingSphere() {
var vvv_return, vvv_switch, positions, array, center, maxRadiusSq;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (this.boundingSphere === null) {
    this.boundingSphere = new Sphere();
}
positions = this.attributes.position;
if (positions) {
    array = positions.array;
    center = this.boundingSphere.center;
    box.setFromArray(array);
    box.center(center);
    maxRadiusSq = 0;
    for (var i = 0, il = array.length; i < il; i += 3) {
        vector.fromArray(array, i);
        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(vector));
    }
    this.boundingSphere.radius = Math.sqrt(maxRadiusSq);
    if (isNaN(this.boundingSphere.radius)) {
        console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
    }
}});
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
box = new Box3();
vector = new Vector3();
return function computeBoundingSphere() {
    if (this.boundingSphere === null) {
        this.boundingSphere = new Sphere();
    }
    var positions = this.attributes.position;
    if (positions) {
        var array = positions.array;
        var center = this.boundingSphere.center;
        box.setFromArray(array);
        box.center(center);
        var maxRadiusSq = 0;
        for (var i = 0, il = array.length; i < il; i += 3) {
            vector.fromArray(array, i);
            maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(vector));
        }
        this.boundingSphere.radius = Math.sqrt(maxRadiusSq);
        if (isNaN(this.boundingSphere.radius)) {
            console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
        }
    }
};}), $__.fs.J$__v494107025_1450_903)(0, true, $__.uid),
        'computeFaceNormals': ($__.fs.J$__v494107025_1452_905 = function J$__v494107025_1452() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');}),
        'computeVertexNormals': ($__.fs.J$__v494107025_1454_906 = function J$__v494107025_1454() {
var vvv_return, vvv_switch, index, attributes, groups, positions, array, normals, vA, vB, vC, pA, pB, pC, cb, ab, indices, group, start, count;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
index = this.index;
attributes = this.attributes;
groups = this.groups;
if (attributes.position) {
    positions = attributes.position.array;
    if (attributes.normal === undefined) {
        this.addAttribute('normal', new BufferAttribute(new Float32Array(positions.length), 3));
    } else {
        array = attributes.normal.array;
        for (var i = 0, il = array.length; i < il; i++) {
            array[i] = 0;
        }
    }
    normals = attributes.normal.array;
    pA = new Vector3();
    pB = new Vector3();
    pC = new Vector3();
    cb = new Vector3();
    ab = new Vector3();
    if (index) {
        indices = index.array;
        if (groups.length === 0) {
            this.addGroup(0, indices.length);
        }
        for (var j = 0, jl = groups.length; j < jl; ++j) {
            group = groups[j];
            start = group.start;
            count = group.count;
            for (var i = start, il = start + count; i < il; i += 3) {
                vA = indices[i + 0] * 3;
                vB = indices[i + 1] * 3;
                vC = indices[i + 2] * 3;
                pA.fromArray(positions, vA);
                pB.fromArray(positions, vB);
                pC.fromArray(positions, vC);
                cb.subVectors(pC, pB);
                ab.subVectors(pA, pB);
                cb.cross(ab);
                normals[vA] += cb.x;
                normals[vA + 1] += cb.y;
                normals[vA + 2] += cb.z;
                normals[vB] += cb.x;
                normals[vB + 1] += cb.y;
                normals[vB + 2] += cb.z;
                normals[vC] += cb.x;
                normals[vC + 1] += cb.y;
                normals[vC + 2] += cb.z;
            }
        }
    } else {
        for (var i = 0, il = positions.length; i < il; i += 9) {
            pA.fromArray(positions, i);
            pB.fromArray(positions, i + 3);
            pC.fromArray(positions, i + 6);
            cb.subVectors(pC, pB);
            ab.subVectors(pA, pB);
            cb.cross(ab);
            normals[i] = cb.x;
            normals[i + 1] = cb.y;
            normals[i + 2] = cb.z;
            normals[i + 3] = cb.x;
            normals[i + 4] = cb.y;
            normals[i + 5] = cb.z;
            normals[i + 6] = cb.x;
            normals[i + 7] = cb.y;
            normals[i + 8] = cb.z;
        }
    }
    this.normalizeNormals();
    attributes.normal.needsUpdate = true;
}}),
        'merge': ($__.fs.J$__v494107025_1456_907 = function J$__v494107025_1456(geometry, offset) {
var vvv_return, vvv_switch, attributes, attribute1, attributeArray1, attribute2, attributeArray2, attributeSize;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
geometry = arguments[0], offset = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if ((geometry && geometry.isBufferGeometry) === false) {
    console.error('THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry);
    return;
}
if (offset === undefined)
    offset = 0;
attributes = this.attributes;
for (var key in attributes) {
    if (geometry.attributes[key] === undefined)
        continue;
    attribute1 = attributes[key];
    attributeArray1 = attribute1.array;
    attribute2 = geometry.attributes[key];
    attributeArray2 = attribute2.array;
    attributeSize = attribute2.itemSize;
    for (var i = 0, j = attributeSize * offset; i < attributeArray2.length; i++, j++) {
        attributeArray1[j] = attributeArray2[i];
    }
}
return this;}),
        'normalizeNormals': ($__.fs.J$__v494107025_1458_908 = function J$__v494107025_1458() {
var vvv_return, vvv_switch, normals, x, y, z, n;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
normals = this.attributes.normal.array;
for (var i = 0, il = normals.length; i < il; i += 3) {
    x = normals[i];
    y = normals[i + 1];
    z = normals[i + 2];
    n = 1 / Math.sqrt(x * x + y * y + z * z);
    normals[i] *= n;
    normals[i + 1] *= n;
    normals[i + 2] *= n;
}}),
        'toNonIndexed': ($__.fs.J$__v494107025_1460_909 = function J$__v494107025_1460() {
var vvv_return, vvv_switch, geometry2, indices, attributes, attribute, array, itemSize, array2, index, index2;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (this.index === null) {
    console.warn('THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.');
    return this;
}
geometry2 = new BufferGeometry();
indices = this.index.array;
attributes = this.attributes;
for (var name in attributes) {
    attribute = attributes[name];
    array = attribute.array;
    itemSize = attribute.itemSize;
    array2 = new array.constructor(indices.length * itemSize);
    index = 0;
    index2 = 0;
    for (var i = 0, l = indices.length; i < l; i++) {
        index = indices[i] * itemSize;
        for (var j = 0; j < itemSize; j++) {
            array2[index2++] = array[index++];
        }
    }
    geometry2.addAttribute(name, new BufferAttribute(array2, itemSize));
}
return geometry2;}),
        'toJSON': ($__.fs.J$__v494107025_1462_910 = function J$__v494107025_1462() {
var vvv_return, vvv_switch, data, parameters, index, array, attributes, attribute, groups, boundingSphere;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
data = {
    metadata: {
        version: 4.4,
        type: 'BufferGeometry',
        generator: 'BufferGeometry.toJSON'
    }
};
data.uuid = this.uuid;
data.type = this.type;
if (this.name !== '')
    data.name = this.name;
if (this.parameters !== undefined) {
    parameters = this.parameters;
    for (var key in parameters) {
        if (parameters[key] !== undefined)
            data[key] = parameters[key];
    }
    return data;
}
data.data = {
    attributes: {}
};
index = this.index;
if (index !== null) {
    array = Array.prototype.slice.call(index.array);
    data.data.index = {
        type: index.array.constructor.name,
        array: array
    };
}
attributes = this.attributes;
for (var key in attributes) {
    attribute = attributes[key];
    array = Array.prototype.slice.call(attribute.array);
    data.data.attributes[key] = {
        itemSize: attribute.itemSize,
        type: attribute.array.constructor.name,
        array: array,
        normalized: attribute.normalized
    };
}
groups = this.groups;
if (groups.length > 0) {
    data.data.groups = JSON.parse(JSON.stringify(groups));
}
boundingSphere = this.boundingSphere;
if (boundingSphere !== null) {
    data.data.boundingSphere = {
        center: boundingSphere.center.toArray(),
        radius: boundingSphere.radius
    };
}
return data;}),
        'clone': ($__.fs.J$__v494107025_1464_911 = function J$__v494107025_1464() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return new BufferGeometry().copy(this);}),
        'copy': ($__.fs.J$__v494107025_1466_912 = function J$__v494107025_1466(source) {
var vvv_return, vvv_switch, index, attributes, attribute, groups, group;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
source = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
index = source.index;
if (index !== null) {
    this.setIndex(index.clone());
}
attributes = source.attributes;
for (var name in attributes) {
    attribute = attributes[name];
    this.addAttribute(name, attribute.clone());
}
groups = source.groups;
for (var i = 0, l = groups.length; i < l; i++) {
    group = groups[i];
    this.addGroup(group.start, group.count, group.materialIndex);
}
return this;}),
        'dispose': ($__.fs.J$__v494107025_1468_913 = function J$__v494107025_1468() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.dispatchEvent({
    type: 'dispose'
});})
    });
    BufferGeometry.MaxIndex = 65535;
    WebGLRenderTargetCube.prototype = Object['create'](TAJS_restrictToType(WebGLRenderTarget.prototype, 'object'));
    TAJS_restrictToType(WebGLRenderTargetCube.prototype, 'object').constructor = WebGLRenderTargetCube;
    TAJS_restrictToType(WebGLRenderTargetCube.prototype, 'object').isWebGLRenderTargetCube = true;
    BoxBufferGeometry.prototype = Object['create'](TAJS_restrictToType(BufferGeometry.prototype, 'object'));
    TAJS_restrictToType(BoxBufferGeometry.prototype, 'object').constructor = BoxBufferGeometry;
    Ray.prototype = $__.os.oid430 = {
        'constructor': Ray,
        'set': ($__.fs.J$__v494107025_1521_914 = function J$__v494107025_1521(origin, direction) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
origin = arguments[0], direction = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.origin.copy(origin);
this.direction.copy(direction);
return this;}),
        'clone': ($__.fs.J$__v494107025_1523_915 = function J$__v494107025_1523() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return new this.constructor().copy(this);}),
        'copy': ($__.fs.J$__v494107025_1525_916 = function J$__v494107025_1525(ray) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
ray = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.origin.copy(ray.origin);
this.direction.copy(ray.direction);
return this;}),
        'at': ($__.fs.J$__v494107025_1527_917 = function J$__v494107025_1527(t, optionalTarget) {
var vvv_return, vvv_switch, result;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
t = arguments[0], optionalTarget = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
result = optionalTarget || new Vector3();
return result.copy(this.direction).multiplyScalar(t).add(this.origin);}),
        'lookAt': ($__.fs.J$__v494107025_1529_918 = function J$__v494107025_1529(v) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
v = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.direction.copy(v).sub(this.origin).normalize();
return this;}),
        'recast': (($__.fs.J$__v494107025_1532_919 = function J$__v494107025_1532() {
var vvv_return, vvv_switch, v1;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    v1 = new (Vector3, $__.fs.Vector3_11)(37, true, $__.uid);
    return ($__.fs.recast_920 = function recast(t) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
t = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.origin.copy(this.at(t, v1));
return this;});
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
v1 = new Vector3();
return function recast(t) {
    this.origin.copy(this.at(t, v1));
    return this;
};}), $__.fs.J$__v494107025_1532_919)(0, true, $__.uid),
        'closestPointToPoint': ($__.fs.J$__v494107025_1534_921 = function J$__v494107025_1534(point, optionalTarget) {
var vvv_return, vvv_switch, result, directionDistance;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
point = arguments[0], optionalTarget = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
result = optionalTarget || new Vector3();
result.subVectors(point, this.origin);
directionDistance = result.dot(this.direction);
if (directionDistance < 0) {
    return result.copy(this.origin);
}
return result.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);}),
        'distanceToPoint': ($__.fs.J$__v494107025_1536_922 = function J$__v494107025_1536(point) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
point = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return Math.sqrt(this.distanceSqToPoint(point));}),
        'distanceSqToPoint': (($__.fs.J$__v494107025_1539_923 = function J$__v494107025_1539() {
var vvv_return, vvv_switch, v1;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    v1 = new (Vector3, $__.fs.Vector3_11)(38, true, $__.uid);
    return ($__.fs.distanceSqToPoint_924 = function distanceSqToPoint(point) {
var vvv_return, vvv_switch, directionDistance;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
point = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
directionDistance = v1.subVectors(point, this.origin).dot(this.direction);
if (directionDistance < 0) {
    return this.origin.distanceToSquared(point);
}
v1.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
return v1.distanceToSquared(point);});
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
v1 = new Vector3();
return function distanceSqToPoint(point) {
    var directionDistance = v1.subVectors(point, this.origin).dot(this.direction);
    if (directionDistance < 0) {
        return this.origin.distanceToSquared(point);
    }
    v1.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
    return v1.distanceToSquared(point);
};}), $__.fs.J$__v494107025_1539_923)(0, true, $__.uid),
        'distanceSqToSegment': (($__.fs.J$__v494107025_1542_925 = function J$__v494107025_1542() {
var vvv_return, vvv_switch, segCenter, segDir, diff;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    segCenter = new (Vector3, $__.fs.Vector3_11)(39, true, $__.uid);
    segDir = new (Vector3, $__.fs.Vector3_11)(40, true, $__.uid);
    diff = new (Vector3, $__.fs.Vector3_11)(41, true, $__.uid);
    return ($__.fs.distanceSqToSegment_926 = function distanceSqToSegment(v0, v1, optionalPointOnRay, optionalPointOnSegment) {
var vvv_return, vvv_switch, segExtent, a01, b0, b1, c, det, s0, s1, sqrDist, extDet, invDet;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
v0 = arguments[0], v1 = arguments[1], optionalPointOnRay = arguments[2], optionalPointOnSegment = arguments[3];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
segCenter.copy(v0).add(v1).multiplyScalar(0.5);
segDir.copy(v1).sub(v0).normalize();
diff.copy(this.origin).sub(segCenter);
segExtent = v0.distanceTo(v1) * 0.5;
a01 = -this.direction.dot(segDir);
b0 = diff.dot(this.direction);
b1 = -diff.dot(segDir);
c = diff.lengthSq();
det = Math.abs(1 - a01 * a01);
if (det > 0) {
    s0 = a01 * b1 - b0;
    s1 = a01 * b0 - b1;
    extDet = segExtent * det;
    if (s0 >= 0) {
        if (s1 >= -extDet) {
            if (s1 <= extDet) {
                invDet = 1 / det;
                s0 *= invDet;
                s1 *= invDet;
                sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c;
            } else {
                s1 = segExtent;
                s0 = Math.max(0, -(a01 * s1 + b0));
                sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
            }
        } else {
            s1 = -segExtent;
            s0 = Math.max(0, -(a01 * s1 + b0));
            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
        }
    } else {
        if (s1 <= -extDet) {
            s0 = Math.max(0, -(-a01 * segExtent + b0));
            s1 = s0 > 0 ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
        } else if (s1 <= extDet) {
            s0 = 0;
            s1 = Math.min(Math.max(-segExtent, -b1), segExtent);
            sqrDist = s1 * (s1 + 2 * b1) + c;
        } else {
            s0 = Math.max(0, -(a01 * segExtent + b0));
            s1 = s0 > 0 ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
        }
    }
} else {
    s1 = a01 > 0 ? -segExtent : segExtent;
    s0 = Math.max(0, -(a01 * s1 + b0));
    sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
}
if (optionalPointOnRay) {
    optionalPointOnRay.copy(this.direction).multiplyScalar(s0).add(this.origin);
}
if (optionalPointOnSegment) {
    optionalPointOnSegment.copy(segDir).multiplyScalar(s1).add(segCenter);
}
return sqrDist;});
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
segCenter = new Vector3();
segDir = new Vector3();
diff = new Vector3();
return function distanceSqToSegment(v0, v1, optionalPointOnRay, optionalPointOnSegment) {
    segCenter.copy(v0).add(v1).multiplyScalar(0.5);
    segDir.copy(v1).sub(v0).normalize();
    diff.copy(this.origin).sub(segCenter);
    var segExtent = v0.distanceTo(v1) * 0.5;
    var a01 = -this.direction.dot(segDir);
    var b0 = diff.dot(this.direction);
    var b1 = -diff.dot(segDir);
    var c = diff.lengthSq();
    var det = Math.abs(1 - a01 * a01);
    var s0, s1, sqrDist, extDet;
    if (det > 0) {
        s0 = a01 * b1 - b0;
        s1 = a01 * b0 - b1;
        extDet = segExtent * det;
        if (s0 >= 0) {
            if (s1 >= -extDet) {
                if (s1 <= extDet) {
                    var invDet = 1 / det;
                    s0 *= invDet;
                    s1 *= invDet;
                    sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c;
                } else {
                    s1 = segExtent;
                    s0 = Math.max(0, -(a01 * s1 + b0));
                    sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
                }
            } else {
                s1 = -segExtent;
                s0 = Math.max(0, -(a01 * s1 + b0));
                sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
            }
        } else {
            if (s1 <= -extDet) {
                s0 = Math.max(0, -(-a01 * segExtent + b0));
                s1 = s0 > 0 ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
                sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
            } else if (s1 <= extDet) {
                s0 = 0;
                s1 = Math.min(Math.max(-segExtent, -b1), segExtent);
                sqrDist = s1 * (s1 + 2 * b1) + c;
            } else {
                s0 = Math.max(0, -(a01 * segExtent + b0));
                s1 = s0 > 0 ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
                sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
            }
        }
    } else {
        s1 = a01 > 0 ? -segExtent : segExtent;
        s0 = Math.max(0, -(a01 * s1 + b0));
        sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
    }
    if (optionalPointOnRay) {
        optionalPointOnRay.copy(this.direction).multiplyScalar(s0).add(this.origin);
    }
    if (optionalPointOnSegment) {
        optionalPointOnSegment.copy(segDir).multiplyScalar(s1).add(segCenter);
    }
    return sqrDist;
};}), $__.fs.J$__v494107025_1542_925)(0, true, $__.uid),
        'intersectSphere': (($__.fs.J$__v494107025_1545_927 = function J$__v494107025_1545() {
var vvv_return, vvv_switch, v1;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    v1 = new (Vector3, $__.fs.Vector3_11)(42, true, $__.uid);
    return ($__.fs.intersectSphere_928 = function intersectSphere(sphere, optionalTarget) {
var vvv_return, vvv_switch, tca, d2, radius2, thc, t0, t1;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
sphere = arguments[0], optionalTarget = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
v1.subVectors(sphere.center, this.origin);
tca = v1.dot(this.direction);
d2 = v1.dot(v1) - tca * tca;
radius2 = sphere.radius * sphere.radius;
if (d2 > radius2)
    return null;
thc = Math.sqrt(radius2 - d2);
t0 = tca - thc;
t1 = tca + thc;
if (t0 < 0 && t1 < 0)
    return null;
if (t0 < 0)
    return this.at(t1, optionalTarget);
return this.at(t0, optionalTarget);});
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
v1 = new Vector3();
return function intersectSphere(sphere, optionalTarget) {
    v1.subVectors(sphere.center, this.origin);
    var tca = v1.dot(this.direction);
    var d2 = v1.dot(v1) - tca * tca;
    var radius2 = sphere.radius * sphere.radius;
    if (d2 > radius2)
        return null;
    var thc = Math.sqrt(radius2 - d2);
    var t0 = tca - thc;
    var t1 = tca + thc;
    if (t0 < 0 && t1 < 0)
        return null;
    if (t0 < 0)
        return this.at(t1, optionalTarget);
    return this.at(t0, optionalTarget);
};}), $__.fs.J$__v494107025_1545_927)(0, true, $__.uid),
        'intersectsSphere': ($__.fs.J$__v494107025_1547_929 = function J$__v494107025_1547(sphere) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
sphere = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return this.distanceToPoint(sphere.center) <= sphere.radius;}),
        'distanceToPlane': ($__.fs.J$__v494107025_1549_930 = function J$__v494107025_1549(plane) {
var vvv_return, vvv_switch, denominator, t;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
plane = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
denominator = plane.normal.dot(this.direction);
if (denominator === 0) {
    if (plane.distanceToPoint(this.origin) === 0) {
        return 0;
    }
    return null;
}
t = -(this.origin.dot(plane.normal) + plane.constant) / denominator;
return t >= 0 ? t : null;}),
        'intersectPlane': ($__.fs.J$__v494107025_1551_931 = function J$__v494107025_1551(plane, optionalTarget) {
var vvv_return, vvv_switch, t;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
plane = arguments[0], optionalTarget = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
t = this.distanceToPlane(plane);
if (t === null) {
    return null;
}
return this.at(t, optionalTarget);}),
        'intersectsPlane': ($__.fs.J$__v494107025_1553_932 = function J$__v494107025_1553(plane) {
var vvv_return, vvv_switch, distToPoint, denominator;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
plane = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
distToPoint = plane.distanceToPoint(this.origin);
if (distToPoint === 0) {
    return true;
}
denominator = plane.normal.dot(this.direction);
if (denominator * distToPoint < 0) {
    return true;
}
return false;}),
        'intersectBox': ($__.fs.J$__v494107025_1555_933 = function J$__v494107025_1555(box, optionalTarget) {
var vvv_return, vvv_switch, tmin, tmax, tymin, tymax, tzmin, tzmax, invdirx, invdiry, invdirz, origin;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
box = arguments[0], optionalTarget = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
invdirx = 1 / this.direction.x;
invdiry = 1 / this.direction.y;
invdirz = 1 / this.direction.z;
origin = this.origin;
if (invdirx >= 0) {
    tmin = (box.min.x - origin.x) * invdirx;
    tmax = (box.max.x - origin.x) * invdirx;
} else {
    tmin = (box.max.x - origin.x) * invdirx;
    tmax = (box.min.x - origin.x) * invdirx;
}
if (invdiry >= 0) {
    tymin = (box.min.y - origin.y) * invdiry;
    tymax = (box.max.y - origin.y) * invdiry;
} else {
    tymin = (box.max.y - origin.y) * invdiry;
    tymax = (box.min.y - origin.y) * invdiry;
}
if (tmin > tymax || tymin > tmax)
    return null;
if (tymin > tmin || tmin !== tmin)
    tmin = tymin;
if (tymax < tmax || tmax !== tmax)
    tmax = tymax;
if (invdirz >= 0) {
    tzmin = (box.min.z - origin.z) * invdirz;
    tzmax = (box.max.z - origin.z) * invdirz;
} else {
    tzmin = (box.max.z - origin.z) * invdirz;
    tzmax = (box.min.z - origin.z) * invdirz;
}
if (tmin > tzmax || tzmin > tmax)
    return null;
if (tzmin > tmin || tmin !== tmin)
    tmin = tzmin;
if (tzmax < tmax || tmax !== tmax)
    tmax = tzmax;
if (tmax < 0)
    return null;
return this.at(tmin >= 0 ? tmin : tmax, optionalTarget);}),
        'intersectsBox': (($__.fs.J$__v494107025_1558_934 = function J$__v494107025_1558() {
var vvv_return, vvv_switch, v;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    v = new (Vector3, $__.fs.Vector3_11)(43, true, $__.uid);
    return ($__.fs.intersectsBox_935 = function intersectsBox(box) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
box = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return this.intersectBox(box, v) !== null;});
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
v = new Vector3();
return function intersectsBox(box) {
    return this.intersectBox(box, v) !== null;
};}), $__.fs.J$__v494107025_1558_934)(0, true, $__.uid),
        'intersectTriangle': (($__.fs.J$__v494107025_1561_936 = function J$__v494107025_1561() {
var vvv_return, vvv_switch, diff, edge1, edge2, normal;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    diff = new (Vector3, $__.fs.Vector3_11)(44, true, $__.uid);
    edge1 = new (Vector3, $__.fs.Vector3_11)(45, true, $__.uid);
    edge2 = new (Vector3, $__.fs.Vector3_11)(46, true, $__.uid);
    normal = new (Vector3, $__.fs.Vector3_11)(47, true, $__.uid);
    return ($__.fs.intersectTriangle_937 = function intersectTriangle(a, b, c, backfaceCulling, optionalTarget) {
var vvv_return, vvv_switch, DdN, sign, DdQxE2, DdE1xQ, QdN;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
a = arguments[0], b = arguments[1], c = arguments[2], backfaceCulling = arguments[3], optionalTarget = arguments[4];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
edge1.subVectors(b, a);
edge2.subVectors(c, a);
normal.crossVectors(edge1, edge2);
DdN = this.direction.dot(normal);
if (DdN > 0) {
    if (backfaceCulling)
        return null;
    sign = 1;
} else if (DdN < 0) {
    sign = -1;
    DdN = -DdN;
} else {
    return null;
}
diff.subVectors(this.origin, a);
DdQxE2 = sign * this.direction.dot(edge2.crossVectors(diff, edge2));
if (DdQxE2 < 0) {
    return null;
}
DdE1xQ = sign * this.direction.dot(edge1.cross(diff));
if (DdE1xQ < 0) {
    return null;
}
if (DdQxE2 + DdE1xQ > DdN) {
    return null;
}
QdN = -sign * diff.dot(normal);
if (QdN < 0) {
    return null;
}
return this.at(QdN / DdN, optionalTarget);});
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
diff = new Vector3();
edge1 = new Vector3();
edge2 = new Vector3();
normal = new Vector3();
return function intersectTriangle(a, b, c, backfaceCulling, optionalTarget) {
    edge1.subVectors(b, a);
    edge2.subVectors(c, a);
    normal.crossVectors(edge1, edge2);
    var DdN = this.direction.dot(normal);
    var sign;
    if (DdN > 0) {
        if (backfaceCulling)
            return null;
        sign = 1;
    } else if (DdN < 0) {
        sign = -1;
        DdN = -DdN;
    } else {
        return null;
    }
    diff.subVectors(this.origin, a);
    var DdQxE2 = sign * this.direction.dot(edge2.crossVectors(diff, edge2));
    if (DdQxE2 < 0) {
        return null;
    }
    var DdE1xQ = sign * this.direction.dot(edge1.cross(diff));
    if (DdE1xQ < 0) {
        return null;
    }
    if (DdQxE2 + DdE1xQ > DdN) {
        return null;
    }
    var QdN = -sign * diff.dot(normal);
    if (QdN < 0) {
        return null;
    }
    return this.at(QdN / DdN, optionalTarget);
};}), $__.fs.J$__v494107025_1561_936)(0, true, $__.uid),
        'applyMatrix4': ($__.fs.J$__v494107025_1563_938 = function J$__v494107025_1563(matrix4) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
matrix4 = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.direction.add(this.origin).applyMatrix4(matrix4);
this.origin.applyMatrix4(matrix4);
this.direction.sub(this.origin);
this.direction.normalize();
return this;}),
        'equals': ($__.fs.J$__v494107025_1565_939 = function J$__v494107025_1565(ray) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
ray = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return ray.origin.equals(this.origin) && ray.direction.equals(this.direction);})
    };
    Line3.prototype = $__.os.oid431 = {
        'constructor': Line3,
        'set': ($__.fs.J$__v494107025_1568_940 = function J$__v494107025_1568(start, end) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
start = arguments[0], end = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.start.copy(start);
this.end.copy(end);
return this;}),
        'clone': ($__.fs.J$__v494107025_1570_941 = function J$__v494107025_1570() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return new this.constructor().copy(this);}),
        'copy': ($__.fs.J$__v494107025_1572_942 = function J$__v494107025_1572(line) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
line = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.start.copy(line.start);
this.end.copy(line.end);
return this;}),
        'center': ($__.fs.J$__v494107025_1574_943 = function J$__v494107025_1574(optionalTarget) {
var vvv_return, vvv_switch, result;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
optionalTarget = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
result = optionalTarget || new Vector3();
return result.addVectors(this.start, this.end).multiplyScalar(0.5);}),
        'delta': ($__.fs.J$__v494107025_1576_944 = function J$__v494107025_1576(optionalTarget) {
var vvv_return, vvv_switch, result;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
optionalTarget = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
result = optionalTarget || new Vector3();
return result.subVectors(this.end, this.start);}),
        'distanceSq': ($__.fs.J$__v494107025_1578_945 = function J$__v494107025_1578() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return this.start.distanceToSquared(this.end);}),
        'distance': ($__.fs.J$__v494107025_1580_946 = function J$__v494107025_1580() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return this.start.distanceTo(this.end);}),
        'at': ($__.fs.J$__v494107025_1582_947 = function J$__v494107025_1582(t, optionalTarget) {
var vvv_return, vvv_switch, result;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
t = arguments[0], optionalTarget = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
result = optionalTarget || new Vector3();
return this.delta(result).multiplyScalar(t).add(this.start);}),
        'closestPointToPointParameter': (($__.fs.J$__v494107025_1585_948 = function J$__v494107025_1585() {
var vvv_return, vvv_switch, startP, startEnd;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    startP = new (Vector3, $__.fs.Vector3_11)(48, true, $__.uid);
    startEnd = new (Vector3, $__.fs.Vector3_11)(49, true, $__.uid);
    return ($__.fs.closestPointToPointParameter_949 = function closestPointToPointParameter(point, clampToLine) {
var vvv_return, vvv_switch, startEnd2, startEnd_startP, t;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
point = arguments[0], clampToLine = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
startP.subVectors(point, this.start);
startEnd.subVectors(this.end, this.start);
startEnd2 = startEnd.dot(startEnd);
startEnd_startP = startEnd.dot(startP);
t = startEnd_startP / startEnd2;
if (clampToLine) {
    t = exports.Math.clamp(t, 0, 1);
}
return t;});
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
startP = new Vector3();
startEnd = new Vector3();
return function closestPointToPointParameter(point, clampToLine) {
    startP.subVectors(point, this.start);
    startEnd.subVectors(this.end, this.start);
    var startEnd2 = startEnd.dot(startEnd);
    var startEnd_startP = startEnd.dot(startP);
    var t = startEnd_startP / startEnd2;
    if (clampToLine) {
        t = exports.Math.clamp(t, 0, 1);
    }
    return t;
};}), $__.fs.J$__v494107025_1585_948)(0, true, $__.uid),
        'closestPointToPoint': ($__.fs.J$__v494107025_1587_950 = function J$__v494107025_1587(point, clampToLine, optionalTarget) {
var vvv_return, vvv_switch, t, result;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
point = arguments[0], clampToLine = arguments[1], optionalTarget = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
t = this.closestPointToPointParameter(point, clampToLine);
result = optionalTarget || new Vector3();
return this.delta(result).multiplyScalar(t).add(this.start);}),
        'applyMatrix4': ($__.fs.J$__v494107025_1589_951 = function J$__v494107025_1589(matrix) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
matrix = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.start.applyMatrix4(matrix);
this.end.applyMatrix4(matrix);
return this;}),
        'equals': ($__.fs.J$__v494107025_1591_952 = function J$__v494107025_1591(line) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
line = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return line.start.equals(this.start) && line.end.equals(this.end);})
    };
    Triangle.normal = (($__.fs.J$__v494107025_1595_953 = function J$__v494107025_1595() {
var vvv_return, vvv_switch, v0;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    v0 = new (Vector3, $__.fs.Vector3_11)(50, true, $__.uid);
    return ($__.fs.normal_954 = function normal(a, b, c, optionalTarget) {
var vvv_return, vvv_switch, result, resultLengthSq;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
a = arguments[0], b = arguments[1], c = arguments[2], optionalTarget = arguments[3];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
result = optionalTarget || new Vector3();
result.subVectors(c, b);
v0.subVectors(a, b);
result.cross(v0);
resultLengthSq = result.lengthSq();
if (resultLengthSq > 0) {
    return result.multiplyScalar(1 / Math.sqrt(resultLengthSq));
}
return result.set(0, 0, 0);});
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
v0 = new Vector3();
return function normal(a, b, c, optionalTarget) {
    var result = optionalTarget || new Vector3();
    result.subVectors(c, b);
    v0.subVectors(a, b);
    result.cross(v0);
    var resultLengthSq = result.lengthSq();
    if (resultLengthSq > 0) {
        return result.multiplyScalar(1 / Math.sqrt(resultLengthSq));
    }
    return result.set(0, 0, 0);
};}), $__.fs.J$__v494107025_1595_953)(0, true, $__.uid);
    Triangle.barycoordFromPoint = (($__.fs.J$__v494107025_1598_955 = function J$__v494107025_1598() {
var vvv_return, vvv_switch, v0, v1, v2;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    v0 = new (Vector3, $__.fs.Vector3_11)(51, true, $__.uid);
    v1 = new (Vector3, $__.fs.Vector3_11)(52, true, $__.uid);
    v2 = new (Vector3, $__.fs.Vector3_11)(53, true, $__.uid);
    return ($__.fs.barycoordFromPoint_956 = function barycoordFromPoint(point, a, b, c, optionalTarget) {
var vvv_return, vvv_switch, dot00, dot01, dot02, dot11, dot12, denom, result, invDenom, u, v;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
point = arguments[0], a = arguments[1], b = arguments[2], c = arguments[3], optionalTarget = arguments[4];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
v0.subVectors(c, a);
v1.subVectors(b, a);
v2.subVectors(point, a);
dot00 = v0.dot(v0);
dot01 = v0.dot(v1);
dot02 = v0.dot(v2);
dot11 = v1.dot(v1);
dot12 = v1.dot(v2);
denom = dot00 * dot11 - dot01 * dot01;
result = optionalTarget || new Vector3();
if (denom === 0) {
    return result.set(-2, -1, -1);
}
invDenom = 1 / denom;
u = (dot11 * dot02 - dot01 * dot12) * invDenom;
v = (dot00 * dot12 - dot01 * dot02) * invDenom;
return result.set(1 - u - v, v, u);});
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
v0 = new Vector3();
v1 = new Vector3();
v2 = new Vector3();
return function barycoordFromPoint(point, a, b, c, optionalTarget) {
    v0.subVectors(c, a);
    v1.subVectors(b, a);
    v2.subVectors(point, a);
    var dot00 = v0.dot(v0);
    var dot01 = v0.dot(v1);
    var dot02 = v0.dot(v2);
    var dot11 = v1.dot(v1);
    var dot12 = v1.dot(v2);
    var denom = dot00 * dot11 - dot01 * dot01;
    var result = optionalTarget || new Vector3();
    if (denom === 0) {
        return result.set(-2, -1, -1);
    }
    var invDenom = 1 / denom;
    var u = (dot11 * dot02 - dot01 * dot12) * invDenom;
    var v = (dot00 * dot12 - dot01 * dot02) * invDenom;
    return result.set(1 - u - v, v, u);
};}), $__.fs.J$__v494107025_1598_955)(0, true, $__.uid);
    Triangle.containsPoint = (($__.fs.J$__v494107025_1601_957 = function J$__v494107025_1601() {
var vvv_return, vvv_switch, v1;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    v1 = new (Vector3, $__.fs.Vector3_11)(54, true, $__.uid);
    return ($__.fs.containsPoint_958 = function containsPoint(point, a, b, c) {
var vvv_return, vvv_switch, result;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
point = arguments[0], a = arguments[1], b = arguments[2], c = arguments[3];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
result = Triangle.barycoordFromPoint(point, a, b, c, v1);
return result.x >= 0 && result.y >= 0 && result.x + result.y <= 1;});
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
v1 = new Vector3();
return function containsPoint(point, a, b, c) {
    var result = Triangle.barycoordFromPoint(point, a, b, c, v1);
    return result.x >= 0 && result.y >= 0 && result.x + result.y <= 1;
};}), $__.fs.J$__v494107025_1601_957)(0, true, $__.uid);
    Triangle.prototype = $__.os.oid432 = {
        'constructor': Triangle,
        'set': ($__.fs.J$__v494107025_1603_959 = function J$__v494107025_1603(a, b, c) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
a = arguments[0], b = arguments[1], c = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.a.copy(a);
this.b.copy(b);
this.c.copy(c);
return this;}),
        'setFromPointsAndIndices': ($__.fs.J$__v494107025_1605_960 = function J$__v494107025_1605(points, i0, i1, i2) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
points = arguments[0], i0 = arguments[1], i1 = arguments[2], i2 = arguments[3];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.a.copy(points[i0]);
this.b.copy(points[i1]);
this.c.copy(points[i2]);
return this;}),
        'clone': ($__.fs.J$__v494107025_1607_961 = function J$__v494107025_1607() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return new this.constructor().copy(this);}),
        'copy': ($__.fs.J$__v494107025_1609_962 = function J$__v494107025_1609(triangle) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
triangle = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.a.copy(triangle.a);
this.b.copy(triangle.b);
this.c.copy(triangle.c);
return this;}),
        'area': (($__.fs.J$__v494107025_1612_963 = function J$__v494107025_1612() {
var vvv_return, vvv_switch, v0, v1;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    v0 = new (Vector3, $__.fs.Vector3_11)(55, true, $__.uid);
    v1 = new (Vector3, $__.fs.Vector3_11)(56, true, $__.uid);
    return ($__.fs.area_964 = function area() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
v0.subVectors(this.c, this.b);
v1.subVectors(this.a, this.b);
return v0.cross(v1).length() * 0.5;});
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
v0 = new Vector3();
v1 = new Vector3();
return function area() {
    v0.subVectors(this.c, this.b);
    v1.subVectors(this.a, this.b);
    return v0.cross(v1).length() * 0.5;
};}), $__.fs.J$__v494107025_1612_963)(0, true, $__.uid),
        'midpoint': ($__.fs.J$__v494107025_1614_965 = function J$__v494107025_1614(optionalTarget) {
var vvv_return, vvv_switch, result;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
optionalTarget = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
result = optionalTarget || new Vector3();
return result.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);}),
        'normal': ($__.fs.J$__v494107025_1616_966 = function J$__v494107025_1616(optionalTarget) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
optionalTarget = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return Triangle.normal(this.a, this.b, this.c, optionalTarget);}),
        'plane': ($__.fs.J$__v494107025_1618_967 = function J$__v494107025_1618(optionalTarget) {
var vvv_return, vvv_switch, result;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
optionalTarget = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
result = optionalTarget || new Plane();
return result.setFromCoplanarPoints(this.a, this.b, this.c);}),
        'barycoordFromPoint': ($__.fs.J$__v494107025_1620_968 = function J$__v494107025_1620(point, optionalTarget) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
point = arguments[0], optionalTarget = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return Triangle.barycoordFromPoint(point, this.a, this.b, this.c, optionalTarget);}),
        'containsPoint': ($__.fs.J$__v494107025_1622_969 = function J$__v494107025_1622(point) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
point = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return Triangle.containsPoint(point, this.a, this.b, this.c);}),
        'closestPointToPoint': (($__.fs.J$__v494107025_1625_970 = function J$__v494107025_1625() {
var vvv_return, vvv_switch, plane, edgeList, projectedPoint, closestPoint;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    return ($__.fs.closestPointToPoint_971 = function closestPointToPoint(point, optionalTarget) {
var vvv_return, vvv_switch, result, minDistance, distance;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
point = arguments[0], optionalTarget = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (plane === undefined) {
    plane = new Plane();
    edgeList = [
        new Line3(),
        new Line3(),
        new Line3()
    ];
    projectedPoint = new Vector3();
    closestPoint = new Vector3();
}
result = optionalTarget || new Vector3();
minDistance = Infinity;
plane.setFromCoplanarPoints(this.a, this.b, this.c);
plane.projectPoint(point, projectedPoint);
if (this.containsPoint(projectedPoint) === true) {
    result.copy(projectedPoint);
} else {
    edgeList[0].set(this.a, this.b);
    edgeList[1].set(this.b, this.c);
    edgeList[2].set(this.c, this.a);
    for (var i = 0; i < edgeList.length; i++) {
        edgeList[i].closestPointToPoint(projectedPoint, true, closestPoint);
        distance = projectedPoint.distanceToSquared(closestPoint);
        if (distance < minDistance) {
            minDistance = distance;
            result.copy(closestPoint);
        }
    }
}
return result;});
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return function closestPointToPoint(point, optionalTarget) {
    if (plane === undefined) {
        plane = new Plane();
        edgeList = [
            new Line3(),
            new Line3(),
            new Line3()
        ];
        projectedPoint = new Vector3();
        closestPoint = new Vector3();
    }
    var result = optionalTarget || new Vector3();
    var minDistance = Infinity;
    plane.setFromCoplanarPoints(this.a, this.b, this.c);
    plane.projectPoint(point, projectedPoint);
    if (this.containsPoint(projectedPoint) === true) {
        result.copy(projectedPoint);
    } else {
        edgeList[0].set(this.a, this.b);
        edgeList[1].set(this.b, this.c);
        edgeList[2].set(this.c, this.a);
        for (var i = 0; i < edgeList.length; i++) {
            edgeList[i].closestPointToPoint(projectedPoint, true, closestPoint);
            var distance = projectedPoint.distanceToSquared(closestPoint);
            if (distance < minDistance) {
                minDistance = distance;
                result.copy(closestPoint);
            }
        }
    }
    return result;
};}), $__.fs.J$__v494107025_1625_970)(0, true, $__.uid),
        'equals': ($__.fs.J$__v494107025_1627_972 = function J$__v494107025_1627(triangle) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
triangle = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c);})
    };
    MeshBasicMaterial.prototype = Object['create']((Material.prototype, $__.os.oid16));
    TAJS_restrictToType(MeshBasicMaterial.prototype, 'object').constructor = MeshBasicMaterial;
    TAJS_restrictToType(MeshBasicMaterial.prototype, 'object').isMeshBasicMaterial = true;
    TAJS_restrictToType(MeshBasicMaterial.prototype, 'object').copy = ($__.fs.J$__v494107025_1630_973 = function J$__v494107025_1630(source) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
source = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
Material.prototype.copy.call(this, source);
this.color.copy(source.color);
this.map = source.map;
this.aoMap = source.aoMap;
this.aoMapIntensity = source.aoMapIntensity;
this.specularMap = source.specularMap;
this.alphaMap = source.alphaMap;
this.envMap = source.envMap;
this.combine = source.combine;
this.reflectivity = source.reflectivity;
this.refractionRatio = source.refractionRatio;
this.wireframe = source.wireframe;
this.wireframeLinewidth = source.wireframeLinewidth;
this.wireframeLinecap = source.wireframeLinecap;
this.wireframeLinejoin = source.wireframeLinejoin;
this.skinning = source.skinning;
this.morphTargets = source.morphTargets;
return this;});
    Mesh.prototype = Object['assign'](Object['create'](TAJS_restrictToType(Object3D.prototype, 'object')), $__.os.oid433 = {
        'constructor': Mesh,
        'isMesh': true,
        'setDrawMode': ($__.fs.J$__v494107025_1633_974 = function J$__v494107025_1633(value) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
value = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.drawMode = value;}),
        'copy': ($__.fs.J$__v494107025_1635_975 = function J$__v494107025_1635(source) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
source = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
Object3D.prototype.copy.call(this, source);
this.drawMode = source.drawMode;
return this;}),
        'updateMorphTargets': ($__.fs.J$__v494107025_1637_976 = function J$__v494107025_1637() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (this.geometry.morphTargets !== undefined && this.geometry.morphTargets.length > 0) {
    this.morphTargetBase = -1;
    this.morphTargetInfluences = [];
    this.morphTargetDictionary = {};
    for (var m = 0, ml = this.geometry.morphTargets.length; m < ml; m++) {
        this.morphTargetInfluences.push(0);
        this.morphTargetDictionary[this.geometry.morphTargets[m].name] = m;
    }
}}),
        'getMorphTargetIndexByName': ($__.fs.J$__v494107025_1639_977 = function J$__v494107025_1639(name) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
name = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (this.morphTargetDictionary[name] !== undefined) {
    return this.morphTargetDictionary[name];
}
console.warn('THREE.Mesh.getMorphTargetIndexByName: morph target ' + name + ' does not exist. Returning 0.');
return 0;}),
        'raycast': (($__.fs.J$__v494107025_1645_978 = function J$__v494107025_1645() {
var vvv_return, vvv_switch, inverseMatrix, ray, sphere, vA, vB, vC, tempA, tempB, tempC, uvA, uvB, uvC, barycoord, intersectionPoint, intersectionPointWorld, uvIntersection, checkIntersection, checkBufferGeometryIntersection;
uvIntersection = function uvIntersection(point, p1, p2, p3, uv1, uv2, uv3) {
    Triangle.barycoordFromPoint(point, p1, p2, p3, barycoord);
    uv1.multiplyScalar(barycoord.x);
    uv2.multiplyScalar(barycoord.y);
    uv3.multiplyScalar(barycoord.z);
    uv1.add(uv2).add(uv3);
    return uv1.clone();
};
checkIntersection = function checkIntersection(object, raycaster, ray, pA, pB, pC, point) {
    var intersect;
    var material = object.material;
    if (material.side === BackSide) {
        intersect = ray.intersectTriangle(pC, pB, pA, true, point);
    } else {
        intersect = ray.intersectTriangle(pA, pB, pC, material.side !== DoubleSide, point);
    }
    if (intersect === null)
        return null;
    intersectionPointWorld.copy(point);
    intersectionPointWorld.applyMatrix4(object.matrixWorld);
    var distance = raycaster.ray.origin.distanceTo(intersectionPointWorld);
    if (distance < raycaster.near || distance > raycaster.far)
        return null;
    return {
        distance: distance,
        point: intersectionPointWorld.clone(),
        object: object
    };
};
checkBufferGeometryIntersection = function checkBufferGeometryIntersection(object, raycaster, ray, positions, uvs, a, b, c) {
    vA.fromArray(positions, a * 3);
    vB.fromArray(positions, b * 3);
    vC.fromArray(positions, c * 3);
    var intersection = checkIntersection(object, raycaster, ray, vA, vB, vC, intersectionPoint);
    if (intersection) {
        if (uvs) {
            uvA.fromArray(uvs, a * 2);
            uvB.fromArray(uvs, b * 2);
            uvC.fromArray(uvs, c * 2);
            intersection.uv = uvIntersection(intersectionPoint, vA, vB, vC, uvA, uvB, uvC);
        }
        intersection.face = new Face3(a, b, c, Triangle.normal(vA, vB, vC));
        intersection.faceIndex = a;
    }
    return intersection;
};
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    uvIntersection = ($__.fs.uvIntersection_979 = function uvIntersection(point, p1, p2, p3, uv1, uv2, uv3) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
point = arguments[0], p1 = arguments[1], p2 = arguments[2], p3 = arguments[3], uv1 = arguments[4], uv2 = arguments[5], uv3 = arguments[6];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
Triangle.barycoordFromPoint(point, p1, p2, p3, barycoord);
uv1.multiplyScalar(barycoord.x);
uv2.multiplyScalar(barycoord.y);
uv3.multiplyScalar(barycoord.z);
uv1.add(uv2).add(uv3);
return uv1.clone();});
    checkIntersection = ($__.fs.checkIntersection_980 = function checkIntersection(object, raycaster, ray, pA, pB, pC, point) {
var vvv_return, vvv_switch, intersect, material, distance;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
object = arguments[0], raycaster = arguments[1], ray = arguments[2], pA = arguments[3], pB = arguments[4], pC = arguments[5], point = arguments[6];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
material = object.material;
if (material.side === BackSide) {
    intersect = ray.intersectTriangle(pC, pB, pA, true, point);
} else {
    intersect = ray.intersectTriangle(pA, pB, pC, material.side !== DoubleSide, point);
}
if (intersect === null)
    return null;
intersectionPointWorld.copy(point);
intersectionPointWorld.applyMatrix4(object.matrixWorld);
distance = raycaster.ray.origin.distanceTo(intersectionPointWorld);
if (distance < raycaster.near || distance > raycaster.far)
    return null;
return {
    distance: distance,
    point: intersectionPointWorld.clone(),
    object: object
};});
    checkBufferGeometryIntersection = ($__.fs.checkBufferGeometryIntersection_981 = function checkBufferGeometryIntersection(object, raycaster, ray, positions, uvs, a, b, c) {
var vvv_return, vvv_switch, intersection;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
object = arguments[0], raycaster = arguments[1], ray = arguments[2], positions = arguments[3], uvs = arguments[4], a = arguments[5], b = arguments[6], c = arguments[7];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
vA.fromArray(positions, a * 3);
vB.fromArray(positions, b * 3);
vC.fromArray(positions, c * 3);
intersection = checkIntersection(object, raycaster, ray, vA, vB, vC, intersectionPoint);
if (intersection) {
    if (uvs) {
        uvA.fromArray(uvs, a * 2);
        uvB.fromArray(uvs, b * 2);
        uvC.fromArray(uvs, c * 2);
        intersection.uv = uvIntersection(intersectionPoint, vA, vB, vC, uvA, uvB, uvC);
    }
    intersection.face = new Face3(a, b, c, Triangle.normal(vA, vB, vC));
    intersection.faceIndex = a;
}
return intersection;});
    inverseMatrix = new (Matrix4, $__.fs.Matrix4_9)(2, true, $__.uid);
    ray = new (Ray, $__.fs.Ray_111)(0, true, $__.uid);
    sphere = new (Sphere, $__.fs.Sphere_60)(2, true, $__.uid);
    vA = new (Vector3, $__.fs.Vector3_11)(60, true, $__.uid);
    vB = new (Vector3, $__.fs.Vector3_11)(61, true, $__.uid);
    vC = new (Vector3, $__.fs.Vector3_11)(62, true, $__.uid);
    tempA = new (Vector3, $__.fs.Vector3_11)(63, true, $__.uid);
    tempB = new (Vector3, $__.fs.Vector3_11)(64, true, $__.uid);
    tempC = new (Vector3, $__.fs.Vector3_11)(65, true, $__.uid);
    uvA = new (Vector2, $__.fs.Vector2_6)(10, true, $__.uid);
    uvB = new (Vector2, $__.fs.Vector2_6)(11, true, $__.uid);
    uvC = new (Vector2, $__.fs.Vector2_6)(12, true, $__.uid);
    barycoord = new (Vector3, $__.fs.Vector3_11)(66, true, $__.uid);
    intersectionPoint = new (Vector3, $__.fs.Vector3_11)(67, true, $__.uid);
    intersectionPointWorld = new (Vector3, $__.fs.Vector3_11)(68, true, $__.uid);
    return ($__.fs.raycast_982 = function raycast(raycaster, intersects) {
var vvv_return, vvv_switch, geometry, material, matrixWorld, uvs, intersection, a, b, c, index, attributes, positions, indices, fvA, fvB, fvC, isFaceMaterial, materials, vertices, faces, faceVertexUvs, face, faceMaterial, morphTargets, morphInfluences, influence, targets, uvs_f;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
raycaster = arguments[0], intersects = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
geometry = this.geometry;
material = this.material;
matrixWorld = this.matrixWorld;
if (material === undefined)
    return;
if (geometry.boundingSphere === null)
    geometry.computeBoundingSphere();
sphere.copy(geometry.boundingSphere);
sphere.applyMatrix4(matrixWorld);
if (raycaster.ray.intersectsSphere(sphere) === false)
    return;
inverseMatrix.getInverse(matrixWorld);
ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);
if (geometry.boundingBox !== null) {
    if (ray.intersectsBox(geometry.boundingBox) === false)
        return;
}
if (geometry && geometry.isBufferGeometry) {
    index = geometry.index;
    attributes = geometry.attributes;
    positions = attributes.position.array;
    if (attributes.uv !== undefined) {
        uvs = attributes.uv.array;
    }
    if (index !== null) {
        indices = index.array;
        for (var i = 0, l = indices.length; i < l; i += 3) {
            a = indices[i];
            b = indices[i + 1];
            c = indices[i + 2];
            intersection = checkBufferGeometryIntersection(this, raycaster, ray, positions, uvs, a, b, c);
            if (intersection) {
                intersection.faceIndex = Math.floor(i / 3);
                intersects.push(intersection);
            }
        }
    } else {
        for (var i = 0, l = positions.length; i < l; i += 9) {
            a = i / 3;
            b = a + 1;
            c = a + 2;
            intersection = checkBufferGeometryIntersection(this, raycaster, ray, positions, uvs, a, b, c);
            if (intersection) {
                intersection.index = a;
                intersects.push(intersection);
            }
        }
    }
} else if (geometry && geometry.isGeometry) {
    isFaceMaterial = material && material.isMultiMaterial;
    materials = isFaceMaterial === true ? material.materials : null;
    vertices = geometry.vertices;
    faces = geometry.faces;
    faceVertexUvs = geometry.faceVertexUvs[0];
    if (faceVertexUvs.length > 0)
        uvs = faceVertexUvs;
    for (var f = 0, fl = faces.length; f < fl; f++) {
        face = faces[f];
        faceMaterial = isFaceMaterial === true ? materials[face.materialIndex] : material;
        if (faceMaterial === undefined)
            continue;
        fvA = vertices[face.a];
        fvB = vertices[face.b];
        fvC = vertices[face.c];
        if (faceMaterial.morphTargets === true) {
            morphTargets = geometry.morphTargets;
            morphInfluences = this.morphTargetInfluences;
            vA.set(0, 0, 0);
            vB.set(0, 0, 0);
            vC.set(0, 0, 0);
            for (var t = 0, tl = morphTargets.length; t < tl; t++) {
                influence = morphInfluences[t];
                if (influence === 0)
                    continue;
                targets = morphTargets[t].vertices;
                vA.addScaledVector(tempA.subVectors(targets[face.a], fvA), influence);
                vB.addScaledVector(tempB.subVectors(targets[face.b], fvB), influence);
                vC.addScaledVector(tempC.subVectors(targets[face.c], fvC), influence);
            }
            vA.add(fvA);
            vB.add(fvB);
            vC.add(fvC);
            fvA = vA;
            fvB = vB;
            fvC = vC;
        }
        intersection = checkIntersection(this, raycaster, ray, fvA, fvB, fvC, intersectionPoint);
        if (intersection) {
            if (uvs) {
                uvs_f = uvs[f];
                uvA.copy(uvs_f[0]);
                uvB.copy(uvs_f[1]);
                uvC.copy(uvs_f[2]);
                intersection.uv = uvIntersection(intersectionPoint, fvA, fvB, fvC, uvA, uvB, uvC);
            }
            intersection.face = face;
            intersection.faceIndex = f;
            intersects.push(intersection);
        }
    }
}});
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
inverseMatrix = new Matrix4();
ray = new Ray();
sphere = new Sphere();
vA = new Vector3();
vB = new Vector3();
vC = new Vector3();
tempA = new Vector3();
tempB = new Vector3();
tempC = new Vector3();
uvA = new Vector2();
uvB = new Vector2();
uvC = new Vector2();
barycoord = new Vector3();
intersectionPoint = new Vector3();
intersectionPointWorld = new Vector3();
return function raycast(raycaster, intersects) {
    var geometry = this.geometry;
    var material = this.material;
    var matrixWorld = this.matrixWorld;
    if (material === undefined)
        return;
    if (geometry.boundingSphere === null)
        geometry.computeBoundingSphere();
    sphere.copy(geometry.boundingSphere);
    sphere.applyMatrix4(matrixWorld);
    if (raycaster.ray.intersectsSphere(sphere) === false)
        return;
    inverseMatrix.getInverse(matrixWorld);
    ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);
    if (geometry.boundingBox !== null) {
        if (ray.intersectsBox(geometry.boundingBox) === false)
            return;
    }
    var uvs, intersection;
    if (geometry && geometry.isBufferGeometry) {
        var a, b, c;
        var index = geometry.index;
        var attributes = geometry.attributes;
        var positions = attributes.position.array;
        if (attributes.uv !== undefined) {
            uvs = attributes.uv.array;
        }
        if (index !== null) {
            var indices = index.array;
            for (var i = 0, l = indices.length; i < l; i += 3) {
                a = indices[i];
                b = indices[i + 1];
                c = indices[i + 2];
                intersection = checkBufferGeometryIntersection(this, raycaster, ray, positions, uvs, a, b, c);
                if (intersection) {
                    intersection.faceIndex = Math.floor(i / 3);
                    intersects.push(intersection);
                }
            }
        } else {
            for (var i = 0, l = positions.length; i < l; i += 9) {
                a = i / 3;
                b = a + 1;
                c = a + 2;
                intersection = checkBufferGeometryIntersection(this, raycaster, ray, positions, uvs, a, b, c);
                if (intersection) {
                    intersection.index = a;
                    intersects.push(intersection);
                }
            }
        }
    } else if (geometry && geometry.isGeometry) {
        var fvA, fvB, fvC;
        var isFaceMaterial = material && material.isMultiMaterial;
        var materials = isFaceMaterial === true ? material.materials : null;
        var vertices = geometry.vertices;
        var faces = geometry.faces;
        var faceVertexUvs = geometry.faceVertexUvs[0];
        if (faceVertexUvs.length > 0)
            uvs = faceVertexUvs;
        for (var f = 0, fl = faces.length; f < fl; f++) {
            var face = faces[f];
            var faceMaterial = isFaceMaterial === true ? materials[face.materialIndex] : material;
            if (faceMaterial === undefined)
                continue;
            fvA = vertices[face.a];
            fvB = vertices[face.b];
            fvC = vertices[face.c];
            if (faceMaterial.morphTargets === true) {
                var morphTargets = geometry.morphTargets;
                var morphInfluences = this.morphTargetInfluences;
                vA.set(0, 0, 0);
                vB.set(0, 0, 0);
                vC.set(0, 0, 0);
                for (var t = 0, tl = morphTargets.length; t < tl; t++) {
                    var influence = morphInfluences[t];
                    if (influence === 0)
                        continue;
                    var targets = morphTargets[t].vertices;
                    vA.addScaledVector(tempA.subVectors(targets[face.a], fvA), influence);
                    vB.addScaledVector(tempB.subVectors(targets[face.b], fvB), influence);
                    vC.addScaledVector(tempC.subVectors(targets[face.c], fvC), influence);
                }
                vA.add(fvA);
                vB.add(fvB);
                vC.add(fvC);
                fvA = vA;
                fvB = vB;
                fvC = vC;
            }
            intersection = checkIntersection(this, raycaster, ray, fvA, fvB, fvC, intersectionPoint);
            if (intersection) {
                if (uvs) {
                    var uvs_f = uvs[f];
                    uvA.copy(uvs_f[0]);
                    uvB.copy(uvs_f[1]);
                    uvC.copy(uvs_f[2]);
                    intersection.uv = uvIntersection(intersectionPoint, fvA, fvB, fvC, uvA, uvB, uvC);
                }
                intersection.face = face;
                intersection.faceIndex = f;
                intersects.push(intersection);
            }
        }
    }
};}), $__.fs.J$__v494107025_1645_978)(0, true, $__.uid),
        'clone': ($__.fs.J$__v494107025_1647_983 = function J$__v494107025_1647() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return new this.constructor(this.geometry, this.material).copy(this);})
    });
    PlaneBufferGeometry.prototype = Object['create'](TAJS_restrictToType(BufferGeometry.prototype, 'object'));
    TAJS_restrictToType(PlaneBufferGeometry.prototype, 'object').constructor = PlaneBufferGeometry;
    Camera.prototype = Object['create'](TAJS_restrictToType(Object3D.prototype, 'object'));
    TAJS_restrictToType(Camera.prototype, 'object').constructor = Camera;
    TAJS_restrictToType(Camera.prototype, 'object').isCamera = true;
    TAJS_restrictToType(Camera.prototype, 'object').getWorldDirection = (($__.fs.J$__v494107025_1652_984 = function J$__v494107025_1652() {
var vvv_return, vvv_switch, quaternion;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    quaternion = new (Quaternion, $__.fs.Quaternion_10)(5, true, $__.uid);
    return ($__.fs.getWorldDirection_985 = function getWorldDirection(optionalTarget) {
var vvv_return, vvv_switch, result;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
optionalTarget = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
result = optionalTarget || new Vector3();
this.getWorldQuaternion(quaternion);
return result.set(0, 0, -1).applyQuaternion(quaternion);});
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
quaternion = new Quaternion();
return function getWorldDirection(optionalTarget) {
    var result = optionalTarget || new Vector3();
    this.getWorldQuaternion(quaternion);
    return result.set(0, 0, -1).applyQuaternion(quaternion);
};}), $__.fs.J$__v494107025_1652_984)(0, true, $__.uid);
    TAJS_restrictToType(Camera.prototype, 'object').lookAt = (($__.fs.J$__v494107025_1655_986 = function J$__v494107025_1655() {
var vvv_return, vvv_switch, m1;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    m1 = new (Matrix4, $__.fs.Matrix4_9)(3, true, $__.uid);
    return ($__.fs.lookAt_987 = function lookAt(vector) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
vector = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
m1.lookAt(this.position, vector, this.up);
this.quaternion.setFromRotationMatrix(m1);});
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
m1 = new Matrix4();
return function lookAt(vector) {
    m1.lookAt(this.position, vector, this.up);
    this.quaternion.setFromRotationMatrix(m1);
};}), $__.fs.J$__v494107025_1655_986)(0, true, $__.uid);
    TAJS_restrictToType(Camera.prototype, 'object').clone = ($__.fs.J$__v494107025_1657_988 = function J$__v494107025_1657() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return new this.constructor().copy(this);});
    TAJS_restrictToType(Camera.prototype, 'object').copy = ($__.fs.J$__v494107025_1659_989 = function J$__v494107025_1659(source) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
source = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
Object3D.prototype.copy.call(this, source);
this.matrixWorldInverse.copy(source.matrixWorldInverse);
this.projectionMatrix.copy(source.projectionMatrix);
return this;});
    PerspectiveCamera.prototype = Object['assign'](Object['create'](TAJS_restrictToType(Camera.prototype, 'object')), $__.os.oid434 = {
        'constructor': PerspectiveCamera,
        'isPerspectiveCamera': true,
        'copy': ($__.fs.J$__v494107025_1662_990 = function J$__v494107025_1662(source) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
source = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
Camera.prototype.copy.call(this, source);
this.fov = source.fov;
this.zoom = source.zoom;
this.near = source.near;
this.far = source.far;
this.focus = source.focus;
this.aspect = source.aspect;
this.view = source.view === null ? null : Object.assign({}, source.view);
this.filmGauge = source.filmGauge;
this.filmOffset = source.filmOffset;
return this;}),
        'setFocalLength': ($__.fs.J$__v494107025_1664_991 = function J$__v494107025_1664(focalLength) {
var vvv_return, vvv_switch, vExtentSlope;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
focalLength = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;
this.fov = exports.Math.RAD2DEG * 2 * Math.atan(vExtentSlope);
this.updateProjectionMatrix();}),
        'getFocalLength': ($__.fs.J$__v494107025_1666_992 = function J$__v494107025_1666() {
var vvv_return, vvv_switch, vExtentSlope;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
vExtentSlope = Math.tan(exports.Math.DEG2RAD * 0.5 * this.fov);
return 0.5 * this.getFilmHeight() / vExtentSlope;}),
        'getEffectiveFOV': ($__.fs.J$__v494107025_1668_993 = function J$__v494107025_1668() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return exports.Math.RAD2DEG * 2 * Math.atan(Math.tan(exports.Math.DEG2RAD * 0.5 * this.fov) / this.zoom);}),
        'getFilmWidth': ($__.fs.J$__v494107025_1670_994 = function J$__v494107025_1670() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return this.filmGauge * Math.min(this.aspect, 1);}),
        'getFilmHeight': ($__.fs.J$__v494107025_1672_995 = function J$__v494107025_1672() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return this.filmGauge / Math.max(this.aspect, 1);}),
        'setViewOffset': ($__.fs.J$__v494107025_1674_996 = function J$__v494107025_1674(fullWidth, fullHeight, x, y, width, height) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
fullWidth = arguments[0], fullHeight = arguments[1], x = arguments[2], y = arguments[3], width = arguments[4], height = arguments[5];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.aspect = fullWidth / fullHeight;
this.view = {
    fullWidth: fullWidth,
    fullHeight: fullHeight,
    offsetX: x,
    offsetY: y,
    width: width,
    height: height
};
this.updateProjectionMatrix();}),
        'clearViewOffset': ($__.fs.J$__v494107025_1676_997 = function J$__v494107025_1676() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.view = null;
this.updateProjectionMatrix();}),
        'updateProjectionMatrix': ($__.fs.J$__v494107025_1678_998 = function J$__v494107025_1678() {
var vvv_return, vvv_switch, near, top, height, width, left, view, fullWidth, fullHeight, skew;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
near = this.near;
top = near * Math.tan(exports.Math.DEG2RAD * 0.5 * this.fov) / this.zoom;
height = 2 * top;
width = this.aspect * height;
left = -0.5 * width;
view = this.view;
if (view !== null) {
    fullWidth = view.fullWidth;
    fullHeight = view.fullHeight;
    left += view.offsetX * width / fullWidth;
    top -= view.offsetY * height / fullHeight;
    width *= view.width / fullWidth;
    height *= view.height / fullHeight;
}
skew = this.filmOffset;
if (skew !== 0)
    left += near * skew / this.getFilmWidth();
this.projectionMatrix.makeFrustum(left, left + width, top - height, top, near, this.far);}),
        'toJSON': ($__.fs.J$__v494107025_1680_999 = function J$__v494107025_1680(meta) {
var vvv_return, vvv_switch, data;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
meta = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
data = Object3D.prototype.toJSON.call(this, meta);
data.object.fov = this.fov;
data.object.zoom = this.zoom;
data.object.near = this.near;
data.object.far = this.far;
data.object.focus = this.focus;
data.object.aspect = this.aspect;
if (this.view !== null)
    data.object.view = Object.assign({}, this.view);
data.object.filmGauge = this.filmGauge;
data.object.filmOffset = this.filmOffset;
return data;})
    });
    OrthographicCamera.prototype = Object['assign'](Object['create'](TAJS_restrictToType(Camera.prototype, 'object')), $__.os.oid435 = {
        'constructor': OrthographicCamera,
        'isOrthographicCamera': true,
        'copy': ($__.fs.J$__v494107025_1683_1000 = function J$__v494107025_1683(source) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
source = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
Camera.prototype.copy.call(this, source);
this.left = source.left;
this.right = source.right;
this.top = source.top;
this.bottom = source.bottom;
this.near = source.near;
this.far = source.far;
this.zoom = source.zoom;
this.view = source.view === null ? null : Object.assign({}, source.view);
return this;}),
        'setViewOffset': ($__.fs.J$__v494107025_1685_1001 = function J$__v494107025_1685(fullWidth, fullHeight, x, y, width, height) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
fullWidth = arguments[0], fullHeight = arguments[1], x = arguments[2], y = arguments[3], width = arguments[4], height = arguments[5];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.view = {
    fullWidth: fullWidth,
    fullHeight: fullHeight,
    offsetX: x,
    offsetY: y,
    width: width,
    height: height
};
this.updateProjectionMatrix();}),
        'clearViewOffset': ($__.fs.J$__v494107025_1687_1002 = function J$__v494107025_1687() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.view = null;
this.updateProjectionMatrix();}),
        'updateProjectionMatrix': ($__.fs.J$__v494107025_1689_1003 = function J$__v494107025_1689() {
var vvv_return, vvv_switch, dx, dy, cx, cy, left, right, top, bottom, zoomW, zoomH, scaleW, scaleH;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
dx = (this.right - this.left) / (2 * this.zoom);
dy = (this.top - this.bottom) / (2 * this.zoom);
cx = (this.right + this.left) / 2;
cy = (this.top + this.bottom) / 2;
left = cx - dx;
right = cx + dx;
top = cy + dy;
bottom = cy - dy;
if (this.view !== null) {
    zoomW = this.zoom / (this.view.width / this.view.fullWidth);
    zoomH = this.zoom / (this.view.height / this.view.fullHeight);
    scaleW = (this.right - this.left) / this.view.width;
    scaleH = (this.top - this.bottom) / this.view.height;
    left += scaleW * (this.view.offsetX / zoomW);
    right = left + scaleW * (this.view.width / zoomW);
    top -= scaleH * (this.view.offsetY / zoomH);
    bottom = top - scaleH * (this.view.height / zoomH);
}
this.projectionMatrix.makeOrthographic(left, right, top, bottom, this.near, this.far);}),
        'toJSON': ($__.fs.J$__v494107025_1691_1004 = function J$__v494107025_1691(meta) {
var vvv_return, vvv_switch, data;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
meta = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
data = Object3D.prototype.toJSON.call(this, meta);
data.object.zoom = this.zoom;
data.object.left = this.left;
data.object.right = this.right;
data.object.top = this.top;
data.object.bottom = this.bottom;
data.object.near = this.near;
data.object.far = this.far;
if (this.view !== null)
    data.object.view = Object.assign({}, this.view);
return data;})
    });
    TAJS_restrictToType(FogExp2.prototype, 'object').isFogExp2 = true;
    TAJS_restrictToType(FogExp2.prototype, 'object').clone = ($__.fs.J$__v494107025_1801_1005 = function J$__v494107025_1801() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return new FogExp2(this.color.getHex(), this.density);});
    TAJS_restrictToType(FogExp2.prototype, 'object').toJSON = ($__.fs.J$__v494107025_1803_1006 = function J$__v494107025_1803(meta) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
meta = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return {
    type: 'FogExp2',
    color: this.color.getHex(),
    density: this.density
};});
    TAJS_restrictToType(Fog.prototype, 'object').isFog = true;
    TAJS_restrictToType(Fog.prototype, 'object').clone = ($__.fs.J$__v494107025_1806_1007 = function J$__v494107025_1806() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return new Fog(this.color.getHex(), this.near, this.far);});
    TAJS_restrictToType(Fog.prototype, 'object').toJSON = ($__.fs.J$__v494107025_1808_1008 = function J$__v494107025_1808(meta) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
meta = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return {
    type: 'Fog',
    color: this.color.getHex(),
    near: this.near,
    far: this.far
};});
    Scene.prototype = Object['create'](TAJS_restrictToType(Object3D.prototype, 'object'));
    TAJS_restrictToType(Scene.prototype, 'object').constructor = Scene;
    TAJS_restrictToType(Scene.prototype, 'object').copy = ($__.fs.J$__v494107025_1811_1009 = function J$__v494107025_1811(source, recursive) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
source = arguments[0], recursive = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
Object3D.prototype.copy.call(this, source, recursive);
if (source.background !== null)
    this.background = source.background.clone();
if (source.fog !== null)
    this.fog = source.fog.clone();
if (source.overrideMaterial !== null)
    this.overrideMaterial = source.overrideMaterial.clone();
this.autoUpdate = source.autoUpdate;
this.matrixAutoUpdate = source.matrixAutoUpdate;
return this;});
    TAJS_restrictToType(Scene.prototype, 'object').toJSON = ($__.fs.J$__v494107025_1813_1010 = function J$__v494107025_1813(meta) {
var vvv_return, vvv_switch, data;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
meta = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
data = Object3D.prototype.toJSON.call(this, meta);
if (this.background !== null)
    data.object.background = this.background.toJSON(meta);
if (this.fog !== null)
    data.object.fog = this.fog.toJSON();
return data;});
    LensFlare.prototype = Object['assign'](Object['create'](TAJS_restrictToType(Object3D.prototype, 'object')), $__.os.oid436 = {
        'constructor': LensFlare,
        'isLensFlare': true,
        'copy': ($__.fs.J$__v494107025_1816_1011 = function J$__v494107025_1816(source) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
source = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
Object3D.prototype.copy.call(this, source);
this.positionScreen.copy(source.positionScreen);
this.customUpdateCallback = source.customUpdateCallback;
for (var i = 0, l = source.lensFlares.length; i < l; i++) {
    this.lensFlares.push(source.lensFlares[i]);
}
return this;}),
        'add': ($__.fs.J$__v494107025_1818_1012 = function J$__v494107025_1818(texture, size, distance, blending, color, opacity) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
texture = arguments[0], size = arguments[1], distance = arguments[2], blending = arguments[3], color = arguments[4], opacity = arguments[5];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (size === undefined)
    size = -1;
if (distance === undefined)
    distance = 0;
if (opacity === undefined)
    opacity = 1;
if (color === undefined)
    color = new Color(16777215);
if (blending === undefined)
    blending = NormalBlending;
distance = Math.min(distance, Math.max(0, distance));
this.lensFlares.push({
    texture: texture,
    size: size,
    distance: distance,
    x: 0,
    y: 0,
    z: 0,
    scale: 1,
    rotation: 0,
    opacity: opacity,
    color: color,
    blending: blending
});}),
        'updateLensFlares': ($__.fs.J$__v494107025_1820_1013 = function J$__v494107025_1820() {
var vvv_return, vvv_switch, f, fl, flare, vecX, vecY;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
fl = this.lensFlares.length;
vecX = -this.positionScreen.x * 2;
vecY = -this.positionScreen.y * 2;
for (f = 0; f < fl; f++) {
    flare = this.lensFlares[f];
    flare.x = this.positionScreen.x + vecX * flare.distance;
    flare.y = this.positionScreen.y + vecY * flare.distance;
    flare.wantedRotation = flare.x * Math.PI * 0.25;
    flare.rotation += (flare.wantedRotation - flare.rotation) * 0.25;
}})
    });
    SpriteMaterial.prototype = Object['create']((Material.prototype, $__.os.oid16));
    TAJS_restrictToType(SpriteMaterial.prototype, 'object').constructor = SpriteMaterial;
    TAJS_restrictToType(SpriteMaterial.prototype, 'object').copy = ($__.fs.J$__v494107025_1823_1014 = function J$__v494107025_1823(source) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
source = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
Material.prototype.copy.call(this, source);
this.color.copy(source.color);
this.map = source.map;
this.rotation = source.rotation;
return this;});
    Sprite.prototype = Object['assign'](Object['create'](TAJS_restrictToType(Object3D.prototype, 'object')), $__.os.oid437 = {
        'constructor': Sprite,
        'isSprite': true,
        'raycast': (($__.fs.J$__v494107025_1827_1015 = function J$__v494107025_1827() {
var vvv_return, vvv_switch, matrixPosition;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    matrixPosition = new (Vector3, $__.fs.Vector3_11)(69, true, $__.uid);
    return ($__.fs.raycast_1016 = function raycast(raycaster, intersects) {
var vvv_return, vvv_switch, distanceSq, guessSizeSq;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
raycaster = arguments[0], intersects = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
matrixPosition.setFromMatrixPosition(this.matrixWorld);
distanceSq = raycaster.ray.distanceSqToPoint(matrixPosition);
guessSizeSq = this.scale.x * this.scale.y / 4;
if (distanceSq > guessSizeSq) {
    return;
}
intersects.push({
    distance: Math.sqrt(distanceSq),
    point: this.position,
    face: null,
    object: this
});});
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
matrixPosition = new Vector3();
return function raycast(raycaster, intersects) {
    matrixPosition.setFromMatrixPosition(this.matrixWorld);
    var distanceSq = raycaster.ray.distanceSqToPoint(matrixPosition);
    var guessSizeSq = this.scale.x * this.scale.y / 4;
    if (distanceSq > guessSizeSq) {
        return;
    }
    intersects.push({
        distance: Math.sqrt(distanceSq),
        point: this.position,
        face: null,
        object: this
    });
};}), $__.fs.J$__v494107025_1827_1015)(0, true, $__.uid),
        'clone': ($__.fs.J$__v494107025_1829_1017 = function J$__v494107025_1829() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return new this.constructor(this.material).copy(this);})
    });
    LOD.prototype = Object['assign'](Object['create'](TAJS_restrictToType(Object3D.prototype, 'object')), $__.os.oid438 = {
        'constructor': LOD,
        'copy': ($__.fs.J$__v494107025_1832_1018 = function J$__v494107025_1832(source) {
var vvv_return, vvv_switch, levels, level;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
source = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
Object3D.prototype.copy.call(this, source, false);
levels = source.levels;
for (var i = 0, l = levels.length; i < l; i++) {
    level = levels[i];
    this.addLevel(level.object.clone(), level.distance);
}
return this;}),
        'addLevel': ($__.fs.J$__v494107025_1834_1019 = function J$__v494107025_1834(object, distance) {
var vvv_return, vvv_switch, levels;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
object = arguments[0], distance = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (distance === undefined)
    distance = 0;
distance = Math.abs(distance);
levels = this.levels;
for (var l = 0; l < levels.length; l++) {
    if (distance < levels[l].distance) {
        break;
    }
}
levels.splice(l, 0, {
    distance: distance,
    object: object
});
this.add(object);}),
        'getObjectForDistance': ($__.fs.J$__v494107025_1836_1020 = function J$__v494107025_1836(distance) {
var vvv_return, vvv_switch, levels;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
distance = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
levels = this.levels;
for (var i = 1, l = levels.length; i < l; i++) {
    if (distance < levels[i].distance) {
        break;
    }
}
return levels[i - 1].object;}),
        'raycast': (($__.fs.J$__v494107025_1839_1021 = function J$__v494107025_1839() {
var vvv_return, vvv_switch, matrixPosition;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    matrixPosition = new (Vector3, $__.fs.Vector3_11)(70, true, $__.uid);
    return ($__.fs.raycast_1022 = function raycast(raycaster, intersects) {
var vvv_return, vvv_switch, distance;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
raycaster = arguments[0], intersects = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
matrixPosition.setFromMatrixPosition(this.matrixWorld);
distance = raycaster.ray.origin.distanceTo(matrixPosition);
this.getObjectForDistance(distance).raycast(raycaster, intersects);});
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
matrixPosition = new Vector3();
return function raycast(raycaster, intersects) {
    matrixPosition.setFromMatrixPosition(this.matrixWorld);
    var distance = raycaster.ray.origin.distanceTo(matrixPosition);
    this.getObjectForDistance(distance).raycast(raycaster, intersects);
};}), $__.fs.J$__v494107025_1839_1021)(0, true, $__.uid),
        'update': (($__.fs.J$__v494107025_1842_1023 = function J$__v494107025_1842() {
var vvv_return, vvv_switch, v1, v2;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    v1 = new (Vector3, $__.fs.Vector3_11)(71, true, $__.uid);
    v2 = new (Vector3, $__.fs.Vector3_11)(72, true, $__.uid);
    return ($__.fs.update_1024 = function update(camera) {
var vvv_return, vvv_switch, levels, distance;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
camera = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
levels = this.levels;
if (levels.length > 1) {
    v1.setFromMatrixPosition(camera.matrixWorld);
    v2.setFromMatrixPosition(this.matrixWorld);
    distance = v1.distanceTo(v2);
    levels[0].object.visible = true;
    for (var i = 1, l = levels.length; i < l; i++) {
        if (distance >= levels[i].distance) {
            levels[i - 1].object.visible = false;
            levels[i].object.visible = true;
        } else {
            break;
        }
    }
    for (; i < l; i++) {
        levels[i].object.visible = false;
    }
}});
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
v1 = new Vector3();
v2 = new Vector3();
return function update(camera) {
    var levels = this.levels;
    if (levels.length > 1) {
        v1.setFromMatrixPosition(camera.matrixWorld);
        v2.setFromMatrixPosition(this.matrixWorld);
        var distance = v1.distanceTo(v2);
        levels[0].object.visible = true;
        for (var i = 1, l = levels.length; i < l; i++) {
            if (distance >= levels[i].distance) {
                levels[i - 1].object.visible = false;
                levels[i].object.visible = true;
            } else {
                break;
            }
        }
        for (; i < l; i++) {
            levels[i].object.visible = false;
        }
    }
};}), $__.fs.J$__v494107025_1842_1023)(0, true, $__.uid),
        'toJSON': ($__.fs.J$__v494107025_1844_1025 = function J$__v494107025_1844(meta) {
var vvv_return, vvv_switch, data, levels, level;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
meta = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
data = Object3D.prototype.toJSON.call(this, meta);
data.object.levels = [];
levels = this.levels;
for (var i = 0, l = levels.length; i < l; i++) {
    level = levels[i];
    data.object.levels.push({
        object: level.object.uuid,
        distance: level.distance
    });
}
return data;})
    });
    DataTexture.prototype = Object['create']((Texture.prototype, $__.os.oid5));
    TAJS_restrictToType(DataTexture.prototype, 'object').constructor = DataTexture;
    TAJS_restrictToType(DataTexture.prototype, 'object').isDataTexture = true;
    Object['assign'](TAJS_restrictToType(Skeleton.prototype, 'object'), $__.os.oid439 = {
        'calculateInverses': ($__.fs.J$__v494107025_1848_1026 = function J$__v494107025_1848() {
var vvv_return, vvv_switch, inverse;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.boneInverses = [];
for (var b = 0, bl = this.bones.length; b < bl; b++) {
    inverse = new Matrix4();
    if (this.bones[b]) {
        inverse.getInverse(this.bones[b].matrixWorld);
    }
    this.boneInverses.push(inverse);
}}),
        'pose': ($__.fs.J$__v494107025_1850_1027 = function J$__v494107025_1850() {
var vvv_return, vvv_switch, bone;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
for (var b = 0, bl = this.bones.length; b < bl; b++) {
    bone = this.bones[b];
    if (bone) {
        bone.matrixWorld.getInverse(this.boneInverses[b]);
    }
}
for (var b = 0, bl = this.bones.length; b < bl; b++) {
    bone = this.bones[b];
    if (bone) {
        if (bone.parent && bone.parent.isBone) {
            bone.matrix.getInverse(bone.parent.matrixWorld);
            bone.matrix.multiply(bone.matrixWorld);
        } else {
            bone.matrix.copy(bone.matrixWorld);
        }
        bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);
    }
}}),
        'update': (($__.fs.J$__v494107025_1853_1028 = function J$__v494107025_1853() {
var vvv_return, vvv_switch, offsetMatrix;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    offsetMatrix = new (Matrix4, $__.fs.Matrix4_9)(4, true, $__.uid);
    return ($__.fs.update_1029 = function update() {
var vvv_return, vvv_switch, matrix;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
for (var b = 0, bl = this.bones.length; b < bl; b++) {
    matrix = this.bones[b] ? this.bones[b].matrixWorld : this.identityMatrix;
    offsetMatrix.multiplyMatrices(matrix, this.boneInverses[b]);
    offsetMatrix.toArray(this.boneMatrices, b * 16);
}
if (this.useVertexTexture) {
    this.boneTexture.needsUpdate = true;
}});
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
offsetMatrix = new Matrix4();
return function update() {
    for (var b = 0, bl = this.bones.length; b < bl; b++) {
        var matrix = this.bones[b] ? this.bones[b].matrixWorld : this.identityMatrix;
        offsetMatrix.multiplyMatrices(matrix, this.boneInverses[b]);
        offsetMatrix.toArray(this.boneMatrices, b * 16);
    }
    if (this.useVertexTexture) {
        this.boneTexture.needsUpdate = true;
    }
};}), $__.fs.J$__v494107025_1853_1028)(0, true, $__.uid),
        'clone': ($__.fs.J$__v494107025_1855_1030 = function J$__v494107025_1855() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return new Skeleton(this.bones, this.boneInverses, this.useVertexTexture);})
    });
    Bone.prototype = Object['assign'](Object['create'](TAJS_restrictToType(Object3D.prototype, 'object')), $__.os.oid440 = {
        'constructor': Bone,
        'isBone': true,
        'copy': ($__.fs.J$__v494107025_1858_1031 = function J$__v494107025_1858(source) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
source = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
Object3D.prototype.copy.call(this, source);
this.skin = source.skin;
return this;})
    });
    SkinnedMesh.prototype = Object['assign'](Object['create'](TAJS_restrictToType(Mesh.prototype, 'object')), $__.os.oid441 = {
        'constructor': SkinnedMesh,
        'isSkinnedMesh': true,
        'bind': ($__.fs.J$__v494107025_1861_1032 = function J$__v494107025_1861(skeleton, bindMatrix) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
skeleton = arguments[0], bindMatrix = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.skeleton = skeleton;
if (bindMatrix === undefined) {
    this.updateMatrixWorld(true);
    this.skeleton.calculateInverses();
    bindMatrix = this.matrixWorld;
}
this.bindMatrix.copy(bindMatrix);
this.bindMatrixInverse.getInverse(bindMatrix);}),
        'pose': ($__.fs.J$__v494107025_1863_1033 = function J$__v494107025_1863() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.skeleton.pose();}),
        'normalizeSkinWeights': ($__.fs.J$__v494107025_1865_1034 = function J$__v494107025_1865() {
var vvv_return, vvv_switch, sw, scale, vec, skinWeight;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (this.geometry && this.geometry.isGeometry) {
    for (var i = 0; i < this.geometry.skinWeights.length; i++) {
        sw = this.geometry.skinWeights[i];
        scale = 1 / sw.lengthManhattan();
        if (scale !== Infinity) {
            sw.multiplyScalar(scale);
        } else {
            sw.set(1, 0, 0, 0);
        }
    }
} else if (this.geometry && this.geometry.isBufferGeometry) {
    vec = new Vector4();
    skinWeight = this.geometry.attributes.skinWeight;
    for (var i = 0; i < skinWeight.count; i++) {
        vec.x = skinWeight.getX(i);
        vec.y = skinWeight.getY(i);
        vec.z = skinWeight.getZ(i);
        vec.w = skinWeight.getW(i);
        scale = 1 / vec.lengthManhattan();
        if (scale !== Infinity) {
            vec.multiplyScalar(scale);
        } else {
            vec.set(1, 0, 0, 0);
        }
        skinWeight.setXYZW(i, vec.x, vec.y, vec.z, vec.w);
    }
}}),
        'updateMatrixWorld': ($__.fs.J$__v494107025_1867_1035 = function J$__v494107025_1867(force) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
force = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
Mesh.prototype.updateMatrixWorld.call(this, true);
if (this.bindMode === 'attached') {
    this.bindMatrixInverse.getInverse(this.matrixWorld);
} else if (this.bindMode === 'detached') {
    this.bindMatrixInverse.getInverse(this.bindMatrix);
} else {
    console.warn('THREE.SkinnedMesh unrecognized bindMode: ' + this.bindMode);
}}),
        'clone': ($__.fs.J$__v494107025_1869_1036 = function J$__v494107025_1869() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return new this.constructor(this.geometry, this.material, this.skeleton.useVertexTexture).copy(this);})
    });
    LineBasicMaterial.prototype = Object['create']((Material.prototype, $__.os.oid16));
    TAJS_restrictToType(LineBasicMaterial.prototype, 'object').constructor = LineBasicMaterial;
    TAJS_restrictToType(LineBasicMaterial.prototype, 'object').isLineBasicMaterial = true;
    TAJS_restrictToType(LineBasicMaterial.prototype, 'object').copy = ($__.fs.J$__v494107025_1872_1037 = function J$__v494107025_1872(source) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
source = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
Material.prototype.copy.call(this, source);
this.color.copy(source.color);
this.linewidth = source.linewidth;
this.linecap = source.linecap;
this.linejoin = source.linejoin;
return this;});
    Line.prototype = Object['assign'](Object['create'](TAJS_restrictToType(Object3D.prototype, 'object')), $__.os.oid442 = {
        'constructor': Line,
        'isLine': true,
        'raycast': (($__.fs.J$__v494107025_1876_1038 = function J$__v494107025_1876() {
var vvv_return, vvv_switch, inverseMatrix, ray, sphere;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    inverseMatrix = new (Matrix4, $__.fs.Matrix4_9)(5, true, $__.uid);
    ray = new (Ray, $__.fs.Ray_111)(1, true, $__.uid);
    sphere = new (Sphere, $__.fs.Sphere_60)(3, true, $__.uid);
    return ($__.fs.raycast_1039 = function raycast(raycaster, intersects) {
var vvv_return, vvv_switch, precision, precisionSq, geometry, matrixWorld, vStart, vEnd, interSegment, interRay, step, index, attributes, positions, indices, a, b, distSq, distance, vertices, nbVertices;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
raycaster = arguments[0], intersects = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
precision = raycaster.linePrecision;
precisionSq = precision * precision;
geometry = this.geometry;
matrixWorld = this.matrixWorld;
if (geometry.boundingSphere === null)
    geometry.computeBoundingSphere();
sphere.copy(geometry.boundingSphere);
sphere.applyMatrix4(matrixWorld);
if (raycaster.ray.intersectsSphere(sphere) === false)
    return;
inverseMatrix.getInverse(matrixWorld);
ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);
vStart = new Vector3();
vEnd = new Vector3();
interSegment = new Vector3();
interRay = new Vector3();
step = this && this.isLineSegments ? 2 : 1;
if (geometry && geometry.isBufferGeometry) {
    index = geometry.index;
    attributes = geometry.attributes;
    positions = attributes.position.array;
    if (index !== null) {
        indices = index.array;
        for (var i = 0, l = indices.length - 1; i < l; i += step) {
            a = indices[i];
            b = indices[i + 1];
            vStart.fromArray(positions, a * 3);
            vEnd.fromArray(positions, b * 3);
            distSq = ray.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
            if (distSq > precisionSq)
                continue;
            interRay.applyMatrix4(this.matrixWorld);
            distance = raycaster.ray.origin.distanceTo(interRay);
            if (distance < raycaster.near || distance > raycaster.far)
                continue;
            intersects.push({
                distance: distance,
                point: interSegment.clone().applyMatrix4(this.matrixWorld),
                index: i,
                face: null,
                faceIndex: null,
                object: this
            });
        }
    } else {
        for (var i = 0, l = positions.length / 3 - 1; i < l; i += step) {
            vStart.fromArray(positions, 3 * i);
            vEnd.fromArray(positions, 3 * i + 3);
            distSq = ray.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
            if (distSq > precisionSq)
                continue;
            interRay.applyMatrix4(this.matrixWorld);
            distance = raycaster.ray.origin.distanceTo(interRay);
            if (distance < raycaster.near || distance > raycaster.far)
                continue;
            intersects.push({
                distance: distance,
                point: interSegment.clone().applyMatrix4(this.matrixWorld),
                index: i,
                face: null,
                faceIndex: null,
                object: this
            });
        }
    }
} else if (geometry && geometry.isGeometry) {
    vertices = geometry.vertices;
    nbVertices = vertices.length;
    for (var i = 0; i < nbVertices - 1; i += step) {
        distSq = ray.distanceSqToSegment(vertices[i], vertices[i + 1], interRay, interSegment);
        if (distSq > precisionSq)
            continue;
        interRay.applyMatrix4(this.matrixWorld);
        distance = raycaster.ray.origin.distanceTo(interRay);
        if (distance < raycaster.near || distance > raycaster.far)
            continue;
        intersects.push({
            distance: distance,
            point: interSegment.clone().applyMatrix4(this.matrixWorld),
            index: i,
            face: null,
            faceIndex: null,
            object: this
        });
    }
}});
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
inverseMatrix = new Matrix4();
ray = new Ray();
sphere = new Sphere();
return function raycast(raycaster, intersects) {
    var precision = raycaster.linePrecision;
    var precisionSq = precision * precision;
    var geometry = this.geometry;
    var matrixWorld = this.matrixWorld;
    if (geometry.boundingSphere === null)
        geometry.computeBoundingSphere();
    sphere.copy(geometry.boundingSphere);
    sphere.applyMatrix4(matrixWorld);
    if (raycaster.ray.intersectsSphere(sphere) === false)
        return;
    inverseMatrix.getInverse(matrixWorld);
    ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);
    var vStart = new Vector3();
    var vEnd = new Vector3();
    var interSegment = new Vector3();
    var interRay = new Vector3();
    var step = this && this.isLineSegments ? 2 : 1;
    if (geometry && geometry.isBufferGeometry) {
        var index = geometry.index;
        var attributes = geometry.attributes;
        var positions = attributes.position.array;
        if (index !== null) {
            var indices = index.array;
            for (var i = 0, l = indices.length - 1; i < l; i += step) {
                var a = indices[i];
                var b = indices[i + 1];
                vStart.fromArray(positions, a * 3);
                vEnd.fromArray(positions, b * 3);
                var distSq = ray.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
                if (distSq > precisionSq)
                    continue;
                interRay.applyMatrix4(this.matrixWorld);
                var distance = raycaster.ray.origin.distanceTo(interRay);
                if (distance < raycaster.near || distance > raycaster.far)
                    continue;
                intersects.push({
                    distance: distance,
                    point: interSegment.clone().applyMatrix4(this.matrixWorld),
                    index: i,
                    face: null,
                    faceIndex: null,
                    object: this
                });
            }
        } else {
            for (var i = 0, l = positions.length / 3 - 1; i < l; i += step) {
                vStart.fromArray(positions, 3 * i);
                vEnd.fromArray(positions, 3 * i + 3);
                var distSq = ray.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
                if (distSq > precisionSq)
                    continue;
                interRay.applyMatrix4(this.matrixWorld);
                var distance = raycaster.ray.origin.distanceTo(interRay);
                if (distance < raycaster.near || distance > raycaster.far)
                    continue;
                intersects.push({
                    distance: distance,
                    point: interSegment.clone().applyMatrix4(this.matrixWorld),
                    index: i,
                    face: null,
                    faceIndex: null,
                    object: this
                });
            }
        }
    } else if (geometry && geometry.isGeometry) {
        var vertices = geometry.vertices;
        var nbVertices = vertices.length;
        for (var i = 0; i < nbVertices - 1; i += step) {
            var distSq = ray.distanceSqToSegment(vertices[i], vertices[i + 1], interRay, interSegment);
            if (distSq > precisionSq)
                continue;
            interRay.applyMatrix4(this.matrixWorld);
            var distance = raycaster.ray.origin.distanceTo(interRay);
            if (distance < raycaster.near || distance > raycaster.far)
                continue;
            intersects.push({
                distance: distance,
                point: interSegment.clone().applyMatrix4(this.matrixWorld),
                index: i,
                face: null,
                faceIndex: null,
                object: this
            });
        }
    }
};}), $__.fs.J$__v494107025_1876_1038)(0, true, $__.uid),
        'clone': ($__.fs.J$__v494107025_1878_1040 = function J$__v494107025_1878() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return new this.constructor(this.geometry, this.material).copy(this);})
    });
    LineSegments.prototype = Object['assign'](Object['create'](TAJS_restrictToType(Line.prototype, 'object')), $__.os.oid443 = {
        'constructor': LineSegments,
        'isLineSegments': true
    });
    PointsMaterial.prototype = Object['create']((Material.prototype, $__.os.oid16));
    TAJS_restrictToType(PointsMaterial.prototype, 'object').constructor = PointsMaterial;
    TAJS_restrictToType(PointsMaterial.prototype, 'object').isPointsMaterial = true;
    TAJS_restrictToType(PointsMaterial.prototype, 'object').copy = ($__.fs.J$__v494107025_1882_1041 = function J$__v494107025_1882(source) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
source = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
Material.prototype.copy.call(this, source);
this.color.copy(source.color);
this.map = source.map;
this.size = source.size;
this.sizeAttenuation = source.sizeAttenuation;
return this;});
    Points.prototype = Object['assign'](Object['create'](TAJS_restrictToType(Object3D.prototype, 'object')), $__.os.oid444 = {
        'constructor': Points,
        'isPoints': true,
        'raycast': (($__.fs.J$__v494107025_1887_1042 = function J$__v494107025_1887() {
var vvv_return, vvv_switch, inverseMatrix, ray, sphere;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    inverseMatrix = new (Matrix4, $__.fs.Matrix4_9)(6, true, $__.uid);
    ray = new (Ray, $__.fs.Ray_111)(2, true, $__.uid);
    sphere = new (Sphere, $__.fs.Sphere_60)(4, true, $__.uid);
    return ($__.fs.raycast_1043 = function raycast(raycaster, intersects) {
var vvv_return, vvv_switch, object, geometry, matrixWorld, threshold, localThreshold, localThresholdSq, position, testPoint, index, attributes, positions, indices, a, vertices;
testPoint = function testPoint(point, index) {
    var rayPointDistanceSq = ray.distanceSqToPoint(point);
    if (rayPointDistanceSq < localThresholdSq) {
        var intersectPoint = ray.closestPointToPoint(point);
        intersectPoint.applyMatrix4(matrixWorld);
        var distance = raycaster.ray.origin.distanceTo(intersectPoint);
        if (distance < raycaster.near || distance > raycaster.far)
            return;
        intersects.push({
            distance: distance,
            distanceToRay: Math.sqrt(rayPointDistanceSq),
            point: intersectPoint.clone(),
            index: index,
            face: null,
            object: object
        });
    }
};
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
raycaster = arguments[0], intersects = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
object = this;
geometry = this.geometry;
matrixWorld = this.matrixWorld;
threshold = raycaster.params.Points.threshold;
if (geometry.boundingSphere === null)
    geometry.computeBoundingSphere();
sphere.copy(geometry.boundingSphere);
sphere.applyMatrix4(matrixWorld);
if (raycaster.ray.intersectsSphere(sphere) === false)
    return;
inverseMatrix.getInverse(matrixWorld);
ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);
localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
localThresholdSq = localThreshold * localThreshold;
position = new Vector3();
if (geometry && geometry.isBufferGeometry) {
    index = geometry.index;
    attributes = geometry.attributes;
    positions = attributes.position.array;
    if (index !== null) {
        indices = index.array;
        for (var i = 0, il = indices.length; i < il; i++) {
            a = indices[i];
            position.fromArray(positions, a * 3);
            testPoint(position, a);
        }
    } else {
        for (var i = 0, l = positions.length / 3; i < l; i++) {
            position.fromArray(positions, i * 3);
            testPoint(position, i);
        }
    }
} else {
    vertices = geometry.vertices;
    for (var i = 0, l = vertices.length; i < l; i++) {
        testPoint(vertices[i], i);
    }
}});
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
inverseMatrix = new Matrix4();
ray = new Ray();
sphere = new Sphere();
return function raycast(raycaster, intersects) {
    var object = this;
    var geometry = this.geometry;
    var matrixWorld = this.matrixWorld;
    var threshold = raycaster.params.Points.threshold;
    if (geometry.boundingSphere === null)
        geometry.computeBoundingSphere();
    sphere.copy(geometry.boundingSphere);
    sphere.applyMatrix4(matrixWorld);
    if (raycaster.ray.intersectsSphere(sphere) === false)
        return;
    inverseMatrix.getInverse(matrixWorld);
    ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);
    var localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
    var localThresholdSq = localThreshold * localThreshold;
    var position = new Vector3();
    function testPoint(point, index) {
        var rayPointDistanceSq = ray.distanceSqToPoint(point);
        if (rayPointDistanceSq < localThresholdSq) {
            var intersectPoint = ray.closestPointToPoint(point);
            intersectPoint.applyMatrix4(matrixWorld);
            var distance = raycaster.ray.origin.distanceTo(intersectPoint);
            if (distance < raycaster.near || distance > raycaster.far)
                return;
            intersects.push({
                distance: distance,
                distanceToRay: Math.sqrt(rayPointDistanceSq),
                point: intersectPoint.clone(),
                index: index,
                face: null,
                object: object
            });
        }
    }
    if (geometry && geometry.isBufferGeometry) {
        var index = geometry.index;
        var attributes = geometry.attributes;
        var positions = attributes.position.array;
        if (index !== null) {
            var indices = index.array;
            for (var i = 0, il = indices.length; i < il; i++) {
                var a = indices[i];
                position.fromArray(positions, a * 3);
                testPoint(position, a);
            }
        } else {
            for (var i = 0, l = positions.length / 3; i < l; i++) {
                position.fromArray(positions, i * 3);
                testPoint(position, i);
            }
        }
    } else {
        var vertices = geometry.vertices;
        for (var i = 0, l = vertices.length; i < l; i++) {
            testPoint(vertices[i], i);
        }
    }
};}), $__.fs.J$__v494107025_1887_1042)(0, true, $__.uid),
        'clone': ($__.fs.J$__v494107025_1889_1044 = function J$__v494107025_1889() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return new this.constructor(this.geometry, this.material).copy(this);})
    });
    Group.prototype = Object['assign'](Object['create'](TAJS_restrictToType(Object3D.prototype, 'object')), $__.os.oid445 = {
        'constructor': Group
    });
    VideoTexture.prototype = Object['create']((Texture.prototype, $__.os.oid5));
    TAJS_restrictToType(VideoTexture.prototype, 'object').constructor = VideoTexture;
    CompressedTexture.prototype = Object['create']((Texture.prototype, $__.os.oid5));
    TAJS_restrictToType(CompressedTexture.prototype, 'object').constructor = CompressedTexture;
    TAJS_restrictToType(CompressedTexture.prototype, 'object').isCompressedTexture = true;
    CanvasTexture.prototype = Object['create']((Texture.prototype, $__.os.oid5));
    TAJS_restrictToType(CanvasTexture.prototype, 'object').constructor = CanvasTexture;
    DepthTexture.prototype = Object['create']((Texture.prototype, $__.os.oid5));
    TAJS_restrictToType(DepthTexture.prototype, 'object').constructor = DepthTexture;
    TAJS_restrictToType(DepthTexture.prototype, 'object').isDepthTexture = true;
    ShadowMaterial.prototype = Object['create'](TAJS_restrictToType(ShaderMaterial.prototype, 'object'));
    TAJS_restrictToType(ShadowMaterial.prototype, 'object').constructor = ShadowMaterial;
    TAJS_restrictToType(ShadowMaterial.prototype, 'object').isShadowMaterial = true;
    RawShaderMaterial.prototype = Object['create'](TAJS_restrictToType(ShaderMaterial.prototype, 'object'));
    TAJS_restrictToType(RawShaderMaterial.prototype, 'object').constructor = RawShaderMaterial;
    TAJS_restrictToType(RawShaderMaterial.prototype, 'object').isRawShaderMaterial = true;
    MultiMaterial.prototype = $__.os.oid446 = {
        'constructor': MultiMaterial,
        'isMultiMaterial': true,
        'toJSON': ($__.fs.J$__v494107025_1904_1045 = function J$__v494107025_1904(meta) {
var vvv_return, vvv_switch, output, materials, material;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
meta = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
output = {
    metadata: {
        version: 4.2,
        type: 'material',
        generator: 'MaterialExporter'
    },
    uuid: this.uuid,
    type: this.type,
    materials: []
};
materials = this.materials;
for (var i = 0, l = materials.length; i < l; i++) {
    material = materials[i].toJSON(meta);
    delete material.metadata;
    output.materials.push(material);
}
output.visible = this.visible;
return output;}),
        'clone': ($__.fs.J$__v494107025_1906_1046 = function J$__v494107025_1906() {
var vvv_return, vvv_switch, material;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
material = new this.constructor();
for (var i = 0; i < this.materials.length; i++) {
    material.materials.push(this.materials[i].clone());
}
material.visible = this.visible;
return material;})
    };
    MeshStandardMaterial.prototype = Object['create']((Material.prototype, $__.os.oid16));
    TAJS_restrictToType(MeshStandardMaterial.prototype, 'object').constructor = MeshStandardMaterial;
    TAJS_restrictToType(MeshStandardMaterial.prototype, 'object').isMeshStandardMaterial = true;
    TAJS_restrictToType(MeshStandardMaterial.prototype, 'object').copy = ($__.fs.J$__v494107025_1909_1047 = function J$__v494107025_1909(source) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
source = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
Material.prototype.copy.call(this, source);
this.defines = {
    'STANDARD': ''
};
this.color.copy(source.color);
this.roughness = source.roughness;
this.metalness = source.metalness;
this.map = source.map;
this.lightMap = source.lightMap;
this.lightMapIntensity = source.lightMapIntensity;
this.aoMap = source.aoMap;
this.aoMapIntensity = source.aoMapIntensity;
this.emissive.copy(source.emissive);
this.emissiveMap = source.emissiveMap;
this.emissiveIntensity = source.emissiveIntensity;
this.bumpMap = source.bumpMap;
this.bumpScale = source.bumpScale;
this.normalMap = source.normalMap;
this.normalScale.copy(source.normalScale);
this.displacementMap = source.displacementMap;
this.displacementScale = source.displacementScale;
this.displacementBias = source.displacementBias;
this.roughnessMap = source.roughnessMap;
this.metalnessMap = source.metalnessMap;
this.alphaMap = source.alphaMap;
this.envMap = source.envMap;
this.envMapIntensity = source.envMapIntensity;
this.refractionRatio = source.refractionRatio;
this.wireframe = source.wireframe;
this.wireframeLinewidth = source.wireframeLinewidth;
this.wireframeLinecap = source.wireframeLinecap;
this.wireframeLinejoin = source.wireframeLinejoin;
this.skinning = source.skinning;
this.morphTargets = source.morphTargets;
this.morphNormals = source.morphNormals;
return this;});
    MeshPhysicalMaterial.prototype = Object['create'](TAJS_restrictToType(MeshStandardMaterial.prototype, 'object'));
    TAJS_restrictToType(MeshPhysicalMaterial.prototype, 'object').constructor = MeshPhysicalMaterial;
    TAJS_restrictToType(MeshPhysicalMaterial.prototype, 'object').isMeshPhysicalMaterial = true;
    TAJS_restrictToType(MeshPhysicalMaterial.prototype, 'object').copy = ($__.fs.J$__v494107025_1912_1048 = function J$__v494107025_1912(source) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
source = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
MeshStandardMaterial.prototype.copy.call(this, source);
this.defines = {
    'PHYSICAL': ''
};
this.reflectivity = source.reflectivity;
this.clearCoat = source.clearCoat;
this.clearCoatRoughness = source.clearCoatRoughness;
return this;});
    MeshPhongMaterial.prototype = Object['create']((Material.prototype, $__.os.oid16));
    TAJS_restrictToType(MeshPhongMaterial.prototype, 'object').constructor = MeshPhongMaterial;
    TAJS_restrictToType(MeshPhongMaterial.prototype, 'object').isMeshPhongMaterial = true;
    TAJS_restrictToType(MeshPhongMaterial.prototype, 'object').copy = ($__.fs.J$__v494107025_1915_1049 = function J$__v494107025_1915(source) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
source = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
Material.prototype.copy.call(this, source);
this.color.copy(source.color);
this.specular.copy(source.specular);
this.shininess = source.shininess;
this.map = source.map;
this.lightMap = source.lightMap;
this.lightMapIntensity = source.lightMapIntensity;
this.aoMap = source.aoMap;
this.aoMapIntensity = source.aoMapIntensity;
this.emissive.copy(source.emissive);
this.emissiveMap = source.emissiveMap;
this.emissiveIntensity = source.emissiveIntensity;
this.bumpMap = source.bumpMap;
this.bumpScale = source.bumpScale;
this.normalMap = source.normalMap;
this.normalScale.copy(source.normalScale);
this.displacementMap = source.displacementMap;
this.displacementScale = source.displacementScale;
this.displacementBias = source.displacementBias;
this.specularMap = source.specularMap;
this.alphaMap = source.alphaMap;
this.envMap = source.envMap;
this.combine = source.combine;
this.reflectivity = source.reflectivity;
this.refractionRatio = source.refractionRatio;
this.wireframe = source.wireframe;
this.wireframeLinewidth = source.wireframeLinewidth;
this.wireframeLinecap = source.wireframeLinecap;
this.wireframeLinejoin = source.wireframeLinejoin;
this.skinning = source.skinning;
this.morphTargets = source.morphTargets;
this.morphNormals = source.morphNormals;
return this;});
    MeshNormalMaterial.prototype = Object['create']((Material.prototype, $__.os.oid16));
    TAJS_restrictToType(MeshNormalMaterial.prototype, 'object').constructor = MeshNormalMaterial;
    TAJS_restrictToType(MeshNormalMaterial.prototype, 'object').isMeshNormalMaterial = true;
    TAJS_restrictToType(MeshNormalMaterial.prototype, 'object').copy = ($__.fs.J$__v494107025_1918_1050 = function J$__v494107025_1918(source) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
source = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
Material.prototype.copy.call(this, source);
this.wireframe = source.wireframe;
this.wireframeLinewidth = source.wireframeLinewidth;
return this;});
    MeshLambertMaterial.prototype = Object['create']((Material.prototype, $__.os.oid16));
    TAJS_restrictToType(MeshLambertMaterial.prototype, 'object').constructor = MeshLambertMaterial;
    TAJS_restrictToType(MeshLambertMaterial.prototype, 'object').isMeshLambertMaterial = true;
    TAJS_restrictToType(MeshLambertMaterial.prototype, 'object').copy = ($__.fs.J$__v494107025_1921_1051 = function J$__v494107025_1921(source) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
source = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
Material.prototype.copy.call(this, source);
this.color.copy(source.color);
this.map = source.map;
this.lightMap = source.lightMap;
this.lightMapIntensity = source.lightMapIntensity;
this.aoMap = source.aoMap;
this.aoMapIntensity = source.aoMapIntensity;
this.emissive.copy(source.emissive);
this.emissiveMap = source.emissiveMap;
this.emissiveIntensity = source.emissiveIntensity;
this.specularMap = source.specularMap;
this.alphaMap = source.alphaMap;
this.envMap = source.envMap;
this.combine = source.combine;
this.reflectivity = source.reflectivity;
this.refractionRatio = source.refractionRatio;
this.wireframe = source.wireframe;
this.wireframeLinewidth = source.wireframeLinewidth;
this.wireframeLinecap = source.wireframeLinecap;
this.wireframeLinejoin = source.wireframeLinejoin;
this.skinning = source.skinning;
this.morphTargets = source.morphTargets;
this.morphNormals = source.morphNormals;
return this;});
    LineDashedMaterial.prototype = Object['create']((Material.prototype, $__.os.oid16));
    TAJS_restrictToType(LineDashedMaterial.prototype, 'object').constructor = LineDashedMaterial;
    TAJS_restrictToType(LineDashedMaterial.prototype, 'object').isLineDashedMaterial = true;
    TAJS_restrictToType(LineDashedMaterial.prototype, 'object').copy = ($__.fs.J$__v494107025_1924_1052 = function J$__v494107025_1924(source) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
source = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
Material.prototype.copy.call(this, source);
this.color.copy(source.color);
this.linewidth = source.linewidth;
this.scale = source.scale;
this.dashSize = source.dashSize;
this.gapSize = source.gapSize;
return this;});
    (exports, $__.os.oid0).Cache = $__.os.oid448 = {
        'enabled': false,
        'files': $__.os.oid447 = {},
        'add': ($__.fs.J$__v494107025_1926_1053 = function J$__v494107025_1926(key, file) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
key = arguments[0], file = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (this.enabled === false)
    return;
this.files[key] = file;}),
        'get': ($__.fs.J$__v494107025_1928_1054 = function J$__v494107025_1928(key) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
key = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (this.enabled === false)
    return;
return this.files[key];}),
        'remove': ($__.fs.J$__v494107025_1930_1055 = function J$__v494107025_1930(key) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
key = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
delete this.files[key];}),
        'clear': ($__.fs.J$__v494107025_1932_1056 = function J$__v494107025_1932() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.files = {};})
    };
    (exports, $__.os.oid0).DefaultLoadingManager = new (LoadingManager, $__.fs.LoadingManager_151)(0, true, $__.uid);
    Object['assign'](TAJS_restrictToType(XHRLoader.prototype, 'object'), $__.os.oid449 = {
        'load': ($__.fs.J$__v494107025_1950_1060 = function J$__v494107025_1950(url, onLoad, onProgress, onError) {
var vvv_return, vvv_switch, scope, cached, request;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
url = arguments[0], onLoad = arguments[1], onProgress = arguments[2], onError = arguments[3];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (this.path !== undefined)
    url = this.path + url;
scope = this;
cached = exports.Cache.get(url);
if (cached !== undefined) {
    scope.manager.itemStart(url);
    setTimeout(function () {
        if (onLoad)
            onLoad(cached);
        scope.manager.itemEnd(url);
    }, 0);
    return cached;
}
request = new XMLHttpRequest();
request.open('GET', url, true);
request.addEventListener('load', function (event) {
    var response = event.target.response;
    exports.Cache.add(url, response);
    if (this.status === 200) {
        if (onLoad)
            onLoad(response);
        scope.manager.itemEnd(url);
    } else if (this.status === 0) {
        console.warn('THREE.XHRLoader: HTTP Status 0 received.');
        if (onLoad)
            onLoad(response);
        scope.manager.itemEnd(url);
    } else {
        if (onError)
            onError(event);
        scope.manager.itemError(url);
    }
}, false);
if (onProgress !== undefined) {
    request.addEventListener('progress', function (event) {
        onProgress(event);
    }, false);
}
request.addEventListener('error', function (event) {
    if (onError)
        onError(event);
    scope.manager.itemError(url);
}, false);
if (this.responseType !== undefined)
    request.responseType = this.responseType;
if (this.withCredentials !== undefined)
    request.withCredentials = this.withCredentials;
if (request.overrideMimeType)
    request.overrideMimeType('text/plain');
request.send(null);
scope.manager.itemStart(url);
return request;}),
        'setPath': ($__.fs.J$__v494107025_1952_1061 = function J$__v494107025_1952(value) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
value = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.path = value;
return this;}),
        'setResponseType': ($__.fs.J$__v494107025_1954_1062 = function J$__v494107025_1954(value) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
value = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.responseType = value;
return this;}),
        'setWithCredentials': ($__.fs.J$__v494107025_1956_1063 = function J$__v494107025_1956(value) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
value = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.withCredentials = value;
return this;})
    });
    Object['assign'](TAJS_restrictToType(CompressedTextureLoader.prototype, 'object'), $__.os.oid450 = {
        'load': ($__.fs.J$__v494107025_1964_1064 = function J$__v494107025_1964(url, onLoad, onProgress, onError) {
var vvv_return, vvv_switch, scope, images, texture, loader, loadTexture, loaded;
loadTexture = function loadTexture(i) {
    loader.load(url[i], function (buffer) {
        var texDatas = scope._parser(buffer, true);
        images[i] = {
            width: texDatas.width,
            height: texDatas.height,
            format: texDatas.format,
            mipmaps: texDatas.mipmaps
        };
        loaded += 1;
        if (loaded === 6) {
            if (texDatas.mipmapCount === 1)
                texture.minFilter = LinearFilter;
            texture.format = texDatas.format;
            texture.needsUpdate = true;
            if (onLoad)
                onLoad(texture);
        }
    }, onProgress, onError);
};
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
url = arguments[0], onLoad = arguments[1], onProgress = arguments[2], onError = arguments[3];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
scope = this;
images = [];
texture = new CompressedTexture();
texture.image = images;
loader = new XHRLoader(this.manager);
loader.setPath(this.path);
loader.setResponseType('arraybuffer');
if (Array.isArray(url)) {
    loaded = 0;
    for (var i = 0, il = url.length; i < il; ++i) {
        loadTexture(i);
    }
} else {
    loader.load(url, function (buffer) {
        var texDatas = scope._parser(buffer, true);
        if (texDatas.isCubemap) {
            var faces = texDatas.mipmaps.length / texDatas.mipmapCount;
            for (var f = 0; f < faces; f++) {
                images[f] = {
                    mipmaps: []
                };
                for (var i = 0; i < texDatas.mipmapCount; i++) {
                    images[f].mipmaps.push(texDatas.mipmaps[f * texDatas.mipmapCount + i]);
                    images[f].format = texDatas.format;
                    images[f].width = texDatas.width;
                    images[f].height = texDatas.height;
                }
            }
        } else {
            texture.image.width = texDatas.width;
            texture.image.height = texDatas.height;
            texture.mipmaps = texDatas.mipmaps;
        }
        if (texDatas.mipmapCount === 1) {
            texture.minFilter = LinearFilter;
        }
        texture.format = texDatas.format;
        texture.needsUpdate = true;
        if (onLoad)
            onLoad(texture);
    }, onProgress, onError);
}
return texture;}),
        'setPath': ($__.fs.J$__v494107025_1966_1065 = function J$__v494107025_1966(value) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
value = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.path = value;
return this;})
    });
    DataTextureLoader = BinaryTextureLoader;
    Object['assign'](TAJS_restrictToType(BinaryTextureLoader.prototype, 'object'), $__.os.oid451 = {
        'load': ($__.fs.J$__v494107025_1971_1066 = function J$__v494107025_1971(url, onLoad, onProgress, onError) {
var vvv_return, vvv_switch, scope, texture, loader;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
url = arguments[0], onLoad = arguments[1], onProgress = arguments[2], onError = arguments[3];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
scope = this;
texture = new DataTexture();
loader = new XHRLoader(this.manager);
loader.setResponseType('arraybuffer');
loader.load(url, function (buffer) {
    var texData = scope._parser(buffer);
    if (!texData)
        return;
    if (undefined !== texData.image) {
        texture.image = texData.image;
    } else if (undefined !== texData.data) {
        texture.image.width = texData.width;
        texture.image.height = texData.height;
        texture.image.data = texData.data;
    }
    texture.wrapS = undefined !== texData.wrapS ? texData.wrapS : ClampToEdgeWrapping;
    texture.wrapT = undefined !== texData.wrapT ? texData.wrapT : ClampToEdgeWrapping;
    texture.magFilter = undefined !== texData.magFilter ? texData.magFilter : LinearFilter;
    texture.minFilter = undefined !== texData.minFilter ? texData.minFilter : LinearMipMapLinearFilter;
    texture.anisotropy = undefined !== texData.anisotropy ? texData.anisotropy : 1;
    if (undefined !== texData.format) {
        texture.format = texData.format;
    }
    if (undefined !== texData.type) {
        texture.type = texData.type;
    }
    if (undefined !== texData.mipmaps) {
        texture.mipmaps = texData.mipmaps;
    }
    if (1 === texData.mipmapCount) {
        texture.minFilter = LinearFilter;
    }
    texture.needsUpdate = true;
    if (onLoad)
        onLoad(texture, texData);
}, onProgress, onError);
return texture;})
    });
    Object['assign'](TAJS_restrictToType(ImageLoader.prototype, 'object'), $__.os.oid452 = {
        'load': ($__.fs.J$__v494107025_1978_1067 = function J$__v494107025_1978(url, onLoad, onProgress, onError) {
var vvv_return, vvv_switch, scope, image, loader;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
url = arguments[0], onLoad = arguments[1], onProgress = arguments[2], onError = arguments[3];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
scope = this;
image = document.createElementNS('http://www.w3.org/1999/xhtml', 'img');
image.onload = function () {
    URL.revokeObjectURL(image.src);
    if (onLoad)
        onLoad(image);
    scope.manager.itemEnd(url);
};
if (url.indexOf('data:') === 0) {
    image.src = url;
} else {
    loader = new XHRLoader();
    loader.setPath(this.path);
    loader.setResponseType('blob');
    loader.setWithCredentials(this.withCredentials);
    loader.load(url, function (blob) {
        image.src = URL.createObjectURL(blob);
    }, onProgress, onError);
}
scope.manager.itemStart(url);
return image;}),
        'setCrossOrigin': ($__.fs.J$__v494107025_1980_1068 = function J$__v494107025_1980(value) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
value = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.crossOrigin = value;
return this;}),
        'setWithCredentials': ($__.fs.J$__v494107025_1982_1069 = function J$__v494107025_1982(value) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
value = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.withCredentials = value;
return this;}),
        'setPath': ($__.fs.J$__v494107025_1984_1070 = function J$__v494107025_1984(value) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
value = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.path = value;
return this;})
    });
    Object['assign'](TAJS_restrictToType(CubeTextureLoader.prototype, 'object'), $__.os.oid453 = {
        'load': ($__.fs.J$__v494107025_1990_1071 = function J$__v494107025_1990(urls, onLoad, onProgress, onError) {
var vvv_return, vvv_switch, texture, loader, loaded, loadTexture;
loadTexture = function loadTexture(i) {
    loader.load(urls[i], function (image) {
        texture.images[i] = image;
        loaded++;
        if (loaded === 6) {
            texture.needsUpdate = true;
            if (onLoad)
                onLoad(texture);
        }
    }, undefined, onError);
};
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
urls = arguments[0], onLoad = arguments[1], onProgress = arguments[2], onError = arguments[3];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
texture = new CubeTexture();
loader = new ImageLoader(this.manager);
loader.setCrossOrigin(this.crossOrigin);
loader.setPath(this.path);
loaded = 0;
for (var i = 0; i < urls.length; ++i) {
    loadTexture(i);
}
return texture;}),
        'setCrossOrigin': ($__.fs.J$__v494107025_1992_1072 = function J$__v494107025_1992(value) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
value = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.crossOrigin = value;
return this;}),
        'setPath': ($__.fs.J$__v494107025_1994_1073 = function J$__v494107025_1994(value) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
value = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.path = value;
return this;})
    });
    Object['assign'](TAJS_restrictToType(TextureLoader.prototype, 'object'), $__.os.oid454 = {
        'load': ($__.fs.J$__v494107025_1999_1074 = function J$__v494107025_1999(url, onLoad, onProgress, onError) {
var vvv_return, vvv_switch, texture, loader;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
url = arguments[0], onLoad = arguments[1], onProgress = arguments[2], onError = arguments[3];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
texture = new Texture();
loader = new ImageLoader(this.manager);
loader.setCrossOrigin(this.crossOrigin);
loader.setWithCredentials(this.withCredentials);
loader.setPath(this.path);
loader.load(url, function (image) {
    var isJPEG = url.search(/\.(jpg|jpeg)$/) > 0 || url.search(/^data\:image\/jpeg/) === 0;
    texture.format = isJPEG ? RGBFormat : RGBAFormat;
    texture.image = image;
    texture.needsUpdate = true;
    if (onLoad !== undefined) {
        onLoad(texture);
    }
}, onProgress, onError);
return texture;}),
        'setCrossOrigin': ($__.fs.J$__v494107025_2001_1075 = function J$__v494107025_2001(value) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
value = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.crossOrigin = value;
return this;}),
        'setWithCredentials': ($__.fs.J$__v494107025_2003_1076 = function J$__v494107025_2003(value) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
value = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.withCredentials = value;
return this;}),
        'setPath': ($__.fs.J$__v494107025_2005_1077 = function J$__v494107025_2005(value) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
value = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.path = value;
return this;})
    });
    Light.prototype = Object['assign'](Object['create'](TAJS_restrictToType(Object3D.prototype, 'object')), $__.os.oid455 = {
        'constructor': Light,
        'isLight': true,
        'copy': ($__.fs.J$__v494107025_2008_1078 = function J$__v494107025_2008(source) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
source = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
Object3D.prototype.copy.call(this, source);
this.color.copy(source.color);
this.intensity = source.intensity;
return this;}),
        'toJSON': ($__.fs.J$__v494107025_2010_1079 = function J$__v494107025_2010(meta) {
var vvv_return, vvv_switch, data;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
meta = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
data = Object3D.prototype.toJSON.call(this, meta);
data.object.color = this.color.getHex();
data.object.intensity = this.intensity;
if (this.groundColor !== undefined)
    data.object.groundColor = this.groundColor.getHex();
if (this.distance !== undefined)
    data.object.distance = this.distance;
if (this.angle !== undefined)
    data.object.angle = this.angle;
if (this.decay !== undefined)
    data.object.decay = this.decay;
if (this.penumbra !== undefined)
    data.object.penumbra = this.penumbra;
if (this.shadow !== undefined)
    data.object.shadow = this.shadow.toJSON();
return data;})
    });
    HemisphereLight.prototype = Object['assign'](Object['create'](TAJS_restrictToType(Light.prototype, 'object')), $__.os.oid456 = {
        'constructor': HemisphereLight,
        'isHemisphereLight': true,
        'copy': ($__.fs.J$__v494107025_2013_1080 = function J$__v494107025_2013(source) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
source = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
Light.prototype.copy.call(this, source);
this.groundColor.copy(source.groundColor);
return this;})
    });
    Object['assign'](TAJS_restrictToType(LightShadow.prototype, 'object'), $__.os.oid457 = {
        'copy': ($__.fs.J$__v494107025_2016_1081 = function J$__v494107025_2016(source) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
source = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.camera = source.camera.clone();
this.bias = source.bias;
this.radius = source.radius;
this.mapSize.copy(source.mapSize);
return this;}),
        'clone': ($__.fs.J$__v494107025_2018_1082 = function J$__v494107025_2018() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return new this.constructor().copy(this);}),
        'toJSON': ($__.fs.J$__v494107025_2020_1083 = function J$__v494107025_2020() {
var vvv_return, vvv_switch, object;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
object = {};
if (this.bias !== 0)
    object.bias = this.bias;
if (this.radius !== 1)
    object.radius = this.radius;
if (this.mapSize.x !== 512 || this.mapSize.y !== 512)
    object.mapSize = this.mapSize.toArray();
object.camera = this.camera.toJSON(false).object;
delete object.camera.matrix;
return object;})
    });
    SpotLightShadow.prototype = Object['assign'](Object['create'](TAJS_restrictToType(LightShadow.prototype, 'object')), $__.os.oid458 = {
        'constructor': SpotLightShadow,
        'isSpotLightShadow': true,
        'update': ($__.fs.J$__v494107025_2023_1084 = function J$__v494107025_2023(light) {
var vvv_return, vvv_switch, fov, aspect, far, camera;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
light = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
fov = exports.Math.RAD2DEG * 2 * light.angle;
aspect = this.mapSize.width / this.mapSize.height;
far = light.distance || 500;
camera = this.camera;
if (fov !== camera.fov || aspect !== camera.aspect || far !== camera.far) {
    camera.fov = fov;
    camera.aspect = aspect;
    camera.far = far;
    camera.updateProjectionMatrix();
}})
    });
    SpotLight.prototype = Object['assign'](Object['create'](TAJS_restrictToType(Light.prototype, 'object')), $__.os.oid459 = {
        'constructor': SpotLight,
        'isSpotLight': true,
        'copy': ($__.fs.J$__v494107025_2030_1085 = function J$__v494107025_2030(source) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
source = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
Light.prototype.copy.call(this, source);
this.distance = source.distance;
this.angle = source.angle;
this.penumbra = source.penumbra;
this.decay = source.decay;
this.target = source.target.clone();
this.shadow = source.shadow.clone();
return this;})
    });
    PointLight.prototype = Object['assign'](Object['create'](TAJS_restrictToType(Light.prototype, 'object')), $__.os.oid460 = {
        'constructor': PointLight,
        'isPointLight': true,
        'copy': ($__.fs.J$__v494107025_2037_1086 = function J$__v494107025_2037(source) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
source = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
Light.prototype.copy.call(this, source);
this.distance = source.distance;
this.decay = source.decay;
this.shadow = source.shadow.clone();
return this;})
    });
    DirectionalLightShadow.prototype = Object['assign'](Object['create'](TAJS_restrictToType(LightShadow.prototype, 'object')), $__.os.oid461 = {
        'constructor': DirectionalLightShadow
    });
    DirectionalLight.prototype = Object['assign'](Object['create'](TAJS_restrictToType(Light.prototype, 'object')), $__.os.oid462 = {
        'constructor': DirectionalLight,
        'isDirectionalLight': true,
        'copy': ($__.fs.J$__v494107025_2041_1087 = function J$__v494107025_2041(source) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
source = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
Light.prototype.copy.call(this, source);
this.target = source.target.clone();
this.shadow = source.shadow.clone();
return this;})
    });
    AmbientLight.prototype = Object['assign'](Object['create'](TAJS_restrictToType(Light.prototype, 'object')), $__.os.oid463 = {
        'constructor': AmbientLight,
        'isAmbientLight': true
    });
    (exports, $__.os.oid0).AnimationUtils = $__.os.oid464 = {
        'arraySlice': ($__.fs.J$__v494107025_2044_1088 = function J$__v494107025_2044(array, from, to) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
array = arguments[0], from = arguments[1], to = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (exports.AnimationUtils.isTypedArray(array)) {
    return new array.constructor(array.subarray(from, to));
}
return array.slice(from, to);}),
        'convertArray': ($__.fs.J$__v494107025_2046_1089 = function J$__v494107025_2046(array, type, forceClone) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
array = arguments[0], type = arguments[1], forceClone = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (!array || !forceClone && array.constructor === type)
    return array;
if (typeof type.BYTES_PER_ELEMENT === 'number') {
    return new type(array);
}
return Array.prototype.slice.call(array);}),
        'isTypedArray': ($__.fs.J$__v494107025_2048_1090 = function J$__v494107025_2048(object) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
object = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return ArrayBuffer.isView(object) && !(object instanceof DataView);}),
        'getKeyframeOrder': ($__.fs.J$__v494107025_2051_1091 = function J$__v494107025_2051(times) {
var vvv_return, vvv_switch, compareTime, n, result;
compareTime = function compareTime(i, j) {
    return times[i] - times[j];
};
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
times = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
n = times.length;
result = new Array(n);
for (var i = 0; i !== n; ++i)
    result[i] = i;
result.sort(compareTime);
return result;}),
        'sortedArray': ($__.fs.J$__v494107025_2053_1092 = function J$__v494107025_2053(values, stride, order) {
var vvv_return, vvv_switch, nValues, result, srcOffset;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
values = arguments[0], stride = arguments[1], order = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
nValues = values.length;
result = new values.constructor(nValues);
for (var i = 0, dstOffset = 0; dstOffset !== nValues; ++i) {
    srcOffset = order[i] * stride;
    for (var j = 0; j !== stride; ++j) {
        result[dstOffset++] = values[srcOffset + j];
    }
}
return result;}),
        'flattenJSON': ($__.fs.J$__v494107025_2055_1093 = function J$__v494107025_2055(jsonKeys, times, values, valuePropertyName) {
var vvv_return, vvv_switch, i, key, value;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
jsonKeys = arguments[0], times = arguments[1], values = arguments[2], valuePropertyName = arguments[3];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
i = 1;
key = jsonKeys[0];
while (key !== undefined && key[valuePropertyName] === undefined) {
    key = jsonKeys[i++];
}
if (key === undefined)
    return;
value = key[valuePropertyName];
if (value === undefined)
    return;
if (Array.isArray(value)) {
    do {
        value = key[valuePropertyName];
        if (value !== undefined) {
            times.push(key.time);
            values.push.apply(values, value);
        }
        key = jsonKeys[i++];
    } while (key !== undefined);
} else if (value.toArray !== undefined) {
    do {
        value = key[valuePropertyName];
        if (value !== undefined) {
            times.push(key.time);
            value.toArray(values, values.length);
        }
        key = jsonKeys[i++];
    } while (key !== undefined);
} else {
    do {
        value = key[valuePropertyName];
        if (value !== undefined) {
            times.push(key.time);
            values.push(value);
        }
        key = jsonKeys[i++];
    } while (key !== undefined);
}})
    };
    Interpolant.prototype = $__.os.oid466 = {
        'constructor': Interpolant,
        'evaluate': ($__.fs.J$__v494107025_2058_1094 = function J$__v494107025_2058(t) {
var vvv_return, vvv_switch, pp, i1, t1, t0, right, t1global, mid;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
t = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
pp = this.parameterPositions;
i1 = this._cachedIndex;
t1 = pp[i1];
t0 = pp[i1 - 1];
validate_interval: {
    seek: {
        linear_scan: {
            forward_scan:
                if (!(t < t1)) {
                    for (var giveUpAt = i1 + 2;;) {
                        if (t1 === undefined) {
                            if (t < t0)
                                break forward_scan;
                            i1 = pp.length;
                            this._cachedIndex = i1;
                            return this.afterEnd_(i1 - 1, t, t0);
                        }
                        if (i1 === giveUpAt)
                            break;
                        t0 = t1;
                        t1 = pp[++i1];
                        if (t < t1) {
                            break seek;
                        }
                    }
                    right = pp.length;
                    break linear_scan;
                }
            if (!(t >= t0)) {
                t1global = pp[1];
                if (t < t1global) {
                    i1 = 2;
                    t0 = t1global;
                }
                for (var giveUpAt = i1 - 2;;) {
                    if (t0 === undefined) {
                        this._cachedIndex = 0;
                        return this.beforeStart_(0, t, t1);
                    }
                    if (i1 === giveUpAt)
                        break;
                    t1 = t0;
                    t0 = pp[--i1 - 1];
                    if (t >= t0) {
                        break seek;
                    }
                }
                right = i1;
                i1 = 0;
                break linear_scan;
            }
            break validate_interval;
        }
        while (i1 < right) {
            mid = i1 + right >>> 1;
            if (t < pp[mid]) {
                right = mid;
            } else {
                i1 = mid + 1;
            }
        }
        t1 = pp[i1];
        t0 = pp[i1 - 1];
        if (t0 === undefined) {
            this._cachedIndex = 0;
            return this.beforeStart_(0, t, t1);
        }
        if (t1 === undefined) {
            i1 = pp.length;
            this._cachedIndex = i1;
            return this.afterEnd_(i1 - 1, t0, t);
        }
    }
    this._cachedIndex = i1;
    this.intervalChanged_(i1, t0, t1);
}
return this.interpolate_(i1, t0, t, t1);}),
        'settings': null,
        'DefaultSettings_': $__.os.oid465 = {},
        'getSettings_': ($__.fs.J$__v494107025_2060_1095 = function J$__v494107025_2060() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return this.settings || this.DefaultSettings_;}),
        'copySampleValue_': ($__.fs.J$__v494107025_2062_1096 = function J$__v494107025_2062(index) {
var vvv_return, vvv_switch, result, values, stride, offset;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
index = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
result = this.resultBuffer;
values = this.sampleValues;
stride = this.valueSize;
offset = index * stride;
for (var i = 0; i !== stride; ++i) {
    result[i] = values[offset + i];
}
return result;}),
        'interpolate_': ($__.fs.J$__v494107025_2064_1097 = function J$__v494107025_2064(i1, t0, t, t1) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
i1 = arguments[0], t0 = arguments[1], t = arguments[2], t1 = arguments[3];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
throw new Error('call to abstract method');}),
        'intervalChanged_': ($__.fs.J$__v494107025_2066_1098 = function J$__v494107025_2066(i1, t0, t1) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
i1 = arguments[0], t0 = arguments[1], t1 = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');})
    };
    Object['assign']((Interpolant.prototype, $__.os.oid466), $__.os.oid467 = {
        'beforeStart_': TAJS_restrictToType(((Interpolant.prototype, $__.os.oid466), $__.os.oid466).copySampleValue_, 'function'),
        'afterEnd_': TAJS_restrictToType(((Interpolant.prototype, $__.os.oid466), $__.os.oid466).copySampleValue_, 'function')
    });
    CubicInterpolant.prototype = Object['assign'](Object['create']((Interpolant.prototype, $__.os.oid466)), $__.os.oid469 = {
        'constructor': CubicInterpolant,
        'DefaultSettings_': $__.os.oid468 = {
            'endingStart': ZeroCurvatureEnding,
            'endingEnd': ZeroCurvatureEnding
        },
        'intervalChanged_': ($__.fs.J$__v494107025_2069_1099 = function J$__v494107025_2069(i1, t0, t1) {
var vvv_return, vvv_switch, pp, iPrev, iNext, tPrev, tNext, halfDt, stride;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
i1 = arguments[0], t0 = arguments[1], t1 = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
pp = this.parameterPositions;
iPrev = i1 - 2;
iNext = i1 + 1;
tPrev = pp[iPrev];
tNext = pp[iNext];
if (tPrev === undefined) {
    switch (this.getSettings_().endingStart) {
    case ZeroSlopeEnding:
        iPrev = i1;
        tPrev = 2 * t0 - t1;
        break;
    case WrapAroundEnding:
        iPrev = pp.length - 2;
        tPrev = t0 + pp[iPrev] - pp[iPrev + 1];
        break;
    default:
        iPrev = i1;
        tPrev = t1;
    }
}
if (tNext === undefined) {
    switch (this.getSettings_().endingEnd) {
    case ZeroSlopeEnding:
        iNext = i1;
        tNext = 2 * t1 - t0;
        break;
    case WrapAroundEnding:
        iNext = 1;
        tNext = t1 + pp[1] - pp[0];
        break;
    default:
        iNext = i1 - 1;
        tNext = t0;
    }
}
halfDt = (t1 - t0) * 0.5;
stride = this.valueSize;
this._weightPrev = halfDt / (t0 - tPrev);
this._weightNext = halfDt / (tNext - t1);
this._offsetPrev = iPrev * stride;
this._offsetNext = iNext * stride;}),
        'interpolate_': ($__.fs.J$__v494107025_2071_1100 = function J$__v494107025_2071(i1, t0, t, t1) {
var vvv_return, vvv_switch, result, values, stride, o1, o0, oP, oN, wP, wN, p, pp, ppp, sP, s0, s1, sN;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
i1 = arguments[0], t0 = arguments[1], t = arguments[2], t1 = arguments[3];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
result = this.resultBuffer;
values = this.sampleValues;
stride = this.valueSize;
o1 = i1 * stride;
o0 = o1 - stride;
oP = this._offsetPrev;
oN = this._offsetNext;
wP = this._weightPrev;
wN = this._weightNext;
p = (t - t0) / (t1 - t0);
pp = p * p;
ppp = pp * p;
sP = -wP * ppp + 2 * wP * pp - wP * p;
s0 = (1 + wP) * ppp + (-1.5 - 2 * wP) * pp + (-0.5 + wP) * p + 1;
s1 = (-1 - wN) * ppp + (1.5 + wN) * pp + 0.5 * p;
sN = wN * ppp - wN * pp;
for (var i = 0; i !== stride; ++i) {
    result[i] = sP * values[oP + i] + s0 * values[o0 + i] + s1 * values[o1 + i] + sN * values[oN + i];
}
return result;})
    });
    LinearInterpolant.prototype = Object['assign'](Object['create']((Interpolant.prototype, $__.os.oid466)), $__.os.oid470 = {
        'constructor': LinearInterpolant,
        'interpolate_': ($__.fs.J$__v494107025_2074_1101 = function J$__v494107025_2074(i1, t0, t, t1) {
var vvv_return, vvv_switch, result, values, stride, offset1, offset0, weight1, weight0;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
i1 = arguments[0], t0 = arguments[1], t = arguments[2], t1 = arguments[3];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
result = this.resultBuffer;
values = this.sampleValues;
stride = this.valueSize;
offset1 = i1 * stride;
offset0 = offset1 - stride;
weight1 = (t - t0) / (t1 - t0);
weight0 = 1 - weight1;
for (var i = 0; i !== stride; ++i) {
    result[i] = values[offset0 + i] * weight0 + values[offset1 + i] * weight1;
}
return result;})
    });
    DiscreteInterpolant.prototype = Object['assign'](Object['create']((Interpolant.prototype, $__.os.oid466)), $__.os.oid471 = {
        'constructor': DiscreteInterpolant,
        'interpolate_': ($__.fs.J$__v494107025_2077_1102 = function J$__v494107025_2077(i1, t0, t, t1) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
i1 = arguments[0], t0 = arguments[1], t = arguments[2], t1 = arguments[3];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return this.copySampleValue_(i1 - 1);})
    });
    KeyframeTrackPrototype = $__.os.oid472 = {
        'TimeBufferType': Float32Array,
        'ValueBufferType': Float32Array,
        'DefaultInterpolation': InterpolateLinear,
        'InterpolantFactoryMethodDiscrete': ($__.fs.J$__v494107025_2079_1103 = function J$__v494107025_2079(result) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
result = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return new DiscreteInterpolant(this.times, this.values, this.getValueSize(), result);}),
        'InterpolantFactoryMethodLinear': ($__.fs.J$__v494107025_2081_1104 = function J$__v494107025_2081(result) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
result = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return new LinearInterpolant(this.times, this.values, this.getValueSize(), result);}),
        'InterpolantFactoryMethodSmooth': ($__.fs.J$__v494107025_2083_1105 = function J$__v494107025_2083(result) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
result = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return new CubicInterpolant(this.times, this.values, this.getValueSize(), result);}),
        'setInterpolation': ($__.fs.J$__v494107025_2085_1106 = function J$__v494107025_2085(interpolation) {
var vvv_return, vvv_switch, factoryMethod, message;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
interpolation = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
switch (interpolation) {
case InterpolateDiscrete:
    factoryMethod = this.InterpolantFactoryMethodDiscrete;
    break;
case InterpolateLinear:
    factoryMethod = this.InterpolantFactoryMethodLinear;
    break;
case InterpolateSmooth:
    factoryMethod = this.InterpolantFactoryMethodSmooth;
    break;
}
if (factoryMethod === undefined) {
    message = 'unsupported interpolation for ' + this.ValueTypeName + ' keyframe track named ' + this.name;
    if (this.createInterpolant === undefined) {
        if (interpolation !== this.DefaultInterpolation) {
            this.setInterpolation(this.DefaultInterpolation);
        } else {
            throw new Error(message);
        }
    }
    console.warn(message);
    return;
}
this.createInterpolant = factoryMethod;}),
        'getInterpolation': ($__.fs.J$__v494107025_2087_1107 = function J$__v494107025_2087() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
switch (this.createInterpolant) {
case this.InterpolantFactoryMethodDiscrete:
    return InterpolateDiscrete;
case this.InterpolantFactoryMethodLinear:
    return InterpolateLinear;
case this.InterpolantFactoryMethodSmooth:
    return InterpolateSmooth;
}}),
        'getValueSize': ($__.fs.J$__v494107025_2089_1108 = function J$__v494107025_2089() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return this.values.length / this.times.length;}),
        'shift': ($__.fs.J$__v494107025_2091_1109 = function J$__v494107025_2091(timeOffset) {
var vvv_return, vvv_switch, times;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
timeOffset = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (timeOffset !== 0) {
    times = this.times;
    for (var i = 0, n = times.length; i !== n; ++i) {
        times[i] += timeOffset;
    }
}
return this;}),
        'scale': ($__.fs.J$__v494107025_2093_1110 = function J$__v494107025_2093(timeScale) {
var vvv_return, vvv_switch, times;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
timeScale = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (timeScale !== 1) {
    times = this.times;
    for (var i = 0, n = times.length; i !== n; ++i) {
        times[i] *= timeScale;
    }
}
return this;}),
        'trim': ($__.fs.J$__v494107025_2095_1111 = function J$__v494107025_2095(startTime, endTime) {
var vvv_return, vvv_switch, times, nKeys, from, to, stride;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
startTime = arguments[0], endTime = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
times = this.times;
nKeys = times.length;
from = 0;
to = nKeys - 1;
while (from !== nKeys && times[from] < startTime)
    ++from;
while (to !== -1 && times[to] > endTime)
    --to;
++to;
if (from !== 0 || to !== nKeys) {
    if (from >= to)
        to = Math.max(to, 1), from = to - 1;
    stride = this.getValueSize();
    this.times = exports.AnimationUtils.arraySlice(times, from, to);
    this.values = exports.AnimationUtils.arraySlice(this.values, from * stride, to * stride);
}
return this;}),
        'validate': ($__.fs.J$__v494107025_2097_1112 = function J$__v494107025_2097() {
var vvv_return, vvv_switch, valid, valueSize, times, values, nKeys, prevTime, currTime, value;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
valid = true;
valueSize = this.getValueSize();
if (valueSize - Math.floor(valueSize) !== 0) {
    console.error('invalid value size in track', this);
    valid = false;
}
times = this.times;
values = this.values;
nKeys = times.length;
if (nKeys === 0) {
    console.error('track is empty', this);
    valid = false;
}
prevTime = null;
for (var i = 0; i !== nKeys; i++) {
    currTime = times[i];
    if (typeof currTime === 'number' && isNaN(currTime)) {
        console.error('time is not a valid number', this, i, currTime);
        valid = false;
        break;
    }
    if (prevTime !== null && prevTime > currTime) {
        console.error('out of order keys', this, i, currTime, prevTime);
        valid = false;
        break;
    }
    prevTime = currTime;
}
if (values !== undefined) {
    if (exports.AnimationUtils.isTypedArray(values)) {
        for (var i = 0, n = values.length; i !== n; ++i) {
            value = values[i];
            if (isNaN(value)) {
                console.error('value is not a valid number', this, i, value);
                valid = false;
                break;
            }
        }
    }
}
return valid;}),
        'optimize': ($__.fs.J$__v494107025_2099_1113 = function J$__v494107025_2099() {
var vvv_return, vvv_switch, times, values, stride, writeIndex, keep, time, timeNext, offset, offsetP, offsetN, value, readOffset, writeOffset;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
times = this.times;
values = this.values;
stride = this.getValueSize();
writeIndex = 1;
for (var i = 1, n = times.length - 1; i <= n; ++i) {
    keep = false;
    time = times[i];
    timeNext = times[i + 1];
    if (time !== timeNext && (i !== 1 || time !== time[0])) {
        offset = i * stride;
        offsetP = offset - stride;
        offsetN = offset + stride;
        for (var j = 0; j !== stride; ++j) {
            value = values[offset + j];
            if (value !== values[offsetP + j] || value !== values[offsetN + j]) {
                keep = true;
                break;
            }
        }
    }
    if (keep) {
        if (i !== writeIndex) {
            times[writeIndex] = times[i];
            readOffset = i * stride;
            writeOffset = writeIndex * stride;
            for (var j = 0; j !== stride; ++j) {
                values[writeOffset + j] = values[readOffset + j];
            }
        }
        ++writeIndex;
    }
}
if (writeIndex !== times.length) {
    this.times = exports.AnimationUtils.arraySlice(times, 0, writeIndex);
    this.values = exports.AnimationUtils.arraySlice(values, 0, writeIndex * stride);
}
return this;})
    };
    VectorKeyframeTrack.prototype = Object['assign'](Object['create'](KeyframeTrackPrototype), $__.os.oid473 = {
        'constructor': VectorKeyframeTrack,
        'ValueTypeName': 'vector'
    });
    QuaternionLinearInterpolant.prototype = Object['assign'](Object['create']((Interpolant.prototype, $__.os.oid466)), $__.os.oid474 = {
        'constructor': QuaternionLinearInterpolant,
        'interpolate_': ($__.fs.J$__v494107025_2104_1114 = function J$__v494107025_2104(i1, t0, t, t1) {
var vvv_return, vvv_switch, result, values, stride, offset, alpha;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
i1 = arguments[0], t0 = arguments[1], t = arguments[2], t1 = arguments[3];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
result = this.resultBuffer;
values = this.sampleValues;
stride = this.valueSize;
offset = i1 * stride;
alpha = (t - t0) / (t1 - t0);
for (var end = offset + stride; offset !== end; offset += 4) {
    Quaternion.slerpFlat(result, 0, values, offset - stride, values, offset, alpha);
}
return result;})
    });
    QuaternionKeyframeTrack.prototype = Object['assign'](Object['create'](KeyframeTrackPrototype), $__.os.oid475 = {
        'constructor': QuaternionKeyframeTrack,
        'ValueTypeName': 'quaternion',
        'DefaultInterpolation': InterpolateLinear,
        'InterpolantFactoryMethodLinear': ($__.fs.J$__v494107025_2107_1115 = function J$__v494107025_2107(result) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
result = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return new QuaternionLinearInterpolant(this.times, this.values, this.getValueSize(), result);}),
        'InterpolantFactoryMethodSmooth': undefined
    });
    NumberKeyframeTrack.prototype = Object['assign'](Object['create'](KeyframeTrackPrototype), $__.os.oid476 = {
        'constructor': NumberKeyframeTrack,
        'ValueTypeName': 'number'
    });
    StringKeyframeTrack.prototype = Object['assign'](Object['create'](KeyframeTrackPrototype), $__.os.oid477 = {
        'constructor': StringKeyframeTrack,
        'ValueTypeName': 'string',
        'ValueBufferType': Array,
        'DefaultInterpolation': InterpolateDiscrete,
        'InterpolantFactoryMethodLinear': undefined,
        'InterpolantFactoryMethodSmooth': undefined
    });
    BooleanKeyframeTrack.prototype = Object['assign'](Object['create'](KeyframeTrackPrototype), $__.os.oid478 = {
        'constructor': BooleanKeyframeTrack,
        'ValueTypeName': 'bool',
        'ValueBufferType': Array,
        'DefaultInterpolation': InterpolateDiscrete,
        'InterpolantFactoryMethodLinear': undefined,
        'InterpolantFactoryMethodSmooth': undefined
    });
    ColorKeyframeTrack.prototype = Object['assign'](Object['create'](KeyframeTrackPrototype), $__.os.oid479 = {
        'constructor': ColorKeyframeTrack,
        'ValueTypeName': 'color'
    });
    KeyframeTrack.prototype = KeyframeTrackPrototype;
    (KeyframeTrackPrototype, $__.os.oid472).constructor = KeyframeTrack;
    Object['assign'](((KeyframeTrack, $__.fs.KeyframeTrack_179), $__.fs.KeyframeTrack_179_2), $__.os.oid480 = {
        'parse': ($__.fs.J$__v494107025_2114_1116 = function J$__v494107025_2114(json) {
var vvv_return, vvv_switch, trackType, times, values;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
json = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (json.type === undefined) {
    throw new Error('track type undefined, can not parse');
}
trackType = KeyframeTrack._getTrackTypeForValueTypeName(json.type);
if (json.times === undefined) {
    times = [];
    values = [];
    exports.AnimationUtils.flattenJSON(json.keys, times, values, 'value');
    json.times = times;
    json.values = values;
}
if (trackType.parse !== undefined) {
    return trackType.parse(json);
} else {
    return new trackType(json.name, json.times, json.values, json.interpolation);
}}),
        'toJSON': ($__.fs.J$__v494107025_2116_1117 = function J$__v494107025_2116(track) {
var vvv_return, vvv_switch, trackType, json, interpolation;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
track = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
trackType = track.constructor;
if (trackType.toJSON !== undefined) {
    json = trackType.toJSON(track);
} else {
    json = {
        'name': track.name,
        'times': exports.AnimationUtils.convertArray(track.times, Array),
        'values': exports.AnimationUtils.convertArray(track.values, Array)
    };
    interpolation = track.getInterpolation();
    if (interpolation !== track.DefaultInterpolation) {
        json.interpolation = interpolation;
    }
}
json.type = track.ValueTypeName;
return json;}),
        '_getTrackTypeForValueTypeName': ($__.fs.J$__v494107025_2118_1118 = function J$__v494107025_2118(typeName) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
typeName = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
switch (typeName.toLowerCase()) {
case 'scalar':
case 'double':
case 'float':
case 'number':
case 'integer':
    return NumberKeyframeTrack;
case 'vector':
case 'vector2':
case 'vector3':
case 'vector4':
    return VectorKeyframeTrack;
case 'color':
    return ColorKeyframeTrack;
case 'quaternion':
    return QuaternionKeyframeTrack;
case 'bool':
case 'boolean':
    return BooleanKeyframeTrack;
case 'string':
    return StringKeyframeTrack;
}
throw new Error('Unsupported typeName: ' + typeName);})
    });
    AnimationClip.prototype = $__.os.oid481 = {
        'constructor': AnimationClip,
        'resetDuration': ($__.fs.J$__v494107025_2121_1119 = function J$__v494107025_2121() {
var vvv_return, vvv_switch, tracks, duration, track;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
tracks = this.tracks;
duration = 0;
for (var i = 0, n = tracks.length; i !== n; ++i) {
    track = this.tracks[i];
    duration = Math.max(duration, track.times[track.times.length - 1]);
}
this.duration = duration;}),
        'trim': ($__.fs.J$__v494107025_2123_1120 = function J$__v494107025_2123() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
for (var i = 0; i < this.tracks.length; i++) {
    this.tracks[i].trim(0, this.duration);
}
return this;}),
        'optimize': ($__.fs.J$__v494107025_2125_1121 = function J$__v494107025_2125() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
for (var i = 0; i < this.tracks.length; i++) {
    this.tracks[i].optimize();
}
return this;})
    };
    Object['assign'](((AnimationClip, $__.fs.AnimationClip_180), $__.fs.AnimationClip_180_3), $__.os.oid482 = {
        'parse': ($__.fs.J$__v494107025_2127_1122 = function J$__v494107025_2127(json) {
var vvv_return, vvv_switch, tracks, jsonTracks, frameTime;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
json = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
tracks = [];
jsonTracks = json.tracks;
frameTime = 1 / (json.fps || 1);
for (var i = 0, n = jsonTracks.length; i !== n; ++i) {
    tracks.push(KeyframeTrack.parse(jsonTracks[i]).scale(frameTime));
}
return new AnimationClip(json.name, json.duration, tracks);}),
        'toJSON': ($__.fs.J$__v494107025_2129_1123 = function J$__v494107025_2129(clip) {
var vvv_return, vvv_switch, tracks, clipTracks, json;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
clip = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
tracks = [];
clipTracks = clip.tracks;
json = {
    'name': clip.name,
    'duration': clip.duration,
    'tracks': tracks
};
for (var i = 0, n = clipTracks.length; i !== n; ++i) {
    tracks.push(KeyframeTrack.toJSON(clipTracks[i]));
}
return json;}),
        'CreateFromMorphTargetSequence': ($__.fs.J$__v494107025_2131_1124 = function J$__v494107025_2131(name, morphTargetSequence, fps, noLoop) {
var vvv_return, vvv_switch, numMorphTargets, tracks, times, values, order;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
name = arguments[0], morphTargetSequence = arguments[1], fps = arguments[2], noLoop = arguments[3];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
numMorphTargets = morphTargetSequence.length;
tracks = [];
for (var i = 0; i < numMorphTargets; i++) {
    times = [];
    values = [];
    times.push((i + numMorphTargets - 1) % numMorphTargets, i, (i + 1) % numMorphTargets);
    values.push(0, 1, 0);
    order = exports.AnimationUtils.getKeyframeOrder(times);
    times = exports.AnimationUtils.sortedArray(times, 1, order);
    values = exports.AnimationUtils.sortedArray(values, 1, order);
    if (!noLoop && times[0] === 0) {
        times.push(numMorphTargets);
        values.push(values[0]);
    }
    tracks.push(new NumberKeyframeTrack('.morphTargetInfluences[' + morphTargetSequence[i].name + ']', times, values).scale(1 / fps));
}
return new AnimationClip(name, -1, tracks);}),
        'findByName': ($__.fs.J$__v494107025_2133_1125 = function J$__v494107025_2133(objectOrClipArray, name) {
var vvv_return, vvv_switch, clipArray, o;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
objectOrClipArray = arguments[0], name = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
clipArray = objectOrClipArray;
if (!Array.isArray(objectOrClipArray)) {
    o = objectOrClipArray;
    clipArray = o.geometry && o.geometry.animations || o.animations;
}
for (var i = 0; i < clipArray.length; i++) {
    if (clipArray[i].name === name) {
        return clipArray[i];
    }
}
return null;}),
        'CreateClipsFromMorphTargetSequences': ($__.fs.J$__v494107025_2135_1126 = function J$__v494107025_2135(morphTargets, fps, noLoop) {
var vvv_return, vvv_switch, animationToMorphTargets, pattern, morphTarget, parts, name, animationMorphTargets, clips;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
morphTargets = arguments[0], fps = arguments[1], noLoop = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
animationToMorphTargets = {};
pattern = /^([\w-]*?)([\d]+)$/;
for (var i = 0, il = morphTargets.length; i < il; i++) {
    morphTarget = morphTargets[i];
    parts = morphTarget.name.match(pattern);
    if (parts && parts.length > 1) {
        name = parts[1];
        animationMorphTargets = animationToMorphTargets[name];
        if (!animationMorphTargets) {
            animationToMorphTargets[name] = animationMorphTargets = [];
        }
        animationMorphTargets.push(morphTarget);
    }
}
clips = [];
for (var name in animationToMorphTargets) {
    clips.push(AnimationClip.CreateFromMorphTargetSequence(name, animationToMorphTargets[name], fps, noLoop));
}
return clips;}),
        'parseAnimation': ($__.fs.J$__v494107025_2139_1127 = function J$__v494107025_2139(animation, bones, nodeName) {
var vvv_return, vvv_switch, addNonemptyTrack, tracks, clipName, duration, fps, hierarchyTracks, animationKeys, morphTargetNames, times, values, animationKey, boneName, clip;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
animation = arguments[0], bones = arguments[1], nodeName = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (!animation) {
    console.error('  no animation in JSONLoader data');
    return null;
}
addNonemptyTrack = function (trackType, trackName, animationKeys, propertyName, destTracks) {
    if (animationKeys.length !== 0) {
        var times = [];
        var values = [];
        exports.AnimationUtils.flattenJSON(animationKeys, times, values, propertyName);
        if (times.length !== 0) {
            destTracks.push(new trackType(trackName, times, values));
        }
    }
};
tracks = [];
clipName = animation.name || 'default';
duration = animation.length || -1;
fps = animation.fps || 30;
hierarchyTracks = animation.hierarchy || [];
for (var h = 0; h < hierarchyTracks.length; h++) {
    animationKeys = hierarchyTracks[h].keys;
    if (!animationKeys || animationKeys.length === 0)
        continue;
    if (animationKeys[0].morphTargets) {
        morphTargetNames = {};
        for (var k = 0; k < animationKeys.length; k++) {
            if (animationKeys[k].morphTargets) {
                for (var m = 0; m < animationKeys[k].morphTargets.length; m++) {
                    morphTargetNames[animationKeys[k].morphTargets[m]] = -1;
                }
            }
        }
        for (var morphTargetName in morphTargetNames) {
            times = [];
            values = [];
            for (var m = 0; m !== animationKeys[k].morphTargets.length; ++m) {
                animationKey = animationKeys[k];
                times.push(animationKey.time);
                values.push(animationKey.morphTarget === morphTargetName ? 1 : 0);
            }
            tracks.push(new NumberKeyframeTrack('.morphTargetInfluence[' + morphTargetName + ']', times, values));
        }
        duration = morphTargetNames.length * (fps || 1);
    } else {
        boneName = '.bones[' + bones[h].name + ']';
        addNonemptyTrack(VectorKeyframeTrack, boneName + '.position', animationKeys, 'pos', tracks);
        addNonemptyTrack(QuaternionKeyframeTrack, boneName + '.quaternion', animationKeys, 'rot', tracks);
        addNonemptyTrack(VectorKeyframeTrack, boneName + '.scale', animationKeys, 'scl', tracks);
    }
}
if (tracks.length === 0) {
    return null;
}
clip = new AnimationClip(clipName, duration, tracks);
return clip;})
    });
    Object['assign'](TAJS_restrictToType(MaterialLoader.prototype, 'object'), $__.os.oid483 = {
        'load': ($__.fs.J$__v494107025_2144_1128 = function J$__v494107025_2144(url, onLoad, onProgress, onError) {
var vvv_return, vvv_switch, scope, loader;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
url = arguments[0], onLoad = arguments[1], onProgress = arguments[2], onError = arguments[3];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
scope = this;
loader = new XHRLoader(scope.manager);
loader.load(url, function (text) {
    onLoad(scope.parse(JSON.parse(text)));
}, onProgress, onError);}),
        'setTextures': ($__.fs.J$__v494107025_2146_1129 = function J$__v494107025_2146(value) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
value = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.textures = value;}),
        'parse': ($__.fs.J$__v494107025_2149_1130 = function J$__v494107025_2149(json) {
var vvv_return, vvv_switch, textures, getTexture, material, normalScale;
getTexture = function getTexture(name) {
    if (textures[name] === undefined) {
        console.warn('THREE.MaterialLoader: Undefined texture', name);
    }
    return textures[name];
};
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
json = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
textures = this.textures;
material = new THREE[json.type]();
if (json.uuid !== undefined)
    material.uuid = json.uuid;
if (json.name !== undefined)
    material.name = json.name;
if (json.color !== undefined)
    material.color.setHex(json.color);
if (json.roughness !== undefined)
    material.roughness = json.roughness;
if (json.metalness !== undefined)
    material.metalness = json.metalness;
if (json.emissive !== undefined)
    material.emissive.setHex(json.emissive);
if (json.specular !== undefined)
    material.specular.setHex(json.specular);
if (json.shininess !== undefined)
    material.shininess = json.shininess;
if (json.uniforms !== undefined)
    material.uniforms = json.uniforms;
if (json.vertexShader !== undefined)
    material.vertexShader = json.vertexShader;
if (json.fragmentShader !== undefined)
    material.fragmentShader = json.fragmentShader;
if (json.vertexColors !== undefined)
    material.vertexColors = json.vertexColors;
if (json.fog !== undefined)
    material.fog = json.fog;
if (json.shading !== undefined)
    material.shading = json.shading;
if (json.blending !== undefined)
    material.blending = json.blending;
if (json.side !== undefined)
    material.side = json.side;
if (json.opacity !== undefined)
    material.opacity = json.opacity;
if (json.transparent !== undefined)
    material.transparent = json.transparent;
if (json.alphaTest !== undefined)
    material.alphaTest = json.alphaTest;
if (json.depthTest !== undefined)
    material.depthTest = json.depthTest;
if (json.depthWrite !== undefined)
    material.depthWrite = json.depthWrite;
if (json.colorWrite !== undefined)
    material.colorWrite = json.colorWrite;
if (json.wireframe !== undefined)
    material.wireframe = json.wireframe;
if (json.wireframeLinewidth !== undefined)
    material.wireframeLinewidth = json.wireframeLinewidth;
if (json.wireframeLinecap !== undefined)
    material.wireframeLinecap = json.wireframeLinecap;
if (json.wireframeLinejoin !== undefined)
    material.wireframeLinejoin = json.wireframeLinejoin;
if (json.skinning !== undefined)
    material.skinning = json.skinning;
if (json.morphTargets !== undefined)
    material.morphTargets = json.morphTargets;
if (json.size !== undefined)
    material.size = json.size;
if (json.sizeAttenuation !== undefined)
    material.sizeAttenuation = json.sizeAttenuation;
if (json.map !== undefined)
    material.map = getTexture(json.map);
if (json.alphaMap !== undefined) {
    material.alphaMap = getTexture(json.alphaMap);
    material.transparent = true;
}
if (json.bumpMap !== undefined)
    material.bumpMap = getTexture(json.bumpMap);
if (json.bumpScale !== undefined)
    material.bumpScale = json.bumpScale;
if (json.normalMap !== undefined)
    material.normalMap = getTexture(json.normalMap);
if (json.normalScale !== undefined) {
    normalScale = json.normalScale;
    if (Array.isArray(normalScale) === false) {
        normalScale = [
            normalScale,
            normalScale
        ];
    }
    material.normalScale = new Vector2().fromArray(normalScale);
}
if (json.displacementMap !== undefined)
    material.displacementMap = getTexture(json.displacementMap);
if (json.displacementScale !== undefined)
    material.displacementScale = json.displacementScale;
if (json.displacementBias !== undefined)
    material.displacementBias = json.displacementBias;
if (json.roughnessMap !== undefined)
    material.roughnessMap = getTexture(json.roughnessMap);
if (json.metalnessMap !== undefined)
    material.metalnessMap = getTexture(json.metalnessMap);
if (json.emissiveMap !== undefined)
    material.emissiveMap = getTexture(json.emissiveMap);
if (json.emissiveIntensity !== undefined)
    material.emissiveIntensity = json.emissiveIntensity;
if (json.specularMap !== undefined)
    material.specularMap = getTexture(json.specularMap);
if (json.envMap !== undefined)
    material.envMap = getTexture(json.envMap);
if (json.reflectivity !== undefined)
    material.reflectivity = json.reflectivity;
if (json.lightMap !== undefined)
    material.lightMap = getTexture(json.lightMap);
if (json.lightMapIntensity !== undefined)
    material.lightMapIntensity = json.lightMapIntensity;
if (json.aoMap !== undefined)
    material.aoMap = getTexture(json.aoMap);
if (json.aoMapIntensity !== undefined)
    material.aoMapIntensity = json.aoMapIntensity;
if (json.materials !== undefined) {
    for (var i = 0, l = json.materials.length; i < l; i++) {
        material.materials.push(this.parse(json.materials[i]));
    }
}
return material;})
    });
    Object['assign'](TAJS_restrictToType(BufferGeometryLoader.prototype, 'object'), $__.os.oid484 = {
        'load': ($__.fs.J$__v494107025_2154_1131 = function J$__v494107025_2154(url, onLoad, onProgress, onError) {
var vvv_return, vvv_switch, scope, loader;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
url = arguments[0], onLoad = arguments[1], onProgress = arguments[2], onError = arguments[3];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
scope = this;
loader = new XHRLoader(scope.manager);
loader.load(url, function (text) {
    onLoad(scope.parse(JSON.parse(text)));
}, onProgress, onError);}),
        'parse': ($__.fs.J$__v494107025_2156_1132 = function J$__v494107025_2156(json) {
var vvv_return, vvv_switch, geometry, index, TYPED_ARRAYS, typedArray, attributes, attribute, groups, group, boundingSphere, center;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
json = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
geometry = new BufferGeometry();
index = json.data.index;
TYPED_ARRAYS = {
    'Int8Array': Int8Array,
    'Uint8Array': Uint8Array,
    'Uint8ClampedArray': Uint8ClampedArray,
    'Int16Array': Int16Array,
    'Uint16Array': Uint16Array,
    'Int32Array': Int32Array,
    'Uint32Array': Uint32Array,
    'Float32Array': Float32Array,
    'Float64Array': Float64Array
};
if (index !== undefined) {
    typedArray = new TYPED_ARRAYS[index.type](index.array);
    geometry.setIndex(new BufferAttribute(typedArray, 1));
}
attributes = json.data.attributes;
for (var key in attributes) {
    attribute = attributes[key];
    typedArray = new TYPED_ARRAYS[attribute.type](attribute.array);
    geometry.addAttribute(key, new BufferAttribute(typedArray, attribute.itemSize, attribute.normalized));
}
groups = json.data.groups || json.data.drawcalls || json.data.offsets;
if (groups !== undefined) {
    for (var i = 0, n = groups.length; i !== n; ++i) {
        group = groups[i];
        geometry.addGroup(group.start, group.count, group.materialIndex);
    }
}
boundingSphere = json.data.boundingSphere;
if (boundingSphere !== undefined) {
    center = new Vector3();
    if (boundingSphere.center !== undefined) {
        center.fromArray(boundingSphere.center);
    }
    geometry.boundingSphere = new Sphere(center, boundingSphere.radius);
}
return geometry;})
    });
    Loader.prototype = $__.os.oid485 = {
        'constructor': Loader,
        'crossOrigin': undefined,
        'extractUrlBase': ($__.fs.J$__v494107025_2165_1133 = function J$__v494107025_2165(url) {
var vvv_return, vvv_switch, parts;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
url = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
parts = url.split('/');
if (parts.length === 1)
    return './';
parts.pop();
return parts.join('/') + '/';}),
        'initMaterials': ($__.fs.J$__v494107025_2167_1134 = function J$__v494107025_2167(materials, texturePath, crossOrigin) {
var vvv_return, vvv_switch, array;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
materials = arguments[0], texturePath = arguments[1], crossOrigin = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
array = [];
for (var i = 0; i < materials.length; ++i) {
    array[i] = this.createMaterial(materials[i], texturePath, crossOrigin);
}
return array;}),
        'createMaterial': (($__.fs.J$__v494107025_2171_1135 = function J$__v494107025_2171() {
var vvv_return, vvv_switch, color, textureLoader, materialLoader;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    return ($__.fs.createMaterial_1136 = function createMaterial(m, texturePath, crossOrigin) {
var vvv_return, vvv_switch, textures, loadTexture, json, value;
loadTexture = function loadTexture(path, repeat, offset, wrap, anisotropy) {
    var fullPath = texturePath + path;
    var loader = Loader.Handlers.get(fullPath);
    var texture;
    if (loader !== null) {
        texture = loader.load(fullPath);
    } else {
        textureLoader.setCrossOrigin(crossOrigin);
        texture = textureLoader.load(fullPath);
    }
    if (repeat !== undefined) {
        texture.repeat.fromArray(repeat);
        if (repeat[0] !== 1)
            texture.wrapS = RepeatWrapping;
        if (repeat[1] !== 1)
            texture.wrapT = RepeatWrapping;
    }
    if (offset !== undefined) {
        texture.offset.fromArray(offset);
    }
    if (wrap !== undefined) {
        if (wrap[0] === 'repeat')
            texture.wrapS = RepeatWrapping;
        if (wrap[0] === 'mirror')
            texture.wrapS = MirroredRepeatWrapping;
        if (wrap[1] === 'repeat')
            texture.wrapT = RepeatWrapping;
        if (wrap[1] === 'mirror')
            texture.wrapT = MirroredRepeatWrapping;
    }
    if (anisotropy !== undefined) {
        texture.anisotropy = anisotropy;
    }
    var uuid = exports.Math.generateUUID();
    textures[uuid] = texture;
    return uuid;
};
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
m = arguments[0], texturePath = arguments[1], crossOrigin = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (color === undefined)
    color = new Color();
if (textureLoader === undefined)
    textureLoader = new TextureLoader();
if (materialLoader === undefined)
    materialLoader = new MaterialLoader();
textures = {};
json = {
    uuid: exports.Math.generateUUID(),
    type: 'MeshLambertMaterial'
};
for (var name in m) {
    value = m[name];
    switch (name) {
    case 'DbgColor':
    case 'DbgIndex':
    case 'opticalDensity':
    case 'illumination':
        break;
    case 'DbgName':
        json.name = value;
        break;
    case 'blending':
        json.blending = THREE[value];
        break;
    case 'colorAmbient':
    case 'mapAmbient':
        console.warn('THREE.Loader.createMaterial:', name, 'is no longer supported.');
        break;
    case 'colorDiffuse':
        json.color = color.fromArray(value).getHex();
        break;
    case 'colorSpecular':
        json.specular = color.fromArray(value).getHex();
        break;
    case 'colorEmissive':
        json.emissive = color.fromArray(value).getHex();
        break;
    case 'specularCoef':
        json.shininess = value;
        break;
    case 'shading':
        if (value.toLowerCase() === 'basic')
            json.type = 'MeshBasicMaterial';
        if (value.toLowerCase() === 'phong')
            json.type = 'MeshPhongMaterial';
        if (value.toLowerCase() === 'standard')
            json.type = 'MeshStandardMaterial';
        break;
    case 'mapDiffuse':
        json.map = loadTexture(value, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy);
        break;
    case 'mapDiffuseRepeat':
    case 'mapDiffuseOffset':
    case 'mapDiffuseWrap':
    case 'mapDiffuseAnisotropy':
        break;
    case 'mapEmissive':
        json.emissiveMap = loadTexture(value, m.mapEmissiveRepeat, m.mapEmissiveOffset, m.mapEmissiveWrap, m.mapEmissiveAnisotropy);
        break;
    case 'mapEmissiveRepeat':
    case 'mapEmissiveOffset':
    case 'mapEmissiveWrap':
    case 'mapEmissiveAnisotropy':
        break;
    case 'mapLight':
        json.lightMap = loadTexture(value, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy);
        break;
    case 'mapLightRepeat':
    case 'mapLightOffset':
    case 'mapLightWrap':
    case 'mapLightAnisotropy':
        break;
    case 'mapAO':
        json.aoMap = loadTexture(value, m.mapAORepeat, m.mapAOOffset, m.mapAOWrap, m.mapAOAnisotropy);
        break;
    case 'mapAORepeat':
    case 'mapAOOffset':
    case 'mapAOWrap':
    case 'mapAOAnisotropy':
        break;
    case 'mapBump':
        json.bumpMap = loadTexture(value, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy);
        break;
    case 'mapBumpScale':
        json.bumpScale = value;
        break;
    case 'mapBumpRepeat':
    case 'mapBumpOffset':
    case 'mapBumpWrap':
    case 'mapBumpAnisotropy':
        break;
    case 'mapNormal':
        json.normalMap = loadTexture(value, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy);
        break;
    case 'mapNormalFactor':
        json.normalScale = [
            value,
            value
        ];
        break;
    case 'mapNormalRepeat':
    case 'mapNormalOffset':
    case 'mapNormalWrap':
    case 'mapNormalAnisotropy':
        break;
    case 'mapSpecular':
        json.specularMap = loadTexture(value, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy);
        break;
    case 'mapSpecularRepeat':
    case 'mapSpecularOffset':
    case 'mapSpecularWrap':
    case 'mapSpecularAnisotropy':
        break;
    case 'mapMetalness':
        json.metalnessMap = loadTexture(value, m.mapMetalnessRepeat, m.mapMetalnessOffset, m.mapMetalnessWrap, m.mapMetalnessAnisotropy);
        break;
    case 'mapMetalnessRepeat':
    case 'mapMetalnessOffset':
    case 'mapMetalnessWrap':
    case 'mapMetalnessAnisotropy':
        break;
    case 'mapRoughness':
        json.roughnessMap = loadTexture(value, m.mapRoughnessRepeat, m.mapRoughnessOffset, m.mapRoughnessWrap, m.mapRoughnessAnisotropy);
        break;
    case 'mapRoughnessRepeat':
    case 'mapRoughnessOffset':
    case 'mapRoughnessWrap':
    case 'mapRoughnessAnisotropy':
        break;
    case 'mapAlpha':
        json.alphaMap = loadTexture(value, m.mapAlphaRepeat, m.mapAlphaOffset, m.mapAlphaWrap, m.mapAlphaAnisotropy);
        break;
    case 'mapAlphaRepeat':
    case 'mapAlphaOffset':
    case 'mapAlphaWrap':
    case 'mapAlphaAnisotropy':
        break;
    case 'flipSided':
        json.side = BackSide;
        break;
    case 'doubleSided':
        json.side = DoubleSide;
        break;
    case 'transparency':
        console.warn('THREE.Loader.createMaterial: transparency has been renamed to opacity');
        json.opacity = value;
        break;
    case 'depthTest':
    case 'depthWrite':
    case 'colorWrite':
    case 'opacity':
    case 'reflectivity':
    case 'transparent':
    case 'visible':
    case 'wireframe':
        json[name] = value;
        break;
    case 'vertexColors':
        if (value === true)
            json.vertexColors = VertexColors;
        if (value === 'face')
            json.vertexColors = FaceColors;
        break;
    default:
        console.error('THREE.Loader.createMaterial: Unsupported', name, value);
        break;
    }
}
if (json.type === 'MeshBasicMaterial')
    delete json.emissive;
if (json.type !== 'MeshPhongMaterial')
    delete json.specular;
if (json.opacity < 1)
    json.transparent = true;
materialLoader.setTextures(textures);
return materialLoader.parse(json);});
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return function createMaterial(m, texturePath, crossOrigin) {
    if (color === undefined)
        color = new Color();
    if (textureLoader === undefined)
        textureLoader = new TextureLoader();
    if (materialLoader === undefined)
        materialLoader = new MaterialLoader();
    var textures = {};
    function loadTexture(path, repeat, offset, wrap, anisotropy) {
        var fullPath = texturePath + path;
        var loader = Loader.Handlers.get(fullPath);
        var texture;
        if (loader !== null) {
            texture = loader.load(fullPath);
        } else {
            textureLoader.setCrossOrigin(crossOrigin);
            texture = textureLoader.load(fullPath);
        }
        if (repeat !== undefined) {
            texture.repeat.fromArray(repeat);
            if (repeat[0] !== 1)
                texture.wrapS = RepeatWrapping;
            if (repeat[1] !== 1)
                texture.wrapT = RepeatWrapping;
        }
        if (offset !== undefined) {
            texture.offset.fromArray(offset);
        }
        if (wrap !== undefined) {
            if (wrap[0] === 'repeat')
                texture.wrapS = RepeatWrapping;
            if (wrap[0] === 'mirror')
                texture.wrapS = MirroredRepeatWrapping;
            if (wrap[1] === 'repeat')
                texture.wrapT = RepeatWrapping;
            if (wrap[1] === 'mirror')
                texture.wrapT = MirroredRepeatWrapping;
        }
        if (anisotropy !== undefined) {
            texture.anisotropy = anisotropy;
        }
        var uuid = exports.Math.generateUUID();
        textures[uuid] = texture;
        return uuid;
    }
    var json = {
        uuid: exports.Math.generateUUID(),
        type: 'MeshLambertMaterial'
    };
    for (var name in m) {
        var value = m[name];
        switch (name) {
        case 'DbgColor':
        case 'DbgIndex':
        case 'opticalDensity':
        case 'illumination':
            break;
        case 'DbgName':
            json.name = value;
            break;
        case 'blending':
            json.blending = THREE[value];
            break;
        case 'colorAmbient':
        case 'mapAmbient':
            console.warn('THREE.Loader.createMaterial:', name, 'is no longer supported.');
            break;
        case 'colorDiffuse':
            json.color = color.fromArray(value).getHex();
            break;
        case 'colorSpecular':
            json.specular = color.fromArray(value).getHex();
            break;
        case 'colorEmissive':
            json.emissive = color.fromArray(value).getHex();
            break;
        case 'specularCoef':
            json.shininess = value;
            break;
        case 'shading':
            if (value.toLowerCase() === 'basic')
                json.type = 'MeshBasicMaterial';
            if (value.toLowerCase() === 'phong')
                json.type = 'MeshPhongMaterial';
            if (value.toLowerCase() === 'standard')
                json.type = 'MeshStandardMaterial';
            break;
        case 'mapDiffuse':
            json.map = loadTexture(value, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy);
            break;
        case 'mapDiffuseRepeat':
        case 'mapDiffuseOffset':
        case 'mapDiffuseWrap':
        case 'mapDiffuseAnisotropy':
            break;
        case 'mapEmissive':
            json.emissiveMap = loadTexture(value, m.mapEmissiveRepeat, m.mapEmissiveOffset, m.mapEmissiveWrap, m.mapEmissiveAnisotropy);
            break;
        case 'mapEmissiveRepeat':
        case 'mapEmissiveOffset':
        case 'mapEmissiveWrap':
        case 'mapEmissiveAnisotropy':
            break;
        case 'mapLight':
            json.lightMap = loadTexture(value, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy);
            break;
        case 'mapLightRepeat':
        case 'mapLightOffset':
        case 'mapLightWrap':
        case 'mapLightAnisotropy':
            break;
        case 'mapAO':
            json.aoMap = loadTexture(value, m.mapAORepeat, m.mapAOOffset, m.mapAOWrap, m.mapAOAnisotropy);
            break;
        case 'mapAORepeat':
        case 'mapAOOffset':
        case 'mapAOWrap':
        case 'mapAOAnisotropy':
            break;
        case 'mapBump':
            json.bumpMap = loadTexture(value, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy);
            break;
        case 'mapBumpScale':
            json.bumpScale = value;
            break;
        case 'mapBumpRepeat':
        case 'mapBumpOffset':
        case 'mapBumpWrap':
        case 'mapBumpAnisotropy':
            break;
        case 'mapNormal':
            json.normalMap = loadTexture(value, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy);
            break;
        case 'mapNormalFactor':
            json.normalScale = [
                value,
                value
            ];
            break;
        case 'mapNormalRepeat':
        case 'mapNormalOffset':
        case 'mapNormalWrap':
        case 'mapNormalAnisotropy':
            break;
        case 'mapSpecular':
            json.specularMap = loadTexture(value, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy);
            break;
        case 'mapSpecularRepeat':
        case 'mapSpecularOffset':
        case 'mapSpecularWrap':
        case 'mapSpecularAnisotropy':
            break;
        case 'mapMetalness':
            json.metalnessMap = loadTexture(value, m.mapMetalnessRepeat, m.mapMetalnessOffset, m.mapMetalnessWrap, m.mapMetalnessAnisotropy);
            break;
        case 'mapMetalnessRepeat':
        case 'mapMetalnessOffset':
        case 'mapMetalnessWrap':
        case 'mapMetalnessAnisotropy':
            break;
        case 'mapRoughness':
            json.roughnessMap = loadTexture(value, m.mapRoughnessRepeat, m.mapRoughnessOffset, m.mapRoughnessWrap, m.mapRoughnessAnisotropy);
            break;
        case 'mapRoughnessRepeat':
        case 'mapRoughnessOffset':
        case 'mapRoughnessWrap':
        case 'mapRoughnessAnisotropy':
            break;
        case 'mapAlpha':
            json.alphaMap = loadTexture(value, m.mapAlphaRepeat, m.mapAlphaOffset, m.mapAlphaWrap, m.mapAlphaAnisotropy);
            break;
        case 'mapAlphaRepeat':
        case 'mapAlphaOffset':
        case 'mapAlphaWrap':
        case 'mapAlphaAnisotropy':
            break;
        case 'flipSided':
            json.side = BackSide;
            break;
        case 'doubleSided':
            json.side = DoubleSide;
            break;
        case 'transparency':
            console.warn('THREE.Loader.createMaterial: transparency has been renamed to opacity');
            json.opacity = value;
            break;
        case 'depthTest':
        case 'depthWrite':
        case 'colorWrite':
        case 'opacity':
        case 'reflectivity':
        case 'transparent':
        case 'visible':
        case 'wireframe':
            json[name] = value;
            break;
        case 'vertexColors':
            if (value === true)
                json.vertexColors = VertexColors;
            if (value === 'face')
                json.vertexColors = FaceColors;
            break;
        default:
            console.error('THREE.Loader.createMaterial: Unsupported', name, value);
            break;
        }
    }
    if (json.type === 'MeshBasicMaterial')
        delete json.emissive;
    if (json.type !== 'MeshPhongMaterial')
        delete json.specular;
    if (json.opacity < 1)
        json.transparent = true;
    materialLoader.setTextures(textures);
    return materialLoader.parse(json);
};}), $__.fs.J$__v494107025_2171_1135)(0, true, $__.uid)
    };
    Loader.Handlers = $__.os.oid486 = {
        'handlers': [],
        'add': ($__.fs.J$__v494107025_2173_1137 = function J$__v494107025_2173(regex, loader) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
regex = arguments[0], loader = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.handlers.push(regex, loader);}),
        'get': ($__.fs.J$__v494107025_2175_1138 = function J$__v494107025_2175(file) {
var vvv_return, vvv_switch, handlers, regex, loader;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
file = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
handlers = this.handlers;
for (var i = 0, l = handlers.length; i < l; i += 2) {
    regex = handlers[i];
    loader = handlers[i + 1];
    if (regex.test(file)) {
        return loader;
    }
}
return null;})
    };
    Object['assign'](TAJS_restrictToType(JSONLoader.prototype, 'object'), $__.os.oid487 = {
        'load': ($__.fs.J$__v494107025_2180_1139 = function J$__v494107025_2180(url, onLoad, onProgress, onError) {
var vvv_return, vvv_switch, scope, texturePath, loader;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
url = arguments[0], onLoad = arguments[1], onProgress = arguments[2], onError = arguments[3];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
scope = this;
texturePath = this.texturePath && typeof this.texturePath === 'string' ? this.texturePath : Loader.prototype.extractUrlBase(url);
loader = new XHRLoader(this.manager);
loader.setWithCredentials(this.withCredentials);
loader.load(url, function (text) {
    var json = JSON.parse(text);
    var metadata = json.metadata;
    if (metadata !== undefined) {
        var type = metadata.type;
        if (type !== undefined) {
            if (type.toLowerCase() === 'object') {
                console.error('THREE.JSONLoader: ' + url + ' should be loaded with THREE.ObjectLoader instead.');
                return;
            }
            if (type.toLowerCase() === 'scene') {
                console.error('THREE.JSONLoader: ' + url + ' should be loaded with THREE.SceneLoader instead.');
                return;
            }
        }
    }
    var object = scope.parse(json, texturePath);
    onLoad(object.geometry, object.materials);
}, onProgress, onError);}),
        'setTexturePath': ($__.fs.J$__v494107025_2182_1140 = function J$__v494107025_2182(value) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
value = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.texturePath = value;}),
        'parse': ($__.fs.J$__v494107025_2189_1141 = function J$__v494107025_2189(json, texturePath) {
var vvv_return, vvv_switch, geometry, scale, parseModel, parseSkin, parseMorphing, parseAnimations, materials;
parseModel = function parseModel(scale) {
    function isBitSet(value, position) {
        return value & 1 << position;
    }
    var i, j, fi, offset, zLength, colorIndex, normalIndex, uvIndex, materialIndex, type, isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor, vertex, face, faceA, faceB, hex, normal, uvLayer, uv, u, v, faces = json.faces, vertices = json.vertices, normals = json.normals, colors = json.colors, nUvLayers = 0;
    if (json.uvs !== undefined) {
        for (i = 0; i < json.uvs.length; i++) {
            if (json.uvs[i].length)
                nUvLayers++;
        }
        for (i = 0; i < nUvLayers; i++) {
            geometry.faceVertexUvs[i] = [];
        }
    }
    offset = 0;
    zLength = vertices.length;
    while (offset < zLength) {
        vertex = new Vector3();
        vertex.x = vertices[offset++] * scale;
        vertex.y = vertices[offset++] * scale;
        vertex.z = vertices[offset++] * scale;
        geometry.vertices.push(vertex);
    }
    offset = 0;
    zLength = faces.length;
    while (offset < zLength) {
        type = faces[offset++];
        isQuad = isBitSet(type, 0);
        hasMaterial = isBitSet(type, 1);
        hasFaceVertexUv = isBitSet(type, 3);
        hasFaceNormal = isBitSet(type, 4);
        hasFaceVertexNormal = isBitSet(type, 5);
        hasFaceColor = isBitSet(type, 6);
        hasFaceVertexColor = isBitSet(type, 7);
        if (isQuad) {
            faceA = new Face3();
            faceA.a = faces[offset];
            faceA.b = faces[offset + 1];
            faceA.c = faces[offset + 3];
            faceB = new Face3();
            faceB.a = faces[offset + 1];
            faceB.b = faces[offset + 2];
            faceB.c = faces[offset + 3];
            offset += 4;
            if (hasMaterial) {
                materialIndex = faces[offset++];
                faceA.materialIndex = materialIndex;
                faceB.materialIndex = materialIndex;
            }
            fi = geometry.faces.length;
            if (hasFaceVertexUv) {
                for (i = 0; i < nUvLayers; i++) {
                    uvLayer = json.uvs[i];
                    geometry.faceVertexUvs[i][fi] = [];
                    geometry.faceVertexUvs[i][fi + 1] = [];
                    for (j = 0; j < 4; j++) {
                        uvIndex = faces[offset++];
                        u = uvLayer[uvIndex * 2];
                        v = uvLayer[uvIndex * 2 + 1];
                        uv = new Vector2(u, v);
                        if (j !== 2)
                            geometry.faceVertexUvs[i][fi].push(uv);
                        if (j !== 0)
                            geometry.faceVertexUvs[i][fi + 1].push(uv);
                    }
                }
            }
            if (hasFaceNormal) {
                normalIndex = faces[offset++] * 3;
                faceA.normal.set(normals[normalIndex++], normals[normalIndex++], normals[normalIndex]);
                faceB.normal.copy(faceA.normal);
            }
            if (hasFaceVertexNormal) {
                for (i = 0; i < 4; i++) {
                    normalIndex = faces[offset++] * 3;
                    normal = new Vector3(normals[normalIndex++], normals[normalIndex++], normals[normalIndex]);
                    if (i !== 2)
                        faceA.vertexNormals.push(normal);
                    if (i !== 0)
                        faceB.vertexNormals.push(normal);
                }
            }
            if (hasFaceColor) {
                colorIndex = faces[offset++];
                hex = colors[colorIndex];
                faceA.color.setHex(hex);
                faceB.color.setHex(hex);
            }
            if (hasFaceVertexColor) {
                for (i = 0; i < 4; i++) {
                    colorIndex = faces[offset++];
                    hex = colors[colorIndex];
                    if (i !== 2)
                        faceA.vertexColors.push(new Color(hex));
                    if (i !== 0)
                        faceB.vertexColors.push(new Color(hex));
                }
            }
            geometry.faces.push(faceA);
            geometry.faces.push(faceB);
        } else {
            face = new Face3();
            face.a = faces[offset++];
            face.b = faces[offset++];
            face.c = faces[offset++];
            if (hasMaterial) {
                materialIndex = faces[offset++];
                face.materialIndex = materialIndex;
            }
            fi = geometry.faces.length;
            if (hasFaceVertexUv) {
                for (i = 0; i < nUvLayers; i++) {
                    uvLayer = json.uvs[i];
                    geometry.faceVertexUvs[i][fi] = [];
                    for (j = 0; j < 3; j++) {
                        uvIndex = faces[offset++];
                        u = uvLayer[uvIndex * 2];
                        v = uvLayer[uvIndex * 2 + 1];
                        uv = new Vector2(u, v);
                        geometry.faceVertexUvs[i][fi].push(uv);
                    }
                }
            }
            if (hasFaceNormal) {
                normalIndex = faces[offset++] * 3;
                face.normal.set(normals[normalIndex++], normals[normalIndex++], normals[normalIndex]);
            }
            if (hasFaceVertexNormal) {
                for (i = 0; i < 3; i++) {
                    normalIndex = faces[offset++] * 3;
                    normal = new Vector3(normals[normalIndex++], normals[normalIndex++], normals[normalIndex]);
                    face.vertexNormals.push(normal);
                }
            }
            if (hasFaceColor) {
                colorIndex = faces[offset++];
                face.color.setHex(colors[colorIndex]);
            }
            if (hasFaceVertexColor) {
                for (i = 0; i < 3; i++) {
                    colorIndex = faces[offset++];
                    face.vertexColors.push(new Color(colors[colorIndex]));
                }
            }
            geometry.faces.push(face);
        }
    }
};
parseSkin = function parseSkin() {
    var influencesPerVertex = json.influencesPerVertex !== undefined ? json.influencesPerVertex : 2;
    if (json.skinWeights) {
        for (var i = 0, l = json.skinWeights.length; i < l; i += influencesPerVertex) {
            var x = json.skinWeights[i];
            var y = influencesPerVertex > 1 ? json.skinWeights[i + 1] : 0;
            var z = influencesPerVertex > 2 ? json.skinWeights[i + 2] : 0;
            var w = influencesPerVertex > 3 ? json.skinWeights[i + 3] : 0;
            geometry.skinWeights.push(new Vector4(x, y, z, w));
        }
    }
    if (json.skinIndices) {
        for (var i = 0, l = json.skinIndices.length; i < l; i += influencesPerVertex) {
            var a = json.skinIndices[i];
            var b = influencesPerVertex > 1 ? json.skinIndices[i + 1] : 0;
            var c = influencesPerVertex > 2 ? json.skinIndices[i + 2] : 0;
            var d = influencesPerVertex > 3 ? json.skinIndices[i + 3] : 0;
            geometry.skinIndices.push(new Vector4(a, b, c, d));
        }
    }
    geometry.bones = json.bones;
    if (geometry.bones && geometry.bones.length > 0 && (geometry.skinWeights.length !== geometry.skinIndices.length || geometry.skinIndices.length !== geometry.vertices.length)) {
        console.warn('When skinning, number of vertices (' + geometry.vertices.length + '), skinIndices (' + geometry.skinIndices.length + '), and skinWeights (' + geometry.skinWeights.length + ') should match.');
    }
};
parseMorphing = function parseMorphing(scale) {
    if (json.morphTargets !== undefined) {
        for (var i = 0, l = json.morphTargets.length; i < l; i++) {
            geometry.morphTargets[i] = {};
            geometry.morphTargets[i].name = json.morphTargets[i].name;
            geometry.morphTargets[i].vertices = [];
            var dstVertices = geometry.morphTargets[i].vertices;
            var srcVertices = json.morphTargets[i].vertices;
            for (var v = 0, vl = srcVertices.length; v < vl; v += 3) {
                var vertex = new Vector3();
                vertex.x = srcVertices[v] * scale;
                vertex.y = srcVertices[v + 1] * scale;
                vertex.z = srcVertices[v + 2] * scale;
                dstVertices.push(vertex);
            }
        }
    }
    if (json.morphColors !== undefined && json.morphColors.length > 0) {
        console.warn('THREE.JSONLoader: "morphColors" no longer supported. Using them as face colors.');
        var faces = geometry.faces;
        var morphColors = json.morphColors[0].colors;
        for (var i = 0, l = faces.length; i < l; i++) {
            faces[i].color.fromArray(morphColors, i * 3);
        }
    }
};
parseAnimations = function parseAnimations() {
    var outputAnimations = [];
    var animations = [];
    if (json.animation !== undefined) {
        animations.push(json.animation);
    }
    if (json.animations !== undefined) {
        if (json.animations.length) {
            animations = animations.concat(json.animations);
        } else {
            animations.push(json.animations);
        }
    }
    for (var i = 0; i < animations.length; i++) {
        var clip = AnimationClip.parseAnimation(animations[i], geometry.bones);
        if (clip)
            outputAnimations.push(clip);
    }
    if (geometry.morphTargets) {
        var morphAnimationClips = AnimationClip.CreateClipsFromMorphTargetSequences(geometry.morphTargets, 10);
        outputAnimations = outputAnimations.concat(morphAnimationClips);
    }
    if (outputAnimations.length > 0)
        geometry.animations = outputAnimations;
};
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
json = arguments[0], texturePath = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
geometry = new Geometry();
scale = json.scale !== undefined ? 1 / json.scale : 1;
parseModel(scale);
parseSkin();
parseMorphing(scale);
parseAnimations();
geometry.computeFaceNormals();
geometry.computeBoundingSphere();
if (json.materials === undefined || json.materials.length === 0) {
    return {
        geometry: geometry
    };
} else {
    materials = Loader.prototype.initMaterials(json.materials, texturePath, this.crossOrigin);
    return {
        geometry: geometry,
        materials: materials
    };
}})
    });
    Object['assign'](TAJS_restrictToType(ObjectLoader.prototype, 'object'), $__.os.oid488 = {
        'load': ($__.fs.J$__v494107025_2194_1142 = function J$__v494107025_2194(url, onLoad, onProgress, onError) {
var vvv_return, vvv_switch, scope, loader;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
url = arguments[0], onLoad = arguments[1], onProgress = arguments[2], onError = arguments[3];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (this.texturePath === '') {
    this.texturePath = url.substring(0, url.lastIndexOf('/') + 1);
}
scope = this;
loader = new XHRLoader(scope.manager);
loader.load(url, function (text) {
    scope.parse(JSON.parse(text), onLoad);
}, onProgress, onError);}),
        'setTexturePath': ($__.fs.J$__v494107025_2196_1143 = function J$__v494107025_2196(value) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
value = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.texturePath = value;}),
        'setCrossOrigin': ($__.fs.J$__v494107025_2198_1144 = function J$__v494107025_2198(value) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
value = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.crossOrigin = value;}),
        'parse': ($__.fs.J$__v494107025_2202_1145 = function J$__v494107025_2202(json, onLoad) {
var vvv_return, vvv_switch, geometries, images, textures, materials, object;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
json = arguments[0], onLoad = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
geometries = this.parseGeometries(json.geometries);
images = this.parseImages(json.images, function () {
    if (onLoad !== undefined)
        onLoad(object);
});
textures = this.parseTextures(json.textures, images);
materials = this.parseMaterials(json.materials, textures);
object = this.parseObject(json.object, geometries, materials);
if (json.animations) {
    object.animations = this.parseAnimations(json.animations);
}
if (json.images === undefined || json.images.length === 0) {
    if (onLoad !== undefined)
        onLoad(object);
}
return object;}),
        'parseGeometries': ($__.fs.J$__v494107025_2204_1146 = function J$__v494107025_2204(json) {
var vvv_return, vvv_switch, geometries, geometryLoader, bufferGeometryLoader, geometry, data;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
json = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
geometries = {};
if (json !== undefined) {
    geometryLoader = new JSONLoader();
    bufferGeometryLoader = new BufferGeometryLoader();
    for (var i = 0, l = json.length; i < l; i++) {
        data = json[i];
        switch (data.type) {
        case 'PlaneGeometry':
        case 'PlaneBufferGeometry':
            geometry = new THREE[data.type](data.width, data.height, data.widthSegments, data.heightSegments);
            break;
        case 'BoxGeometry':
        case 'BoxBufferGeometry':
        case 'CubeGeometry':
            geometry = new THREE[data.type](data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments);
            break;
        case 'CircleGeometry':
        case 'CircleBufferGeometry':
            geometry = new THREE[data.type](data.radius, data.segments, data.thetaStart, data.thetaLength);
            break;
        case 'CylinderGeometry':
        case 'CylinderBufferGeometry':
            geometry = new THREE[data.type](data.radiusTop, data.radiusBottom, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
            break;
        case 'ConeGeometry':
        case 'ConeBufferGeometry':
            geometry = new THREE[data.type](data.radius, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
            break;
        case 'SphereGeometry':
        case 'SphereBufferGeometry':
            geometry = new THREE[data.type](data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength);
            break;
        case 'DodecahedronGeometry':
        case 'IcosahedronGeometry':
        case 'OctahedronGeometry':
        case 'TetrahedronGeometry':
            geometry = new THREE[data.type](data.radius, data.detail);
            break;
        case 'RingGeometry':
        case 'RingBufferGeometry':
            geometry = new THREE[data.type](data.innerRadius, data.outerRadius, data.thetaSegments, data.phiSegments, data.thetaStart, data.thetaLength);
            break;
        case 'TorusGeometry':
        case 'TorusBufferGeometry':
            geometry = new THREE[data.type](data.radius, data.tube, data.radialSegments, data.tubularSegments, data.arc);
            break;
        case 'TorusKnotGeometry':
        case 'TorusKnotBufferGeometry':
            geometry = new THREE[data.type](data.radius, data.tube, data.tubularSegments, data.radialSegments, data.p, data.q);
            break;
        case 'LatheGeometry':
        case 'LatheBufferGeometry':
            geometry = new THREE[data.type](data.points, data.segments, data.phiStart, data.phiLength);
            break;
        case 'BufferGeometry':
            geometry = bufferGeometryLoader.parse(data);
            break;
        case 'Geometry':
            geometry = geometryLoader.parse(data.data, this.texturePath).geometry;
            break;
        default:
            console.warn('THREE.ObjectLoader: Unsupported geometry type "' + data.type + '"');
            continue;
        }
        geometry.uuid = data.uuid;
        if (data.name !== undefined)
            geometry.name = data.name;
        geometries[data.uuid] = geometry;
    }
}
return geometries;}),
        'parseMaterials': ($__.fs.J$__v494107025_2206_1147 = function J$__v494107025_2206(json, textures) {
var vvv_return, vvv_switch, materials, loader, material;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
json = arguments[0], textures = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
materials = {};
if (json !== undefined) {
    loader = new MaterialLoader();
    loader.setTextures(textures);
    for (var i = 0, l = json.length; i < l; i++) {
        material = loader.parse(json[i]);
        materials[material.uuid] = material;
    }
}
return materials;}),
        'parseAnimations': ($__.fs.J$__v494107025_2208_1148 = function J$__v494107025_2208(json) {
var vvv_return, vvv_switch, animations, clip;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
json = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
animations = [];
for (var i = 0; i < json.length; i++) {
    clip = AnimationClip.parse(json[i]);
    animations.push(clip);
}
return animations;}),
        'parseImages': ($__.fs.J$__v494107025_2215_1149 = function J$__v494107025_2215(json, onLoad) {
var vvv_return, vvv_switch, scope, images, loadImage, manager, loader, image, path;
loadImage = function loadImage(url) {
    scope.manager.itemStart(url);
    return loader.load(url, function () {
        scope.manager.itemEnd(url);
    }, undefined, function () {
        scope.manager.itemError(url);
    });
};
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
json = arguments[0], onLoad = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
scope = this;
images = {};
if (json !== undefined && json.length > 0) {
    manager = new LoadingManager(onLoad);
    loader = new ImageLoader(manager);
    loader.setCrossOrigin(this.crossOrigin);
    for (var i = 0, l = json.length; i < l; i++) {
        image = json[i];
        path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(image.url) ? image.url : scope.texturePath + image.url;
        images[image.uuid] = loadImage(path);
    }
}
return images;}),
        'parseTextures': ($__.fs.J$__v494107025_2218_1150 = function J$__v494107025_2218(json, images) {
var vvv_return, vvv_switch, parseConstant, textures, data, texture;
parseConstant = function parseConstant(value) {
    if (typeof value === 'number')
        return value;
    console.warn('THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value);
    return THREE[value];
};
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
json = arguments[0], images = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
textures = {};
if (json !== undefined) {
    for (var i = 0, l = json.length; i < l; i++) {
        data = json[i];
        if (data.image === undefined) {
            console.warn('THREE.ObjectLoader: No "image" specified for', data.uuid);
        }
        if (images[data.image] === undefined) {
            console.warn('THREE.ObjectLoader: Undefined image', data.image);
        }
        texture = new Texture(images[data.image]);
        texture.needsUpdate = true;
        texture.uuid = data.uuid;
        if (data.name !== undefined)
            texture.name = data.name;
        if (data.mapping !== undefined)
            texture.mapping = parseConstant(data.mapping);
        if (data.offset !== undefined)
            texture.offset.fromArray(data.offset);
        if (data.repeat !== undefined)
            texture.repeat.fromArray(data.repeat);
        if (data.wrap !== undefined) {
            texture.wrapS = parseConstant(data.wrap[0]);
            texture.wrapT = parseConstant(data.wrap[1]);
        }
        if (data.minFilter !== undefined)
            texture.minFilter = parseConstant(data.minFilter);
        if (data.magFilter !== undefined)
            texture.magFilter = parseConstant(data.magFilter);
        if (data.anisotropy !== undefined)
            texture.anisotropy = data.anisotropy;
        if (data.flipY !== undefined)
            texture.flipY = data.flipY;
        textures[data.uuid] = texture;
    }
}
return textures;}),
        'parseObject': (($__.fs.J$__v494107025_2223_1151 = function J$__v494107025_2223() {
var vvv_return, vvv_switch, matrix;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    matrix = new (Matrix4, $__.fs.Matrix4_9)(7, true, $__.uid);
    return ($__.fs.parseObject_1152 = function parseObject(data, geometries, materials) {
var vvv_return, vvv_switch, object, getGeometry, getMaterial, geometry, material, levels, level, child;
getGeometry = function getGeometry(name) {
    if (geometries[name] === undefined) {
        console.warn('THREE.ObjectLoader: Undefined geometry', name);
    }
    return geometries[name];
};
getMaterial = function getMaterial(name) {
    if (name === undefined)
        return undefined;
    if (materials[name] === undefined) {
        console.warn('THREE.ObjectLoader: Undefined material', name);
    }
    return materials[name];
};
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
data = arguments[0], geometries = arguments[1], materials = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
switch (data.type) {
case 'Scene':
    object = new Scene();
    if (data.background !== undefined) {
        if (Number.isInteger(data.background)) {
            object.background = new THREE.Color(data.background);
        }
    }
    if (data.fog !== undefined) {
        if (data.fog.type === 'Fog') {
            object.fog = new Fog(data.fog.color, data.fog.near, data.fog.far);
        } else if (data.fog.type === 'FogExp2') {
            object.fog = new FogExp2(data.fog.color, data.fog.density);
        }
    }
    break;
case 'PerspectiveCamera':
    object = new PerspectiveCamera(data.fov, data.aspect, data.near, data.far);
    if (data.focus !== undefined)
        object.focus = data.focus;
    if (data.zoom !== undefined)
        object.zoom = data.zoom;
    if (data.filmGauge !== undefined)
        object.filmGauge = data.filmGauge;
    if (data.filmOffset !== undefined)
        object.filmOffset = data.filmOffset;
    if (data.view !== undefined)
        object.view = Object.assign({}, data.view);
    break;
case 'OrthographicCamera':
    object = new OrthographicCamera(data.left, data.right, data.top, data.bottom, data.near, data.far);
    break;
case 'AmbientLight':
    object = new AmbientLight(data.color, data.intensity);
    break;
case 'DirectionalLight':
    object = new DirectionalLight(data.color, data.intensity);
    break;
case 'PointLight':
    object = new PointLight(data.color, data.intensity, data.distance, data.decay);
    break;
case 'SpotLight':
    object = new SpotLight(data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay);
    break;
case 'HemisphereLight':
    object = new HemisphereLight(data.color, data.groundColor, data.intensity);
    break;
case 'Mesh':
    geometry = getGeometry(data.geometry);
    material = getMaterial(data.material);
    if (geometry.bones && geometry.bones.length > 0) {
        object = new SkinnedMesh(geometry, material);
    } else {
        object = new Mesh(geometry, material);
    }
    break;
case 'LOD':
    object = new LOD();
    break;
case 'Line':
    object = new Line(getGeometry(data.geometry), getMaterial(data.material), data.mode);
    break;
case 'LineSegments':
    object = new LineSegments(getGeometry(data.geometry), getMaterial(data.material));
    break;
case 'PointCloud':
case 'Points':
    object = new Points(getGeometry(data.geometry), getMaterial(data.material));
    break;
case 'Sprite':
    object = new Sprite(getMaterial(data.material));
    break;
case 'Group':
    object = new Group();
    break;
default:
    object = new Object3D();
}
object.uuid = data.uuid;
if (data.name !== undefined)
    object.name = data.name;
if (data.matrix !== undefined) {
    matrix.fromArray(data.matrix);
    matrix.decompose(object.position, object.quaternion, object.scale);
} else {
    if (data.position !== undefined)
        object.position.fromArray(data.position);
    if (data.rotation !== undefined)
        object.rotation.fromArray(data.rotation);
    if (data.quaternion !== undefined)
        object.quaternion.fromArray(data.quaternion);
    if (data.scale !== undefined)
        object.scale.fromArray(data.scale);
}
if (data.castShadow !== undefined)
    object.castShadow = data.castShadow;
if (data.receiveShadow !== undefined)
    object.receiveShadow = data.receiveShadow;
if (data.shadow) {
    if (data.shadow.bias !== undefined)
        object.shadow.bias = data.shadow.bias;
    if (data.shadow.radius !== undefined)
        object.shadow.radius = data.shadow.radius;
    if (data.shadow.mapSize !== undefined)
        object.shadow.mapSize.fromArray(data.shadow.mapSize);
    if (data.shadow.camera !== undefined)
        object.shadow.camera = this.parseObject(data.shadow.camera);
}
if (data.visible !== undefined)
    object.visible = data.visible;
if (data.userData !== undefined)
    object.userData = data.userData;
if (data.children !== undefined) {
    for (var child in data.children) {
        object.add(this.parseObject(data.children[child], geometries, materials));
    }
}
if (data.type === 'LOD') {
    levels = data.levels;
    for (var l = 0; l < levels.length; l++) {
        level = levels[l];
        child = object.getObjectByProperty('uuid', level.object);
        if (child !== undefined) {
            object.addLevel(child, level.distance);
        }
    }
}
return object;});
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
matrix = new Matrix4();
return function parseObject(data, geometries, materials) {
    var object;
    function getGeometry(name) {
        if (geometries[name] === undefined) {
            console.warn('THREE.ObjectLoader: Undefined geometry', name);
        }
        return geometries[name];
    }
    function getMaterial(name) {
        if (name === undefined)
            return undefined;
        if (materials[name] === undefined) {
            console.warn('THREE.ObjectLoader: Undefined material', name);
        }
        return materials[name];
    }
    switch (data.type) {
    case 'Scene':
        object = new Scene();
        if (data.background !== undefined) {
            if (Number.isInteger(data.background)) {
                object.background = new THREE.Color(data.background);
            }
        }
        if (data.fog !== undefined) {
            if (data.fog.type === 'Fog') {
                object.fog = new Fog(data.fog.color, data.fog.near, data.fog.far);
            } else if (data.fog.type === 'FogExp2') {
                object.fog = new FogExp2(data.fog.color, data.fog.density);
            }
        }
        break;
    case 'PerspectiveCamera':
        object = new PerspectiveCamera(data.fov, data.aspect, data.near, data.far);
        if (data.focus !== undefined)
            object.focus = data.focus;
        if (data.zoom !== undefined)
            object.zoom = data.zoom;
        if (data.filmGauge !== undefined)
            object.filmGauge = data.filmGauge;
        if (data.filmOffset !== undefined)
            object.filmOffset = data.filmOffset;
        if (data.view !== undefined)
            object.view = Object.assign({}, data.view);
        break;
    case 'OrthographicCamera':
        object = new OrthographicCamera(data.left, data.right, data.top, data.bottom, data.near, data.far);
        break;
    case 'AmbientLight':
        object = new AmbientLight(data.color, data.intensity);
        break;
    case 'DirectionalLight':
        object = new DirectionalLight(data.color, data.intensity);
        break;
    case 'PointLight':
        object = new PointLight(data.color, data.intensity, data.distance, data.decay);
        break;
    case 'SpotLight':
        object = new SpotLight(data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay);
        break;
    case 'HemisphereLight':
        object = new HemisphereLight(data.color, data.groundColor, data.intensity);
        break;
    case 'Mesh':
        var geometry = getGeometry(data.geometry);
        var material = getMaterial(data.material);
        if (geometry.bones && geometry.bones.length > 0) {
            object = new SkinnedMesh(geometry, material);
        } else {
            object = new Mesh(geometry, material);
        }
        break;
    case 'LOD':
        object = new LOD();
        break;
    case 'Line':
        object = new Line(getGeometry(data.geometry), getMaterial(data.material), data.mode);
        break;
    case 'LineSegments':
        object = new LineSegments(getGeometry(data.geometry), getMaterial(data.material));
        break;
    case 'PointCloud':
    case 'Points':
        object = new Points(getGeometry(data.geometry), getMaterial(data.material));
        break;
    case 'Sprite':
        object = new Sprite(getMaterial(data.material));
        break;
    case 'Group':
        object = new Group();
        break;
    default:
        object = new Object3D();
    }
    object.uuid = data.uuid;
    if (data.name !== undefined)
        object.name = data.name;
    if (data.matrix !== undefined) {
        matrix.fromArray(data.matrix);
        matrix.decompose(object.position, object.quaternion, object.scale);
    } else {
        if (data.position !== undefined)
            object.position.fromArray(data.position);
        if (data.rotation !== undefined)
            object.rotation.fromArray(data.rotation);
        if (data.quaternion !== undefined)
            object.quaternion.fromArray(data.quaternion);
        if (data.scale !== undefined)
            object.scale.fromArray(data.scale);
    }
    if (data.castShadow !== undefined)
        object.castShadow = data.castShadow;
    if (data.receiveShadow !== undefined)
        object.receiveShadow = data.receiveShadow;
    if (data.shadow) {
        if (data.shadow.bias !== undefined)
            object.shadow.bias = data.shadow.bias;
        if (data.shadow.radius !== undefined)
            object.shadow.radius = data.shadow.radius;
        if (data.shadow.mapSize !== undefined)
            object.shadow.mapSize.fromArray(data.shadow.mapSize);
        if (data.shadow.camera !== undefined)
            object.shadow.camera = this.parseObject(data.shadow.camera);
    }
    if (data.visible !== undefined)
        object.visible = data.visible;
    if (data.userData !== undefined)
        object.userData = data.userData;
    if (data.children !== undefined) {
        for (var child in data.children) {
            object.add(this.parseObject(data.children[child], geometries, materials));
        }
    }
    if (data.type === 'LOD') {
        var levels = data.levels;
        for (var l = 0; l < levels.length; l++) {
            var level = levels[l];
            var child = object.getObjectByProperty('uuid', level.object);
            if (child !== undefined) {
                object.addLevel(child, level.distance);
            }
        }
    }
    return object;
};}), $__.fs.J$__v494107025_2223_1151)(0, true, $__.uid)
    });
    (exports, $__.os.oid0).ShapeUtils = $__.os.oid489 = {
        'area': ($__.fs.J$__v494107025_2225_1153 = function J$__v494107025_2225(contour) {
var vvv_return, vvv_switch, n, a;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
contour = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
n = contour.length;
a = 0;
for (var p = n - 1, q = 0; q < n; p = q++) {
    a += contour[p].x * contour[q].y - contour[q].x * contour[p].y;
}
return a * 0.5;}),
        'triangulate': (($__.fs.J$__v494107025_2229_1154 = function J$__v494107025_2229() {
var vvv_return, vvv_switch, snip;
snip = function snip(contour, u, v, w, n, verts) {
    var p;
    var ax, ay, bx, by;
    var cx, cy, px, py;
    ax = contour[verts[u]].x;
    ay = contour[verts[u]].y;
    bx = contour[verts[v]].x;
    by = contour[verts[v]].y;
    cx = contour[verts[w]].x;
    cy = contour[verts[w]].y;
    if (Number.EPSILON > (bx - ax) * (cy - ay) - (by - ay) * (cx - ax))
        return false;
    var aX, aY, bX, bY, cX, cY;
    var apx, apy, bpx, bpy, cpx, cpy;
    var cCROSSap, bCROSScp, aCROSSbp;
    aX = cx - bx;
    aY = cy - by;
    bX = ax - cx;
    bY = ay - cy;
    cX = bx - ax;
    cY = by - ay;
    for (p = 0; p < n; p++) {
        px = contour[verts[p]].x;
        py = contour[verts[p]].y;
        if (px === ax && py === ay || px === bx && py === by || px === cx && py === cy)
            continue;
        apx = px - ax;
        apy = py - ay;
        bpx = px - bx;
        bpy = py - by;
        cpx = px - cx;
        cpy = py - cy;
        aCROSSbp = aX * bpy - aY * bpx;
        cCROSSap = cX * apy - cY * apx;
        bCROSScp = bX * cpy - bY * cpx;
        if (aCROSSbp >= -Number.EPSILON && bCROSScp >= -Number.EPSILON && cCROSSap >= -Number.EPSILON)
            return false;
    }
    return true;
};
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    snip = ($__.fs.snip_1155 = function snip(contour, u, v, w, n, verts) {
var vvv_return, vvv_switch, p, ax, ay, bx, by, cx, cy, px, py, aX, aY, bX, bY, cX, cY, apx, apy, bpx, bpy, cpx, cpy, cCROSSap, bCROSScp, aCROSSbp;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
contour = arguments[0], u = arguments[1], v = arguments[2], w = arguments[3], n = arguments[4], verts = arguments[5];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
ax = contour[verts[u]].x;
ay = contour[verts[u]].y;
bx = contour[verts[v]].x;
by = contour[verts[v]].y;
cx = contour[verts[w]].x;
cy = contour[verts[w]].y;
if (Number.EPSILON > (bx - ax) * (cy - ay) - (by - ay) * (cx - ax))
    return false;
aX = cx - bx;
aY = cy - by;
bX = ax - cx;
bY = ay - cy;
cX = bx - ax;
cY = by - ay;
for (p = 0; p < n; p++) {
    px = contour[verts[p]].x;
    py = contour[verts[p]].y;
    if (px === ax && py === ay || px === bx && py === by || px === cx && py === cy)
        continue;
    apx = px - ax;
    apy = py - ay;
    bpx = px - bx;
    bpy = py - by;
    cpx = px - cx;
    cpy = py - cy;
    aCROSSbp = aX * bpy - aY * bpx;
    cCROSSap = cX * apy - cY * apx;
    bCROSScp = bX * cpy - bY * cpx;
    if (aCROSSbp >= -Number.EPSILON && bCROSScp >= -Number.EPSILON && cCROSSap >= -Number.EPSILON)
        return false;
}
return true;});
    return ($__.fs.triangulate_1156 = function triangulate(contour, indices) {
var vvv_return, vvv_switch, n, result, verts, vertIndices, u, v, w, nv, count, a, b, c, s, t;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
contour = arguments[0], indices = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
n = contour.length;
if (n < 3)
    return null;
result = [];
verts = [];
vertIndices = [];
if (exports.ShapeUtils.area(contour) > 0) {
    for (v = 0; v < n; v++)
        verts[v] = v;
} else {
    for (v = 0; v < n; v++)
        verts[v] = n - 1 - v;
}
nv = n;
count = 2 * nv;
for (v = nv - 1; nv > 2;) {
    if (count-- <= 0) {
        console.warn('THREE.ShapeUtils: Unable to triangulate polygon! in triangulate()');
        if (indices)
            return vertIndices;
        return result;
    }
    u = v;
    if (nv <= u)
        u = 0;
    v = u + 1;
    if (nv <= v)
        v = 0;
    w = v + 1;
    if (nv <= w)
        w = 0;
    if (snip(contour, u, v, w, nv, verts)) {
        a = verts[u];
        b = verts[v];
        c = verts[w];
        result.push([
            contour[a],
            contour[b],
            contour[c]
        ]);
        vertIndices.push([
            verts[u],
            verts[v],
            verts[w]
        ]);
        for (s = v, t = v + 1; t < nv; s++, t++) {
            verts[s] = verts[t];
        }
        nv--;
        count = 2 * nv;
    }
}
if (indices)
    return vertIndices;
return result;});
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return function triangulate(contour, indices) {
    var n = contour.length;
    if (n < 3)
        return null;
    var result = [], verts = [], vertIndices = [];
    var u, v, w;
    if (exports.ShapeUtils.area(contour) > 0) {
        for (v = 0; v < n; v++)
            verts[v] = v;
    } else {
        for (v = 0; v < n; v++)
            verts[v] = n - 1 - v;
    }
    var nv = n;
    var count = 2 * nv;
    for (v = nv - 1; nv > 2;) {
        if (count-- <= 0) {
            console.warn('THREE.ShapeUtils: Unable to triangulate polygon! in triangulate()');
            if (indices)
                return vertIndices;
            return result;
        }
        u = v;
        if (nv <= u)
            u = 0;
        v = u + 1;
        if (nv <= v)
            v = 0;
        w = v + 1;
        if (nv <= w)
            w = 0;
        if (snip(contour, u, v, w, nv, verts)) {
            var a, b, c, s, t;
            a = verts[u];
            b = verts[v];
            c = verts[w];
            result.push([
                contour[a],
                contour[b],
                contour[c]
            ]);
            vertIndices.push([
                verts[u],
                verts[v],
                verts[w]
            ]);
            for (s = v, t = v + 1; t < nv; s++, t++) {
                verts[s] = verts[t];
            }
            nv--;
            count = 2 * nv;
        }
    }
    if (indices)
        return vertIndices;
    return result;
};}), $__.fs.J$__v494107025_2229_1154)(0, true, $__.uid),
        'triangulateShape': ($__.fs.J$__v494107025_2239_1157 = function J$__v494107025_2239(contour, holes) {
var vvv_return, vvv_switch, removeDupEndPts, point_in_segment_2D_colin, intersect_segments_2D, isPointInsideAngle, removeHoles, i, il, f, face, key, index, allPointsMap, allpoints, shapeWithoutHoles, triangles;
removeDupEndPts = function removeDupEndPts(points) {
    var l = points.length;
    if (l > 2 && points[l - 1].equals(points[0])) {
        points.pop();
    }
};
point_in_segment_2D_colin = function point_in_segment_2D_colin(inSegPt1, inSegPt2, inOtherPt) {
    if (inSegPt1.x !== inSegPt2.x) {
        if (inSegPt1.x < inSegPt2.x) {
            return inSegPt1.x <= inOtherPt.x && inOtherPt.x <= inSegPt2.x;
        } else {
            return inSegPt2.x <= inOtherPt.x && inOtherPt.x <= inSegPt1.x;
        }
    } else {
        if (inSegPt1.y < inSegPt2.y) {
            return inSegPt1.y <= inOtherPt.y && inOtherPt.y <= inSegPt2.y;
        } else {
            return inSegPt2.y <= inOtherPt.y && inOtherPt.y <= inSegPt1.y;
        }
    }
};
intersect_segments_2D = function intersect_segments_2D(inSeg1Pt1, inSeg1Pt2, inSeg2Pt1, inSeg2Pt2, inExcludeAdjacentSegs) {
    var seg1dx = inSeg1Pt2.x - inSeg1Pt1.x, seg1dy = inSeg1Pt2.y - inSeg1Pt1.y;
    var seg2dx = inSeg2Pt2.x - inSeg2Pt1.x, seg2dy = inSeg2Pt2.y - inSeg2Pt1.y;
    var seg1seg2dx = inSeg1Pt1.x - inSeg2Pt1.x;
    var seg1seg2dy = inSeg1Pt1.y - inSeg2Pt1.y;
    var limit = seg1dy * seg2dx - seg1dx * seg2dy;
    var perpSeg1 = seg1dy * seg1seg2dx - seg1dx * seg1seg2dy;
    if (Math.abs(limit) > Number.EPSILON) {
        var perpSeg2;
        if (limit > 0) {
            if (perpSeg1 < 0 || perpSeg1 > limit)
                return [];
            perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;
            if (perpSeg2 < 0 || perpSeg2 > limit)
                return [];
        } else {
            if (perpSeg1 > 0 || perpSeg1 < limit)
                return [];
            perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;
            if (perpSeg2 > 0 || perpSeg2 < limit)
                return [];
        }
        if (perpSeg2 === 0) {
            if (inExcludeAdjacentSegs && (perpSeg1 === 0 || perpSeg1 === limit))
                return [];
            return [inSeg1Pt1];
        }
        if (perpSeg2 === limit) {
            if (inExcludeAdjacentSegs && (perpSeg1 === 0 || perpSeg1 === limit))
                return [];
            return [inSeg1Pt2];
        }
        if (perpSeg1 === 0)
            return [inSeg2Pt1];
        if (perpSeg1 === limit)
            return [inSeg2Pt2];
        var factorSeg1 = perpSeg2 / limit;
        return [{
                x: inSeg1Pt1.x + factorSeg1 * seg1dx,
                y: inSeg1Pt1.y + factorSeg1 * seg1dy
            }];
    } else {
        if (perpSeg1 !== 0 || seg2dy * seg1seg2dx !== seg2dx * seg1seg2dy)
            return [];
        var seg1Pt = seg1dx === 0 && seg1dy === 0;
        var seg2Pt = seg2dx === 0 && seg2dy === 0;
        if (seg1Pt && seg2Pt) {
            if (inSeg1Pt1.x !== inSeg2Pt1.x || inSeg1Pt1.y !== inSeg2Pt1.y)
                return [];
            return [inSeg1Pt1];
        }
        if (seg1Pt) {
            if (!point_in_segment_2D_colin(inSeg2Pt1, inSeg2Pt2, inSeg1Pt1))
                return [];
            return [inSeg1Pt1];
        }
        if (seg2Pt) {
            if (!point_in_segment_2D_colin(inSeg1Pt1, inSeg1Pt2, inSeg2Pt1))
                return [];
            return [inSeg2Pt1];
        }
        var seg1min, seg1max, seg1minVal, seg1maxVal;
        var seg2min, seg2max, seg2minVal, seg2maxVal;
        if (seg1dx !== 0) {
            if (inSeg1Pt1.x < inSeg1Pt2.x) {
                seg1min = inSeg1Pt1;
                seg1minVal = inSeg1Pt1.x;
                seg1max = inSeg1Pt2;
                seg1maxVal = inSeg1Pt2.x;
            } else {
                seg1min = inSeg1Pt2;
                seg1minVal = inSeg1Pt2.x;
                seg1max = inSeg1Pt1;
                seg1maxVal = inSeg1Pt1.x;
            }
            if (inSeg2Pt1.x < inSeg2Pt2.x) {
                seg2min = inSeg2Pt1;
                seg2minVal = inSeg2Pt1.x;
                seg2max = inSeg2Pt2;
                seg2maxVal = inSeg2Pt2.x;
            } else {
                seg2min = inSeg2Pt2;
                seg2minVal = inSeg2Pt2.x;
                seg2max = inSeg2Pt1;
                seg2maxVal = inSeg2Pt1.x;
            }
        } else {
            if (inSeg1Pt1.y < inSeg1Pt2.y) {
                seg1min = inSeg1Pt1;
                seg1minVal = inSeg1Pt1.y;
                seg1max = inSeg1Pt2;
                seg1maxVal = inSeg1Pt2.y;
            } else {
                seg1min = inSeg1Pt2;
                seg1minVal = inSeg1Pt2.y;
                seg1max = inSeg1Pt1;
                seg1maxVal = inSeg1Pt1.y;
            }
            if (inSeg2Pt1.y < inSeg2Pt2.y) {
                seg2min = inSeg2Pt1;
                seg2minVal = inSeg2Pt1.y;
                seg2max = inSeg2Pt2;
                seg2maxVal = inSeg2Pt2.y;
            } else {
                seg2min = inSeg2Pt2;
                seg2minVal = inSeg2Pt2.y;
                seg2max = inSeg2Pt1;
                seg2maxVal = inSeg2Pt1.y;
            }
        }
        if (seg1minVal <= seg2minVal) {
            if (seg1maxVal < seg2minVal)
                return [];
            if (seg1maxVal === seg2minVal) {
                if (inExcludeAdjacentSegs)
                    return [];
                return [seg2min];
            }
            if (seg1maxVal <= seg2maxVal)
                return [
                seg2min,
                seg1max
            ];
            return [
                seg2min,
                seg2max
            ];
        } else {
            if (seg1minVal > seg2maxVal)
                return [];
            if (seg1minVal === seg2maxVal) {
                if (inExcludeAdjacentSegs)
                    return [];
                return [seg1min];
            }
            if (seg1maxVal <= seg2maxVal)
                return [
                seg1min,
                seg1max
            ];
            return [
                seg1min,
                seg2max
            ];
        }
    }
};
isPointInsideAngle = function isPointInsideAngle(inVertex, inLegFromPt, inLegToPt, inOtherPt) {
    var legFromPtX = inLegFromPt.x - inVertex.x, legFromPtY = inLegFromPt.y - inVertex.y;
    var legToPtX = inLegToPt.x - inVertex.x, legToPtY = inLegToPt.y - inVertex.y;
    var otherPtX = inOtherPt.x - inVertex.x, otherPtY = inOtherPt.y - inVertex.y;
    var from2toAngle = legFromPtX * legToPtY - legFromPtY * legToPtX;
    var from2otherAngle = legFromPtX * otherPtY - legFromPtY * otherPtX;
    if (Math.abs(from2toAngle) > Number.EPSILON) {
        var other2toAngle = otherPtX * legToPtY - otherPtY * legToPtX;
        if (from2toAngle > 0) {
            return from2otherAngle >= 0 && other2toAngle >= 0;
        } else {
            return from2otherAngle >= 0 || other2toAngle >= 0;
        }
    } else {
        return from2otherAngle > 0;
    }
};
removeHoles = function removeHoles(contour, holes) {
    var shape = contour.concat();
    var hole;
    function isCutLineInsideAngles(inShapeIdx, inHoleIdx) {
        var lastShapeIdx = shape.length - 1;
        var prevShapeIdx = inShapeIdx - 1;
        if (prevShapeIdx < 0)
            prevShapeIdx = lastShapeIdx;
        var nextShapeIdx = inShapeIdx + 1;
        if (nextShapeIdx > lastShapeIdx)
            nextShapeIdx = 0;
        var insideAngle = isPointInsideAngle(shape[inShapeIdx], shape[prevShapeIdx], shape[nextShapeIdx], hole[inHoleIdx]);
        if (!insideAngle) {
            return false;
        }
        var lastHoleIdx = hole.length - 1;
        var prevHoleIdx = inHoleIdx - 1;
        if (prevHoleIdx < 0)
            prevHoleIdx = lastHoleIdx;
        var nextHoleIdx = inHoleIdx + 1;
        if (nextHoleIdx > lastHoleIdx)
            nextHoleIdx = 0;
        insideAngle = isPointInsideAngle(hole[inHoleIdx], hole[prevHoleIdx], hole[nextHoleIdx], shape[inShapeIdx]);
        if (!insideAngle) {
            return false;
        }
        return true;
    }
    function intersectsShapeEdge(inShapePt, inHolePt) {
        var sIdx, nextIdx, intersection;
        for (sIdx = 0; sIdx < shape.length; sIdx++) {
            nextIdx = sIdx + 1;
            nextIdx %= shape.length;
            intersection = intersect_segments_2D(inShapePt, inHolePt, shape[sIdx], shape[nextIdx], true);
            if (intersection.length > 0)
                return true;
        }
        return false;
    }
    var indepHoles = [];
    function intersectsHoleEdge(inShapePt, inHolePt) {
        var ihIdx, chkHole, hIdx, nextIdx, intersection;
        for (ihIdx = 0; ihIdx < indepHoles.length; ihIdx++) {
            chkHole = holes[indepHoles[ihIdx]];
            for (hIdx = 0; hIdx < chkHole.length; hIdx++) {
                nextIdx = hIdx + 1;
                nextIdx %= chkHole.length;
                intersection = intersect_segments_2D(inShapePt, inHolePt, chkHole[hIdx], chkHole[nextIdx], true);
                if (intersection.length > 0)
                    return true;
            }
        }
        return false;
    }
    var holeIndex, shapeIndex, shapePt, holePt, holeIdx, cutKey, failedCuts = [], tmpShape1, tmpShape2, tmpHole1, tmpHole2;
    for (var h = 0, hl = holes.length; h < hl; h++) {
        indepHoles.push(h);
    }
    var minShapeIndex = 0;
    var counter = indepHoles.length * 2;
    while (indepHoles.length > 0) {
        counter--;
        if (counter < 0) {
            console.log('Infinite Loop! Holes left:' + indepHoles.length + ', Probably Hole outside Shape!');
            break;
        }
        for (shapeIndex = minShapeIndex; shapeIndex < shape.length; shapeIndex++) {
            shapePt = shape[shapeIndex];
            holeIndex = -1;
            for (var h = 0; h < indepHoles.length; h++) {
                holeIdx = indepHoles[h];
                cutKey = shapePt.x + ':' + shapePt.y + ':' + holeIdx;
                if (failedCuts[cutKey] !== undefined)
                    continue;
                hole = holes[holeIdx];
                for (var h2 = 0; h2 < hole.length; h2++) {
                    holePt = hole[h2];
                    if (!isCutLineInsideAngles(shapeIndex, h2))
                        continue;
                    if (intersectsShapeEdge(shapePt, holePt))
                        continue;
                    if (intersectsHoleEdge(shapePt, holePt))
                        continue;
                    holeIndex = h2;
                    indepHoles.splice(h, 1);
                    tmpShape1 = shape.slice(0, shapeIndex + 1);
                    tmpShape2 = shape.slice(shapeIndex);
                    tmpHole1 = hole.slice(holeIndex);
                    tmpHole2 = hole.slice(0, holeIndex + 1);
                    shape = tmpShape1.concat(tmpHole1).concat(tmpHole2).concat(tmpShape2);
                    minShapeIndex = shapeIndex;
                    break;
                }
                if (holeIndex >= 0)
                    break;
                failedCuts[cutKey] = true;
            }
            if (holeIndex >= 0)
                break;
        }
    }
    return shape;
};
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
contour = arguments[0], holes = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
removeDupEndPts(contour);
holes.forEach(removeDupEndPts);
allPointsMap = {};
allpoints = contour.concat();
for (var h = 0, hl = holes.length; h < hl; h++) {
    Array.prototype.push.apply(allpoints, holes[h]);
}
for (i = 0, il = allpoints.length; i < il; i++) {
    key = allpoints[i].x + ':' + allpoints[i].y;
    if (allPointsMap[key] !== undefined) {
        console.warn('THREE.ShapeUtils: Duplicate point', key, i);
    }
    allPointsMap[key] = i;
}
shapeWithoutHoles = removeHoles(contour, holes);
triangles = exports.ShapeUtils.triangulate(shapeWithoutHoles, false);
for (i = 0, il = triangles.length; i < il; i++) {
    face = triangles[i];
    for (f = 0; f < 3; f++) {
        key = face[f].x + ':' + face[f].y;
        index = allPointsMap[key];
        if (index !== undefined) {
            face[f] = index;
        }
    }
}
return triangles.concat();}),
        'isClockWise': ($__.fs.J$__v494107025_2241_1158 = function J$__v494107025_2241(pts) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
pts = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return exports.ShapeUtils.area(pts) < 0;}),
        'b2': (($__.fs.J$__v494107025_2247_1159 = function J$__v494107025_2247() {
var vvv_return, vvv_switch, b2p0, b2p1, b2p2;
b2p0 = function b2p0(t, p) {
    var k = 1 - t;
    return k * k * p;
};
b2p1 = function b2p1(t, p) {
    return 2 * (1 - t) * t * p;
};
b2p2 = function b2p2(t, p) {
    return t * t * p;
};
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    b2p0 = ($__.fs.b2p0_1160 = function b2p0(t, p) {
var vvv_return, vvv_switch, k;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
t = arguments[0], p = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
k = 1 - t;
return k * k * p;});
    b2p1 = ($__.fs.b2p1_1161 = function b2p1(t, p) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
t = arguments[0], p = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return 2 * (1 - t) * t * p;});
    b2p2 = ($__.fs.b2p2_1162 = function b2p2(t, p) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
t = arguments[0], p = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return t * t * p;});
    return ($__.fs.b2_1163 = function b2(t, p0, p1, p2) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
t = arguments[0], p0 = arguments[1], p1 = arguments[2], p2 = arguments[3];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return b2p0(t, p0) + b2p1(t, p1) + b2p2(t, p2);});
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return function b2(t, p0, p1, p2) {
    return b2p0(t, p0) + b2p1(t, p1) + b2p2(t, p2);
};}), $__.fs.J$__v494107025_2247_1159)(0, true, $__.uid),
        'b3': (($__.fs.J$__v494107025_2254_1164 = function J$__v494107025_2254() {
var vvv_return, vvv_switch, b3p0, b3p1, b3p2, b3p3;
b3p0 = function b3p0(t, p) {
    var k = 1 - t;
    return k * k * k * p;
};
b3p1 = function b3p1(t, p) {
    var k = 1 - t;
    return 3 * k * k * t * p;
};
b3p2 = function b3p2(t, p) {
    var k = 1 - t;
    return 3 * k * t * t * p;
};
b3p3 = function b3p3(t, p) {
    return t * t * t * p;
};
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    b3p0 = ($__.fs.b3p0_1165 = function b3p0(t, p) {
var vvv_return, vvv_switch, k;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
t = arguments[0], p = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
k = 1 - t;
return k * k * k * p;});
    b3p1 = ($__.fs.b3p1_1166 = function b3p1(t, p) {
var vvv_return, vvv_switch, k;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
t = arguments[0], p = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
k = 1 - t;
return 3 * k * k * t * p;});
    b3p2 = ($__.fs.b3p2_1167 = function b3p2(t, p) {
var vvv_return, vvv_switch, k;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
t = arguments[0], p = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
k = 1 - t;
return 3 * k * t * t * p;});
    b3p3 = ($__.fs.b3p3_1168 = function b3p3(t, p) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
t = arguments[0], p = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return t * t * t * p;});
    return ($__.fs.b3_1169 = function b3(t, p0, p1, p2, p3) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
t = arguments[0], p0 = arguments[1], p1 = arguments[2], p2 = arguments[3], p3 = arguments[4];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return b3p0(t, p0) + b3p1(t, p1) + b3p2(t, p2) + b3p3(t, p3);});
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return function b3(t, p0, p1, p2, p3) {
    return b3p0(t, p0) + b3p1(t, p1) + b3p2(t, p2) + b3p3(t, p3);
};}), $__.fs.J$__v494107025_2254_1164)(0, true, $__.uid)
    };
    Curve.prototype = $__.os.oid490 = {
        'constructor': Curve,
        'getPoint': ($__.fs.J$__v494107025_2257_1170 = function J$__v494107025_2257(t) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
t = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
console.warn('THREE.Curve: Warning, getPoint() not implemented!');
return null;}),
        'getPointAt': ($__.fs.J$__v494107025_2259_1171 = function J$__v494107025_2259(u) {
var vvv_return, vvv_switch, t;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
u = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
t = this.getUtoTmapping(u);
return this.getPoint(t);}),
        'getPoints': ($__.fs.J$__v494107025_2261_1172 = function J$__v494107025_2261(divisions) {
var vvv_return, vvv_switch, points;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
divisions = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (!divisions)
    divisions = 5;
points = [];
for (var d = 0; d <= divisions; d++) {
    points.push(this.getPoint(d / divisions));
}
return points;}),
        'getSpacedPoints': ($__.fs.J$__v494107025_2263_1173 = function J$__v494107025_2263(divisions) {
var vvv_return, vvv_switch, points;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
divisions = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (!divisions)
    divisions = 5;
points = [];
for (var d = 0; d <= divisions; d++) {
    points.push(this.getPointAt(d / divisions));
}
return points;}),
        'getLength': ($__.fs.J$__v494107025_2265_1174 = function J$__v494107025_2265() {
var vvv_return, vvv_switch, lengths;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
lengths = this.getLengths();
return lengths[lengths.length - 1];}),
        'getLengths': ($__.fs.J$__v494107025_2267_1175 = function J$__v494107025_2267(divisions) {
var vvv_return, vvv_switch, cache, current, last, p, sum;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
divisions = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (!divisions)
    divisions = this.__arcLengthDivisions ? this.__arcLengthDivisions : 200;
if (this.cacheArcLengths && this.cacheArcLengths.length === divisions + 1 && !this.needsUpdate) {
    return this.cacheArcLengths;
}
this.needsUpdate = false;
cache = [];
last = this.getPoint(0);
sum = 0;
cache.push(0);
for (p = 1; p <= divisions; p++) {
    current = this.getPoint(p / divisions);
    sum += current.distanceTo(last);
    cache.push(sum);
    last = current;
}
this.cacheArcLengths = cache;
return cache;}),
        'updateArcLengths': ($__.fs.J$__v494107025_2269_1176 = function J$__v494107025_2269() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.needsUpdate = true;
this.getLengths();}),
        'getUtoTmapping': ($__.fs.J$__v494107025_2271_1177 = function J$__v494107025_2271(u, distance) {
var vvv_return, vvv_switch, arcLengths, i, il, targetArcLength, low, high, comparison, t, lengthBefore, lengthAfter, segmentLength, segmentFraction;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
u = arguments[0], distance = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
arcLengths = this.getLengths();
i = 0;
il = arcLengths.length;
if (distance) {
    targetArcLength = distance;
} else {
    targetArcLength = u * arcLengths[il - 1];
}
low = 0;
high = il - 1;
while (low <= high) {
    i = Math.floor(low + (high - low) / 2);
    comparison = arcLengths[i] - targetArcLength;
    if (comparison < 0) {
        low = i + 1;
    } else if (comparison > 0) {
        high = i - 1;
    } else {
        high = i;
        break;
    }
}
i = high;
if (arcLengths[i] === targetArcLength) {
    t = i / (il - 1);
    return t;
}
lengthBefore = arcLengths[i];
lengthAfter = arcLengths[i + 1];
segmentLength = lengthAfter - lengthBefore;
segmentFraction = (targetArcLength - lengthBefore) / segmentLength;
t = (i + segmentFraction) / (il - 1);
return t;}),
        'getTangent': ($__.fs.J$__v494107025_2273_1178 = function J$__v494107025_2273(t) {
var vvv_return, vvv_switch, delta, t1, t2, pt1, pt2, vec;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
t = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
delta = 0.0001;
t1 = t - delta;
t2 = t + delta;
if (t1 < 0)
    t1 = 0;
if (t2 > 1)
    t2 = 1;
pt1 = this.getPoint(t1);
pt2 = this.getPoint(t2);
vec = pt2.clone().sub(pt1);
return vec.normalize();}),
        'getTangentAt': ($__.fs.J$__v494107025_2275_1179 = function J$__v494107025_2275(u) {
var vvv_return, vvv_switch, t;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
u = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
t = this.getUtoTmapping(u);
return this.getTangent(t);})
    };
    Curve.create = ($__.fs.J$__v494107025_2277_1180 = function J$__v494107025_2277(constructor, getPointFunc) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
constructor = arguments[0], getPointFunc = arguments[1];
switch (vvv_switch) {
case 0:
case 1:
case 2:
case 3:
case 4:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(0 <= vvv_switch && vvv_switch <= 4);
    constructor.prototype = Object['create']((Curve.prototype, $__.os.oid490));
    TAJS_restrictToType(constructor.prototype, 'object').constructor = constructor;
    TAJS_restrictToType(constructor.prototype, 'object').getPoint = getPointFunc;
    return constructor;
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
constructor.prototype = Object.create(Curve.prototype);
constructor.prototype.constructor = constructor;
constructor.prototype.getPoint = getPointFunc;
return constructor;});
    LineCurve.prototype = Object['create']((Curve.prototype, $__.os.oid490));
    TAJS_restrictToType(LineCurve.prototype, 'object').constructor = LineCurve;
    TAJS_restrictToType(LineCurve.prototype, 'object').isLineCurve = true;
    TAJS_restrictToType(LineCurve.prototype, 'object').getPoint = ($__.fs.J$__v494107025_2280_1181 = function J$__v494107025_2280(t) {
var vvv_return, vvv_switch, point;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
t = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (t === 1) {
    return this.v2.clone();
}
point = this.v2.clone().sub(this.v1);
point.multiplyScalar(t).add(this.v1);
return point;});
    TAJS_restrictToType(LineCurve.prototype, 'object').getPointAt = ($__.fs.J$__v494107025_2282_1182 = function J$__v494107025_2282(u) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
u = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return this.getPoint(u);});
    TAJS_restrictToType(LineCurve.prototype, 'object').getTangent = ($__.fs.J$__v494107025_2284_1183 = function J$__v494107025_2284(t) {
var vvv_return, vvv_switch, tangent;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
t = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
tangent = this.v2.clone().sub(this.v1);
return tangent.normalize();});
    CurvePath.prototype = Object['assign'](Object['create']((Curve.prototype, $__.os.oid490)), $__.os.oid491 = {
        'constructor': CurvePath,
        'add': ($__.fs.J$__v494107025_2287_1184 = function J$__v494107025_2287(curve) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
curve = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.curves.push(curve);}),
        'closePath': ($__.fs.J$__v494107025_2289_1185 = function J$__v494107025_2289() {
var vvv_return, vvv_switch, startPoint, endPoint;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
startPoint = this.curves[0].getPoint(0);
endPoint = this.curves[this.curves.length - 1].getPoint(1);
if (!startPoint.equals(endPoint)) {
    this.curves.push(new LineCurve(endPoint, startPoint));
}}),
        'getPoint': ($__.fs.J$__v494107025_2291_1186 = function J$__v494107025_2291(t) {
var vvv_return, vvv_switch, d, curveLengths, i, diff, curve, segmentLength, u;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
t = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
d = t * this.getLength();
curveLengths = this.getCurveLengths();
i = 0;
while (i < curveLengths.length) {
    if (curveLengths[i] >= d) {
        diff = curveLengths[i] - d;
        curve = this.curves[i];
        segmentLength = curve.getLength();
        u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;
        return curve.getPointAt(u);
    }
    i++;
}
return null;}),
        'getLength': ($__.fs.J$__v494107025_2293_1187 = function J$__v494107025_2293() {
var vvv_return, vvv_switch, lens;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
lens = this.getCurveLengths();
return lens[lens.length - 1];}),
        'updateArcLengths': ($__.fs.J$__v494107025_2295_1188 = function J$__v494107025_2295() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.needsUpdate = true;
this.cacheLengths = null;
this.getLengths();}),
        'getCurveLengths': ($__.fs.J$__v494107025_2297_1189 = function J$__v494107025_2297() {
var vvv_return, vvv_switch, lengths, sums;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (this.cacheLengths && this.cacheLengths.length === this.curves.length) {
    return this.cacheLengths;
}
lengths = [];
sums = 0;
for (var i = 0, l = this.curves.length; i < l; i++) {
    sums += this.curves[i].getLength();
    lengths.push(sums);
}
this.cacheLengths = lengths;
return lengths;}),
        'getSpacedPoints': ($__.fs.J$__v494107025_2299_1190 = function J$__v494107025_2299(divisions) {
var vvv_return, vvv_switch, points;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
divisions = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (!divisions)
    divisions = 40;
points = [];
for (var i = 0; i <= divisions; i++) {
    points.push(this.getPoint(i / divisions));
}
if (this.autoClose) {
    points.push(points[0]);
}
return points;}),
        'getPoints': ($__.fs.J$__v494107025_2301_1191 = function J$__v494107025_2301(divisions) {
var vvv_return, vvv_switch, points, last, curve, resolution, pts, point;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
divisions = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
divisions = divisions || 12;
points = [];
for (var i = 0, curves = this.curves; i < curves.length; i++) {
    curve = curves[i];
    resolution = curve && curve.isEllipseCurve ? divisions * 2 : curve && curve.isLineCurve ? 1 : curve && curve.isSplineCurve ? divisions * curve.points.length : divisions;
    pts = curve.getPoints(resolution);
    for (var j = 0; j < pts.length; j++) {
        point = pts[j];
        if (last && last.equals(point))
            continue;
        points.push(point);
        last = point;
    }
}
if (this.autoClose && points.length > 1 && !points[points.length - 1].equals(points[0])) {
    points.push(points[0]);
}
return points;}),
        'createPointsGeometry': ($__.fs.J$__v494107025_2303_1192 = function J$__v494107025_2303(divisions) {
var vvv_return, vvv_switch, pts;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
divisions = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
pts = this.getPoints(divisions);
return this.createGeometry(pts);}),
        'createSpacedPointsGeometry': ($__.fs.J$__v494107025_2305_1193 = function J$__v494107025_2305(divisions) {
var vvv_return, vvv_switch, pts;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
divisions = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
pts = this.getSpacedPoints(divisions);
return this.createGeometry(pts);}),
        'createGeometry': ($__.fs.J$__v494107025_2307_1194 = function J$__v494107025_2307(points) {
var vvv_return, vvv_switch, geometry, point;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
points = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
geometry = new Geometry();
for (var i = 0, l = points.length; i < l; i++) {
    point = points[i];
    geometry.vertices.push(new Vector3(point.x, point.y, point.z || 0));
}
return geometry;})
    });
    EllipseCurve.prototype = Object['create']((Curve.prototype, $__.os.oid490));
    TAJS_restrictToType(EllipseCurve.prototype, 'object').constructor = EllipseCurve;
    TAJS_restrictToType(EllipseCurve.prototype, 'object').isEllipseCurve = true;
    TAJS_restrictToType(EllipseCurve.prototype, 'object').getPoint = ($__.fs.J$__v494107025_2310_1195 = function J$__v494107025_2310(t) {
var vvv_return, vvv_switch, twoPi, deltaAngle, samePoints, angle, x, y, cos, sin, tx, ty;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
t = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
twoPi = Math.PI * 2;
deltaAngle = this.aEndAngle - this.aStartAngle;
samePoints = Math.abs(deltaAngle) < Number.EPSILON;
while (deltaAngle < 0)
    deltaAngle += twoPi;
while (deltaAngle > twoPi)
    deltaAngle -= twoPi;
if (deltaAngle < Number.EPSILON) {
    if (samePoints) {
        deltaAngle = 0;
    } else {
        deltaAngle = twoPi;
    }
}
if (this.aClockwise === true && !samePoints) {
    if (deltaAngle === twoPi) {
        deltaAngle = -twoPi;
    } else {
        deltaAngle = deltaAngle - twoPi;
    }
}
angle = this.aStartAngle + t * deltaAngle;
x = this.aX + this.xRadius * Math.cos(angle);
y = this.aY + this.yRadius * Math.sin(angle);
if (this.aRotation !== 0) {
    cos = Math.cos(this.aRotation);
    sin = Math.sin(this.aRotation);
    tx = x - this.aX;
    ty = y - this.aY;
    x = tx * cos - ty * sin + this.aX;
    y = tx * sin + ty * cos + this.aY;
}
return new Vector2(x, y);});
    (exports, $__.os.oid0).CurveUtils = $__.os.oid492 = {
        'tangentQuadraticBezier': ($__.fs.J$__v494107025_2312_1196 = function J$__v494107025_2312(t, p0, p1, p2) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
t = arguments[0], p0 = arguments[1], p1 = arguments[2], p2 = arguments[3];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return 2 * (1 - t) * (p1 - p0) + 2 * t * (p2 - p1);}),
        'tangentCubicBezier': ($__.fs.J$__v494107025_2314_1197 = function J$__v494107025_2314(t, p0, p1, p2, p3) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
t = arguments[0], p0 = arguments[1], p1 = arguments[2], p2 = arguments[3], p3 = arguments[4];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return -3 * p0 * (1 - t) * (1 - t) + 3 * p1 * (1 - t) * (1 - t) - 6 * t * p1 * (1 - t) + 6 * t * p2 * (1 - t) - 3 * t * t * p2 + 3 * t * t * p3;}),
        'tangentSpline': ($__.fs.J$__v494107025_2316_1198 = function J$__v494107025_2316(t, p0, p1, p2, p3) {
var vvv_return, vvv_switch, h00, h10, h01, h11;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
t = arguments[0], p0 = arguments[1], p1 = arguments[2], p2 = arguments[3], p3 = arguments[4];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
h00 = 6 * t * t - 6 * t;
h10 = 3 * t * t - 4 * t + 1;
h01 = -6 * t * t + 6 * t;
h11 = 3 * t * t - 2 * t;
return h00 + h10 + h01 + h11;}),
        'interpolate': ($__.fs.J$__v494107025_2318_1199 = function J$__v494107025_2318(p0, p1, p2, p3, t) {
var vvv_return, vvv_switch, v0, v1, t2, t3;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
p0 = arguments[0], p1 = arguments[1], p2 = arguments[2], p3 = arguments[3], t = arguments[4];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
v0 = (p2 - p0) * 0.5;
v1 = (p3 - p1) * 0.5;
t2 = t * t;
t3 = t * t2;
return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;})
    };
    SplineCurve.prototype = Object['create']((Curve.prototype, $__.os.oid490));
    TAJS_restrictToType(SplineCurve.prototype, 'object').constructor = SplineCurve;
    TAJS_restrictToType(SplineCurve.prototype, 'object').isSplineCurve = true;
    TAJS_restrictToType(SplineCurve.prototype, 'object').getPoint = ($__.fs.J$__v494107025_2321_1200 = function J$__v494107025_2321(t) {
var vvv_return, vvv_switch, points, point, intPoint, weight, point0, point1, point2, point3, interpolate;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
t = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
points = this.points;
point = (points.length - 1) * t;
intPoint = Math.floor(point);
weight = point - intPoint;
point0 = points[intPoint === 0 ? intPoint : intPoint - 1];
point1 = points[intPoint];
point2 = points[intPoint > points.length - 2 ? points.length - 1 : intPoint + 1];
point3 = points[intPoint > points.length - 3 ? points.length - 1 : intPoint + 2];
interpolate = exports.CurveUtils.interpolate;
return new Vector2(interpolate(point0.x, point1.x, point2.x, point3.x, weight), interpolate(point0.y, point1.y, point2.y, point3.y, weight));});
    CubicBezierCurve.prototype = Object['create']((Curve.prototype, $__.os.oid490));
    TAJS_restrictToType(CubicBezierCurve.prototype, 'object').constructor = CubicBezierCurve;
    TAJS_restrictToType(CubicBezierCurve.prototype, 'object').getPoint = ($__.fs.J$__v494107025_2324_1201 = function J$__v494107025_2324(t) {
var vvv_return, vvv_switch, b3;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
t = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
b3 = exports.ShapeUtils.b3;
return new Vector2(b3(t, this.v0.x, this.v1.x, this.v2.x, this.v3.x), b3(t, this.v0.y, this.v1.y, this.v2.y, this.v3.y));});
    TAJS_restrictToType(CubicBezierCurve.prototype, 'object').getTangent = ($__.fs.J$__v494107025_2326_1202 = function J$__v494107025_2326(t) {
var vvv_return, vvv_switch, tangentCubicBezier;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
t = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
tangentCubicBezier = exports.CurveUtils.tangentCubicBezier;
return new Vector2(tangentCubicBezier(t, this.v0.x, this.v1.x, this.v2.x, this.v3.x), tangentCubicBezier(t, this.v0.y, this.v1.y, this.v2.y, this.v3.y)).normalize();});
    QuadraticBezierCurve.prototype = Object['create']((Curve.prototype, $__.os.oid490));
    TAJS_restrictToType(QuadraticBezierCurve.prototype, 'object').constructor = QuadraticBezierCurve;
    TAJS_restrictToType(QuadraticBezierCurve.prototype, 'object').getPoint = ($__.fs.J$__v494107025_2329_1203 = function J$__v494107025_2329(t) {
var vvv_return, vvv_switch, b2;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
t = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
b2 = exports.ShapeUtils.b2;
return new Vector2(b2(t, this.v0.x, this.v1.x, this.v2.x), b2(t, this.v0.y, this.v1.y, this.v2.y));});
    TAJS_restrictToType(QuadraticBezierCurve.prototype, 'object').getTangent = ($__.fs.J$__v494107025_2331_1204 = function J$__v494107025_2331(t) {
var vvv_return, vvv_switch, tangentQuadraticBezier;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
t = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
tangentQuadraticBezier = exports.CurveUtils.tangentQuadraticBezier;
return new Vector2(tangentQuadraticBezier(t, this.v0.x, this.v1.x, this.v2.x), tangentQuadraticBezier(t, this.v0.y, this.v1.y, this.v2.y)).normalize();});
    PathPrototype = Object['assign'](Object['create'](TAJS_restrictToType(CurvePath.prototype, 'object')), $__.os.oid493 = {
        'fromPoints': ($__.fs.J$__v494107025_2333_1205 = function J$__v494107025_2333(vectors) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
vectors = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.moveTo(vectors[0].x, vectors[0].y);
for (var i = 1, l = vectors.length; i < l; i++) {
    this.lineTo(vectors[i].x, vectors[i].y);
}}),
        'moveTo': ($__.fs.J$__v494107025_2335_1206 = function J$__v494107025_2335(x, y) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
x = arguments[0], y = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.currentPoint.set(x, y);}),
        'lineTo': ($__.fs.J$__v494107025_2337_1207 = function J$__v494107025_2337(x, y) {
var vvv_return, vvv_switch, curve;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
x = arguments[0], y = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
curve = new LineCurve(this.currentPoint.clone(), new Vector2(x, y));
this.curves.push(curve);
this.currentPoint.set(x, y);}),
        'quadraticCurveTo': ($__.fs.J$__v494107025_2339_1208 = function J$__v494107025_2339(aCPx, aCPy, aX, aY) {
var vvv_return, vvv_switch, curve;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
aCPx = arguments[0], aCPy = arguments[1], aX = arguments[2], aY = arguments[3];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
curve = new QuadraticBezierCurve(this.currentPoint.clone(), new Vector2(aCPx, aCPy), new Vector2(aX, aY));
this.curves.push(curve);
this.currentPoint.set(aX, aY);}),
        'bezierCurveTo': ($__.fs.J$__v494107025_2341_1209 = function J$__v494107025_2341(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
var vvv_return, vvv_switch, curve;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
aCP1x = arguments[0], aCP1y = arguments[1], aCP2x = arguments[2], aCP2y = arguments[3], aX = arguments[4], aY = arguments[5];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
curve = new CubicBezierCurve(this.currentPoint.clone(), new Vector2(aCP1x, aCP1y), new Vector2(aCP2x, aCP2y), new Vector2(aX, aY));
this.curves.push(curve);
this.currentPoint.set(aX, aY);}),
        'splineThru': ($__.fs.J$__v494107025_2343_1210 = function J$__v494107025_2343(pts) {
var vvv_return, vvv_switch, npts, curve;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
pts = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
npts = [this.currentPoint.clone()].concat(pts);
curve = new SplineCurve(npts);
this.curves.push(curve);
this.currentPoint.copy(pts[pts.length - 1]);}),
        'arc': ($__.fs.J$__v494107025_2345_1211 = function J$__v494107025_2345(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
var vvv_return, vvv_switch, x0, y0;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
aX = arguments[0], aY = arguments[1], aRadius = arguments[2], aStartAngle = arguments[3], aEndAngle = arguments[4], aClockwise = arguments[5];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
x0 = this.currentPoint.x;
y0 = this.currentPoint.y;
this.absarc(aX + x0, aY + y0, aRadius, aStartAngle, aEndAngle, aClockwise);}),
        'absarc': ($__.fs.J$__v494107025_2347_1212 = function J$__v494107025_2347(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
aX = arguments[0], aY = arguments[1], aRadius = arguments[2], aStartAngle = arguments[3], aEndAngle = arguments[4], aClockwise = arguments[5];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);}),
        'ellipse': ($__.fs.J$__v494107025_2349_1213 = function J$__v494107025_2349(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
var vvv_return, vvv_switch, x0, y0;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
aX = arguments[0], aY = arguments[1], xRadius = arguments[2], yRadius = arguments[3], aStartAngle = arguments[4], aEndAngle = arguments[5], aClockwise = arguments[6], aRotation = arguments[7];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
x0 = this.currentPoint.x;
y0 = this.currentPoint.y;
this.absellipse(aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);}),
        'absellipse': ($__.fs.J$__v494107025_2351_1214 = function J$__v494107025_2351(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
var vvv_return, vvv_switch, curve, firstPoint, lastPoint;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
aX = arguments[0], aY = arguments[1], xRadius = arguments[2], yRadius = arguments[3], aStartAngle = arguments[4], aEndAngle = arguments[5], aClockwise = arguments[6], aRotation = arguments[7];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
curve = new EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
if (this.curves.length > 0) {
    firstPoint = curve.getPoint(0);
    if (!firstPoint.equals(this.currentPoint)) {
        this.lineTo(firstPoint.x, firstPoint.y);
    }
}
this.curves.push(curve);
lastPoint = curve.getPoint(1);
this.currentPoint.copy(lastPoint);})
    });
    TubeGeometry.prototype = Object['create'](TAJS_restrictToType(Geometry.prototype, 'object'));
    TAJS_restrictToType(TubeGeometry.prototype, 'object').constructor = TubeGeometry;
    TubeGeometry.NoTaper = ($__.fs.J$__v494107025_2355_1215 = function J$__v494107025_2355(u) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
u = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return 1;});
    TubeGeometry.SinusoidalTaper = ($__.fs.J$__v494107025_2357_1216 = function J$__v494107025_2357(u) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
u = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return Math.sin(Math.PI * u);});
    TubeGeometry.FrenetFrames = ($__.fs.J$__v494107025_2360_1217 = function J$__v494107025_2360(path, segments, closed) {
var vvv_return, vvv_switch, normal, tangents, normals, binormals, vec, mat, numpoints, theta, smallest, tx, ty, tz, i, u, initialNormal3;
initialNormal3 = function initialNormal3() {
    normals[0] = new Vector3();
    binormals[0] = new Vector3();
    smallest = Number.MAX_VALUE;
    tx = Math.abs(tangents[0].x);
    ty = Math.abs(tangents[0].y);
    tz = Math.abs(tangents[0].z);
    if (tx <= smallest) {
        smallest = tx;
        normal.set(1, 0, 0);
    }
    if (ty <= smallest) {
        smallest = ty;
        normal.set(0, 1, 0);
    }
    if (tz <= smallest) {
        normal.set(0, 0, 1);
    }
    vec.crossVectors(tangents[0], normal).normalize();
    normals[0].crossVectors(tangents[0], vec);
    binormals[0].crossVectors(tangents[0], normals[0]);
};
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
path = arguments[0], segments = arguments[1], closed = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
normal = new Vector3();
tangents = [];
normals = [];
binormals = [];
vec = new Vector3();
mat = new Matrix4();
numpoints = segments + 1;
this.tangents = tangents;
this.normals = normals;
this.binormals = binormals;
for (i = 0; i < numpoints; i++) {
    u = i / (numpoints - 1);
    tangents[i] = path.getTangentAt(u);
    tangents[i].normalize();
}
initialNormal3();
for (i = 1; i < numpoints; i++) {
    normals[i] = normals[i - 1].clone();
    binormals[i] = binormals[i - 1].clone();
    vec.crossVectors(tangents[i - 1], tangents[i]);
    if (vec.length() > Number.EPSILON) {
        vec.normalize();
        theta = Math.acos(exports.Math.clamp(tangents[i - 1].dot(tangents[i]), -1, 1));
        normals[i].applyMatrix4(mat.makeRotationAxis(vec, theta));
    }
    binormals[i].crossVectors(tangents[i], normals[i]);
}
if (closed) {
    theta = Math.acos(exports.Math.clamp(normals[0].dot(normals[numpoints - 1]), -1, 1));
    theta /= numpoints - 1;
    if (tangents[0].dot(vec.crossVectors(normals[0], normals[numpoints - 1])) > 0) {
        theta = -theta;
    }
    for (i = 1; i < numpoints; i++) {
        normals[i].applyMatrix4(mat.makeRotationAxis(tangents[i], theta * i));
        binormals[i].crossVectors(tangents[i], normals[i]);
    }
}});
    ExtrudeGeometry.prototype = Object['create'](TAJS_restrictToType(Geometry.prototype, 'object'));
    TAJS_restrictToType(ExtrudeGeometry.prototype, 'object').constructor = ExtrudeGeometry;
    TAJS_restrictToType(ExtrudeGeometry.prototype, 'object').addShapeList = ($__.fs.J$__v494107025_2363_1218 = function J$__v494107025_2363(shapes, options) {
var vvv_return, vvv_switch, sl, shape;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
shapes = arguments[0], options = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
sl = shapes.length;
for (var s = 0; s < sl; s++) {
    shape = shapes[s];
    this.addShape(shape, options);
}});
    TAJS_restrictToType(ExtrudeGeometry.prototype, 'object').addShape = ($__.fs.J$__v494107025_2373_1219 = function J$__v494107025_2373(shape, options) {
var vvv_return, vvv_switch, amount, bevelThickness, bevelSize, bevelSegments, bevelEnabled, curveSegments, steps, extrudePath, extrudePts, extrudeByPath, uvgen, splineTube, binormal, normal, position2, ahole, h, hl, scope, shapesOffset, shapePoints, vertices, holes, reverse, faces, contour, scalePt2, b, bs, t, z, vert, vlen, face, flen, getBevelVec, contourMovements, holesMovements, oneHoleMovements, verticesMovements, s, buildLidFaces, buildSideFaces, sidewalls, v, f3, f4;
scalePt2 = function scalePt2(pt, vec, size) {
    if (!vec)
        console.error('THREE.ExtrudeGeometry: vec does not exist');
    return vec.clone().multiplyScalar(size).add(pt);
};
getBevelVec = function getBevelVec(inPt, inPrev, inNext) {
    var v_trans_x, v_trans_y, shrink_by = 1;
    var v_prev_x = inPt.x - inPrev.x, v_prev_y = inPt.y - inPrev.y;
    var v_next_x = inNext.x - inPt.x, v_next_y = inNext.y - inPt.y;
    var v_prev_lensq = v_prev_x * v_prev_x + v_prev_y * v_prev_y;
    var collinear0 = v_prev_x * v_next_y - v_prev_y * v_next_x;
    if (Math.abs(collinear0) > Number.EPSILON) {
        var v_prev_len = Math.sqrt(v_prev_lensq);
        var v_next_len = Math.sqrt(v_next_x * v_next_x + v_next_y * v_next_y);
        var ptPrevShift_x = inPrev.x - v_prev_y / v_prev_len;
        var ptPrevShift_y = inPrev.y + v_prev_x / v_prev_len;
        var ptNextShift_x = inNext.x - v_next_y / v_next_len;
        var ptNextShift_y = inNext.y + v_next_x / v_next_len;
        var sf = ((ptNextShift_x - ptPrevShift_x) * v_next_y - (ptNextShift_y - ptPrevShift_y) * v_next_x) / (v_prev_x * v_next_y - v_prev_y * v_next_x);
        v_trans_x = ptPrevShift_x + v_prev_x * sf - inPt.x;
        v_trans_y = ptPrevShift_y + v_prev_y * sf - inPt.y;
        var v_trans_lensq = v_trans_x * v_trans_x + v_trans_y * v_trans_y;
        if (v_trans_lensq <= 2) {
            return new Vector2(v_trans_x, v_trans_y);
        } else {
            shrink_by = Math.sqrt(v_trans_lensq / 2);
        }
    } else {
        var direction_eq = false;
        if (v_prev_x > Number.EPSILON) {
            if (v_next_x > Number.EPSILON) {
                direction_eq = true;
            }
        } else {
            if (v_prev_x < -Number.EPSILON) {
                if (v_next_x < -Number.EPSILON) {
                    direction_eq = true;
                }
            } else {
                if (Math.sign(v_prev_y) === Math.sign(v_next_y)) {
                    direction_eq = true;
                }
            }
        }
        if (direction_eq) {
            v_trans_x = -v_prev_y;
            v_trans_y = v_prev_x;
            shrink_by = Math.sqrt(v_prev_lensq);
        } else {
            v_trans_x = v_prev_x;
            v_trans_y = v_prev_y;
            shrink_by = Math.sqrt(v_prev_lensq / 2);
        }
    }
    return new Vector2(v_trans_x / shrink_by, v_trans_y / shrink_by);
};
buildLidFaces = function buildLidFaces() {
    if (bevelEnabled) {
        var layer = 0;
        var offset = vlen * layer;
        for (i = 0; i < flen; i++) {
            face = faces[i];
            f3(face[2] + offset, face[1] + offset, face[0] + offset);
        }
        layer = steps + bevelSegments * 2;
        offset = vlen * layer;
        for (i = 0; i < flen; i++) {
            face = faces[i];
            f3(face[0] + offset, face[1] + offset, face[2] + offset);
        }
    } else {
        for (i = 0; i < flen; i++) {
            face = faces[i];
            f3(face[2], face[1], face[0]);
        }
        for (i = 0; i < flen; i++) {
            face = faces[i];
            f3(face[0] + vlen * steps, face[1] + vlen * steps, face[2] + vlen * steps);
        }
    }
};
buildSideFaces = function buildSideFaces() {
    var layeroffset = 0;
    sidewalls(contour, layeroffset);
    layeroffset += contour.length;
    for (h = 0, hl = holes.length; h < hl; h++) {
        ahole = holes[h];
        sidewalls(ahole, layeroffset);
        layeroffset += ahole.length;
    }
};
sidewalls = function sidewalls(contour, layeroffset) {
    var j, k;
    i = contour.length;
    while (--i >= 0) {
        j = i;
        k = i - 1;
        if (k < 0)
            k = contour.length - 1;
        var s = 0, sl = steps + bevelSegments * 2;
        for (s = 0; s < sl; s++) {
            var slen1 = vlen * s;
            var slen2 = vlen * (s + 1);
            var a = layeroffset + j + slen1, b = layeroffset + k + slen1, c = layeroffset + k + slen2, d = layeroffset + j + slen2;
            f4(a, b, c, d, contour, s, sl, j, k);
        }
    }
};
v = function v(x, y, z) {
    scope.vertices.push(new Vector3(x, y, z));
};
f3 = function f3(a, b, c) {
    a += shapesOffset;
    b += shapesOffset;
    c += shapesOffset;
    scope.faces.push(new Face3(a, b, c, null, null, 0));
    var uvs = uvgen.generateTopUV(scope, a, b, c);
    scope.faceVertexUvs[0].push(uvs);
};
f4 = function f4(a, b, c, d, wallContour, stepIndex, stepsLength, contourIndex1, contourIndex2) {
    a += shapesOffset;
    b += shapesOffset;
    c += shapesOffset;
    d += shapesOffset;
    scope.faces.push(new Face3(a, b, d, null, null, 1));
    scope.faces.push(new Face3(b, c, d, null, null, 1));
    var uvs = uvgen.generateSideWallUV(scope, a, b, c, d);
    scope.faceVertexUvs[0].push([
        uvs[0],
        uvs[1],
        uvs[3]
    ]);
    scope.faceVertexUvs[0].push([
        uvs[1],
        uvs[2],
        uvs[3]
    ]);
};
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
shape = arguments[0], options = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
amount = options.amount !== undefined ? options.amount : 100;
bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6;
bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2;
bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;
bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true;
curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;
steps = options.steps !== undefined ? options.steps : 1;
extrudePath = options.extrudePath;
extrudeByPath = false;
uvgen = options.UVGenerator !== undefined ? options.UVGenerator : ExtrudeGeometry.WorldUVGenerator;
if (extrudePath) {
    extrudePts = extrudePath.getSpacedPoints(steps);
    extrudeByPath = true;
    bevelEnabled = false;
    splineTube = options.frames !== undefined ? options.frames : new TubeGeometry.FrenetFrames(extrudePath, steps, false);
    binormal = new Vector3();
    normal = new Vector3();
    position2 = new Vector3();
}
if (!bevelEnabled) {
    bevelSegments = 0;
    bevelThickness = 0;
    bevelSize = 0;
}
scope = this;
shapesOffset = this.vertices.length;
shapePoints = shape.extractPoints(curveSegments);
vertices = shapePoints.shape;
holes = shapePoints.holes;
reverse = !exports.ShapeUtils.isClockWise(vertices);
if (reverse) {
    vertices = vertices.reverse();
    for (h = 0, hl = holes.length; h < hl; h++) {
        ahole = holes[h];
        if (exports.ShapeUtils.isClockWise(ahole)) {
            holes[h] = ahole.reverse();
        }
    }
    reverse = false;
}
faces = exports.ShapeUtils.triangulateShape(vertices, holes);
contour = vertices;
for (h = 0, hl = holes.length; h < hl; h++) {
    ahole = holes[h];
    vertices = vertices.concat(ahole);
}
vlen = vertices.length;
flen = faces.length;
contourMovements = [];
for (var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {
    if (j === il)
        j = 0;
    if (k === il)
        k = 0;
    contourMovements[i] = getBevelVec(contour[i], contour[j], contour[k]);
}
holesMovements = [];
verticesMovements = contourMovements.concat();
for (h = 0, hl = holes.length; h < hl; h++) {
    ahole = holes[h];
    oneHoleMovements = [];
    for (i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {
        if (j === il)
            j = 0;
        if (k === il)
            k = 0;
        oneHoleMovements[i] = getBevelVec(ahole[i], ahole[j], ahole[k]);
    }
    holesMovements.push(oneHoleMovements);
    verticesMovements = verticesMovements.concat(oneHoleMovements);
}
for (b = 0; b < bevelSegments; b++) {
    t = b / bevelSegments;
    z = bevelThickness * Math.cos(t * Math.PI / 2);
    bs = bevelSize * Math.sin(t * Math.PI / 2);
    for (i = 0, il = contour.length; i < il; i++) {
        vert = scalePt2(contour[i], contourMovements[i], bs);
        v(vert.x, vert.y, -z);
    }
    for (h = 0, hl = holes.length; h < hl; h++) {
        ahole = holes[h];
        oneHoleMovements = holesMovements[h];
        for (i = 0, il = ahole.length; i < il; i++) {
            vert = scalePt2(ahole[i], oneHoleMovements[i], bs);
            v(vert.x, vert.y, -z);
        }
    }
}
bs = bevelSize;
for (i = 0; i < vlen; i++) {
    vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];
    if (!extrudeByPath) {
        v(vert.x, vert.y, 0);
    } else {
        normal.copy(splineTube.normals[0]).multiplyScalar(vert.x);
        binormal.copy(splineTube.binormals[0]).multiplyScalar(vert.y);
        position2.copy(extrudePts[0]).add(normal).add(binormal);
        v(position2.x, position2.y, position2.z);
    }
}
for (s = 1; s <= steps; s++) {
    for (i = 0; i < vlen; i++) {
        vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];
        if (!extrudeByPath) {
            v(vert.x, vert.y, amount / steps * s);
        } else {
            normal.copy(splineTube.normals[s]).multiplyScalar(vert.x);
            binormal.copy(splineTube.binormals[s]).multiplyScalar(vert.y);
            position2.copy(extrudePts[s]).add(normal).add(binormal);
            v(position2.x, position2.y, position2.z);
        }
    }
}
for (b = bevelSegments - 1; b >= 0; b--) {
    t = b / bevelSegments;
    z = bevelThickness * Math.cos(t * Math.PI / 2);
    bs = bevelSize * Math.sin(t * Math.PI / 2);
    for (i = 0, il = contour.length; i < il; i++) {
        vert = scalePt2(contour[i], contourMovements[i], bs);
        v(vert.x, vert.y, amount + z);
    }
    for (h = 0, hl = holes.length; h < hl; h++) {
        ahole = holes[h];
        oneHoleMovements = holesMovements[h];
        for (i = 0, il = ahole.length; i < il; i++) {
            vert = scalePt2(ahole[i], oneHoleMovements[i], bs);
            if (!extrudeByPath) {
                v(vert.x, vert.y, amount + z);
            } else {
                v(vert.x, vert.y + extrudePts[steps - 1].y, extrudePts[steps - 1].x + z);
            }
        }
    }
}
buildLidFaces();
buildSideFaces();});
    ExtrudeGeometry.WorldUVGenerator = $__.os.oid494 = {
        'generateTopUV': ($__.fs.J$__v494107025_2375_1220 = function J$__v494107025_2375(geometry, indexA, indexB, indexC) {
var vvv_return, vvv_switch, vertices, a, b, c;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
geometry = arguments[0], indexA = arguments[1], indexB = arguments[2], indexC = arguments[3];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
vertices = geometry.vertices;
a = vertices[indexA];
b = vertices[indexB];
c = vertices[indexC];
return [
    new Vector2(a.x, a.y),
    new Vector2(b.x, b.y),
    new Vector2(c.x, c.y)
];}),
        'generateSideWallUV': ($__.fs.J$__v494107025_2377_1221 = function J$__v494107025_2377(geometry, indexA, indexB, indexC, indexD) {
var vvv_return, vvv_switch, vertices, a, b, c, d;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
geometry = arguments[0], indexA = arguments[1], indexB = arguments[2], indexC = arguments[3], indexD = arguments[4];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
vertices = geometry.vertices;
a = vertices[indexA];
b = vertices[indexB];
c = vertices[indexC];
d = vertices[indexD];
if (Math.abs(a.y - b.y) < 0.01) {
    return [
        new Vector2(a.x, 1 - a.z),
        new Vector2(b.x, 1 - b.z),
        new Vector2(c.x, 1 - c.z),
        new Vector2(d.x, 1 - d.z)
    ];
} else {
    return [
        new Vector2(a.y, 1 - a.z),
        new Vector2(b.y, 1 - b.z),
        new Vector2(c.y, 1 - c.z),
        new Vector2(d.y, 1 - d.z)
    ];
}})
    };
    ShapeGeometry.prototype = Object['create'](TAJS_restrictToType(Geometry.prototype, 'object'));
    TAJS_restrictToType(ShapeGeometry.prototype, 'object').constructor = ShapeGeometry;
    TAJS_restrictToType(ShapeGeometry.prototype, 'object').addShapeList = ($__.fs.J$__v494107025_2380_1222 = function J$__v494107025_2380(shapes, options) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
shapes = arguments[0], options = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
for (var i = 0, l = shapes.length; i < l; i++) {
    this.addShape(shapes[i], options);
}
return this;});
    TAJS_restrictToType(ShapeGeometry.prototype, 'object').addShape = ($__.fs.J$__v494107025_2382_1223 = function J$__v494107025_2382(shape, options) {
var vvv_return, vvv_switch, curveSegments, material, uvgen, i, l, hole, shapesOffset, shapePoints, vertices, holes, reverse, faces, vert, vlen, face, flen, a, b, c;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
shape = arguments[0], options = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (options === undefined)
    options = {};
curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;
material = options.material;
uvgen = options.UVGenerator === undefined ? ExtrudeGeometry.WorldUVGenerator : options.UVGenerator;
shapesOffset = this.vertices.length;
shapePoints = shape.extractPoints(curveSegments);
vertices = shapePoints.shape;
holes = shapePoints.holes;
reverse = !exports.ShapeUtils.isClockWise(vertices);
if (reverse) {
    vertices = vertices.reverse();
    for (i = 0, l = holes.length; i < l; i++) {
        hole = holes[i];
        if (exports.ShapeUtils.isClockWise(hole)) {
            holes[i] = hole.reverse();
        }
    }
    reverse = false;
}
faces = exports.ShapeUtils.triangulateShape(vertices, holes);
for (i = 0, l = holes.length; i < l; i++) {
    hole = holes[i];
    vertices = vertices.concat(hole);
}
vlen = vertices.length;
flen = faces.length;
for (i = 0; i < vlen; i++) {
    vert = vertices[i];
    this.vertices.push(new Vector3(vert.x, vert.y, 0));
}
for (i = 0; i < flen; i++) {
    face = faces[i];
    a = face[0] + shapesOffset;
    b = face[1] + shapesOffset;
    c = face[2] + shapesOffset;
    this.faces.push(new Face3(a, b, c, null, null, material));
    this.faceVertexUvs[0].push(uvgen.generateTopUV(this, a, b, c));
}});
    Shape.prototype = Object['assign'](Object['create'](PathPrototype), $__.os.oid495 = {
        'constructor': Shape,
        'extrude': ($__.fs.J$__v494107025_2385_1224 = function J$__v494107025_2385(options) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
options = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return new ExtrudeGeometry(this, options);}),
        'makeGeometry': ($__.fs.J$__v494107025_2387_1225 = function J$__v494107025_2387(options) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
options = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return new ShapeGeometry(this, options);}),
        'getPointsHoles': ($__.fs.J$__v494107025_2389_1226 = function J$__v494107025_2389(divisions) {
var vvv_return, vvv_switch, holesPts;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
divisions = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
holesPts = [];
for (var i = 0, l = this.holes.length; i < l; i++) {
    holesPts[i] = this.holes[i].getPoints(divisions);
}
return holesPts;}),
        'extractAllPoints': ($__.fs.J$__v494107025_2391_1227 = function J$__v494107025_2391(divisions) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
divisions = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return {
    shape: this.getPoints(divisions),
    holes: this.getPointsHoles(divisions)
};}),
        'extractPoints': ($__.fs.J$__v494107025_2393_1228 = function J$__v494107025_2393(divisions) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
divisions = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return this.extractAllPoints(divisions);})
    });
    Path.prototype = PathPrototype;
    PathPrototype.constructor = Path;
    ShapePath.prototype = $__.os.oid496 = {
        'moveTo': ($__.fs.J$__v494107025_2397_1229 = function J$__v494107025_2397(x, y) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
x = arguments[0], y = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.currentPath = new Path();
this.subPaths.push(this.currentPath);
this.currentPath.moveTo(x, y);}),
        'lineTo': ($__.fs.J$__v494107025_2399_1230 = function J$__v494107025_2399(x, y) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
x = arguments[0], y = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.currentPath.lineTo(x, y);}),
        'quadraticCurveTo': ($__.fs.J$__v494107025_2401_1231 = function J$__v494107025_2401(aCPx, aCPy, aX, aY) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
aCPx = arguments[0], aCPy = arguments[1], aX = arguments[2], aY = arguments[3];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.currentPath.quadraticCurveTo(aCPx, aCPy, aX, aY);}),
        'bezierCurveTo': ($__.fs.J$__v494107025_2403_1232 = function J$__v494107025_2403(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
aCP1x = arguments[0], aCP1y = arguments[1], aCP2x = arguments[2], aCP2y = arguments[3], aX = arguments[4], aY = arguments[5];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.currentPath.bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY);}),
        'splineThru': ($__.fs.J$__v494107025_2405_1233 = function J$__v494107025_2405(pts) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
pts = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.currentPath.splineThru(pts);}),
        'toShapes': ($__.fs.J$__v494107025_2409_1234 = function J$__v494107025_2409(isCCW, noHoles) {
var vvv_return, vvv_switch, toShapesNoHoles, isPointInsidePolygon, isClockWise, subPaths, solid, tmpPath, tmpShape, shapes, holesFirst, betterShapeHoles, newShapes, newShapeHoles, mainIdx, tmpPoints, ambiguous, toChange, sho, ho, hole_unassigned, tmpHoles;
toShapesNoHoles = function toShapesNoHoles(inSubpaths) {
    var shapes = [];
    for (var i = 0, l = inSubpaths.length; i < l; i++) {
        var tmpPath = inSubpaths[i];
        var tmpShape = new Shape();
        tmpShape.curves = tmpPath.curves;
        shapes.push(tmpShape);
    }
    return shapes;
};
isPointInsidePolygon = function isPointInsidePolygon(inPt, inPolygon) {
    var polyLen = inPolygon.length;
    var inside = false;
    for (var p = polyLen - 1, q = 0; q < polyLen; p = q++) {
        var edgeLowPt = inPolygon[p];
        var edgeHighPt = inPolygon[q];
        var edgeDx = edgeHighPt.x - edgeLowPt.x;
        var edgeDy = edgeHighPt.y - edgeLowPt.y;
        if (Math.abs(edgeDy) > Number.EPSILON) {
            if (edgeDy < 0) {
                edgeLowPt = inPolygon[q];
                edgeDx = -edgeDx;
                edgeHighPt = inPolygon[p];
                edgeDy = -edgeDy;
            }
            if (inPt.y < edgeLowPt.y || inPt.y > edgeHighPt.y)
                continue;
            if (inPt.y === edgeLowPt.y) {
                if (inPt.x === edgeLowPt.x)
                    return true;
            } else {
                var perpEdge = edgeDy * (inPt.x - edgeLowPt.x) - edgeDx * (inPt.y - edgeLowPt.y);
                if (perpEdge === 0)
                    return true;
                if (perpEdge < 0)
                    continue;
                inside = !inside;
            }
        } else {
            if (inPt.y !== edgeLowPt.y)
                continue;
            if (edgeHighPt.x <= inPt.x && inPt.x <= edgeLowPt.x || edgeLowPt.x <= inPt.x && inPt.x <= edgeHighPt.x)
                return true;
        }
    }
    return inside;
};
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
isCCW = arguments[0], noHoles = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
isClockWise = exports.ShapeUtils.isClockWise;
subPaths = this.subPaths;
if (subPaths.length === 0)
    return [];
if (noHoles === true)
    return toShapesNoHoles(subPaths);
shapes = [];
if (subPaths.length === 1) {
    tmpPath = subPaths[0];
    tmpShape = new Shape();
    tmpShape.curves = tmpPath.curves;
    shapes.push(tmpShape);
    return shapes;
}
holesFirst = !isClockWise(subPaths[0].getPoints());
holesFirst = isCCW ? !holesFirst : holesFirst;
betterShapeHoles = [];
newShapes = [];
newShapeHoles = [];
mainIdx = 0;
newShapes[mainIdx] = undefined;
newShapeHoles[mainIdx] = [];
for (var i = 0, l = subPaths.length; i < l; i++) {
    tmpPath = subPaths[i];
    tmpPoints = tmpPath.getPoints();
    solid = isClockWise(tmpPoints);
    solid = isCCW ? !solid : solid;
    if (solid) {
        if (!holesFirst && newShapes[mainIdx])
            mainIdx++;
        newShapes[mainIdx] = {
            s: new Shape(),
            p: tmpPoints
        };
        newShapes[mainIdx].s.curves = tmpPath.curves;
        if (holesFirst)
            mainIdx++;
        newShapeHoles[mainIdx] = [];
    } else {
        newShapeHoles[mainIdx].push({
            h: tmpPath,
            p: tmpPoints[0]
        });
    }
}
if (!newShapes[0])
    return toShapesNoHoles(subPaths);
if (newShapes.length > 1) {
    ambiguous = false;
    toChange = [];
    for (var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {
        betterShapeHoles[sIdx] = [];
    }
    for (var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {
        sho = newShapeHoles[sIdx];
        for (var hIdx = 0; hIdx < sho.length; hIdx++) {
            ho = sho[hIdx];
            hole_unassigned = true;
            for (var s2Idx = 0; s2Idx < newShapes.length; s2Idx++) {
                if (isPointInsidePolygon(ho.p, newShapes[s2Idx].p)) {
                    if (sIdx !== s2Idx)
                        toChange.push({
                        froms: sIdx,
                        tos: s2Idx,
                        hole: hIdx
                    });
                    if (hole_unassigned) {
                        hole_unassigned = false;
                        betterShapeHoles[s2Idx].push(ho);
                    } else {
                        ambiguous = true;
                    }
                }
            }
            if (hole_unassigned) {
                betterShapeHoles[sIdx].push(ho);
            }
        }
    }
    if (toChange.length > 0) {
        if (!ambiguous)
            newShapeHoles = betterShapeHoles;
    }
}
for (var i = 0, il = newShapes.length; i < il; i++) {
    tmpShape = newShapes[i].s;
    shapes.push(tmpShape);
    tmpHoles = newShapeHoles[i];
    for (var j = 0, jl = tmpHoles.length; j < jl; j++) {
        tmpShape.holes.push(tmpHoles[j].h);
    }
}
return shapes;})
    };
    Object['assign'](TAJS_restrictToType(Font.prototype, 'object'), $__.os.oid497 = {
        'isFont': true,
        'generateShapes': ($__.fs.J$__v494107025_2414_1235 = function J$__v494107025_2414(text, size, divisions) {
var vvv_return, vvv_switch, createPaths, createPath, data, paths, shapes;
createPaths = function createPaths(text) {
    var chars = String(text).split('');
    var scale = size / data.resolution;
    var offset = 0;
    var paths = [];
    for (var i = 0; i < chars.length; i++) {
        var ret = createPath(chars[i], scale, offset);
        offset += ret.offset;
        paths.push(ret.path);
    }
    return paths;
};
createPath = function createPath(c, scale, offset) {
    var glyph = data.glyphs[c] || data.glyphs['?'];
    if (!glyph)
        return;
    var path = new ShapePath();
    var pts = [], b2 = exports.ShapeUtils.b2, b3 = exports.ShapeUtils.b3;
    var x, y, cpx, cpy, cpx0, cpy0, cpx1, cpy1, cpx2, cpy2, laste;
    if (glyph.o) {
        var outline = glyph._cachedOutline || (glyph._cachedOutline = glyph.o.split(' '));
        for (var i = 0, l = outline.length; i < l;) {
            var action = outline[i++];
            switch (action) {
            case 'm':
                x = outline[i++] * scale + offset;
                y = outline[i++] * scale;
                path.moveTo(x, y);
                break;
            case 'l':
                x = outline[i++] * scale + offset;
                y = outline[i++] * scale;
                path.lineTo(x, y);
                break;
            case 'q':
                cpx = outline[i++] * scale + offset;
                cpy = outline[i++] * scale;
                cpx1 = outline[i++] * scale + offset;
                cpy1 = outline[i++] * scale;
                path.quadraticCurveTo(cpx1, cpy1, cpx, cpy);
                laste = pts[pts.length - 1];
                if (laste) {
                    cpx0 = laste.x;
                    cpy0 = laste.y;
                    for (var i2 = 1; i2 <= divisions; i2++) {
                        var t = i2 / divisions;
                        b2(t, cpx0, cpx1, cpx);
                        b2(t, cpy0, cpy1, cpy);
                    }
                }
                break;
            case 'b':
                cpx = outline[i++] * scale + offset;
                cpy = outline[i++] * scale;
                cpx1 = outline[i++] * scale + offset;
                cpy1 = outline[i++] * scale;
                cpx2 = outline[i++] * scale + offset;
                cpy2 = outline[i++] * scale;
                path.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, cpx, cpy);
                laste = pts[pts.length - 1];
                if (laste) {
                    cpx0 = laste.x;
                    cpy0 = laste.y;
                    for (var i2 = 1; i2 <= divisions; i2++) {
                        var t = i2 / divisions;
                        b3(t, cpx0, cpx1, cpx2, cpx);
                        b3(t, cpy0, cpy1, cpy2, cpy);
                    }
                }
                break;
            }
        }
    }
    return {
        offset: glyph.ha * scale,
        path: path
    };
};
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
text = arguments[0], size = arguments[1], divisions = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (size === undefined)
    size = 100;
if (divisions === undefined)
    divisions = 4;
data = this.data;
paths = createPaths(text);
shapes = [];
for (var p = 0, pl = paths.length; p < pl; p++) {
    Array.prototype.push.apply(shapes, paths[p].toShapes());
}
return shapes;})
    });
    Object['assign'](TAJS_restrictToType(FontLoader.prototype, 'object'), $__.os.oid498 = {
        'load': ($__.fs.J$__v494107025_2419_1236 = function J$__v494107025_2419(url, onLoad, onProgress, onError) {
var vvv_return, vvv_switch, scope, loader;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
url = arguments[0], onLoad = arguments[1], onProgress = arguments[2], onError = arguments[3];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
scope = this;
loader = new XHRLoader(this.manager);
loader.load(url, function (text) {
    var json;
    try {
        json = JSON.parse(text);
    } catch (e) {
        console.warn('THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.');
        json = JSON.parse(text.substring(65, text.length - 2));
    }
    var font = scope.parse(json);
    if (onLoad)
        onLoad(font);
}, onProgress, onError);}),
        'parse': ($__.fs.J$__v494107025_2421_1237 = function J$__v494107025_2421(json) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
json = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return new Font(json);})
    });
    Object['assign'](TAJS_restrictToType(AudioLoader.prototype, 'object'), $__.os.oid499 = {
        'load': ($__.fs.J$__v494107025_2429_1238 = function J$__v494107025_2429(url, onLoad, onProgress, onError) {
var vvv_return, vvv_switch, loader;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
url = arguments[0], onLoad = arguments[1], onProgress = arguments[2], onError = arguments[3];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
loader = new XHRLoader(this.manager);
loader.setResponseType('arraybuffer');
loader.load(url, function (buffer) {
    var context = getAudioContext();
    context.decodeAudioData(buffer, function (audioBuffer) {
        onLoad(audioBuffer);
    });
}, onProgress, onError);})
    });
    Object['assign'](TAJS_restrictToType(StereoCamera.prototype, 'object'), $__.os.oid500 = {
        'update': (($__.fs.J$__v494107025_2433_1239 = function J$__v494107025_2433() {
var vvv_return, vvv_switch, focus, fov, aspect, near, far, eyeRight, eyeLeft;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    eyeRight = new (Matrix4, $__.fs.Matrix4_9)(8, true, $__.uid);
    eyeLeft = new (Matrix4, $__.fs.Matrix4_9)(9, true, $__.uid);
    return ($__.fs.update_1240 = function update(camera) {
var vvv_return, vvv_switch, needsUpdate, projectionMatrix, eyeSep, eyeSepOnProjection, ymax, xmin, xmax;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
camera = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
needsUpdate = focus !== camera.focus || fov !== camera.fov || aspect !== camera.aspect * this.aspect || near !== camera.near || far !== camera.far;
if (needsUpdate) {
    focus = camera.focus;
    fov = camera.fov;
    aspect = camera.aspect * this.aspect;
    near = camera.near;
    far = camera.far;
    projectionMatrix = camera.projectionMatrix.clone();
    eyeSep = this.eyeSep / 2;
    eyeSepOnProjection = eyeSep * near / focus;
    ymax = near * Math.tan(exports.Math.DEG2RAD * fov * 0.5);
    eyeLeft.elements[12] = -eyeSep;
    eyeRight.elements[12] = eyeSep;
    xmin = -ymax * aspect + eyeSepOnProjection;
    xmax = ymax * aspect + eyeSepOnProjection;
    projectionMatrix.elements[0] = 2 * near / (xmax - xmin);
    projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);
    this.cameraL.projectionMatrix.copy(projectionMatrix);
    xmin = -ymax * aspect - eyeSepOnProjection;
    xmax = ymax * aspect - eyeSepOnProjection;
    projectionMatrix.elements[0] = 2 * near / (xmax - xmin);
    projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);
    this.cameraR.projectionMatrix.copy(projectionMatrix);
}
this.cameraL.matrixWorld.copy(camera.matrixWorld).multiply(eyeLeft);
this.cameraR.matrixWorld.copy(camera.matrixWorld).multiply(eyeRight);});
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
eyeRight = new Matrix4();
eyeLeft = new Matrix4();
return function update(camera) {
    var needsUpdate = focus !== camera.focus || fov !== camera.fov || aspect !== camera.aspect * this.aspect || near !== camera.near || far !== camera.far;
    if (needsUpdate) {
        focus = camera.focus;
        fov = camera.fov;
        aspect = camera.aspect * this.aspect;
        near = camera.near;
        far = camera.far;
        var projectionMatrix = camera.projectionMatrix.clone();
        var eyeSep = this.eyeSep / 2;
        var eyeSepOnProjection = eyeSep * near / focus;
        var ymax = near * Math.tan(exports.Math.DEG2RAD * fov * 0.5);
        var xmin, xmax;
        eyeLeft.elements[12] = -eyeSep;
        eyeRight.elements[12] = eyeSep;
        xmin = -ymax * aspect + eyeSepOnProjection;
        xmax = ymax * aspect + eyeSepOnProjection;
        projectionMatrix.elements[0] = 2 * near / (xmax - xmin);
        projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);
        this.cameraL.projectionMatrix.copy(projectionMatrix);
        xmin = -ymax * aspect - eyeSepOnProjection;
        xmax = ymax * aspect - eyeSepOnProjection;
        projectionMatrix.elements[0] = 2 * near / (xmax - xmin);
        projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);
        this.cameraR.projectionMatrix.copy(projectionMatrix);
    }
    this.cameraL.matrixWorld.copy(camera.matrixWorld).multiply(eyeLeft);
    this.cameraR.matrixWorld.copy(camera.matrixWorld).multiply(eyeRight);
};}), $__.fs.J$__v494107025_2433_1239)(0, true, $__.uid)
    });
    CubeCamera.prototype = Object['create'](TAJS_restrictToType(Object3D.prototype, 'object'));
    TAJS_restrictToType(CubeCamera.prototype, 'object').constructor = CubeCamera;
    AudioListener.prototype = Object['assign'](Object['create'](TAJS_restrictToType(Object3D.prototype, 'object')), $__.os.oid501 = {
        'constructor': AudioListener,
        'getInput': ($__.fs.J$__v494107025_2439_1241 = function J$__v494107025_2439() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return this.gain;}),
        'removeFilter': ($__.fs.J$__v494107025_2441_1242 = function J$__v494107025_2441() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (this.filter !== null) {
    this.gain.disconnect(this.filter);
    this.filter.disconnect(this.context.destination);
    this.gain.connect(this.context.destination);
    this.filter = null;
}}),
        'getFilter': ($__.fs.J$__v494107025_2443_1243 = function J$__v494107025_2443() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return this.filter;}),
        'setFilter': ($__.fs.J$__v494107025_2445_1244 = function J$__v494107025_2445(value) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
value = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (this.filter !== null) {
    this.gain.disconnect(this.filter);
    this.filter.disconnect(this.context.destination);
} else {
    this.gain.disconnect(this.context.destination);
}
this.filter = value;
this.gain.connect(this.filter);
this.filter.connect(this.context.destination);}),
        'getMasterVolume': ($__.fs.J$__v494107025_2447_1245 = function J$__v494107025_2447() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return this.gain.gain.value;}),
        'setMasterVolume': ($__.fs.J$__v494107025_2449_1246 = function J$__v494107025_2449(value) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
value = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.gain.gain.value = value;}),
        'updateMatrixWorld': (($__.fs.J$__v494107025_2452_1247 = function J$__v494107025_2452() {
var vvv_return, vvv_switch, position, quaternion, scale, orientation;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    position = new (Vector3, $__.fs.Vector3_11)(79, true, $__.uid);
    quaternion = new (Quaternion, $__.fs.Quaternion_10)(6, true, $__.uid);
    scale = new (Vector3, $__.fs.Vector3_11)(80, true, $__.uid);
    orientation = new (Vector3, $__.fs.Vector3_11)(81, true, $__.uid);
    return ($__.fs.updateMatrixWorld_1248 = function updateMatrixWorld(force) {
var vvv_return, vvv_switch, listener, up;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
force = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
Object3D.prototype.updateMatrixWorld.call(this, force);
listener = this.context.listener;
up = this.up;
this.matrixWorld.decompose(position, quaternion, scale);
orientation.set(0, 0, -1).applyQuaternion(quaternion);
listener.setPosition(position.x, position.y, position.z);
listener.setOrientation(orientation.x, orientation.y, orientation.z, up.x, up.y, up.z);});
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
position = new Vector3();
quaternion = new Quaternion();
scale = new Vector3();
orientation = new Vector3();
return function updateMatrixWorld(force) {
    Object3D.prototype.updateMatrixWorld.call(this, force);
    var listener = this.context.listener;
    var up = this.up;
    this.matrixWorld.decompose(position, quaternion, scale);
    orientation.set(0, 0, -1).applyQuaternion(quaternion);
    listener.setPosition(position.x, position.y, position.z);
    listener.setOrientation(orientation.x, orientation.y, orientation.z, up.x, up.y, up.z);
};}), $__.fs.J$__v494107025_2452_1247)(0, true, $__.uid)
    });
    Audio.prototype = Object['assign'](Object['create'](TAJS_restrictToType(Object3D.prototype, 'object')), $__.os.oid502 = {
        'constructor': Audio,
        'getOutput': ($__.fs.J$__v494107025_2455_1249 = function J$__v494107025_2455() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return this.gain;}),
        'setNodeSource': ($__.fs.J$__v494107025_2457_1250 = function J$__v494107025_2457(audioNode) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
audioNode = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.hasPlaybackControl = false;
this.sourceType = 'audioNode';
this.source = audioNode;
this.connect();
return this;}),
        'setBuffer': ($__.fs.J$__v494107025_2459_1251 = function J$__v494107025_2459(audioBuffer) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
audioBuffer = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.source.buffer = audioBuffer;
this.sourceType = 'buffer';
if (this.autoplay)
    this.play();
return this;}),
        'play': ($__.fs.J$__v494107025_2461_1252 = function J$__v494107025_2461() {
var vvv_return, vvv_switch, source;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (this.isPlaying === true) {
    console.warn('THREE.Audio: Audio is already playing.');
    return;
}
if (this.hasPlaybackControl === false) {
    console.warn('THREE.Audio: this Audio has no playback control.');
    return;
}
source = this.context.createBufferSource();
source.buffer = this.source.buffer;
source.loop = this.source.loop;
source.onended = this.source.onended;
source.start(0, this.startTime);
source.playbackRate.value = this.playbackRate;
this.isPlaying = true;
this.source = source;
return this.connect();}),
        'pause': ($__.fs.J$__v494107025_2463_1253 = function J$__v494107025_2463() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (this.hasPlaybackControl === false) {
    console.warn('THREE.Audio: this Audio has no playback control.');
    return;
}
this.source.stop();
this.startTime = this.context.currentTime;
this.isPlaying = false;
return this;}),
        'stop': ($__.fs.J$__v494107025_2465_1254 = function J$__v494107025_2465() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (this.hasPlaybackControl === false) {
    console.warn('THREE.Audio: this Audio has no playback control.');
    return;
}
this.source.stop();
this.startTime = 0;
this.isPlaying = false;
return this;}),
        'connect': ($__.fs.J$__v494107025_2467_1255 = function J$__v494107025_2467() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (this.filters.length > 0) {
    this.source.connect(this.filters[0]);
    for (var i = 1, l = this.filters.length; i < l; i++) {
        this.filters[i - 1].connect(this.filters[i]);
    }
    this.filters[this.filters.length - 1].connect(this.getOutput());
} else {
    this.source.connect(this.getOutput());
}
return this;}),
        'disconnect': ($__.fs.J$__v494107025_2469_1256 = function J$__v494107025_2469() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (this.filters.length > 0) {
    this.source.disconnect(this.filters[0]);
    for (var i = 1, l = this.filters.length; i < l; i++) {
        this.filters[i - 1].disconnect(this.filters[i]);
    }
    this.filters[this.filters.length - 1].disconnect(this.getOutput());
} else {
    this.source.disconnect(this.getOutput());
}
return this;}),
        'getFilters': ($__.fs.J$__v494107025_2471_1257 = function J$__v494107025_2471() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return this.filters;}),
        'setFilters': ($__.fs.J$__v494107025_2473_1258 = function J$__v494107025_2473(value) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
value = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (!value)
    value = [];
if (this.isPlaying === true) {
    this.disconnect();
    this.filters = value;
    this.connect();
} else {
    this.filters = value;
}
return this;}),
        'getFilter': ($__.fs.J$__v494107025_2475_1259 = function J$__v494107025_2475() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return this.getFilters()[0];}),
        'setFilter': ($__.fs.J$__v494107025_2477_1260 = function J$__v494107025_2477(filter) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
filter = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return this.setFilters(filter ? [filter] : []);}),
        'setPlaybackRate': ($__.fs.J$__v494107025_2479_1261 = function J$__v494107025_2479(value) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
value = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (this.hasPlaybackControl === false) {
    console.warn('THREE.Audio: this Audio has no playback control.');
    return;
}
this.playbackRate = value;
if (this.isPlaying === true) {
    this.source.playbackRate.value = this.playbackRate;
}
return this;}),
        'getPlaybackRate': ($__.fs.J$__v494107025_2481_1262 = function J$__v494107025_2481() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return this.playbackRate;}),
        'onEnded': ($__.fs.J$__v494107025_2483_1263 = function J$__v494107025_2483() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.isPlaying = false;}),
        'getLoop': ($__.fs.J$__v494107025_2485_1264 = function J$__v494107025_2485() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (this.hasPlaybackControl === false) {
    console.warn('THREE.Audio: this Audio has no playback control.');
    return false;
}
return this.source.loop;}),
        'setLoop': ($__.fs.J$__v494107025_2487_1265 = function J$__v494107025_2487(value) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
value = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (this.hasPlaybackControl === false) {
    console.warn('THREE.Audio: this Audio has no playback control.');
    return;
}
this.source.loop = value;}),
        'getVolume': ($__.fs.J$__v494107025_2489_1266 = function J$__v494107025_2489() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return this.gain.gain.value;}),
        'setVolume': ($__.fs.J$__v494107025_2491_1267 = function J$__v494107025_2491(value) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
value = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.gain.gain.value = value;
return this;})
    });
    PositionalAudio.prototype = Object['assign'](Object['create'](TAJS_restrictToType(Audio.prototype, 'object')), $__.os.oid503 = {
        'constructor': PositionalAudio,
        'getOutput': ($__.fs.J$__v494107025_2494_1268 = function J$__v494107025_2494() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return this.panner;}),
        'getRefDistance': ($__.fs.J$__v494107025_2496_1269 = function J$__v494107025_2496() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return this.panner.refDistance;}),
        'setRefDistance': ($__.fs.J$__v494107025_2498_1270 = function J$__v494107025_2498(value) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
value = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.panner.refDistance = value;}),
        'getRolloffFactor': ($__.fs.J$__v494107025_2500_1271 = function J$__v494107025_2500() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return this.panner.rolloffFactor;}),
        'setRolloffFactor': ($__.fs.J$__v494107025_2502_1272 = function J$__v494107025_2502(value) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
value = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.panner.rolloffFactor = value;}),
        'getDistanceModel': ($__.fs.J$__v494107025_2504_1273 = function J$__v494107025_2504() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return this.panner.distanceModel;}),
        'setDistanceModel': ($__.fs.J$__v494107025_2506_1274 = function J$__v494107025_2506(value) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
value = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.panner.distanceModel = value;}),
        'getMaxDistance': ($__.fs.J$__v494107025_2508_1275 = function J$__v494107025_2508() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return this.panner.maxDistance;}),
        'setMaxDistance': ($__.fs.J$__v494107025_2510_1276 = function J$__v494107025_2510(value) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
value = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.panner.maxDistance = value;}),
        'updateMatrixWorld': (($__.fs.J$__v494107025_2513_1277 = function J$__v494107025_2513() {
var vvv_return, vvv_switch, position;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    position = new (Vector3, $__.fs.Vector3_11)(82, true, $__.uid);
    return ($__.fs.updateMatrixWorld_1278 = function updateMatrixWorld(force) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
force = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
Object3D.prototype.updateMatrixWorld.call(this, force);
position.setFromMatrixPosition(this.matrixWorld);
this.panner.setPosition(position.x, position.y, position.z);});
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
position = new Vector3();
return function updateMatrixWorld(force) {
    Object3D.prototype.updateMatrixWorld.call(this, force);
    position.setFromMatrixPosition(this.matrixWorld);
    this.panner.setPosition(position.x, position.y, position.z);
};}), $__.fs.J$__v494107025_2513_1277)(0, true, $__.uid)
    });
    Object['assign'](TAJS_restrictToType(AudioAnalyser.prototype, 'object'), $__.os.oid504 = {
        'getFrequencyData': ($__.fs.J$__v494107025_2516_1279 = function J$__v494107025_2516() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.analyser.getByteFrequencyData(this.data);
return this.data;}),
        'getAverageFrequency': ($__.fs.J$__v494107025_2518_1280 = function J$__v494107025_2518() {
var vvv_return, vvv_switch, value, data;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
value = 0;
data = this.getFrequencyData();
for (var i = 0; i < data.length; i++) {
    value += data[i];
}
return value / data.length;})
    });
    PropertyMixer.prototype = $__.os.oid505 = {
        'constructor': PropertyMixer,
        'accumulate': ($__.fs.J$__v494107025_2521_1281 = function J$__v494107025_2521(accuIndex, weight) {
var vvv_return, vvv_switch, buffer, stride, offset, currentWeight, mix;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
accuIndex = arguments[0], weight = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
buffer = this.buffer;
stride = this.valueSize;
offset = accuIndex * stride + stride;
currentWeight = this.cumulativeWeight;
if (currentWeight === 0) {
    for (var i = 0; i !== stride; ++i) {
        buffer[offset + i] = buffer[i];
    }
    currentWeight = weight;
} else {
    currentWeight += weight;
    mix = weight / currentWeight;
    this._mixBufferRegion(buffer, offset, 0, mix, stride);
}
this.cumulativeWeight = currentWeight;}),
        'apply': ($__.fs.J$__v494107025_2523_1282 = function J$__v494107025_2523(accuIndex) {
var vvv_return, vvv_switch, stride, buffer, offset, weight, binding, originalValueOffset;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
accuIndex = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
stride = this.valueSize;
buffer = this.buffer;
offset = accuIndex * stride + stride;
weight = this.cumulativeWeight;
binding = this.binding;
this.cumulativeWeight = 0;
if (weight < 1) {
    originalValueOffset = stride * 3;
    this._mixBufferRegion(buffer, offset, originalValueOffset, 1 - weight, stride);
}
for (var i = stride, e = stride + stride; i !== e; ++i) {
    if (buffer[i] !== buffer[i + stride]) {
        binding.setValue(buffer, offset);
        break;
    }
}}),
        'saveOriginalState': ($__.fs.J$__v494107025_2525_1283 = function J$__v494107025_2525() {
var vvv_return, vvv_switch, binding, buffer, stride, originalValueOffset;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
binding = this.binding;
buffer = this.buffer;
stride = this.valueSize;
originalValueOffset = stride * 3;
binding.getValue(buffer, originalValueOffset);
for (var i = stride, e = originalValueOffset; i !== e; ++i) {
    buffer[i] = buffer[originalValueOffset + i % stride];
}
this.cumulativeWeight = 0;}),
        'restoreOriginalState': ($__.fs.J$__v494107025_2527_1284 = function J$__v494107025_2527() {
var vvv_return, vvv_switch, originalValueOffset;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
originalValueOffset = this.valueSize * 3;
this.binding.setValue(this.buffer, originalValueOffset);}),
        '_select': ($__.fs.J$__v494107025_2529_1285 = function J$__v494107025_2529(buffer, dstOffset, srcOffset, t, stride) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
buffer = arguments[0], dstOffset = arguments[1], srcOffset = arguments[2], t = arguments[3], stride = arguments[4];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (t >= 0.5) {
    for (var i = 0; i !== stride; ++i) {
        buffer[dstOffset + i] = buffer[srcOffset + i];
    }
}}),
        '_slerp': ($__.fs.J$__v494107025_2531_1286 = function J$__v494107025_2531(buffer, dstOffset, srcOffset, t, stride) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
buffer = arguments[0], dstOffset = arguments[1], srcOffset = arguments[2], t = arguments[3], stride = arguments[4];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t);}),
        '_lerp': ($__.fs.J$__v494107025_2533_1287 = function J$__v494107025_2533(buffer, dstOffset, srcOffset, t, stride) {
var vvv_return, vvv_switch, s, j;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
buffer = arguments[0], dstOffset = arguments[1], srcOffset = arguments[2], t = arguments[3], stride = arguments[4];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
s = 1 - t;
for (var i = 0; i !== stride; ++i) {
    j = dstOffset + i;
    buffer[j] = buffer[j] * s + buffer[srcOffset + i] * t;
}})
    };
    PropertyBinding.prototype = $__.os.oid506 = {
        'constructor': PropertyBinding,
        'getValue': ($__.fs.getValue_unbound_1288 = function getValue_unbound(targetArray, offset) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
targetArray = arguments[0], offset = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.bind();
this.getValue(targetArray, offset);}),
        'setValue': ($__.fs.getValue_unbound_1289 = function getValue_unbound(sourceArray, offset) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
sourceArray = arguments[0], offset = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.bind();
this.setValue(sourceArray, offset);}),
        'bind': ($__.fs.J$__v494107025_2538_1290 = function J$__v494107025_2538() {
var vvv_return, vvv_switch, targetObject, parsedPath, objectName, propertyName, propertyIndex, objectIndex, nodeProperty, nodeName, versioning, bindingType;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
targetObject = this.node;
parsedPath = this.parsedPath;
objectName = parsedPath.objectName;
propertyName = parsedPath.propertyName;
propertyIndex = parsedPath.propertyIndex;
if (!targetObject) {
    targetObject = PropertyBinding.findNode(this.rootNode, parsedPath.nodeName) || this.rootNode;
    this.node = targetObject;
}
this.getValue = this._getValue_unavailable;
this.setValue = this._setValue_unavailable;
if (!targetObject) {
    console.error('  trying to update node for track: ' + this.path + ' but it wasn\'t found.');
    return;
}
if (objectName) {
    objectIndex = parsedPath.objectIndex;
    switch (objectName) {
    case 'materials':
        if (!targetObject.material) {
            console.error('  can not bind to material as node does not have a material', this);
            return;
        }
        if (!targetObject.material.materials) {
            console.error('  can not bind to material.materials as node.material does not have a materials array', this);
            return;
        }
        targetObject = targetObject.material.materials;
        break;
    case 'bones':
        if (!targetObject.skeleton) {
            console.error('  can not bind to bones as node does not have a skeleton', this);
            return;
        }
        targetObject = targetObject.skeleton.bones;
        for (var i = 0; i < targetObject.length; i++) {
            if (targetObject[i].name === objectIndex) {
                objectIndex = i;
                break;
            }
        }
        break;
    default:
        if (targetObject[objectName] === undefined) {
            console.error('  can not bind to objectName of node, undefined', this);
            return;
        }
        targetObject = targetObject[objectName];
    }
    if (objectIndex !== undefined) {
        if (targetObject[objectIndex] === undefined) {
            console.error('  trying to bind to objectIndex of objectName, but is undefined:', this, targetObject);
            return;
        }
        targetObject = targetObject[objectIndex];
    }
}
nodeProperty = targetObject[propertyName];
if (nodeProperty === undefined) {
    nodeName = parsedPath.nodeName;
    console.error('  trying to update property for track: ' + nodeName + '.' + propertyName + ' but it wasn\'t found.', targetObject);
    return;
}
versioning = this.Versioning.None;
if (targetObject.needsUpdate !== undefined) {
    versioning = this.Versioning.NeedsUpdate;
    this.targetObject = targetObject;
} else if (targetObject.matrixWorldNeedsUpdate !== undefined) {
    versioning = this.Versioning.MatrixWorldNeedsUpdate;
    this.targetObject = targetObject;
}
bindingType = this.BindingType.Direct;
if (propertyIndex !== undefined) {
    if (propertyName === 'morphTargetInfluences') {
        if (!targetObject.geometry) {
            console.error('  can not bind to morphTargetInfluences becasuse node does not have a geometry', this);
            return;
        }
        if (!targetObject.geometry.morphTargets) {
            console.error('  can not bind to morphTargetInfluences becasuse node does not have a geometry.morphTargets', this);
            return;
        }
        for (var i = 0; i < this.node.geometry.morphTargets.length; i++) {
            if (targetObject.geometry.morphTargets[i].name === propertyIndex) {
                propertyIndex = i;
                break;
            }
        }
    }
    bindingType = this.BindingType.ArrayElement;
    this.resolvedProperty = nodeProperty;
    this.propertyIndex = propertyIndex;
} else if (nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined) {
    bindingType = this.BindingType.HasFromToArray;
    this.resolvedProperty = nodeProperty;
} else if (nodeProperty.length !== undefined) {
    bindingType = this.BindingType.EntireArray;
    this.resolvedProperty = nodeProperty;
} else {
    this.propertyName = propertyName;
}
this.getValue = this.GetterByBindingType[bindingType];
this.setValue = this.SetterByBindingTypeAndVersioning[bindingType][versioning];}),
        'unbind': ($__.fs.J$__v494107025_2540_1291 = function J$__v494107025_2540() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.node = null;
this.getValue = this._getValue_unbound;
this.setValue = this._setValue_unbound;})
    };
    Object['assign']((PropertyBinding.prototype, $__.os.oid506), $__.os.oid509 = {
        '_getValue_unavailable': ($__.fs.J$__v494107025_2542_1292 = function J$__v494107025_2542() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');}),
        '_setValue_unavailable': ($__.fs.J$__v494107025_2544_1293 = function J$__v494107025_2544() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');}),
        '_getValue_unbound': TAJS_restrictToType(((PropertyBinding.prototype, $__.os.oid506), $__.os.oid506).getValue, 'function'),
        '_setValue_unbound': TAJS_restrictToType(((PropertyBinding.prototype, $__.os.oid506), $__.os.oid506).setValue, 'function'),
        'BindingType': $__.os.oid507 = {
            'Direct': 0,
            'EntireArray': 1,
            'ArrayElement': 2,
            'HasFromToArray': 3
        },
        'Versioning': $__.os.oid508 = {
            'None': 0,
            'NeedsUpdate': 1,
            'MatrixWorldNeedsUpdate': 2
        },
        'GetterByBindingType': [
            ($__.fs.getValue_direct_1294 = function getValue_direct(buffer, offset) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
buffer = arguments[0], offset = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
buffer[offset] = this.node[this.propertyName];}),
            ($__.fs.getValue_array_1295 = function getValue_array(buffer, offset) {
var vvv_return, vvv_switch, source;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
buffer = arguments[0], offset = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
source = this.resolvedProperty;
for (var i = 0, n = source.length; i !== n; ++i) {
    buffer[offset++] = source[i];
}}),
            ($__.fs.getValue_arrayElement_1296 = function getValue_arrayElement(buffer, offset) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
buffer = arguments[0], offset = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
buffer[offset] = this.resolvedProperty[this.propertyIndex];}),
            ($__.fs.getValue_toArray_1297 = function getValue_toArray(buffer, offset) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
buffer = arguments[0], offset = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.resolvedProperty.toArray(buffer, offset);})
        ],
        'SetterByBindingTypeAndVersioning': [
            [
                ($__.fs.setValue_direct_1298 = function setValue_direct(buffer, offset) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
buffer = arguments[0], offset = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.node[this.propertyName] = buffer[offset];}),
                ($__.fs.setValue_direct_setNeedsUpdate_1299 = function setValue_direct_setNeedsUpdate(buffer, offset) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
buffer = arguments[0], offset = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.node[this.propertyName] = buffer[offset];
this.targetObject.needsUpdate = true;}),
                ($__.fs.setValue_direct_setMatrixWorldNeedsUpdate_1300 = function setValue_direct_setMatrixWorldNeedsUpdate(buffer, offset) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
buffer = arguments[0], offset = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.node[this.propertyName] = buffer[offset];
this.targetObject.matrixWorldNeedsUpdate = true;})
            ],
            [
                ($__.fs.setValue_array_1301 = function setValue_array(buffer, offset) {
var vvv_return, vvv_switch, dest;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
buffer = arguments[0], offset = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
dest = this.resolvedProperty;
for (var i = 0, n = dest.length; i !== n; ++i) {
    dest[i] = buffer[offset++];
}}),
                ($__.fs.setValue_array_setNeedsUpdate_1302 = function setValue_array_setNeedsUpdate(buffer, offset) {
var vvv_return, vvv_switch, dest;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
buffer = arguments[0], offset = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
dest = this.resolvedProperty;
for (var i = 0, n = dest.length; i !== n; ++i) {
    dest[i] = buffer[offset++];
}
this.targetObject.needsUpdate = true;}),
                ($__.fs.setValue_array_setMatrixWorldNeedsUpdate_1303 = function setValue_array_setMatrixWorldNeedsUpdate(buffer, offset) {
var vvv_return, vvv_switch, dest;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
buffer = arguments[0], offset = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
dest = this.resolvedProperty;
for (var i = 0, n = dest.length; i !== n; ++i) {
    dest[i] = buffer[offset++];
}
this.targetObject.matrixWorldNeedsUpdate = true;})
            ],
            [
                ($__.fs.setValue_arrayElement_1304 = function setValue_arrayElement(buffer, offset) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
buffer = arguments[0], offset = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.resolvedProperty[this.propertyIndex] = buffer[offset];}),
                ($__.fs.setValue_arrayElement_setNeedsUpdate_1305 = function setValue_arrayElement_setNeedsUpdate(buffer, offset) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
buffer = arguments[0], offset = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.resolvedProperty[this.propertyIndex] = buffer[offset];
this.targetObject.needsUpdate = true;}),
                ($__.fs.setValue_arrayElement_setMatrixWorldNeedsUpdate_1306 = function setValue_arrayElement_setMatrixWorldNeedsUpdate(buffer, offset) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
buffer = arguments[0], offset = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.resolvedProperty[this.propertyIndex] = buffer[offset];
this.targetObject.matrixWorldNeedsUpdate = true;})
            ],
            [
                ($__.fs.setValue_fromArray_1307 = function setValue_fromArray(buffer, offset) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
buffer = arguments[0], offset = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.resolvedProperty.fromArray(buffer, offset);}),
                ($__.fs.setValue_fromArray_setNeedsUpdate_1308 = function setValue_fromArray_setNeedsUpdate(buffer, offset) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
buffer = arguments[0], offset = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.resolvedProperty.fromArray(buffer, offset);
this.targetObject.needsUpdate = true;}),
                ($__.fs.setValue_fromArray_setMatrixWorldNeedsUpdate_1309 = function setValue_fromArray_setMatrixWorldNeedsUpdate(buffer, offset) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
buffer = arguments[0], offset = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.resolvedProperty.fromArray(buffer, offset);
this.targetObject.matrixWorldNeedsUpdate = true;})
            ]
        ]
    });
    PropertyBinding.Composite = ($__.fs.J$__v494107025_2562_1310 = function J$__v494107025_2562(targetGroup, path, optionalParsedPath) {
var vvv_return, vvv_switch, parsedPath;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
targetGroup = arguments[0], path = arguments[1], optionalParsedPath = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
parsedPath = optionalParsedPath || PropertyBinding.parseTrackName(path);
this._targetGroup = targetGroup;
this._bindings = targetGroup.subscribe_(path, parsedPath);});
    TAJS_restrictToType(PropertyBinding.Composite, 'function').prototype = $__.os.oid510 = {
        'constructor': TAJS_restrictToType(PropertyBinding.Composite, 'function'),
        'getValue': ($__.fs.J$__v494107025_2564_1311 = function J$__v494107025_2564(array, offset) {
var vvv_return, vvv_switch, firstValidIndex, binding;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
array = arguments[0], offset = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.bind();
firstValidIndex = this._targetGroup.nCachedObjects_;
binding = this._bindings[firstValidIndex];
if (binding !== undefined)
    binding.getValue(array, offset);}),
        'setValue': ($__.fs.J$__v494107025_2566_1312 = function J$__v494107025_2566(array, offset) {
var vvv_return, vvv_switch, bindings;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
array = arguments[0], offset = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
bindings = this._bindings;
for (var i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
    bindings[i].setValue(array, offset);
}}),
        'bind': ($__.fs.J$__v494107025_2568_1313 = function J$__v494107025_2568() {
var vvv_return, vvv_switch, bindings;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
bindings = this._bindings;
for (var i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
    bindings[i].bind();
}}),
        'unbind': ($__.fs.J$__v494107025_2570_1314 = function J$__v494107025_2570() {
var vvv_return, vvv_switch, bindings;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
bindings = this._bindings;
for (var i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
    bindings[i].unbind();
}})
    };
    PropertyBinding.create = ($__.fs.J$__v494107025_2572_1315 = function J$__v494107025_2572(root, path, parsedPath) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
root = arguments[0], path = arguments[1], parsedPath = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (!(root && root.isAnimationObjectGroup)) {
    return new PropertyBinding(root, path, parsedPath);
} else {
    return new PropertyBinding.Composite(root, path, parsedPath);
}});
    PropertyBinding.parseTrackName = ($__.fs.J$__v494107025_2574_1316 = function J$__v494107025_2574(trackName) {
var vvv_return, vvv_switch, re, matches, results;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
trackName = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
re = /^((?:\w+\/)*)(\w+)?(?:\.(\w+)(?:\[(.+)\])?)?\.(\w+)(?:\[(.+)\])?$/;
matches = re.exec(trackName);
if (!matches) {
    throw new Error('cannot parse trackName at all: ' + trackName);
}
results = {
    nodeName: matches[2],
    objectName: matches[3],
    objectIndex: matches[4],
    propertyName: matches[5],
    propertyIndex: matches[6]
};
if (results.propertyName === null || results.propertyName.length === 0) {
    throw new Error('can not parse propertyName from trackName: ' + trackName);
}
return results;});
    PropertyBinding.findNode = ($__.fs.J$__v494107025_2580_1317 = function J$__v494107025_2580(root, nodeName) {
var vvv_return, vvv_switch, searchSkeleton, bone, searchNodeSubtree, subTreeNode;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
root = arguments[0], nodeName = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (!nodeName || nodeName === '' || nodeName === 'root' || nodeName === '.' || nodeName === -1 || nodeName === root.name || nodeName === root.uuid) {
    return root;
}
if (root.skeleton) {
    searchSkeleton = function (skeleton) {
        for (var i = 0; i < skeleton.bones.length; i++) {
            var bone = skeleton.bones[i];
            if (bone.name === nodeName) {
                return bone;
            }
        }
        return null;
    };
    bone = searchSkeleton(root.skeleton);
    if (bone) {
        return bone;
    }
}
if (root.children) {
    searchNodeSubtree = function (children) {
        for (var i = 0; i < children.length; i++) {
            var childNode = children[i];
            if (childNode.name === nodeName || childNode.uuid === nodeName) {
                return childNode;
            }
            var result = searchNodeSubtree(childNode.children);
            if (result)
                return result;
        }
        return null;
    };
    subTreeNode = searchNodeSubtree(root.children);
    if (subTreeNode) {
        return subTreeNode;
    }
}
return null;});
    AnimationObjectGroup.prototype = $__.os.oid511 = {
        'constructor': AnimationObjectGroup,
        'isAnimationObjectGroup': true,
        'add': ($__.fs.J$__v494107025_2589_1318 = function J$__v494107025_2589(var_args) {
var vvv_return, vvv_switch, objects, nObjects, nCachedObjects, indicesByUUID, paths, parsedPaths, bindings, nBindings, object, uuid, index, knownObject, firstActiveIndex, lastCachedObject, bindingsForPath, lastCached, binding;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
var_args = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
objects = this._objects;
nObjects = objects.length;
nCachedObjects = this.nCachedObjects_;
indicesByUUID = this._indicesByUUID;
paths = this._paths;
parsedPaths = this._parsedPaths;
bindings = this._bindings;
nBindings = bindings.length;
for (var i = 0, n = arguments.length; i !== n; ++i) {
    object = arguments[i];
    uuid = object.uuid;
    index = indicesByUUID[uuid];
    if (index === undefined) {
        index = nObjects++;
        indicesByUUID[uuid] = index;
        objects.push(object);
        for (var j = 0, m = nBindings; j !== m; ++j) {
            bindings[j].push(new PropertyBinding(object, paths[j], parsedPaths[j]));
        }
    } else if (index < nCachedObjects) {
        knownObject = objects[index];
        firstActiveIndex = --nCachedObjects;
        lastCachedObject = objects[firstActiveIndex];
        indicesByUUID[lastCachedObject.uuid] = index;
        objects[index] = lastCachedObject;
        indicesByUUID[uuid] = firstActiveIndex;
        objects[firstActiveIndex] = object;
        for (var j = 0, m = nBindings; j !== m; ++j) {
            bindingsForPath = bindings[j];
            lastCached = bindingsForPath[firstActiveIndex];
            binding = bindingsForPath[index];
            bindingsForPath[index] = lastCached;
            if (binding === undefined) {
                binding = new PropertyBinding(object, paths[j], parsedPaths[j]);
            }
            bindingsForPath[firstActiveIndex] = binding;
        }
    } else if (objects[index] !== knownObject) {
        console.error('Different objects with the same UUID ' + 'detected. Clean the caches or recreate your ' + 'infrastructure when reloading scenes...');
    }
}
this.nCachedObjects_ = nCachedObjects;}),
        'remove': ($__.fs.J$__v494107025_2591_1319 = function J$__v494107025_2591(var_args) {
var vvv_return, vvv_switch, objects, nCachedObjects, indicesByUUID, bindings, nBindings, object, uuid, index, lastCachedIndex, firstActiveObject, bindingsForPath, firstActive, binding;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
var_args = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
objects = this._objects;
nCachedObjects = this.nCachedObjects_;
indicesByUUID = this._indicesByUUID;
bindings = this._bindings;
nBindings = bindings.length;
for (var i = 0, n = arguments.length; i !== n; ++i) {
    object = arguments[i];
    uuid = object.uuid;
    index = indicesByUUID[uuid];
    if (index !== undefined && index >= nCachedObjects) {
        lastCachedIndex = nCachedObjects++;
        firstActiveObject = objects[lastCachedIndex];
        indicesByUUID[firstActiveObject.uuid] = index;
        objects[index] = firstActiveObject;
        indicesByUUID[uuid] = lastCachedIndex;
        objects[lastCachedIndex] = object;
        for (var j = 0, m = nBindings; j !== m; ++j) {
            bindingsForPath = bindings[j];
            firstActive = bindingsForPath[lastCachedIndex];
            binding = bindingsForPath[index];
            bindingsForPath[index] = firstActive;
            bindingsForPath[lastCachedIndex] = binding;
        }
    }
}
this.nCachedObjects_ = nCachedObjects;}),
        'uncache': ($__.fs.J$__v494107025_2593_1320 = function J$__v494107025_2593(var_args) {
var vvv_return, vvv_switch, objects, nObjects, nCachedObjects, indicesByUUID, bindings, nBindings, object, uuid, index, firstActiveIndex, lastCachedObject, lastIndex, lastObject, bindingsForPath, lastCached, last;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
var_args = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
objects = this._objects;
nObjects = objects.length;
nCachedObjects = this.nCachedObjects_;
indicesByUUID = this._indicesByUUID;
bindings = this._bindings;
nBindings = bindings.length;
for (var i = 0, n = arguments.length; i !== n; ++i) {
    object = arguments[i];
    uuid = object.uuid;
    index = indicesByUUID[uuid];
    if (index !== undefined) {
        delete indicesByUUID[uuid];
        if (index < nCachedObjects) {
            firstActiveIndex = --nCachedObjects;
            lastCachedObject = objects[firstActiveIndex];
            lastIndex = --nObjects;
            lastObject = objects[lastIndex];
            indicesByUUID[lastCachedObject.uuid] = index;
            objects[index] = lastCachedObject;
            indicesByUUID[lastObject.uuid] = firstActiveIndex;
            objects[firstActiveIndex] = lastObject;
            objects.pop();
            for (var j = 0, m = nBindings; j !== m; ++j) {
                bindingsForPath = bindings[j];
                lastCached = bindingsForPath[firstActiveIndex];
                last = bindingsForPath[lastIndex];
                bindingsForPath[index] = lastCached;
                bindingsForPath[firstActiveIndex] = last;
                bindingsForPath.pop();
            }
        } else {
            lastIndex = --nObjects;
            lastObject = objects[lastIndex];
            indicesByUUID[lastObject.uuid] = index;
            objects[index] = lastObject;
            objects.pop();
            for (var j = 0, m = nBindings; j !== m; ++j) {
                bindingsForPath = bindings[j];
                bindingsForPath[index] = bindingsForPath[lastIndex];
                bindingsForPath.pop();
            }
        }
    }
}
this.nCachedObjects_ = nCachedObjects;}),
        'subscribe_': ($__.fs.J$__v494107025_2595_1321 = function J$__v494107025_2595(path, parsedPath) {
var vvv_return, vvv_switch, indicesByPath, index, bindings, paths, parsedPaths, objects, nObjects, nCachedObjects, bindingsForPath, object;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
path = arguments[0], parsedPath = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
indicesByPath = this._bindingsIndicesByPath;
index = indicesByPath[path];
bindings = this._bindings;
if (index !== undefined)
    return bindings[index];
paths = this._paths;
parsedPaths = this._parsedPaths;
objects = this._objects;
nObjects = objects.length;
nCachedObjects = this.nCachedObjects_;
bindingsForPath = new Array(nObjects);
index = bindings.length;
indicesByPath[path] = index;
paths.push(path);
parsedPaths.push(parsedPath);
bindings.push(bindingsForPath);
for (var i = nCachedObjects, n = objects.length; i !== n; ++i) {
    object = objects[i];
    bindingsForPath[i] = new PropertyBinding(object, path, parsedPath);
}
return bindingsForPath;}),
        'unsubscribe_': ($__.fs.J$__v494107025_2597_1322 = function J$__v494107025_2597(path) {
var vvv_return, vvv_switch, indicesByPath, index, paths, parsedPaths, bindings, lastBindingsIndex, lastBindings, lastBindingsPath;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
path = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
indicesByPath = this._bindingsIndicesByPath;
index = indicesByPath[path];
if (index !== undefined) {
    paths = this._paths;
    parsedPaths = this._parsedPaths;
    bindings = this._bindings;
    lastBindingsIndex = bindings.length - 1;
    lastBindings = bindings[lastBindingsIndex];
    lastBindingsPath = path[lastBindingsIndex];
    indicesByPath[lastBindingsPath] = index;
    bindings[index] = lastBindings;
    bindings.pop();
    parsedPaths[index] = parsedPaths[lastBindingsIndex];
    parsedPaths.pop();
    paths[index] = paths[lastBindingsIndex];
    paths.pop();
}})
    };
    AnimationAction.prototype = $__.os.oid512 = {
        'constructor': AnimationAction,
        'play': ($__.fs.J$__v494107025_2600_1323 = function J$__v494107025_2600() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this._mixer._activateAction(this);
return this;}),
        'stop': ($__.fs.J$__v494107025_2602_1324 = function J$__v494107025_2602() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this._mixer._deactivateAction(this);
return this.reset();}),
        'reset': ($__.fs.J$__v494107025_2604_1325 = function J$__v494107025_2604() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.paused = false;
this.enabled = true;
this.time = 0;
this._loopCount = -1;
this._startTime = null;
return this.stopFading().stopWarping();}),
        'isRunning': ($__.fs.J$__v494107025_2606_1326 = function J$__v494107025_2606() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);}),
        'isScheduled': ($__.fs.J$__v494107025_2608_1327 = function J$__v494107025_2608() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return this._mixer._isActiveAction(this);}),
        'startAt': ($__.fs.J$__v494107025_2610_1328 = function J$__v494107025_2610(time) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
time = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this._startTime = time;
return this;}),
        'setLoop': ($__.fs.J$__v494107025_2612_1329 = function J$__v494107025_2612(mode, repetitions) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
mode = arguments[0], repetitions = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.loop = mode;
this.repetitions = repetitions;
return this;}),
        'setEffectiveWeight': ($__.fs.J$__v494107025_2614_1330 = function J$__v494107025_2614(weight) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
weight = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.weight = weight;
this._effectiveWeight = this.enabled ? weight : 0;
return this.stopFading();}),
        'getEffectiveWeight': ($__.fs.J$__v494107025_2616_1331 = function J$__v494107025_2616() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return this._effectiveWeight;}),
        'fadeIn': ($__.fs.J$__v494107025_2618_1332 = function J$__v494107025_2618(duration) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
duration = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return this._scheduleFading(duration, 0, 1);}),
        'fadeOut': ($__.fs.J$__v494107025_2620_1333 = function J$__v494107025_2620(duration) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
duration = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return this._scheduleFading(duration, 1, 0);}),
        'crossFadeFrom': ($__.fs.J$__v494107025_2622_1334 = function J$__v494107025_2622(fadeOutAction, duration, warp) {
var vvv_return, vvv_switch, fadeInDuration, fadeOutDuration, startEndRatio, endStartRatio;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
fadeOutAction = arguments[0], duration = arguments[1], warp = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
fadeOutAction.fadeOut(duration);
this.fadeIn(duration);
if (warp) {
    fadeInDuration = this._clip.duration;
    fadeOutDuration = fadeOutAction._clip.duration;
    startEndRatio = fadeOutDuration / fadeInDuration;
    endStartRatio = fadeInDuration / fadeOutDuration;
    fadeOutAction.warp(1, startEndRatio, duration);
    this.warp(endStartRatio, 1, duration);
}
return this;}),
        'crossFadeTo': ($__.fs.J$__v494107025_2624_1335 = function J$__v494107025_2624(fadeInAction, duration, warp) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
fadeInAction = arguments[0], duration = arguments[1], warp = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return fadeInAction.crossFadeFrom(this, duration, warp);}),
        'stopFading': ($__.fs.J$__v494107025_2626_1336 = function J$__v494107025_2626() {
var vvv_return, vvv_switch, weightInterpolant;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
weightInterpolant = this._weightInterpolant;
if (weightInterpolant !== null) {
    this._weightInterpolant = null;
    this._mixer._takeBackControlInterpolant(weightInterpolant);
}
return this;}),
        'setEffectiveTimeScale': ($__.fs.J$__v494107025_2628_1337 = function J$__v494107025_2628(timeScale) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
timeScale = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.timeScale = timeScale;
this._effectiveTimeScale = this.paused ? 0 : timeScale;
return this.stopWarping();}),
        'getEffectiveTimeScale': ($__.fs.J$__v494107025_2630_1338 = function J$__v494107025_2630() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return this._effectiveTimeScale;}),
        'setDuration': ($__.fs.J$__v494107025_2632_1339 = function J$__v494107025_2632(duration) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
duration = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.timeScale = this._clip.duration / duration;
return this.stopWarping();}),
        'syncWith': ($__.fs.J$__v494107025_2634_1340 = function J$__v494107025_2634(action) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
action = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.time = action.time;
this.timeScale = action.timeScale;
return this.stopWarping();}),
        'halt': ($__.fs.J$__v494107025_2636_1341 = function J$__v494107025_2636(duration) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
duration = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return this.warp(this._effectiveTimeScale, 0, duration);}),
        'warp': ($__.fs.J$__v494107025_2638_1342 = function J$__v494107025_2638(startTimeScale, endTimeScale, duration) {
var vvv_return, vvv_switch, mixer, now, interpolant, timeScale, times, values;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
startTimeScale = arguments[0], endTimeScale = arguments[1], duration = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
mixer = this._mixer;
now = mixer.time;
interpolant = this._timeScaleInterpolant;
timeScale = this.timeScale;
if (interpolant === null) {
    interpolant = mixer._lendControlInterpolant(), this._timeScaleInterpolant = interpolant;
}
times = interpolant.parameterPositions;
values = interpolant.sampleValues;
times[0] = now;
times[1] = now + duration;
values[0] = startTimeScale / timeScale;
values[1] = endTimeScale / timeScale;
return this;}),
        'stopWarping': ($__.fs.J$__v494107025_2640_1343 = function J$__v494107025_2640() {
var vvv_return, vvv_switch, timeScaleInterpolant;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
timeScaleInterpolant = this._timeScaleInterpolant;
if (timeScaleInterpolant !== null) {
    this._timeScaleInterpolant = null;
    this._mixer._takeBackControlInterpolant(timeScaleInterpolant);
}
return this;}),
        'getMixer': ($__.fs.J$__v494107025_2642_1344 = function J$__v494107025_2642() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return this._mixer;}),
        'getClip': ($__.fs.J$__v494107025_2644_1345 = function J$__v494107025_2644() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return this._clip;}),
        'getRoot': ($__.fs.J$__v494107025_2646_1346 = function J$__v494107025_2646() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return this._localRoot || this._mixer._root;}),
        '_update': ($__.fs.J$__v494107025_2648_1347 = function J$__v494107025_2648(time, deltaTime, timeDirection, accuIndex) {
var vvv_return, vvv_switch, startTime, timeRunning, clipTime, weight, interpolants, propertyMixers;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
time = arguments[0], deltaTime = arguments[1], timeDirection = arguments[2], accuIndex = arguments[3];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
startTime = this._startTime;
if (startTime !== null) {
    timeRunning = (time - startTime) * timeDirection;
    if (timeRunning < 0 || timeDirection === 0) {
        return;
    }
    this._startTime = null;
    deltaTime = timeDirection * timeRunning;
}
deltaTime *= this._updateTimeScale(time);
clipTime = this._updateTime(deltaTime);
weight = this._updateWeight(time);
if (weight > 0) {
    interpolants = this._interpolants;
    propertyMixers = this._propertyBindings;
    for (var j = 0, m = interpolants.length; j !== m; ++j) {
        interpolants[j].evaluate(clipTime);
        propertyMixers[j].accumulate(accuIndex, weight);
    }
}}),
        '_updateWeight': ($__.fs.J$__v494107025_2650_1348 = function J$__v494107025_2650(time) {
var vvv_return, vvv_switch, weight, interpolant, interpolantValue;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
time = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
weight = 0;
if (this.enabled) {
    weight = this.weight;
    interpolant = this._weightInterpolant;
    if (interpolant !== null) {
        interpolantValue = interpolant.evaluate(time)[0];
        weight *= interpolantValue;
        if (time > interpolant.parameterPositions[1]) {
            this.stopFading();
            if (interpolantValue === 0) {
                this.enabled = false;
            }
        }
    }
}
this._effectiveWeight = weight;
return weight;}),
        '_updateTimeScale': ($__.fs.J$__v494107025_2652_1349 = function J$__v494107025_2652(time) {
var vvv_return, vvv_switch, timeScale, interpolant, interpolantValue;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
time = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
timeScale = 0;
if (!this.paused) {
    timeScale = this.timeScale;
    interpolant = this._timeScaleInterpolant;
    if (interpolant !== null) {
        interpolantValue = interpolant.evaluate(time)[0];
        timeScale *= interpolantValue;
        if (time > interpolant.parameterPositions[1]) {
            this.stopWarping();
            if (timeScale === 0) {
                this.paused = true;
            } else {
                this.timeScale = timeScale;
            }
        }
    }
}
this._effectiveTimeScale = timeScale;
return timeScale;}),
        '_updateTime': ($__.fs.J$__v494107025_2654_1350 = function J$__v494107025_2654(deltaTime) {
var vvv_return, vvv_switch, time, duration, loop, loopCount, pingPong, loopDelta, pending, atStart;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
deltaTime = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
time = this.time + deltaTime;
if (deltaTime === 0)
    return time;
duration = this._clip.duration;
loop = this.loop;
loopCount = this._loopCount;
if (loop === LoopOnce) {
    if (loopCount === -1) {
        this.loopCount = 0;
        this._setEndings(true, true, false);
    }
    handle_stop: {
        if (time >= duration) {
            time = duration;
        } else if (time < 0) {
            time = 0;
        } else
            break handle_stop;
        if (this.clampWhenFinished)
            this.paused = true;
        else
            this.enabled = false;
        this._mixer.dispatchEvent({
            type: 'finished',
            action: this,
            direction: deltaTime < 0 ? -1 : 1
        });
    }
} else {
    pingPong = loop === LoopPingPong;
    if (loopCount === -1) {
        if (deltaTime >= 0) {
            loopCount = 0;
            this._setEndings(true, this.repetitions === 0, pingPong);
        } else {
            this._setEndings(this.repetitions === 0, true, pingPong);
        }
    }
    if (time >= duration || time < 0) {
        loopDelta = Math.floor(time / duration);
        time -= duration * loopDelta;
        loopCount += Math.abs(loopDelta);
        pending = this.repetitions - loopCount;
        if (pending < 0) {
            if (this.clampWhenFinished)
                this.paused = true;
            else
                this.enabled = false;
            time = deltaTime > 0 ? duration : 0;
            this._mixer.dispatchEvent({
                type: 'finished',
                action: this,
                direction: deltaTime > 0 ? 1 : -1
            });
        } else {
            if (pending === 0) {
                atStart = deltaTime < 0;
                this._setEndings(atStart, !atStart, pingPong);
            } else {
                this._setEndings(false, false, pingPong);
            }
            this._loopCount = loopCount;
            this._mixer.dispatchEvent({
                type: 'loop',
                action: this,
                loopDelta: loopDelta
            });
        }
    }
    if (pingPong && (loopCount & 1) === 1) {
        this.time = time;
        return duration - time;
    }
}
this.time = time;
return time;}),
        '_setEndings': ($__.fs.J$__v494107025_2656_1351 = function J$__v494107025_2656(atStart, atEnd, pingPong) {
var vvv_return, vvv_switch, settings;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
atStart = arguments[0], atEnd = arguments[1], pingPong = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
settings = this._interpolantSettings;
if (pingPong) {
    settings.endingStart = ZeroSlopeEnding;
    settings.endingEnd = ZeroSlopeEnding;
} else {
    if (atStart) {
        settings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;
    } else {
        settings.endingStart = WrapAroundEnding;
    }
    if (atEnd) {
        settings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;
    } else {
        settings.endingEnd = WrapAroundEnding;
    }
}}),
        '_scheduleFading': ($__.fs.J$__v494107025_2658_1352 = function J$__v494107025_2658(duration, weightNow, weightThen) {
var vvv_return, vvv_switch, mixer, now, interpolant, times, values;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
duration = arguments[0], weightNow = arguments[1], weightThen = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
mixer = this._mixer;
now = mixer.time;
interpolant = this._weightInterpolant;
if (interpolant === null) {
    interpolant = mixer._lendControlInterpolant(), this._weightInterpolant = interpolant;
}
times = interpolant.parameterPositions;
values = interpolant.sampleValues;
times[0] = now;
values[0] = weightNow;
times[1] = now + duration;
values[1] = weightThen;
return this;})
    };
    Object['assign'](TAJS_restrictToType(AnimationMixer.prototype, 'object'), TAJS_restrictToType(EventDispatcher.prototype, 'object'), $__.os.oid513 = {
        'clipAction': ($__.fs.J$__v494107025_2661_1353 = function J$__v494107025_2661(clip, optionalRoot) {
var vvv_return, vvv_switch, root, rootUuid, clipObject, clipUuid, actionsForClip, prototypeAction, existingAction, newAction;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
clip = arguments[0], optionalRoot = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
root = optionalRoot || this._root;
rootUuid = root.uuid;
clipObject = typeof clip === 'string' ? AnimationClip.findByName(root, clip) : clip;
clipUuid = clipObject !== null ? clipObject.uuid : clip;
actionsForClip = this._actionsByClip[clipUuid];
prototypeAction = null;
if (actionsForClip !== undefined) {
    existingAction = actionsForClip.actionByRoot[rootUuid];
    if (existingAction !== undefined) {
        return existingAction;
    }
    prototypeAction = actionsForClip.knownActions[0];
    if (clipObject === null)
        clipObject = prototypeAction._clip;
}
if (clipObject === null)
    return null;
newAction = new AnimationAction(this, clipObject, optionalRoot);
this._bindAction(newAction, prototypeAction);
this._addInactiveAction(newAction, clipUuid, rootUuid);
return newAction;}),
        'existingAction': ($__.fs.J$__v494107025_2663_1354 = function J$__v494107025_2663(clip, optionalRoot) {
var vvv_return, vvv_switch, root, rootUuid, clipObject, clipUuid, actionsForClip;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
clip = arguments[0], optionalRoot = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
root = optionalRoot || this._root;
rootUuid = root.uuid;
clipObject = typeof clip === 'string' ? AnimationClip.findByName(root, clip) : clip;
clipUuid = clipObject ? clipObject.uuid : clip;
actionsForClip = this._actionsByClip[clipUuid];
if (actionsForClip !== undefined) {
    return actionsForClip.actionByRoot[rootUuid] || null;
}
return null;}),
        'stopAllAction': ($__.fs.J$__v494107025_2665_1355 = function J$__v494107025_2665() {
var vvv_return, vvv_switch, actions, nActions, bindings, nBindings;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
actions = this._actions;
nActions = this._nActiveActions;
bindings = this._bindings;
nBindings = this._nActiveBindings;
this._nActiveActions = 0;
this._nActiveBindings = 0;
for (var i = 0; i !== nActions; ++i) {
    actions[i].reset();
}
for (var i = 0; i !== nBindings; ++i) {
    bindings[i].useCount = 0;
}
return this;}),
        'update': ($__.fs.J$__v494107025_2667_1356 = function J$__v494107025_2667(deltaTime) {
var vvv_return, vvv_switch, actions, nActions, time, timeDirection, accuIndex, action, bindings, nBindings;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
deltaTime = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
deltaTime *= this.timeScale;
actions = this._actions;
nActions = this._nActiveActions;
time = this.time += deltaTime;
timeDirection = Math.sign(deltaTime);
accuIndex = this._accuIndex ^= 1;
for (var i = 0; i !== nActions; ++i) {
    action = actions[i];
    if (action.enabled) {
        action._update(time, deltaTime, timeDirection, accuIndex);
    }
}
bindings = this._bindings;
nBindings = this._nActiveBindings;
for (var i = 0; i !== nBindings; ++i) {
    bindings[i].apply(accuIndex);
}
return this;}),
        'getRoot': ($__.fs.J$__v494107025_2669_1357 = function J$__v494107025_2669() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return this._root;}),
        'uncacheClip': ($__.fs.J$__v494107025_2671_1358 = function J$__v494107025_2671(clip) {
var vvv_return, vvv_switch, actions, clipUuid, actionsByClip, actionsForClip, actionsToRemove, action, cacheIndex, lastInactiveAction;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
clip = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
actions = this._actions;
clipUuid = clip.uuid;
actionsByClip = this._actionsByClip;
actionsForClip = actionsByClip[clipUuid];
if (actionsForClip !== undefined) {
    actionsToRemove = actionsForClip.knownActions;
    for (var i = 0, n = actionsToRemove.length; i !== n; ++i) {
        action = actionsToRemove[i];
        this._deactivateAction(action);
        cacheIndex = action._cacheIndex;
        lastInactiveAction = actions[actions.length - 1];
        action._cacheIndex = null;
        action._byClipCacheIndex = null;
        lastInactiveAction._cacheIndex = cacheIndex;
        actions[cacheIndex] = lastInactiveAction;
        actions.pop();
        this._removeInactiveBindingsForAction(action);
    }
    delete actionsByClip[clipUuid];
}}),
        'uncacheRoot': ($__.fs.J$__v494107025_2673_1359 = function J$__v494107025_2673(root) {
var vvv_return, vvv_switch, rootUuid, actionsByClip, actionByRoot, action, bindingsByRoot, bindingByName, binding;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
root = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
rootUuid = root.uuid;
actionsByClip = this._actionsByClip;
for (var clipUuid in actionsByClip) {
    actionByRoot = actionsByClip[clipUuid].actionByRoot;
    action = actionByRoot[rootUuid];
    if (action !== undefined) {
        this._deactivateAction(action);
        this._removeInactiveAction(action);
    }
}
bindingsByRoot = this._bindingsByRootAndName;
bindingByName = bindingsByRoot[rootUuid];
if (bindingByName !== undefined) {
    for (var trackName in bindingByName) {
        binding = bindingByName[trackName];
        binding.restoreOriginalState();
        this._removeInactiveBinding(binding);
    }
}}),
        'uncacheAction': ($__.fs.J$__v494107025_2675_1360 = function J$__v494107025_2675(clip, optionalRoot) {
var vvv_return, vvv_switch, action;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
clip = arguments[0], optionalRoot = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
action = this.existingAction(clip, optionalRoot);
if (action !== null) {
    this._deactivateAction(action);
    this._removeInactiveAction(action);
}})
    });
    Object['assign'](TAJS_restrictToType(AnimationMixer.prototype, 'object'), $__.os.oid514 = {
        '_bindAction': ($__.fs.J$__v494107025_2677_1361 = function J$__v494107025_2677(action, prototypeAction) {
var vvv_return, vvv_switch, root, tracks, nTracks, bindings, interpolants, rootUuid, bindingsByRoot, bindingsByName, track, trackName, binding, path;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
action = arguments[0], prototypeAction = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
root = action._localRoot || this._root;
tracks = action._clip.tracks;
nTracks = tracks.length;
bindings = action._propertyBindings;
interpolants = action._interpolants;
rootUuid = root.uuid;
bindingsByRoot = this._bindingsByRootAndName;
bindingsByName = bindingsByRoot[rootUuid];
if (bindingsByName === undefined) {
    bindingsByName = {};
    bindingsByRoot[rootUuid] = bindingsByName;
}
for (var i = 0; i !== nTracks; ++i) {
    track = tracks[i];
    trackName = track.name;
    binding = bindingsByName[trackName];
    if (binding !== undefined) {
        bindings[i] = binding;
    } else {
        binding = bindings[i];
        if (binding !== undefined) {
            if (binding._cacheIndex === null) {
                ++binding.referenceCount;
                this._addInactiveBinding(binding, rootUuid, trackName);
            }
            continue;
        }
        path = prototypeAction && prototypeAction._propertyBindings[i].binding.parsedPath;
        binding = new PropertyMixer(PropertyBinding.create(root, trackName, path), track.ValueTypeName, track.getValueSize());
        ++binding.referenceCount;
        this._addInactiveBinding(binding, rootUuid, trackName);
        bindings[i] = binding;
    }
    interpolants[i].resultBuffer = binding.buffer;
}}),
        '_activateAction': ($__.fs.J$__v494107025_2679_1362 = function J$__v494107025_2679(action) {
var vvv_return, vvv_switch, rootUuid, clipUuid, actionsForClip, bindings, binding;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
action = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (!this._isActiveAction(action)) {
    if (action._cacheIndex === null) {
        rootUuid = (action._localRoot || this._root).uuid;
        clipUuid = action._clip.uuid;
        actionsForClip = this._actionsByClip[clipUuid];
        this._bindAction(action, actionsForClip && actionsForClip.knownActions[0]);
        this._addInactiveAction(action, clipUuid, rootUuid);
    }
    bindings = action._propertyBindings;
    for (var i = 0, n = bindings.length; i !== n; ++i) {
        binding = bindings[i];
        if (binding.useCount++ === 0) {
            this._lendBinding(binding);
            binding.saveOriginalState();
        }
    }
    this._lendAction(action);
}}),
        '_deactivateAction': ($__.fs.J$__v494107025_2681_1363 = function J$__v494107025_2681(action) {
var vvv_return, vvv_switch, bindings, binding;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
action = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (this._isActiveAction(action)) {
    bindings = action._propertyBindings;
    for (var i = 0, n = bindings.length; i !== n; ++i) {
        binding = bindings[i];
        if (--binding.useCount === 0) {
            binding.restoreOriginalState();
            this._takeBackBinding(binding);
        }
    }
    this._takeBackAction(action);
}}),
        '_initMemoryManager': ($__.fs.J$__v494107025_2695_1364 = function J$__v494107025_2695() {
var vvv_return, vvv_switch, scope;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this._actions = [];
this._nActiveActions = 0;
this._actionsByClip = {};
this._bindings = [];
this._nActiveBindings = 0;
this._bindingsByRootAndName = {};
this._controlInterpolants = [];
this._nActiveControlInterpolants = 0;
scope = this;
this.stats = {
    actions: {
        get total() {
            return scope._actions.length;
        },
        get inUse() {
            return scope._nActiveActions;
        }
    },
    bindings: {
        get total() {
            return scope._bindings.length;
        },
        get inUse() {
            return scope._nActiveBindings;
        }
    },
    controlInterpolants: {
        get total() {
            return scope._controlInterpolants.length;
        },
        get inUse() {
            return scope._nActiveControlInterpolants;
        }
    }
};}),
        '_isActiveAction': ($__.fs.J$__v494107025_2697_1365 = function J$__v494107025_2697(action) {
var vvv_return, vvv_switch, index;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
action = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
index = action._cacheIndex;
return index !== null && index < this._nActiveActions;}),
        '_addInactiveAction': ($__.fs.J$__v494107025_2699_1366 = function J$__v494107025_2699(action, clipUuid, rootUuid) {
var vvv_return, vvv_switch, actions, actionsByClip, actionsForClip, knownActions;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
action = arguments[0], clipUuid = arguments[1], rootUuid = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
actions = this._actions;
actionsByClip = this._actionsByClip;
actionsForClip = actionsByClip[clipUuid];
if (actionsForClip === undefined) {
    actionsForClip = {
        knownActions: [action],
        actionByRoot: {}
    };
    action._byClipCacheIndex = 0;
    actionsByClip[clipUuid] = actionsForClip;
} else {
    knownActions = actionsForClip.knownActions;
    action._byClipCacheIndex = knownActions.length;
    knownActions.push(action);
}
action._cacheIndex = actions.length;
actions.push(action);
actionsForClip.actionByRoot[rootUuid] = action;}),
        '_removeInactiveAction': ($__.fs.J$__v494107025_2701_1367 = function J$__v494107025_2701(action) {
var vvv_return, vvv_switch, actions, lastInactiveAction, cacheIndex, clipUuid, actionsByClip, actionsForClip, knownActionsForClip, lastKnownAction, byClipCacheIndex, actionByRoot, rootUuid;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
action = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
actions = this._actions;
lastInactiveAction = actions[actions.length - 1];
cacheIndex = action._cacheIndex;
lastInactiveAction._cacheIndex = cacheIndex;
actions[cacheIndex] = lastInactiveAction;
actions.pop();
action._cacheIndex = null;
clipUuid = action._clip.uuid;
actionsByClip = this._actionsByClip;
actionsForClip = actionsByClip[clipUuid];
knownActionsForClip = actionsForClip.knownActions;
lastKnownAction = knownActionsForClip[knownActionsForClip.length - 1];
byClipCacheIndex = action._byClipCacheIndex;
lastKnownAction._byClipCacheIndex = byClipCacheIndex;
knownActionsForClip[byClipCacheIndex] = lastKnownAction;
knownActionsForClip.pop();
action._byClipCacheIndex = null;
actionByRoot = actionsForClip.actionByRoot;
rootUuid = (actions._localRoot || this._root).uuid;
delete actionByRoot[rootUuid];
if (knownActionsForClip.length === 0) {
    delete actionsByClip[clipUuid];
}
this._removeInactiveBindingsForAction(action);}),
        '_removeInactiveBindingsForAction': ($__.fs.J$__v494107025_2703_1368 = function J$__v494107025_2703(action) {
var vvv_return, vvv_switch, bindings, binding;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
action = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
bindings = action._propertyBindings;
for (var i = 0, n = bindings.length; i !== n; ++i) {
    binding = bindings[i];
    if (--binding.referenceCount === 0) {
        this._removeInactiveBinding(binding);
    }
}}),
        '_lendAction': ($__.fs.J$__v494107025_2705_1369 = function J$__v494107025_2705(action) {
var vvv_return, vvv_switch, actions, prevIndex, lastActiveIndex, firstInactiveAction;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
action = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
actions = this._actions;
prevIndex = action._cacheIndex;
lastActiveIndex = this._nActiveActions++;
firstInactiveAction = actions[lastActiveIndex];
action._cacheIndex = lastActiveIndex;
actions[lastActiveIndex] = action;
firstInactiveAction._cacheIndex = prevIndex;
actions[prevIndex] = firstInactiveAction;}),
        '_takeBackAction': ($__.fs.J$__v494107025_2707_1370 = function J$__v494107025_2707(action) {
var vvv_return, vvv_switch, actions, prevIndex, firstInactiveIndex, lastActiveAction;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
action = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
actions = this._actions;
prevIndex = action._cacheIndex;
firstInactiveIndex = --this._nActiveActions;
lastActiveAction = actions[firstInactiveIndex];
action._cacheIndex = firstInactiveIndex;
actions[firstInactiveIndex] = action;
lastActiveAction._cacheIndex = prevIndex;
actions[prevIndex] = lastActiveAction;}),
        '_addInactiveBinding': ($__.fs.J$__v494107025_2709_1371 = function J$__v494107025_2709(binding, rootUuid, trackName) {
var vvv_return, vvv_switch, bindingsByRoot, bindingByName, bindings;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
binding = arguments[0], rootUuid = arguments[1], trackName = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
bindingsByRoot = this._bindingsByRootAndName;
bindingByName = bindingsByRoot[rootUuid];
bindings = this._bindings;
if (bindingByName === undefined) {
    bindingByName = {};
    bindingsByRoot[rootUuid] = bindingByName;
}
bindingByName[trackName] = binding;
binding._cacheIndex = bindings.length;
bindings.push(binding);}),
        '_removeInactiveBinding': ($__.fs.J$__v494107025_2711_1372 = function J$__v494107025_2711(binding) {
var vvv_return, vvv_switch, bindings, propBinding, rootUuid, trackName, bindingsByRoot, bindingByName, lastInactiveBinding, cacheIndex;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
binding = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
bindings = this._bindings;
propBinding = binding.binding;
rootUuid = propBinding.rootNode.uuid;
trackName = propBinding.path;
bindingsByRoot = this._bindingsByRootAndName;
bindingByName = bindingsByRoot[rootUuid];
lastInactiveBinding = bindings[bindings.length - 1];
cacheIndex = binding._cacheIndex;
lastInactiveBinding._cacheIndex = cacheIndex;
bindings[cacheIndex] = lastInactiveBinding;
bindings.pop();
delete bindingByName[trackName];
remove_empty_map: {
    for (var _ in bindingByName)
        break remove_empty_map;
    delete bindingsByRoot[rootUuid];
}}),
        '_lendBinding': ($__.fs.J$__v494107025_2713_1373 = function J$__v494107025_2713(binding) {
var vvv_return, vvv_switch, bindings, prevIndex, lastActiveIndex, firstInactiveBinding;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
binding = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
bindings = this._bindings;
prevIndex = binding._cacheIndex;
lastActiveIndex = this._nActiveBindings++;
firstInactiveBinding = bindings[lastActiveIndex];
binding._cacheIndex = lastActiveIndex;
bindings[lastActiveIndex] = binding;
firstInactiveBinding._cacheIndex = prevIndex;
bindings[prevIndex] = firstInactiveBinding;}),
        '_takeBackBinding': ($__.fs.J$__v494107025_2715_1374 = function J$__v494107025_2715(binding) {
var vvv_return, vvv_switch, bindings, prevIndex, firstInactiveIndex, lastActiveBinding;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
binding = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
bindings = this._bindings;
prevIndex = binding._cacheIndex;
firstInactiveIndex = --this._nActiveBindings;
lastActiveBinding = bindings[firstInactiveIndex];
binding._cacheIndex = firstInactiveIndex;
bindings[firstInactiveIndex] = binding;
lastActiveBinding._cacheIndex = prevIndex;
bindings[prevIndex] = lastActiveBinding;}),
        '_lendControlInterpolant': ($__.fs.J$__v494107025_2717_1375 = function J$__v494107025_2717() {
var vvv_return, vvv_switch, interpolants, lastActiveIndex, interpolant;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
interpolants = this._controlInterpolants;
lastActiveIndex = this._nActiveControlInterpolants++;
interpolant = interpolants[lastActiveIndex];
if (interpolant === undefined) {
    interpolant = new LinearInterpolant(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer);
    interpolant.__cacheIndex = lastActiveIndex;
    interpolants[lastActiveIndex] = interpolant;
}
return interpolant;}),
        '_takeBackControlInterpolant': ($__.fs.J$__v494107025_2719_1376 = function J$__v494107025_2719(interpolant) {
var vvv_return, vvv_switch, interpolants, prevIndex, firstInactiveIndex, lastActiveInterpolant;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
interpolant = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
interpolants = this._controlInterpolants;
prevIndex = interpolant.__cacheIndex;
firstInactiveIndex = --this._nActiveControlInterpolants;
lastActiveInterpolant = interpolants[firstInactiveIndex];
interpolant.__cacheIndex = firstInactiveIndex;
interpolants[firstInactiveIndex] = interpolant;
lastActiveInterpolant.__cacheIndex = prevIndex;
interpolants[prevIndex] = lastActiveInterpolant;}),
        '_controlInterpolantsResultBuffer': new Float32Array(1)
    });
    Uniform.prototype = $__.os.oid515 = {
        'constructor': Uniform,
        'onUpdate': ($__.fs.J$__v494107025_2722_1377 = function J$__v494107025_2722(callback) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
callback = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.dynamic = true;
this.onUpdateCallback = callback;
return this;})
    };
    InstancedBufferGeometry.prototype = Object['create'](TAJS_restrictToType(BufferGeometry.prototype, 'object'));
    TAJS_restrictToType(InstancedBufferGeometry.prototype, 'object').constructor = InstancedBufferGeometry;
    TAJS_restrictToType(InstancedBufferGeometry.prototype, 'object').isInstancedBufferGeometry = true;
    TAJS_restrictToType(InstancedBufferGeometry.prototype, 'object').addGroup = ($__.fs.J$__v494107025_2725_1378 = function J$__v494107025_2725(start, count, instances) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
start = arguments[0], count = arguments[1], instances = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.groups.push({
    start: start,
    count: count,
    instances: instances
});});
    TAJS_restrictToType(InstancedBufferGeometry.prototype, 'object').copy = ($__.fs.J$__v494107025_2727_1379 = function J$__v494107025_2727(source) {
var vvv_return, vvv_switch, index, attributes, attribute, groups, group;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
source = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
index = source.index;
if (index !== null) {
    this.setIndex(index.clone());
}
attributes = source.attributes;
for (var name in attributes) {
    attribute = attributes[name];
    this.addAttribute(name, attribute.clone());
}
groups = source.groups;
for (var i = 0, l = groups.length; i < l; i++) {
    group = groups[i];
    this.addGroup(group.start, group.count, group.instances);
}
return this;});
    InterleavedBufferAttribute.prototype = (vvv_tmp14 = {
        'constructor': InterleavedBufferAttribute,
        'isInterleavedBufferAttribute': true,
        'setX': ($__.fs.J$__v494107025_2736_1380 = function J$__v494107025_2736(index, x) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
index = arguments[0], x = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.data.array[index * this.data.stride + this.offset] = x;
return this;}),
        'setY': ($__.fs.J$__v494107025_2738_1381 = function J$__v494107025_2738(index, y) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
index = arguments[0], y = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.data.array[index * this.data.stride + this.offset + 1] = y;
return this;}),
        'setZ': ($__.fs.J$__v494107025_2740_1382 = function J$__v494107025_2740(index, z) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
index = arguments[0], z = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.data.array[index * this.data.stride + this.offset + 2] = z;
return this;}),
        'setW': ($__.fs.J$__v494107025_2742_1383 = function J$__v494107025_2742(index, w) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
index = arguments[0], w = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.data.array[index * this.data.stride + this.offset + 3] = w;
return this;}),
        'getX': ($__.fs.J$__v494107025_2744_1384 = function J$__v494107025_2744(index) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
index = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return this.data.array[index * this.data.stride + this.offset];}),
        'getY': ($__.fs.J$__v494107025_2746_1385 = function J$__v494107025_2746(index) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
index = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return this.data.array[index * this.data.stride + this.offset + 1];}),
        'getZ': ($__.fs.J$__v494107025_2748_1386 = function J$__v494107025_2748(index) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
index = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return this.data.array[index * this.data.stride + this.offset + 2];}),
        'getW': ($__.fs.J$__v494107025_2750_1387 = function J$__v494107025_2750(index) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
index = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return this.data.array[index * this.data.stride + this.offset + 3];}),
        'setXY': ($__.fs.J$__v494107025_2752_1388 = function J$__v494107025_2752(index, x, y) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
index = arguments[0], x = arguments[1], y = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
index = index * this.data.stride + this.offset;
this.data.array[index + 0] = x;
this.data.array[index + 1] = y;
return this;}),
        'setXYZ': ($__.fs.J$__v494107025_2754_1389 = function J$__v494107025_2754(index, x, y, z) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
index = arguments[0], x = arguments[1], y = arguments[2], z = arguments[3];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
index = index * this.data.stride + this.offset;
this.data.array[index + 0] = x;
this.data.array[index + 1] = y;
this.data.array[index + 2] = z;
return this;}),
        'setXYZW': ($__.fs.J$__v494107025_2756_1390 = function J$__v494107025_2756(index, x, y, z, w) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
index = arguments[0], x = arguments[1], y = arguments[2], z = arguments[3], w = arguments[4];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
index = index * this.data.stride + this.offset;
this.data.array[index + 0] = x;
this.data.array[index + 1] = y;
this.data.array[index + 2] = z;
this.data.array[index + 3] = w;
return this;}),
        get length() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
console.warn('THREE.BufferAttribute: .length has been deprecated. Please use .count.');
return this.array.length;},
        get count() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return this.data.count;},
        get array() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return this.data.array;}
    }, $__.fs.length_1391 = Object.getOwnPropertyDescriptor(vvv_tmp14, 'length').get, $__.fs.count_1392 = Object.getOwnPropertyDescriptor(vvv_tmp14, 'count').get, $__.fs.array_1393 = Object.getOwnPropertyDescriptor(vvv_tmp14, 'array').get, $__.os.oid516 = vvv_tmp14);
    InterleavedBuffer.prototype = (vvv_tmp15 = {
        'constructor': InterleavedBuffer,
        'isInterleavedBuffer': true,
        'setDynamic': ($__.fs.J$__v494107025_2765_1394 = function J$__v494107025_2765(value) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
value = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.dynamic = value;
return this;}),
        'copy': ($__.fs.J$__v494107025_2767_1395 = function J$__v494107025_2767(source) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
source = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.array = new source.array.constructor(source.array);
this.stride = source.stride;
this.dynamic = source.dynamic;
return this;}),
        'copyAt': ($__.fs.J$__v494107025_2769_1396 = function J$__v494107025_2769(index1, attribute, index2) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
index1 = arguments[0], attribute = arguments[1], index2 = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
index1 *= this.stride;
index2 *= attribute.stride;
for (var i = 0, l = this.stride; i < l; i++) {
    this.array[index1 + i] = attribute.array[index2 + i];
}
return this;}),
        'set': ($__.fs.J$__v494107025_2771_1397 = function J$__v494107025_2771(value, offset) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
value = arguments[0], offset = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (offset === undefined)
    offset = 0;
this.array.set(value, offset);
return this;}),
        'clone': ($__.fs.J$__v494107025_2773_1398 = function J$__v494107025_2773() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return new this.constructor().copy(this);}),
        get length() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return this.array.length;},
        get count() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return this.array.length / this.stride;},
        set needsUpdate(value) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
value = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (value === true)
    this.version++;}
    }, $__.fs.length_1399 = Object.getOwnPropertyDescriptor(vvv_tmp15, 'length').get, $__.fs.count_1400 = Object.getOwnPropertyDescriptor(vvv_tmp15, 'count').get, $__.fs.needsUpdate_1401 = Object.getOwnPropertyDescriptor(vvv_tmp15, 'needsUpdate').set, $__.os.oid517 = vvv_tmp15);
    InstancedInterleavedBuffer.prototype = Object['create']((InterleavedBuffer.prototype, $__.os.oid517));
    TAJS_restrictToType(InstancedInterleavedBuffer.prototype, 'object').constructor = InstancedInterleavedBuffer;
    TAJS_restrictToType(InstancedInterleavedBuffer.prototype, 'object').isInstancedInterleavedBuffer = true;
    TAJS_restrictToType(InstancedInterleavedBuffer.prototype, 'object').copy = ($__.fs.J$__v494107025_2776_1402 = function J$__v494107025_2776(source) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
source = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
InterleavedBuffer.prototype.copy.call(this, source);
this.meshPerAttribute = source.meshPerAttribute;
return this;});
    InstancedBufferAttribute.prototype = Object['create']((BufferAttribute.prototype, $__.os.oid422));
    TAJS_restrictToType(InstancedBufferAttribute.prototype, 'object').constructor = InstancedBufferAttribute;
    TAJS_restrictToType(InstancedBufferAttribute.prototype, 'object').isInstancedBufferAttribute = true;
    TAJS_restrictToType(InstancedBufferAttribute.prototype, 'object').copy = ($__.fs.J$__v494107025_2779_1403 = function J$__v494107025_2779(source) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
source = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
BufferAttribute.prototype.copy.call(this, source);
this.meshPerAttribute = source.meshPerAttribute;
return this;});
    Raycaster.prototype = $__.os.oid518 = {
        'constructor': Raycaster,
        'linePrecision': 1,
        'set': ($__.fs.J$__v494107025_2786_1404 = function J$__v494107025_2786(origin, direction) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
origin = arguments[0], direction = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.ray.set(origin, direction);}),
        'setFromCamera': ($__.fs.J$__v494107025_2788_1405 = function J$__v494107025_2788(coords, camera) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
coords = arguments[0], camera = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (camera && camera.isPerspectiveCamera) {
    this.ray.origin.setFromMatrixPosition(camera.matrixWorld);
    this.ray.direction.set(coords.x, coords.y, 0.5).unproject(camera).sub(this.ray.origin).normalize();
} else if (camera && camera.isOrthographicCamera) {
    this.ray.origin.set(coords.x, coords.y, (camera.near + camera.far) / (camera.near - camera.far)).unproject(camera);
    this.ray.direction.set(0, 0, -1).transformDirection(camera.matrixWorld);
} else {
    console.error('THREE.Raycaster: Unsupported camera type.');
}}),
        'intersectObject': ($__.fs.J$__v494107025_2790_1406 = function J$__v494107025_2790(object, recursive) {
var vvv_return, vvv_switch, intersects;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
object = arguments[0], recursive = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
intersects = [];
intersectObject(object, this, intersects, recursive);
intersects.sort(ascSort);
return intersects;}),
        'intersectObjects': ($__.fs.J$__v494107025_2792_1407 = function J$__v494107025_2792(objects, recursive) {
var vvv_return, vvv_switch, intersects;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
objects = arguments[0], recursive = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
intersects = [];
if (Array.isArray(objects) === false) {
    console.warn('THREE.Raycaster.intersectObjects: objects is not an Array.');
    return intersects;
}
for (var i = 0, l = objects.length; i < l; i++) {
    intersectObject(objects[i], this, intersects, recursive);
}
intersects.sort(ascSort);
return intersects;})
    };
    Clock.prototype = $__.os.oid519 = {
        'constructor': Clock,
        'start': ($__.fs.J$__v494107025_2795_1408 = function J$__v494107025_2795() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.startTime = (performance || Date).now();
this.oldTime = this.startTime;
this.running = true;}),
        'stop': ($__.fs.J$__v494107025_2797_1409 = function J$__v494107025_2797() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.getElapsedTime();
this.running = false;}),
        'getElapsedTime': ($__.fs.J$__v494107025_2799_1410 = function J$__v494107025_2799() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.getDelta();
return this.elapsedTime;}),
        'getDelta': ($__.fs.J$__v494107025_2801_1411 = function J$__v494107025_2801() {
var vvv_return, vvv_switch, diff, newTime;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
diff = 0;
if (this.autoStart && !this.running) {
    this.start();
}
if (this.running) {
    newTime = (performance || Date).now();
    diff = (newTime - this.oldTime) / 1000;
    this.oldTime = newTime;
    this.elapsedTime += diff;
}
return diff;})
    };
    Spherical.prototype = $__.os.oid520 = {
        'constructor': Spherical,
        'set': ($__.fs.J$__v494107025_2816_1412 = function J$__v494107025_2816(radius, phi, theta) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
radius = arguments[0], phi = arguments[1], theta = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.radius = radius;
this.phi = phi;
this.theta = theta;
return this;}),
        'clone': ($__.fs.J$__v494107025_2818_1413 = function J$__v494107025_2818() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return new this.constructor().copy(this);}),
        'copy': ($__.fs.J$__v494107025_2820_1414 = function J$__v494107025_2820(other) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
other = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.radius.copy(other.radius);
this.phi.copy(other.phi);
this.theta.copy(other.theta);
return this;}),
        'makeSafe': ($__.fs.J$__v494107025_2822_1415 = function J$__v494107025_2822() {
var vvv_return, vvv_switch, EPS;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
EPS = 0.000001;
this.phi = Math.max(EPS, Math.min(Math.PI - EPS, this.phi));
return this;}),
        'setFromVector3': ($__.fs.J$__v494107025_2824_1416 = function J$__v494107025_2824(vec3) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
vec3 = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.radius = vec3.length();
if (this.radius === 0) {
    this.theta = 0;
    this.phi = 0;
} else {
    this.theta = Math.atan2(vec3.x, vec3.z);
    this.phi = Math.acos(exports.Math.clamp(vec3.y / this.radius, -1, 1));
}
return this;})
    };
    MorphBlendMesh.prototype = Object['create'](TAJS_restrictToType(Mesh.prototype, 'object'));
    TAJS_restrictToType(MorphBlendMesh.prototype, 'object').constructor = MorphBlendMesh;
    TAJS_restrictToType(MorphBlendMesh.prototype, 'object').createAnimation = ($__.fs.J$__v494107025_2827_1417 = function J$__v494107025_2827(name, start, end, fps) {
var vvv_return, vvv_switch, animation;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
name = arguments[0], start = arguments[1], end = arguments[2], fps = arguments[3];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
animation = {
    start: start,
    end: end,
    length: end - start + 1,
    fps: fps,
    duration: (end - start) / fps,
    lastFrame: 0,
    currentFrame: 0,
    active: false,
    time: 0,
    direction: 1,
    weight: 1,
    directionBackwards: false,
    mirroredLoop: false
};
this.animationsMap[name] = animation;
this.animationsList.push(animation);});
    TAJS_restrictToType(MorphBlendMesh.prototype, 'object').autoCreateAnimations = ($__.fs.J$__v494107025_2829_1418 = function J$__v494107025_2829(fps) {
var vvv_return, vvv_switch, pattern, firstAnimation, frameRanges, geometry, morph, chunks, name, range;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
fps = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
pattern = /([a-z]+)_?(\d+)/i;
frameRanges = {};
geometry = this.geometry;
for (var i = 0, il = geometry.morphTargets.length; i < il; i++) {
    morph = geometry.morphTargets[i];
    chunks = morph.name.match(pattern);
    if (chunks && chunks.length > 1) {
        name = chunks[1];
        if (!frameRanges[name])
            frameRanges[name] = {
            start: Infinity,
            end: -Infinity
        };
        range = frameRanges[name];
        if (i < range.start)
            range.start = i;
        if (i > range.end)
            range.end = i;
        if (!firstAnimation)
            firstAnimation = name;
    }
}
for (var name in frameRanges) {
    range = frameRanges[name];
    this.createAnimation(name, range.start, range.end, fps);
}
this.firstAnimation = firstAnimation;});
    TAJS_restrictToType(MorphBlendMesh.prototype, 'object').setAnimationDirectionForward = ($__.fs.J$__v494107025_2831_1419 = function J$__v494107025_2831(name) {
var vvv_return, vvv_switch, animation;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
name = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
animation = this.animationsMap[name];
if (animation) {
    animation.direction = 1;
    animation.directionBackwards = false;
}});
    TAJS_restrictToType(MorphBlendMesh.prototype, 'object').setAnimationDirectionBackward = ($__.fs.J$__v494107025_2833_1420 = function J$__v494107025_2833(name) {
var vvv_return, vvv_switch, animation;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
name = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
animation = this.animationsMap[name];
if (animation) {
    animation.direction = -1;
    animation.directionBackwards = true;
}});
    TAJS_restrictToType(MorphBlendMesh.prototype, 'object').setAnimationFPS = ($__.fs.J$__v494107025_2835_1421 = function J$__v494107025_2835(name, fps) {
var vvv_return, vvv_switch, animation;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
name = arguments[0], fps = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
animation = this.animationsMap[name];
if (animation) {
    animation.fps = fps;
    animation.duration = (animation.end - animation.start) / animation.fps;
}});
    TAJS_restrictToType(MorphBlendMesh.prototype, 'object').setAnimationDuration = ($__.fs.J$__v494107025_2837_1422 = function J$__v494107025_2837(name, duration) {
var vvv_return, vvv_switch, animation;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
name = arguments[0], duration = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
animation = this.animationsMap[name];
if (animation) {
    animation.duration = duration;
    animation.fps = (animation.end - animation.start) / animation.duration;
}});
    TAJS_restrictToType(MorphBlendMesh.prototype, 'object').setAnimationWeight = ($__.fs.J$__v494107025_2839_1423 = function J$__v494107025_2839(name, weight) {
var vvv_return, vvv_switch, animation;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
name = arguments[0], weight = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
animation = this.animationsMap[name];
if (animation) {
    animation.weight = weight;
}});
    TAJS_restrictToType(MorphBlendMesh.prototype, 'object').setAnimationTime = ($__.fs.J$__v494107025_2841_1424 = function J$__v494107025_2841(name, time) {
var vvv_return, vvv_switch, animation;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
name = arguments[0], time = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
animation = this.animationsMap[name];
if (animation) {
    animation.time = time;
}});
    TAJS_restrictToType(MorphBlendMesh.prototype, 'object').getAnimationTime = ($__.fs.J$__v494107025_2843_1425 = function J$__v494107025_2843(name) {
var vvv_return, vvv_switch, time, animation;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
name = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
time = 0;
animation = this.animationsMap[name];
if (animation) {
    time = animation.time;
}
return time;});
    TAJS_restrictToType(MorphBlendMesh.prototype, 'object').getAnimationDuration = ($__.fs.J$__v494107025_2845_1426 = function J$__v494107025_2845(name) {
var vvv_return, vvv_switch, duration, animation;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
name = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
duration = -1;
animation = this.animationsMap[name];
if (animation) {
    duration = animation.duration;
}
return duration;});
    TAJS_restrictToType(MorphBlendMesh.prototype, 'object').playAnimation = ($__.fs.J$__v494107025_2847_1427 = function J$__v494107025_2847(name) {
var vvv_return, vvv_switch, animation;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
name = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
animation = this.animationsMap[name];
if (animation) {
    animation.time = 0;
    animation.active = true;
} else {
    console.warn('THREE.MorphBlendMesh: animation[' + name + '] undefined in .playAnimation()');
}});
    TAJS_restrictToType(MorphBlendMesh.prototype, 'object').stopAnimation = ($__.fs.J$__v494107025_2849_1428 = function J$__v494107025_2849(name) {
var vvv_return, vvv_switch, animation;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
name = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
animation = this.animationsMap[name];
if (animation) {
    animation.active = false;
}});
    TAJS_restrictToType(MorphBlendMesh.prototype, 'object').update = ($__.fs.J$__v494107025_2851_1429 = function J$__v494107025_2851(delta) {
var vvv_return, vvv_switch, animation, frameTime, keyframe, weight, mix;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
delta = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
for (var i = 0, il = this.animationsList.length; i < il; i++) {
    animation = this.animationsList[i];
    if (!animation.active)
        continue;
    frameTime = animation.duration / animation.length;
    animation.time += animation.direction * delta;
    if (animation.mirroredLoop) {
        if (animation.time > animation.duration || animation.time < 0) {
            animation.direction *= -1;
            if (animation.time > animation.duration) {
                animation.time = animation.duration;
                animation.directionBackwards = true;
            }
            if (animation.time < 0) {
                animation.time = 0;
                animation.directionBackwards = false;
            }
        }
    } else {
        animation.time = animation.time % animation.duration;
        if (animation.time < 0)
            animation.time += animation.duration;
    }
    keyframe = animation.start + exports.Math.clamp(Math.floor(animation.time / frameTime), 0, animation.length - 1);
    weight = animation.weight;
    if (keyframe !== animation.currentFrame) {
        this.morphTargetInfluences[animation.lastFrame] = 0;
        this.morphTargetInfluences[animation.currentFrame] = 1 * weight;
        this.morphTargetInfluences[keyframe] = 0;
        animation.lastFrame = animation.currentFrame;
        animation.currentFrame = keyframe;
    }
    mix = animation.time % frameTime / frameTime;
    if (animation.directionBackwards)
        mix = 1 - mix;
    if (animation.currentFrame !== animation.lastFrame) {
        this.morphTargetInfluences[animation.currentFrame] = mix * weight;
        this.morphTargetInfluences[animation.lastFrame] = (1 - mix) * weight;
    } else {
        this.morphTargetInfluences[animation.currentFrame] = weight;
    }
}});
    ImmediateRenderObject.prototype = Object['create'](TAJS_restrictToType(Object3D.prototype, 'object'));
    TAJS_restrictToType(ImmediateRenderObject.prototype, 'object').constructor = ImmediateRenderObject;
    TAJS_restrictToType(ImmediateRenderObject.prototype, 'object').isImmediateRenderObject = true;
    WireframeGeometry.prototype = Object['create'](TAJS_restrictToType(BufferGeometry.prototype, 'object'));
    TAJS_restrictToType(WireframeGeometry.prototype, 'object').constructor = WireframeGeometry;
    WireframeHelper.prototype = Object['create'](TAJS_restrictToType(LineSegments.prototype, 'object'));
    TAJS_restrictToType(WireframeHelper.prototype, 'object').constructor = WireframeHelper;
    VertexNormalsHelper.prototype = Object['create'](TAJS_restrictToType(LineSegments.prototype, 'object'));
    TAJS_restrictToType(VertexNormalsHelper.prototype, 'object').constructor = VertexNormalsHelper;
    TAJS_restrictToType(VertexNormalsHelper.prototype, 'object').update = (($__.fs.J$__v494107025_2861_1430 = function J$__v494107025_2861() {
var vvv_return, vvv_switch, v1, v2, normalMatrix;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    v1 = new (Vector3, $__.fs.Vector3_11)(83, true, $__.uid);
    v2 = new (Vector3, $__.fs.Vector3_11)(84, true, $__.uid);
    normalMatrix = new (Matrix3, $__.fs.Matrix3_61)(1, true, $__.uid);
    return ($__.fs.update_1431 = function update() {
var vvv_return, vvv_switch, keys, matrixWorld, position, objGeometry, vertices, faces, idx, face, vertex, normal, objPos, objNorm;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
keys = [
    'a',
    'b',
    'c'
];
this.object.updateMatrixWorld(true);
normalMatrix.getNormalMatrix(this.object.matrixWorld);
matrixWorld = this.object.matrixWorld;
position = this.geometry.attributes.position;
objGeometry = this.object.geometry;
if (objGeometry && objGeometry.isGeometry) {
    vertices = objGeometry.vertices;
    faces = objGeometry.faces;
    idx = 0;
    for (var i = 0, l = faces.length; i < l; i++) {
        face = faces[i];
        for (var j = 0, jl = face.vertexNormals.length; j < jl; j++) {
            vertex = vertices[face[keys[j]]];
            normal = face.vertexNormals[j];
            v1.copy(vertex).applyMatrix4(matrixWorld);
            v2.copy(normal).applyMatrix3(normalMatrix).normalize().multiplyScalar(this.size).add(v1);
            position.setXYZ(idx, v1.x, v1.y, v1.z);
            idx = idx + 1;
            position.setXYZ(idx, v2.x, v2.y, v2.z);
            idx = idx + 1;
        }
    }
} else if (objGeometry && objGeometry.isBufferGeometry) {
    objPos = objGeometry.attributes.position;
    objNorm = objGeometry.attributes.normal;
    idx = 0;
    for (var j = 0, jl = objPos.count; j < jl; j++) {
        v1.set(objPos.getX(j), objPos.getY(j), objPos.getZ(j)).applyMatrix4(matrixWorld);
        v2.set(objNorm.getX(j), objNorm.getY(j), objNorm.getZ(j));
        v2.applyMatrix3(normalMatrix).normalize().multiplyScalar(this.size).add(v1);
        position.setXYZ(idx, v1.x, v1.y, v1.z);
        idx = idx + 1;
        position.setXYZ(idx, v2.x, v2.y, v2.z);
        idx = idx + 1;
    }
}
position.needsUpdate = true;
return this;});
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
v1 = new Vector3();
v2 = new Vector3();
normalMatrix = new Matrix3();
return function update() {
    var keys = [
        'a',
        'b',
        'c'
    ];
    this.object.updateMatrixWorld(true);
    normalMatrix.getNormalMatrix(this.object.matrixWorld);
    var matrixWorld = this.object.matrixWorld;
    var position = this.geometry.attributes.position;
    var objGeometry = this.object.geometry;
    if (objGeometry && objGeometry.isGeometry) {
        var vertices = objGeometry.vertices;
        var faces = objGeometry.faces;
        var idx = 0;
        for (var i = 0, l = faces.length; i < l; i++) {
            var face = faces[i];
            for (var j = 0, jl = face.vertexNormals.length; j < jl; j++) {
                var vertex = vertices[face[keys[j]]];
                var normal = face.vertexNormals[j];
                v1.copy(vertex).applyMatrix4(matrixWorld);
                v2.copy(normal).applyMatrix3(normalMatrix).normalize().multiplyScalar(this.size).add(v1);
                position.setXYZ(idx, v1.x, v1.y, v1.z);
                idx = idx + 1;
                position.setXYZ(idx, v2.x, v2.y, v2.z);
                idx = idx + 1;
            }
        }
    } else if (objGeometry && objGeometry.isBufferGeometry) {
        var objPos = objGeometry.attributes.position;
        var objNorm = objGeometry.attributes.normal;
        var idx = 0;
        for (var j = 0, jl = objPos.count; j < jl; j++) {
            v1.set(objPos.getX(j), objPos.getY(j), objPos.getZ(j)).applyMatrix4(matrixWorld);
            v2.set(objNorm.getX(j), objNorm.getY(j), objNorm.getZ(j));
            v2.applyMatrix3(normalMatrix).normalize().multiplyScalar(this.size).add(v1);
            position.setXYZ(idx, v1.x, v1.y, v1.z);
            idx = idx + 1;
            position.setXYZ(idx, v2.x, v2.y, v2.z);
            idx = idx + 1;
        }
    }
    position.needsUpdate = true;
    return this;
};}), $__.fs.J$__v494107025_2861_1430)(0, true, $__.uid);
    SpotLightHelper.prototype = Object['create'](TAJS_restrictToType(Object3D.prototype, 'object'));
    TAJS_restrictToType(SpotLightHelper.prototype, 'object').constructor = SpotLightHelper;
    TAJS_restrictToType(SpotLightHelper.prototype, 'object').dispose = ($__.fs.J$__v494107025_2864_1432 = function J$__v494107025_2864() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.cone.geometry.dispose();
this.cone.material.dispose();});
    TAJS_restrictToType(SpotLightHelper.prototype, 'object').update = (($__.fs.J$__v494107025_2867_1433 = function J$__v494107025_2867() {
var vvv_return, vvv_switch, vector, vector2;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    vector = new (Vector3, $__.fs.Vector3_11)(85, true, $__.uid);
    vector2 = new (Vector3, $__.fs.Vector3_11)(86, true, $__.uid);
    return ($__.fs.update_1434 = function update() {
var vvv_return, vvv_switch, coneLength, coneWidth;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
coneLength = this.light.distance ? this.light.distance : 1000;
coneWidth = coneLength * Math.tan(this.light.angle);
this.cone.scale.set(coneWidth, coneWidth, coneLength);
vector.setFromMatrixPosition(this.light.matrixWorld);
vector2.setFromMatrixPosition(this.light.target.matrixWorld);
this.cone.lookAt(vector2.sub(vector));
this.cone.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);});
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
vector = new Vector3();
vector2 = new Vector3();
return function update() {
    var coneLength = this.light.distance ? this.light.distance : 1000;
    var coneWidth = coneLength * Math.tan(this.light.angle);
    this.cone.scale.set(coneWidth, coneWidth, coneLength);
    vector.setFromMatrixPosition(this.light.matrixWorld);
    vector2.setFromMatrixPosition(this.light.target.matrixWorld);
    this.cone.lookAt(vector2.sub(vector));
    this.cone.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
};}), $__.fs.J$__v494107025_2867_1433)(0, true, $__.uid);
    SkeletonHelper.prototype = Object['create'](TAJS_restrictToType(LineSegments.prototype, 'object'));
    TAJS_restrictToType(SkeletonHelper.prototype, 'object').constructor = SkeletonHelper;
    TAJS_restrictToType(SkeletonHelper.prototype, 'object').getBoneList = ($__.fs.J$__v494107025_2870_1435 = function J$__v494107025_2870(object) {
var vvv_return, vvv_switch, boneList;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
object = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
boneList = [];
if (object && object.isBone) {
    boneList.push(object);
}
for (var i = 0; i < object.children.length; i++) {
    boneList.push.apply(boneList, this.getBoneList(object.children[i]));
}
return boneList;});
    TAJS_restrictToType(SkeletonHelper.prototype, 'object').update = ($__.fs.J$__v494107025_2872_1436 = function J$__v494107025_2872() {
var vvv_return, vvv_switch, geometry, matrixWorldInv, boneMatrix, j, bone;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
geometry = this.geometry;
matrixWorldInv = new Matrix4().getInverse(this.root.matrixWorld);
boneMatrix = new Matrix4();
j = 0;
for (var i = 0; i < this.bones.length; i++) {
    bone = this.bones[i];
    if (bone.parent && bone.parent.isBone) {
        boneMatrix.multiplyMatrices(matrixWorldInv, bone.matrixWorld);
        geometry.vertices[j].setFromMatrixPosition(boneMatrix);
        boneMatrix.multiplyMatrices(matrixWorldInv, bone.parent.matrixWorld);
        geometry.vertices[j + 1].setFromMatrixPosition(boneMatrix);
        j += 2;
    }
}
geometry.verticesNeedUpdate = true;
geometry.computeBoundingSphere();});
    SphereBufferGeometry.prototype = Object['create'](TAJS_restrictToType(BufferGeometry.prototype, 'object'));
    TAJS_restrictToType(SphereBufferGeometry.prototype, 'object').constructor = SphereBufferGeometry;
    PointLightHelper.prototype = Object['create'](TAJS_restrictToType(Mesh.prototype, 'object'));
    TAJS_restrictToType(PointLightHelper.prototype, 'object').constructor = PointLightHelper;
    TAJS_restrictToType(PointLightHelper.prototype, 'object').dispose = ($__.fs.J$__v494107025_2876_1437 = function J$__v494107025_2876() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.geometry.dispose();
this.material.dispose();});
    TAJS_restrictToType(PointLightHelper.prototype, 'object').update = ($__.fs.J$__v494107025_2878_1438 = function J$__v494107025_2878() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);});
    SphereGeometry.prototype = Object['create'](TAJS_restrictToType(Geometry.prototype, 'object'));
    TAJS_restrictToType(SphereGeometry.prototype, 'object').constructor = SphereGeometry;
    HemisphereLightHelper.prototype = Object['create'](TAJS_restrictToType(Object3D.prototype, 'object'));
    TAJS_restrictToType(HemisphereLightHelper.prototype, 'object').constructor = HemisphereLightHelper;
    TAJS_restrictToType(HemisphereLightHelper.prototype, 'object').dispose = ($__.fs.J$__v494107025_2882_1439 = function J$__v494107025_2882() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.lightSphere.geometry.dispose();
this.lightSphere.material.dispose();});
    TAJS_restrictToType(HemisphereLightHelper.prototype, 'object').update = (($__.fs.J$__v494107025_2885_1440 = function J$__v494107025_2885() {
var vvv_return, vvv_switch, vector;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    vector = new (Vector3, $__.fs.Vector3_11)(87, true, $__.uid);
    return ($__.fs.update_1441 = function update() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.colors[0].copy(this.light.color).multiplyScalar(this.light.intensity);
this.colors[1].copy(this.light.groundColor).multiplyScalar(this.light.intensity);
this.lightSphere.lookAt(vector.setFromMatrixPosition(this.light.matrixWorld).negate());
this.lightSphere.geometry.colorsNeedUpdate = true;});
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
vector = new Vector3();
return function update() {
    this.colors[0].copy(this.light.color).multiplyScalar(this.light.intensity);
    this.colors[1].copy(this.light.groundColor).multiplyScalar(this.light.intensity);
    this.lightSphere.lookAt(vector.setFromMatrixPosition(this.light.matrixWorld).negate());
    this.lightSphere.geometry.colorsNeedUpdate = true;
};}), $__.fs.J$__v494107025_2885_1440)(0, true, $__.uid);
    GridHelper.prototype = Object['create'](TAJS_restrictToType(LineSegments.prototype, 'object'));
    TAJS_restrictToType(GridHelper.prototype, 'object').constructor = GridHelper;
    TAJS_restrictToType(GridHelper.prototype, 'object').setColors = ($__.fs.J$__v494107025_2888_1442 = function J$__v494107025_2888() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
console.error('THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.');});
    FaceNormalsHelper.prototype = Object['create'](TAJS_restrictToType(LineSegments.prototype, 'object'));
    TAJS_restrictToType(FaceNormalsHelper.prototype, 'object').constructor = FaceNormalsHelper;
    TAJS_restrictToType(FaceNormalsHelper.prototype, 'object').update = (($__.fs.J$__v494107025_2892_1443 = function J$__v494107025_2892() {
var vvv_return, vvv_switch, v1, v2, normalMatrix;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    v1 = new (Vector3, $__.fs.Vector3_11)(88, true, $__.uid);
    v2 = new (Vector3, $__.fs.Vector3_11)(89, true, $__.uid);
    normalMatrix = new (Matrix3, $__.fs.Matrix3_61)(2, true, $__.uid);
    return ($__.fs.update_1444 = function update() {
var vvv_return, vvv_switch, matrixWorld, position, objGeometry, vertices, faces, idx, face, normal;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.object.updateMatrixWorld(true);
normalMatrix.getNormalMatrix(this.object.matrixWorld);
matrixWorld = this.object.matrixWorld;
position = this.geometry.attributes.position;
objGeometry = this.object.geometry;
vertices = objGeometry.vertices;
faces = objGeometry.faces;
idx = 0;
for (var i = 0, l = faces.length; i < l; i++) {
    face = faces[i];
    normal = face.normal;
    v1.copy(vertices[face.a]).add(vertices[face.b]).add(vertices[face.c]).divideScalar(3).applyMatrix4(matrixWorld);
    v2.copy(normal).applyMatrix3(normalMatrix).normalize().multiplyScalar(this.size).add(v1);
    position.setXYZ(idx, v1.x, v1.y, v1.z);
    idx = idx + 1;
    position.setXYZ(idx, v2.x, v2.y, v2.z);
    idx = idx + 1;
}
position.needsUpdate = true;
return this;});
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
v1 = new Vector3();
v2 = new Vector3();
normalMatrix = new Matrix3();
return function update() {
    this.object.updateMatrixWorld(true);
    normalMatrix.getNormalMatrix(this.object.matrixWorld);
    var matrixWorld = this.object.matrixWorld;
    var position = this.geometry.attributes.position;
    var objGeometry = this.object.geometry;
    var vertices = objGeometry.vertices;
    var faces = objGeometry.faces;
    var idx = 0;
    for (var i = 0, l = faces.length; i < l; i++) {
        var face = faces[i];
        var normal = face.normal;
        v1.copy(vertices[face.a]).add(vertices[face.b]).add(vertices[face.c]).divideScalar(3).applyMatrix4(matrixWorld);
        v2.copy(normal).applyMatrix3(normalMatrix).normalize().multiplyScalar(this.size).add(v1);
        position.setXYZ(idx, v1.x, v1.y, v1.z);
        idx = idx + 1;
        position.setXYZ(idx, v2.x, v2.y, v2.z);
        idx = idx + 1;
    }
    position.needsUpdate = true;
    return this;
};}), $__.fs.J$__v494107025_2892_1443)(0, true, $__.uid);
    EdgesGeometry.prototype = Object['create'](TAJS_restrictToType(BufferGeometry.prototype, 'object'));
    TAJS_restrictToType(EdgesGeometry.prototype, 'object').constructor = EdgesGeometry;
    EdgesHelper.prototype = Object['create'](TAJS_restrictToType(LineSegments.prototype, 'object'));
    TAJS_restrictToType(EdgesHelper.prototype, 'object').constructor = EdgesHelper;
    DirectionalLightHelper.prototype = Object['create'](TAJS_restrictToType(Object3D.prototype, 'object'));
    TAJS_restrictToType(DirectionalLightHelper.prototype, 'object').constructor = DirectionalLightHelper;
    TAJS_restrictToType(DirectionalLightHelper.prototype, 'object').dispose = ($__.fs.J$__v494107025_2898_1445 = function J$__v494107025_2898() {
var vvv_return, vvv_switch, lightPlane, targetLine;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
lightPlane = this.children[0];
targetLine = this.children[1];
lightPlane.geometry.dispose();
lightPlane.material.dispose();
targetLine.geometry.dispose();
targetLine.material.dispose();});
    TAJS_restrictToType(DirectionalLightHelper.prototype, 'object').update = (($__.fs.J$__v494107025_2901_1446 = function J$__v494107025_2901() {
var vvv_return, vvv_switch, v1, v2, v3;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    v1 = new (Vector3, $__.fs.Vector3_11)(90, true, $__.uid);
    v2 = new (Vector3, $__.fs.Vector3_11)(91, true, $__.uid);
    v3 = new (Vector3, $__.fs.Vector3_11)(92, true, $__.uid);
    return ($__.fs.update_1447 = function update() {
var vvv_return, vvv_switch, lightPlane, targetLine;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
v1.setFromMatrixPosition(this.light.matrixWorld);
v2.setFromMatrixPosition(this.light.target.matrixWorld);
v3.subVectors(v2, v1);
lightPlane = this.children[0];
targetLine = this.children[1];
lightPlane.lookAt(v3);
lightPlane.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
targetLine.lookAt(v3);
targetLine.scale.z = v3.length();});
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
v1 = new Vector3();
v2 = new Vector3();
v3 = new Vector3();
return function update() {
    v1.setFromMatrixPosition(this.light.matrixWorld);
    v2.setFromMatrixPosition(this.light.target.matrixWorld);
    v3.subVectors(v2, v1);
    var lightPlane = this.children[0];
    var targetLine = this.children[1];
    lightPlane.lookAt(v3);
    lightPlane.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
    targetLine.lookAt(v3);
    targetLine.scale.z = v3.length();
};}), $__.fs.J$__v494107025_2901_1446)(0, true, $__.uid);
    CameraHelper.prototype = Object['create'](TAJS_restrictToType(LineSegments.prototype, 'object'));
    TAJS_restrictToType(CameraHelper.prototype, 'object').constructor = CameraHelper;
    TAJS_restrictToType(CameraHelper.prototype, 'object').update = (($__.fs.J$__v494107025_2908_1448 = function J$__v494107025_2908() {
var vvv_return, vvv_switch, geometry, pointMap, vector, camera, setPoint;
setPoint = function setPoint(point, x, y, z) {
    vector.set(x, y, z).unproject(camera);
    var points = pointMap[point];
    if (points !== undefined) {
        for (var i = 0, il = points.length; i < il; i++) {
            geometry.vertices[points[i]].copy(vector);
        }
    }
};
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    setPoint = ($__.fs.setPoint_1449 = function setPoint(point, x, y, z) {
var vvv_return, vvv_switch, points;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
point = arguments[0], x = arguments[1], y = arguments[2], z = arguments[3];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
vector.set(x, y, z).unproject(camera);
points = pointMap[point];
if (points !== undefined) {
    for (var i = 0, il = points.length; i < il; i++) {
        geometry.vertices[points[i]].copy(vector);
    }
}});
    vector = new (Vector3, $__.fs.Vector3_11)(93, true, $__.uid);
    camera = new (Camera, $__.fs.Camera_117)(0, true, $__.uid);
    return ($__.fs.update_1452 = function update() {
var vvv_return, vvv_switch, w, h;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
geometry = this.geometry;
pointMap = this.pointMap;
w = 1;
h = 1;
camera.projectionMatrix.copy(this.camera.projectionMatrix);
setPoint('c', 0, 0, -1);
setPoint('t', 0, 0, 1);
setPoint('n1', -w, -h, -1);
setPoint('n2', w, -h, -1);
setPoint('n3', -w, h, -1);
setPoint('n4', w, h, -1);
setPoint('f1', -w, -h, 1);
setPoint('f2', w, -h, 1);
setPoint('f3', -w, h, 1);
setPoint('f4', w, h, 1);
setPoint('u1', w * 0.7, h * 1.1, -1);
setPoint('u2', -w * 0.7, h * 1.1, -1);
setPoint('u3', 0, h * 2, -1);
setPoint('cf1', -w, 0, 1);
setPoint('cf2', w, 0, 1);
setPoint('cf3', 0, -h, 1);
setPoint('cf4', 0, h, 1);
setPoint('cn1', -w, 0, -1);
setPoint('cn2', w, 0, -1);
setPoint('cn3', 0, -h, -1);
setPoint('cn4', 0, h, -1);
geometry.verticesNeedUpdate = true;});
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
vector = new Vector3();
camera = new Camera();
return function update() {
    geometry = this.geometry;
    pointMap = this.pointMap;
    var w = 1, h = 1;
    camera.projectionMatrix.copy(this.camera.projectionMatrix);
    setPoint('c', 0, 0, -1);
    setPoint('t', 0, 0, 1);
    setPoint('n1', -w, -h, -1);
    setPoint('n2', w, -h, -1);
    setPoint('n3', -w, h, -1);
    setPoint('n4', w, h, -1);
    setPoint('f1', -w, -h, 1);
    setPoint('f2', w, -h, 1);
    setPoint('f3', -w, h, 1);
    setPoint('f4', w, h, 1);
    setPoint('u1', w * 0.7, h * 1.1, -1);
    setPoint('u2', -w * 0.7, h * 1.1, -1);
    setPoint('u3', 0, h * 2, -1);
    setPoint('cf1', -w, 0, 1);
    setPoint('cf2', w, 0, 1);
    setPoint('cf3', 0, -h, 1);
    setPoint('cf4', 0, h, 1);
    setPoint('cn1', -w, 0, -1);
    setPoint('cn2', w, 0, -1);
    setPoint('cn3', 0, -h, -1);
    setPoint('cn4', 0, h, -1);
    geometry.verticesNeedUpdate = true;
};}), $__.fs.J$__v494107025_2908_1448)(0, true, $__.uid);
    BoxGeometry.prototype = Object['create'](TAJS_restrictToType(Geometry.prototype, 'object'));
    TAJS_restrictToType(BoxGeometry.prototype, 'object').constructor = BoxGeometry;
    BoundingBoxHelper.prototype = Object['create'](TAJS_restrictToType(Mesh.prototype, 'object'));
    TAJS_restrictToType(BoundingBoxHelper.prototype, 'object').constructor = BoundingBoxHelper;
    TAJS_restrictToType(BoundingBoxHelper.prototype, 'object').update = ($__.fs.J$__v494107025_2912_1453 = function J$__v494107025_2912() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.box.setFromObject(this.object);
this.box.size(this.scale);
this.box.center(this.position);});
    BoxHelper.prototype = Object['create'](TAJS_restrictToType(LineSegments.prototype, 'object'));
    TAJS_restrictToType(BoxHelper.prototype, 'object').constructor = BoxHelper;
    TAJS_restrictToType(BoxHelper.prototype, 'object').update = (($__.fs.J$__v494107025_2916_1454 = function J$__v494107025_2916() {
var vvv_return, vvv_switch, box;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    box = new (Box3, $__.fs.Box3_59)(2, true, $__.uid);
    return ($__.fs.update_1455 = function update(object) {
var vvv_return, vvv_switch, min, max, position, array;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
object = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (object && object.isBox3) {
    box.copy(object);
} else {
    box.setFromObject(object);
}
if (box.isEmpty())
    return;
min = box.min;
max = box.max;
position = this.geometry.attributes.position;
array = position.array;
array[0] = max.x;
array[1] = max.y;
array[2] = max.z;
array[3] = min.x;
array[4] = max.y;
array[5] = max.z;
array[6] = min.x;
array[7] = min.y;
array[8] = max.z;
array[9] = max.x;
array[10] = min.y;
array[11] = max.z;
array[12] = max.x;
array[13] = max.y;
array[14] = min.z;
array[15] = min.x;
array[16] = max.y;
array[17] = min.z;
array[18] = min.x;
array[19] = min.y;
array[20] = min.z;
array[21] = max.x;
array[22] = min.y;
array[23] = min.z;
position.needsUpdate = true;
this.geometry.computeBoundingSphere();});
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
box = new Box3();
return function update(object) {
    if (object && object.isBox3) {
        box.copy(object);
    } else {
        box.setFromObject(object);
    }
    if (box.isEmpty())
        return;
    var min = box.min;
    var max = box.max;
    var position = this.geometry.attributes.position;
    var array = position.array;
    array[0] = max.x;
    array[1] = max.y;
    array[2] = max.z;
    array[3] = min.x;
    array[4] = max.y;
    array[5] = max.z;
    array[6] = min.x;
    array[7] = min.y;
    array[8] = max.z;
    array[9] = max.x;
    array[10] = min.y;
    array[11] = max.z;
    array[12] = max.x;
    array[13] = max.y;
    array[14] = min.z;
    array[15] = min.x;
    array[16] = max.y;
    array[17] = min.z;
    array[18] = min.x;
    array[19] = min.y;
    array[20] = min.z;
    array[21] = max.x;
    array[22] = min.y;
    array[23] = min.z;
    position.needsUpdate = true;
    this.geometry.computeBoundingSphere();
};}), $__.fs.J$__v494107025_2916_1454)(0, true, $__.uid);
    CylinderBufferGeometry.prototype = Object['create'](TAJS_restrictToType(BufferGeometry.prototype, 'object'));
    TAJS_restrictToType(CylinderBufferGeometry.prototype, 'object').constructor = CylinderBufferGeometry;
    lineGeometry = new (BufferGeometry, $__.fs.BufferGeometry_100)(0, true, $__.uid);
    vvv_tmp16 = lineGeometry, 'addAttribute', $__.fs.J$__v494107025_1405_878.call(vvv_tmp16, 'position', new (Float32Attribute, $__.fs.Float32Attribute_89)([
        0,
        0,
        0,
        0,
        1,
        0
    ], 3, 0, true, $__.uid), 0, true, $__.uid);
    coneGeometry = new (CylinderBufferGeometry, $__.fs.CylinderBufferGeometry_246)(0, 0.5, 1, 5, 1, 0, true, $__.uid);
    vvv_tmp17 = coneGeometry, 'translate', $__.fs.translate_892.call(vvv_tmp17, 0, -0.5, 0, 0, true, $__.uid);
    ArrowHelper.prototype = Object['create'](TAJS_restrictToType(Object3D.prototype, 'object'));
    TAJS_restrictToType(ArrowHelper.prototype, 'object').constructor = ArrowHelper;
    TAJS_restrictToType(ArrowHelper.prototype, 'object').setDirection = (($__.fs.J$__v494107025_2925_1460 = function J$__v494107025_2925() {
var vvv_return, vvv_switch, axis, radians;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    axis = new (Vector3, $__.fs.Vector3_11)(104, true, $__.uid);
    return ($__.fs.setDirection_1461 = function setDirection(dir) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
dir = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (dir.y > 0.99999) {
    this.quaternion.set(0, 0, 0, 1);
} else if (dir.y < -0.99999) {
    this.quaternion.set(1, 0, 0, 0);
} else {
    axis.set(dir.z, 0, -dir.x).normalize();
    radians = Math.acos(dir.y);
    this.quaternion.setFromAxisAngle(axis, radians);
}});
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
axis = new Vector3();
return function setDirection(dir) {
    if (dir.y > 0.99999) {
        this.quaternion.set(0, 0, 0, 1);
    } else if (dir.y < -0.99999) {
        this.quaternion.set(1, 0, 0, 0);
    } else {
        axis.set(dir.z, 0, -dir.x).normalize();
        radians = Math.acos(dir.y);
        this.quaternion.setFromAxisAngle(axis, radians);
    }
};}), $__.fs.J$__v494107025_2925_1460)(0, true, $__.uid);
    TAJS_restrictToType(ArrowHelper.prototype, 'object').setLength = ($__.fs.J$__v494107025_2927_1462 = function J$__v494107025_2927(length, headLength, headWidth) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
length = arguments[0], headLength = arguments[1], headWidth = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (headLength === undefined)
    headLength = 0.2 * length;
if (headWidth === undefined)
    headWidth = 0.2 * headLength;
this.line.scale.set(1, Math.max(0, length - headLength), 1);
this.line.updateMatrix();
this.cone.scale.set(headWidth, headLength, headWidth);
this.cone.position.y = length;
this.cone.updateMatrix();});
    TAJS_restrictToType(ArrowHelper.prototype, 'object').setColor = ($__.fs.J$__v494107025_2929_1463 = function J$__v494107025_2929(color) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
color = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.line.material.color.copy(color);
this.cone.material.color.copy(color);});
    AxisHelper.prototype = Object['create'](TAJS_restrictToType(LineSegments.prototype, 'object'));
    TAJS_restrictToType(AxisHelper.prototype, 'object').constructor = AxisHelper;
    ParametricGeometry.prototype = Object['create'](TAJS_restrictToType(Geometry.prototype, 'object'));
    TAJS_restrictToType(ParametricGeometry.prototype, 'object').constructor = ParametricGeometry;
    PolyhedronGeometry.prototype = Object['create'](TAJS_restrictToType(Geometry.prototype, 'object'));
    TAJS_restrictToType(PolyhedronGeometry.prototype, 'object').constructor = PolyhedronGeometry;
    TetrahedronGeometry.prototype = Object['create'](TAJS_restrictToType(PolyhedronGeometry.prototype, 'object'));
    TAJS_restrictToType(TetrahedronGeometry.prototype, 'object').constructor = TetrahedronGeometry;
    OctahedronGeometry.prototype = Object['create'](TAJS_restrictToType(PolyhedronGeometry.prototype, 'object'));
    TAJS_restrictToType(OctahedronGeometry.prototype, 'object').constructor = OctahedronGeometry;
    IcosahedronGeometry.prototype = Object['create'](TAJS_restrictToType(PolyhedronGeometry.prototype, 'object'));
    TAJS_restrictToType(IcosahedronGeometry.prototype, 'object').constructor = IcosahedronGeometry;
    DodecahedronGeometry.prototype = Object['create'](TAJS_restrictToType(PolyhedronGeometry.prototype, 'object'));
    TAJS_restrictToType(DodecahedronGeometry.prototype, 'object').constructor = DodecahedronGeometry;
    TorusKnotBufferGeometry.prototype = Object['create'](TAJS_restrictToType(BufferGeometry.prototype, 'object'));
    TAJS_restrictToType(TorusKnotBufferGeometry.prototype, 'object').constructor = TorusKnotBufferGeometry;
    TorusKnotGeometry.prototype = Object['create'](TAJS_restrictToType(Geometry.prototype, 'object'));
    TAJS_restrictToType(TorusKnotGeometry.prototype, 'object').constructor = TorusKnotGeometry;
    TorusBufferGeometry.prototype = Object['create'](TAJS_restrictToType(BufferGeometry.prototype, 'object'));
    TAJS_restrictToType(TorusBufferGeometry.prototype, 'object').constructor = TorusBufferGeometry;
    TorusGeometry.prototype = Object['create'](TAJS_restrictToType(Geometry.prototype, 'object'));
    TAJS_restrictToType(TorusGeometry.prototype, 'object').constructor = TorusGeometry;
    TextGeometry.prototype = Object['create'](TAJS_restrictToType(ExtrudeGeometry.prototype, 'object'));
    TAJS_restrictToType(TextGeometry.prototype, 'object').constructor = TextGeometry;
    RingBufferGeometry.prototype = Object['create'](TAJS_restrictToType(BufferGeometry.prototype, 'object'));
    TAJS_restrictToType(RingBufferGeometry.prototype, 'object').constructor = RingBufferGeometry;
    RingGeometry.prototype = Object['create'](TAJS_restrictToType(Geometry.prototype, 'object'));
    TAJS_restrictToType(RingGeometry.prototype, 'object').constructor = RingGeometry;
    PlaneGeometry.prototype = Object['create'](TAJS_restrictToType(Geometry.prototype, 'object'));
    TAJS_restrictToType(PlaneGeometry.prototype, 'object').constructor = PlaneGeometry;
    LatheBufferGeometry.prototype = Object['create'](TAJS_restrictToType(BufferGeometry.prototype, 'object'));
    TAJS_restrictToType(LatheBufferGeometry.prototype, 'object').constructor = LatheBufferGeometry;
    LatheGeometry.prototype = Object['create'](TAJS_restrictToType(Geometry.prototype, 'object'));
    TAJS_restrictToType(LatheGeometry.prototype, 'object').constructor = LatheGeometry;
    CylinderGeometry.prototype = Object['create'](TAJS_restrictToType(Geometry.prototype, 'object'));
    TAJS_restrictToType(CylinderGeometry.prototype, 'object').constructor = CylinderGeometry;
    ConeGeometry.prototype = Object['create'](TAJS_restrictToType(CylinderGeometry.prototype, 'object'));
    TAJS_restrictToType(ConeGeometry.prototype, 'object').constructor = ConeGeometry;
    ConeBufferGeometry.prototype = Object['create'](TAJS_restrictToType(BufferGeometry.prototype, 'object'));
    TAJS_restrictToType(ConeBufferGeometry.prototype, 'object').constructor = ConeBufferGeometry;
    CircleBufferGeometry.prototype = Object['create'](TAJS_restrictToType(BufferGeometry.prototype, 'object'));
    TAJS_restrictToType(CircleBufferGeometry.prototype, 'object').constructor = CircleBufferGeometry;
    CircleGeometry.prototype = Object['create'](TAJS_restrictToType(Geometry.prototype, 'object'));
    TAJS_restrictToType(CircleGeometry.prototype, 'object').constructor = CircleGeometry;
    (exports, $__.os.oid0).CatmullRomCurve3 = (($__.fs.J$__v494107025_2973_1464 = function J$__v494107025_2973() {
var vvv_return, vvv_switch, vvv_tmp0, tmp, px, py, pz, CubicPoly;
CubicPoly = function CubicPoly() {
};
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
switch (vvv_switch) {
case 0:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(vvv_switch === 0);
    CubicPoly = ($__.fs.CubicPoly_1465 = function CubicPoly() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    TAJS_invariant(typeof arguments[arguments.length - 1] === 'symbol');
    TAJS_invariant($__.refs.pop.call(arguments) === $__.uid);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
switch (vvv_switch) {
case 0:
case 1:
case 2:
    TAJS_invariant(typeof vvv_switch === 'number');
    TAJS_invariant(0 <= vvv_switch && vvv_switch <= 2);
    return;
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');});
    tmp = new (Vector3, $__.fs.Vector3_11)(105, true, $__.uid);
    px = new (CubicPoly, $__.fs.CubicPoly_1465)(0, true, $__.uid);
    py = new (CubicPoly, $__.fs.CubicPoly_1465)(1, true, $__.uid);
    pz = new (CubicPoly, $__.fs.CubicPoly_1465)(2, true, $__.uid);
    TAJS_restrictToType(CubicPoly.prototype, 'object').init = ($__.fs.J$__v494107025_2961_1466 = function J$__v494107025_2961(x0, x1, t0, t1) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
x0 = arguments[0], x1 = arguments[1], t0 = arguments[2], t1 = arguments[3];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.c0 = x0;
this.c1 = t0;
this.c2 = -3 * x0 + 3 * x1 - 2 * t0 - t1;
this.c3 = 2 * x0 - 2 * x1 + t0 + t1;});
    TAJS_restrictToType(CubicPoly.prototype, 'object').initNonuniformCatmullRom = ($__.fs.J$__v494107025_2963_1467 = function J$__v494107025_2963(x0, x1, x2, x3, dt0, dt1, dt2) {
var vvv_return, vvv_switch, t1, t2;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
x0 = arguments[0], x1 = arguments[1], x2 = arguments[2], x3 = arguments[3], dt0 = arguments[4], dt1 = arguments[5], dt2 = arguments[6];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
t1 = (x1 - x0) / dt0 - (x2 - x0) / (dt0 + dt1) + (x2 - x1) / dt1;
t2 = (x2 - x1) / dt1 - (x3 - x1) / (dt1 + dt2) + (x3 - x2) / dt2;
t1 *= dt1;
t2 *= dt1;
this.init(x1, x2, t1, t2);});
    TAJS_restrictToType(CubicPoly.prototype, 'object').initCatmullRom = ($__.fs.J$__v494107025_2965_1468 = function J$__v494107025_2965(x0, x1, x2, x3, tension) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
x0 = arguments[0], x1 = arguments[1], x2 = arguments[2], x3 = arguments[3], tension = arguments[4];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.init(x1, x2, tension * (x2 - x0), tension * (x3 - x1));});
    TAJS_restrictToType(CubicPoly.prototype, 'object').calc = ($__.fs.J$__v494107025_2967_1469 = function J$__v494107025_2967(t) {
var vvv_return, vvv_switch, t2, t3;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
t = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
t2 = t * t;
t3 = t2 * t;
return this.c0 + this.c1 * t + this.c2 * t2 + this.c3 * t3;});
    return vvv_tmp0 = Curve, 'create', $__.fs.J$__v494107025_2277_1180.call(vvv_tmp0, ($__.fs.J$__v494107025_2969_1470 = function J$__v494107025_2969(p) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
p = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.points = p || [];
this.closed = false;}), ($__.fs.J$__v494107025_2971_1471 = function J$__v494107025_2971(t) {
var vvv_return, vvv_switch, points, point, intPoint, weight, l, p0, p1, p2, p3, pow, dt0, dt1, dt2, tension, v;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
t = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
points = this.points;
l = points.length;
if (l < 2)
    console.log('duh, you need at least 2 points');
point = (l - (this.closed ? 0 : 1)) * t;
intPoint = Math.floor(point);
weight = point - intPoint;
if (this.closed) {
    intPoint += intPoint > 0 ? 0 : (Math.floor(Math.abs(intPoint) / points.length) + 1) * points.length;
} else if (weight === 0 && intPoint === l - 1) {
    intPoint = l - 2;
    weight = 1;
}
if (this.closed || intPoint > 0) {
    p0 = points[(intPoint - 1) % l];
} else {
    tmp.subVectors(points[0], points[1]).add(points[0]);
    p0 = tmp;
}
p1 = points[intPoint % l];
p2 = points[(intPoint + 1) % l];
if (this.closed || intPoint + 2 < l) {
    p3 = points[(intPoint + 2) % l];
} else {
    tmp.subVectors(points[l - 1], points[l - 2]).add(points[l - 1]);
    p3 = tmp;
}
if (this.type === undefined || this.type === 'centripetal' || this.type === 'chordal') {
    pow = this.type === 'chordal' ? 0.5 : 0.25;
    dt0 = Math.pow(p0.distanceToSquared(p1), pow);
    dt1 = Math.pow(p1.distanceToSquared(p2), pow);
    dt2 = Math.pow(p2.distanceToSquared(p3), pow);
    if (dt1 < 0.0001)
        dt1 = 1;
    if (dt0 < 0.0001)
        dt0 = dt1;
    if (dt2 < 0.0001)
        dt2 = dt1;
    px.initNonuniformCatmullRom(p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2);
    py.initNonuniformCatmullRom(p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2);
    pz.initNonuniformCatmullRom(p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2);
} else if (this.type === 'catmullrom') {
    tension = this.tension !== undefined ? this.tension : 0.5;
    px.initCatmullRom(p0.x, p1.x, p2.x, p3.x, tension);
    py.initCatmullRom(p0.y, p1.y, p2.y, p3.y, tension);
    pz.initCatmullRom(p0.z, p1.z, p2.z, p3.z, tension);
}
v = new Vector3(px.calc(weight), py.calc(weight), pz.calc(weight));
return v;}), 0, true, $__.uid);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
tmp = new Vector3();
px = new CubicPoly();
py = new CubicPoly();
pz = new CubicPoly();
CubicPoly.prototype.init = function (x0, x1, t0, t1) {
    this.c0 = x0;
    this.c1 = t0;
    this.c2 = -3 * x0 + 3 * x1 - 2 * t0 - t1;
    this.c3 = 2 * x0 - 2 * x1 + t0 + t1;
};
CubicPoly.prototype.initNonuniformCatmullRom = function (x0, x1, x2, x3, dt0, dt1, dt2) {
    var t1 = (x1 - x0) / dt0 - (x2 - x0) / (dt0 + dt1) + (x2 - x1) / dt1;
    var t2 = (x2 - x1) / dt1 - (x3 - x1) / (dt1 + dt2) + (x3 - x2) / dt2;
    t1 *= dt1;
    t2 *= dt1;
    this.init(x1, x2, t1, t2);
};
CubicPoly.prototype.initCatmullRom = function (x0, x1, x2, x3, tension) {
    this.init(x1, x2, tension * (x2 - x0), tension * (x3 - x1));
};
CubicPoly.prototype.calc = function (t) {
    var t2 = t * t;
    var t3 = t2 * t;
    return this.c0 + this.c1 * t + this.c2 * t2 + this.c3 * t3;
};
return Curve.create(function (p) {
    this.points = p || [];
    this.closed = false;
}, function (t) {
    var points = this.points, point, intPoint, weight, l;
    l = points.length;
    if (l < 2)
        console.log('duh, you need at least 2 points');
    point = (l - (this.closed ? 0 : 1)) * t;
    intPoint = Math.floor(point);
    weight = point - intPoint;
    if (this.closed) {
        intPoint += intPoint > 0 ? 0 : (Math.floor(Math.abs(intPoint) / points.length) + 1) * points.length;
    } else if (weight === 0 && intPoint === l - 1) {
        intPoint = l - 2;
        weight = 1;
    }
    var p0, p1, p2, p3;
    if (this.closed || intPoint > 0) {
        p0 = points[(intPoint - 1) % l];
    } else {
        tmp.subVectors(points[0], points[1]).add(points[0]);
        p0 = tmp;
    }
    p1 = points[intPoint % l];
    p2 = points[(intPoint + 1) % l];
    if (this.closed || intPoint + 2 < l) {
        p3 = points[(intPoint + 2) % l];
    } else {
        tmp.subVectors(points[l - 1], points[l - 2]).add(points[l - 1]);
        p3 = tmp;
    }
    if (this.type === undefined || this.type === 'centripetal' || this.type === 'chordal') {
        var pow = this.type === 'chordal' ? 0.5 : 0.25;
        var dt0 = Math.pow(p0.distanceToSquared(p1), pow);
        var dt1 = Math.pow(p1.distanceToSquared(p2), pow);
        var dt2 = Math.pow(p2.distanceToSquared(p3), pow);
        if (dt1 < 0.0001)
            dt1 = 1;
        if (dt0 < 0.0001)
            dt0 = dt1;
        if (dt2 < 0.0001)
            dt2 = dt1;
        px.initNonuniformCatmullRom(p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2);
        py.initNonuniformCatmullRom(p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2);
        pz.initNonuniformCatmullRom(p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2);
    } else if (this.type === 'catmullrom') {
        var tension = this.tension !== undefined ? this.tension : 0.5;
        px.initCatmullRom(p0.x, p1.x, p2.x, p3.x, tension);
        py.initCatmullRom(p0.y, p1.y, p2.y, p3.y, tension);
        pz.initCatmullRom(p0.z, p1.z, p2.z, p3.z, tension);
    }
    var v = new Vector3(px.calc(weight), py.calc(weight), pz.calc(weight));
    return v;
});}), $__.fs.J$__v494107025_2973_1464)(0, true, $__.uid);
    ClosedSplineCurve3.prototype = Object['create'](TAJS_restrictToType(TAJS_restrictToType((exports, $__.os.oid0).CatmullRomCurve3, 'function').prototype, 'object'));
    SplineCurve3 = (vvv_tmp18 = Curve, 'create', $__.fs.J$__v494107025_2277_1180.call(vvv_tmp18, ($__.fs.J$__v494107025_2976_1472 = function J$__v494107025_2976(points) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
points = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
console.warn('THREE.SplineCurve3 will be deprecated. Please use THREE.CatmullRomCurve3');
this.points = points === undefined ? [] : points;}), ($__.fs.J$__v494107025_2978_1473 = function J$__v494107025_2978(t) {
var vvv_return, vvv_switch, points, point, intPoint, weight, point0, point1, point2, point3, interpolate;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
t = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
points = this.points;
point = (points.length - 1) * t;
intPoint = Math.floor(point);
weight = point - intPoint;
point0 = points[intPoint == 0 ? intPoint : intPoint - 1];
point1 = points[intPoint];
point2 = points[intPoint > points.length - 2 ? points.length - 1 : intPoint + 1];
point3 = points[intPoint > points.length - 3 ? points.length - 1 : intPoint + 2];
interpolate = exports.CurveUtils.interpolate;
return new Vector3(interpolate(point0.x, point1.x, point2.x, point3.x, weight), interpolate(point0.y, point1.y, point2.y, point3.y, weight), interpolate(point0.z, point1.z, point2.z, point3.z, weight));}), 1, true, $__.uid));
    (exports, $__.os.oid0).CubicBezierCurve3 = (vvv_tmp19 = Curve, 'create', $__.fs.J$__v494107025_2277_1180.call(vvv_tmp19, ($__.fs.J$__v494107025_2980_1474 = function J$__v494107025_2980(v0, v1, v2, v3) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
v0 = arguments[0], v1 = arguments[1], v2 = arguments[2], v3 = arguments[3];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.v0 = v0;
this.v1 = v1;
this.v2 = v2;
this.v3 = v3;}), ($__.fs.J$__v494107025_2982_1475 = function J$__v494107025_2982(t) {
var vvv_return, vvv_switch, b3;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
t = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
b3 = exports.ShapeUtils.b3;
return new Vector3(b3(t, this.v0.x, this.v1.x, this.v2.x, this.v3.x), b3(t, this.v0.y, this.v1.y, this.v2.y, this.v3.y), b3(t, this.v0.z, this.v1.z, this.v2.z, this.v3.z));}), 2, true, $__.uid));
    (exports, $__.os.oid0).QuadraticBezierCurve3 = (vvv_tmp20 = Curve, 'create', $__.fs.J$__v494107025_2277_1180.call(vvv_tmp20, ($__.fs.J$__v494107025_2984_1476 = function J$__v494107025_2984(v0, v1, v2) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
v0 = arguments[0], v1 = arguments[1], v2 = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.v0 = v0;
this.v1 = v1;
this.v2 = v2;}), ($__.fs.J$__v494107025_2986_1477 = function J$__v494107025_2986(t) {
var vvv_return, vvv_switch, b2;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
t = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
b2 = exports.ShapeUtils.b2;
return new Vector3(b2(t, this.v0.x, this.v1.x, this.v2.x), b2(t, this.v0.y, this.v1.y, this.v2.y), b2(t, this.v0.z, this.v1.z, this.v2.z));}), 3, true, $__.uid));
    (exports, $__.os.oid0).LineCurve3 = (vvv_tmp21 = Curve, 'create', $__.fs.J$__v494107025_2277_1180.call(vvv_tmp21, ($__.fs.J$__v494107025_2988_1478 = function J$__v494107025_2988(v1, v2) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
v1 = arguments[0], v2 = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
this.v1 = v1;
this.v2 = v2;}), ($__.fs.J$__v494107025_2990_1479 = function J$__v494107025_2990(t) {
var vvv_return, vvv_switch, vector;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
t = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (t === 1) {
    return this.v2.clone();
}
vector = new Vector3();
vector.subVectors(this.v2, this.v1);
vector.multiplyScalar(t);
vector.add(this.v1);
return vector;}), 4, true, $__.uid));
    ArcCurve.prototype = Object['create'](TAJS_restrictToType(EllipseCurve.prototype, 'object'));
    TAJS_restrictToType(ArcCurve.prototype, 'object').constructor = ArcCurve;
    (exports, $__.os.oid0).SceneUtils = $__.os.oid546 = {
        'createMultiMaterialObject': ($__.fs.J$__v494107025_2993_1480 = function J$__v494107025_2993(geometry, materials) {
var vvv_return, vvv_switch, group;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
geometry = arguments[0], materials = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
group = new Group();
for (var i = 0, l = materials.length; i < l; i++) {
    group.add(new Mesh(geometry, materials[i]));
}
return group;}),
        'detach': ($__.fs.J$__v494107025_2995_1481 = function J$__v494107025_2995(child, parent, scene) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
child = arguments[0], parent = arguments[1], scene = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
child.applyMatrix(parent.matrixWorld);
parent.remove(child);
scene.add(child);}),
        'attach': ($__.fs.J$__v494107025_2997_1482 = function J$__v494107025_2997(child, scene, parent) {
var vvv_return, vvv_switch, matrixWorldInverse;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
child = arguments[0], scene = arguments[1], parent = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
matrixWorldInverse = new Matrix4();
matrixWorldInverse.getInverse(parent.matrixWorld);
child.applyMatrix(matrixWorldInverse);
scene.remove(child);
parent.add(child);})
    };
    LineStrip = 0;
    LinePieces = 1;
    Object['assign']((Box2.prototype, $__.os.oid10), $__.os.oid547 = {
        'empty': ($__.fs.J$__v494107025_3006_1483 = function J$__v494107025_3006() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
console.warn('THREE.Box2: .empty() has been renamed to .isEmpty().');
return this.isEmpty();}),
        'isIntersectionBox': ($__.fs.J$__v494107025_3008_1484 = function J$__v494107025_3008(box) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
box = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
console.warn('THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().');
return this.intersectsBox(box);})
    });
    Object['assign']((Box3.prototype, $__.os.oid417), $__.os.oid548 = {
        'empty': ($__.fs.J$__v494107025_3010_1485 = function J$__v494107025_3010() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
console.warn('THREE.Box3: .empty() has been renamed to .isEmpty().');
return this.isEmpty();}),
        'isIntersectionBox': ($__.fs.J$__v494107025_3012_1486 = function J$__v494107025_3012(box) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
box = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
console.warn('THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().');
return this.intersectsBox(box);}),
        'isIntersectionSphere': ($__.fs.J$__v494107025_3014_1487 = function J$__v494107025_3014(sphere) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
sphere = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
console.warn('THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().');
return this.intersectsSphere(sphere);})
    });
    Object['assign']((Matrix3.prototype, $__.os.oid419), $__.os.oid549 = {
        'multiplyVector3': ($__.fs.J$__v494107025_3016_1488 = function J$__v494107025_3016(vector) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
vector = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
console.warn('THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.');
return vector.applyMatrix3(this);}),
        'multiplyVector3Array': ($__.fs.J$__v494107025_3018_1489 = function J$__v494107025_3018(a) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
a = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
console.warn('THREE.Matrix3: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.');
return this.applyToVector3Array(a);})
    });
    Object['assign']((Matrix4.prototype, $__.os.oid6), $__.os.oid550 = {
        'extractPosition': ($__.fs.J$__v494107025_3020_1490 = function J$__v494107025_3020(m) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
m = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
console.warn('THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().');
return this.copyPosition(m);}),
        'setRotationFromQuaternion': ($__.fs.J$__v494107025_3022_1491 = function J$__v494107025_3022(q) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
q = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
console.warn('THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().');
return this.makeRotationFromQuaternion(q);}),
        'multiplyVector3': ($__.fs.J$__v494107025_3024_1492 = function J$__v494107025_3024(vector) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
vector = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
console.warn('THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead.');
return vector.applyProjection(this);}),
        'multiplyVector4': ($__.fs.J$__v494107025_3026_1493 = function J$__v494107025_3026(vector) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
vector = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
console.warn('THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.');
return vector.applyMatrix4(this);}),
        'multiplyVector3Array': ($__.fs.J$__v494107025_3028_1494 = function J$__v494107025_3028(a) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
a = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
console.warn('THREE.Matrix4: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.');
return this.applyToVector3Array(a);}),
        'rotateAxis': ($__.fs.J$__v494107025_3030_1495 = function J$__v494107025_3030(v) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
v = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
console.warn('THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.');
v.transformDirection(this);}),
        'crossVector': ($__.fs.J$__v494107025_3032_1496 = function J$__v494107025_3032(vector) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
vector = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
console.warn('THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.');
return vector.applyMatrix4(this);}),
        'translate': ($__.fs.J$__v494107025_3034_1497 = function J$__v494107025_3034(v) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
v = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
console.error('THREE.Matrix4: .translate() has been removed.');}),
        'rotateX': ($__.fs.J$__v494107025_3036_1498 = function J$__v494107025_3036(angle) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
angle = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
console.error('THREE.Matrix4: .rotateX() has been removed.');}),
        'rotateY': ($__.fs.J$__v494107025_3038_1499 = function J$__v494107025_3038(angle) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
angle = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
console.error('THREE.Matrix4: .rotateY() has been removed.');}),
        'rotateZ': ($__.fs.J$__v494107025_3040_1500 = function J$__v494107025_3040(angle) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
angle = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
console.error('THREE.Matrix4: .rotateZ() has been removed.');}),
        'rotateByAxis': ($__.fs.J$__v494107025_3042_1501 = function J$__v494107025_3042(axis, angle) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
axis = arguments[0], angle = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
console.error('THREE.Matrix4: .rotateByAxis() has been removed.');})
    });
    Object['assign']((Plane.prototype, $__.os.oid420), $__.os.oid551 = {
        'isIntersectionLine': ($__.fs.J$__v494107025_3044_1502 = function J$__v494107025_3044(line) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
line = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
console.warn('THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().');
return this.intersectsLine(line);})
    });
    Object['assign']((Quaternion.prototype, $__.os.oid7), $__.os.oid552 = {
        'multiplyVector3': ($__.fs.J$__v494107025_3046_1503 = function J$__v494107025_3046(vector) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
vector = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
console.warn('THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.');
return vector.applyQuaternion(this);})
    });
    Object['assign']((Ray.prototype, $__.os.oid430), $__.os.oid553 = {
        'isIntersectionBox': ($__.fs.J$__v494107025_3048_1504 = function J$__v494107025_3048(box) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
box = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
console.warn('THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().');
return this.intersectsBox(box);}),
        'isIntersectionPlane': ($__.fs.J$__v494107025_3050_1505 = function J$__v494107025_3050(plane) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
plane = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
console.warn('THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().');
return this.intersectsPlane(plane);}),
        'isIntersectionSphere': ($__.fs.J$__v494107025_3052_1506 = function J$__v494107025_3052(sphere) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
sphere = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
console.warn('THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().');
return this.intersectsSphere(sphere);})
    });
    Object['assign']((Vector3.prototype, $__.os.oid9), $__.os.oid554 = {
        'setEulerFromRotationMatrix': ($__.fs.J$__v494107025_3054_1507 = function J$__v494107025_3054() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
console.error('THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.');}),
        'setEulerFromQuaternion': ($__.fs.J$__v494107025_3056_1508 = function J$__v494107025_3056() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
console.error('THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.');}),
        'getPositionFromMatrix': ($__.fs.J$__v494107025_3058_1509 = function J$__v494107025_3058(m) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
m = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
console.warn('THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().');
return this.setFromMatrixPosition(m);}),
        'getScaleFromMatrix': ($__.fs.J$__v494107025_3060_1510 = function J$__v494107025_3060(m) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
m = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
console.warn('THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().');
return this.setFromMatrixScale(m);}),
        'getColumnFromMatrix': ($__.fs.J$__v494107025_3062_1511 = function J$__v494107025_3062(index, matrix) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
index = arguments[0], matrix = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
console.warn('THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().');
return this.setFromMatrixColumn(matrix, index);})
    });
    Object['assign'](TAJS_restrictToType(Object3D.prototype, 'object'), $__.os.oid555 = {
        'getChildByName': ($__.fs.J$__v494107025_3064_1512 = function J$__v494107025_3064(name) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
name = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
console.warn('THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().');
return this.getObjectByName(name);}),
        'renderDepth': ($__.fs.J$__v494107025_3066_1513 = function J$__v494107025_3066(value) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
value = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
console.warn('THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.');}),
        'translate': ($__.fs.J$__v494107025_3068_1514 = function J$__v494107025_3068(distance, axis) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
distance = arguments[0], axis = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
console.warn('THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.');
return this.translateOnAxis(axis, distance);})
    });
    Object['defineProperties'](TAJS_restrictToType(Object3D.prototype, 'object'), $__.os.oid558 = {
        'eulerOrder': $__.os.oid556 = {
            'get': ($__.fs.J$__v494107025_3070_1515 = function J$__v494107025_3070() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
console.warn('THREE.Object3D: .eulerOrder is now .rotation.order.');
return this.rotation.order;}),
            'set': ($__.fs.J$__v494107025_3072_1516 = function J$__v494107025_3072(value) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
value = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
console.warn('THREE.Object3D: .eulerOrder is now .rotation.order.');
this.rotation.order = value;})
        },
        'useQuaternion': $__.os.oid557 = {
            'get': ($__.fs.J$__v494107025_3074_1517 = function J$__v494107025_3074() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
console.warn('THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.');}),
            'set': ($__.fs.J$__v494107025_3076_1518 = function J$__v494107025_3076(value) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
value = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
console.warn('THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.');})
        }
    });
    Object['defineProperties'](TAJS_restrictToType(LOD.prototype, 'object'), $__.os.oid560 = {
        'objects': $__.os.oid559 = {
            'get': ($__.fs.J$__v494107025_3078_1519 = function J$__v494107025_3078() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
console.warn('THREE.LOD: .objects has been renamed to .levels.');
return this.levels;})
        }
    });
    TAJS_restrictToType(PerspectiveCamera.prototype, 'object').setLens = ($__.fs.J$__v494107025_3080_1520 = function J$__v494107025_3080(focalLength, filmGauge) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
focalLength = arguments[0], filmGauge = arguments[1];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
console.warn('THREE.PerspectiveCamera.setLens is deprecated. ' + 'Use .setFocalLength and .filmGauge for a photographic setup.');
if (filmGauge !== undefined)
    this.filmGauge = filmGauge;
this.setFocalLength(focalLength);});
    Object['defineProperties'](TAJS_restrictToType(Light.prototype, 'object'), $__.os.oid574 = {
        'onlyShadow': $__.os.oid561 = {
            'set': ($__.fs.J$__v494107025_3082_1521 = function J$__v494107025_3082(value) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
value = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
console.warn('THREE.Light: .onlyShadow has been removed.');})
        },
        'shadowCameraFov': $__.os.oid562 = {
            'set': ($__.fs.J$__v494107025_3084_1522 = function J$__v494107025_3084(value) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
value = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
console.warn('THREE.Light: .shadowCameraFov is now .shadow.camera.fov.');
this.shadow.camera.fov = value;})
        },
        'shadowCameraLeft': $__.os.oid563 = {
            'set': ($__.fs.J$__v494107025_3086_1523 = function J$__v494107025_3086(value) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
value = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
console.warn('THREE.Light: .shadowCameraLeft is now .shadow.camera.left.');
this.shadow.camera.left = value;})
        },
        'shadowCameraRight': $__.os.oid564 = {
            'set': ($__.fs.J$__v494107025_3088_1524 = function J$__v494107025_3088(value) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
value = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
console.warn('THREE.Light: .shadowCameraRight is now .shadow.camera.right.');
this.shadow.camera.right = value;})
        },
        'shadowCameraTop': $__.os.oid565 = {
            'set': ($__.fs.J$__v494107025_3090_1525 = function J$__v494107025_3090(value) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
value = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
console.warn('THREE.Light: .shadowCameraTop is now .shadow.camera.top.');
this.shadow.camera.top = value;})
        },
        'shadowCameraBottom': $__.os.oid566 = {
            'set': ($__.fs.J$__v494107025_3092_1526 = function J$__v494107025_3092(value) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
value = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
console.warn('THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.');
this.shadow.camera.bottom = value;})
        },
        'shadowCameraNear': $__.os.oid567 = {
            'set': ($__.fs.J$__v494107025_3094_1527 = function J$__v494107025_3094(value) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
value = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
console.warn('THREE.Light: .shadowCameraNear is now .shadow.camera.near.');
this.shadow.camera.near = value;})
        },
        'shadowCameraFar': $__.os.oid568 = {
            'set': ($__.fs.J$__v494107025_3096_1528 = function J$__v494107025_3096(value) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
value = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
console.warn('THREE.Light: .shadowCameraFar is now .shadow.camera.far.');
this.shadow.camera.far = value;})
        },
        'shadowCameraVisible': $__.os.oid569 = {
            'set': ($__.fs.J$__v494107025_3098_1529 = function J$__v494107025_3098(value) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
value = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
console.warn('THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.');})
        },
        'shadowBias': $__.os.oid570 = {
            'set': ($__.fs.J$__v494107025_3100_1530 = function J$__v494107025_3100(value) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
value = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
console.warn('THREE.Light: .shadowBias is now .shadow.bias.');
this.shadow.bias = value;})
        },
        'shadowDarkness': $__.os.oid571 = {
            'set': ($__.fs.J$__v494107025_3102_1531 = function J$__v494107025_3102(value) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
value = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
console.warn('THREE.Light: .shadowDarkness has been removed.');})
        },
        'shadowMapWidth': $__.os.oid572 = {
            'set': ($__.fs.J$__v494107025_3104_1532 = function J$__v494107025_3104(value) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
value = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
console.warn('THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.');
this.shadow.mapSize.width = value;})
        },
        'shadowMapHeight': $__.os.oid573 = {
            'set': ($__.fs.J$__v494107025_3106_1533 = function J$__v494107025_3106(value) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
value = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
console.warn('THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.');
this.shadow.mapSize.height = value;})
        }
    });
    Object['defineProperties']((BufferAttribute.prototype, $__.os.oid422), $__.os.oid576 = {
        'length': $__.os.oid575 = {
            'get': ($__.fs.J$__v494107025_3108_1534 = function J$__v494107025_3108() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
console.warn('THREE.BufferAttribute: .length has been deprecated. Please use .count.');
return this.array.length;})
        }
    });
    Object['assign'](TAJS_restrictToType(BufferGeometry.prototype, 'object'), $__.os.oid577 = {
        'addIndex': ($__.fs.J$__v494107025_3110_1535 = function J$__v494107025_3110(index) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
index = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
console.warn('THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().');
this.setIndex(index);}),
        'addDrawCall': ($__.fs.J$__v494107025_3112_1536 = function J$__v494107025_3112(start, count, indexOffset) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
start = arguments[0], count = arguments[1], indexOffset = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (indexOffset !== undefined) {
    console.warn('THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.');
}
console.warn('THREE.BufferGeometry: .addDrawCall() is now .addGroup().');
this.addGroup(start, count);}),
        'clearDrawCalls': ($__.fs.J$__v494107025_3114_1537 = function J$__v494107025_3114() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
console.warn('THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().');
this.clearGroups();}),
        'computeTangents': ($__.fs.J$__v494107025_3116_1538 = function J$__v494107025_3116() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
console.warn('THREE.BufferGeometry: .computeTangents() has been removed.');}),
        'computeOffsets': ($__.fs.J$__v494107025_3118_1539 = function J$__v494107025_3118() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
console.warn('THREE.BufferGeometry: .computeOffsets() has been removed.');})
    });
    Object['defineProperties'](TAJS_restrictToType(BufferGeometry.prototype, 'object'), $__.os.oid580 = {
        'drawcalls': $__.os.oid578 = {
            'get': ($__.fs.J$__v494107025_3120_1540 = function J$__v494107025_3120() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
console.error('THREE.BufferGeometry: .drawcalls has been renamed to .groups.');
return this.groups;})
        },
        'offsets': $__.os.oid579 = {
            'get': ($__.fs.J$__v494107025_3122_1541 = function J$__v494107025_3122() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
console.warn('THREE.BufferGeometry: .offsets has been renamed to .groups.');
return this.groups;})
        }
    });
    Object['defineProperties']((Material.prototype, $__.os.oid16), $__.os.oid583 = {
        'wrapAround': $__.os.oid581 = {
            'get': ($__.fs.J$__v494107025_3124_1542 = function J$__v494107025_3124() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
console.warn('THREE.' + this.type + ': .wrapAround has been removed.');}),
            'set': ($__.fs.J$__v494107025_3126_1543 = function J$__v494107025_3126(value) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
value = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
console.warn('THREE.' + this.type + ': .wrapAround has been removed.');})
        },
        'wrapRGB': $__.os.oid582 = {
            'get': ($__.fs.J$__v494107025_3128_1544 = function J$__v494107025_3128() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
console.warn('THREE.' + this.type + ': .wrapRGB has been removed.');
return new Color();})
        }
    });
    Object['defineProperties'](TAJS_restrictToType(MeshPhongMaterial.prototype, 'object'), $__.os.oid585 = {
        'metal': $__.os.oid584 = {
            'get': ($__.fs.J$__v494107025_3130_1545 = function J$__v494107025_3130() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
console.warn('THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.');
return false;}),
            'set': ($__.fs.J$__v494107025_3132_1546 = function J$__v494107025_3132(value) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
value = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
console.warn('THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead');})
        }
    });
    Object['defineProperties'](TAJS_restrictToType(ShaderMaterial.prototype, 'object'), $__.os.oid587 = {
        'derivatives': $__.os.oid586 = {
            'get': ($__.fs.J$__v494107025_3134_1547 = function J$__v494107025_3134() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
console.warn('THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.');
return this.extensions.derivatives;}),
            'set': ($__.fs.J$__v494107025_3136_1548 = function J$__v494107025_3136(value) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
value = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
console.warn('THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.');
this.extensions.derivatives = value;})
        }
    });
    EventDispatcher.prototype = Object['assign'](Object['create']($__.os.oid588 = {
        'constructor': EventDispatcher,
        'apply': ($__.fs.J$__v494107025_3138_1549 = function J$__v494107025_3138(target) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
target = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
console.warn('THREE.EventDispatcher: .apply is deprecated, ' + 'just inherit or Object.assign the prototype to mix-in.');
Object.assign(target, this);})
    }), TAJS_restrictToType(EventDispatcher.prototype, 'object'));
    Object['assign'](TAJS_restrictToType(WebGLRenderer.prototype, 'object'), $__.os.oid589 = {
        'supportsFloatTextures': ($__.fs.J$__v494107025_3140_1550 = function J$__v494107025_3140() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
console.warn('THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \'OES_texture_float\' ).');
return this.extensions.get('OES_texture_float');}),
        'supportsHalfFloatTextures': ($__.fs.J$__v494107025_3142_1551 = function J$__v494107025_3142() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
console.warn('THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \'OES_texture_half_float\' ).');
return this.extensions.get('OES_texture_half_float');}),
        'supportsStandardDerivatives': ($__.fs.J$__v494107025_3144_1552 = function J$__v494107025_3144() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
console.warn('THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \'OES_standard_derivatives\' ).');
return this.extensions.get('OES_standard_derivatives');}),
        'supportsCompressedTextureS3TC': ($__.fs.J$__v494107025_3146_1553 = function J$__v494107025_3146() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
console.warn('THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \'WEBGL_compressed_texture_s3tc\' ).');
return this.extensions.get('WEBGL_compressed_texture_s3tc');}),
        'supportsCompressedTexturePVRTC': ($__.fs.J$__v494107025_3148_1554 = function J$__v494107025_3148() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
console.warn('THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \'WEBGL_compressed_texture_pvrtc\' ).');
return this.extensions.get('WEBGL_compressed_texture_pvrtc');}),
        'supportsBlendMinMax': ($__.fs.J$__v494107025_3150_1555 = function J$__v494107025_3150() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
console.warn('THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \'EXT_blend_minmax\' ).');
return this.extensions.get('EXT_blend_minmax');}),
        'supportsVertexTextures': ($__.fs.J$__v494107025_3152_1556 = function J$__v494107025_3152() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return this.capabilities.vertexTextures;}),
        'supportsInstancedArrays': ($__.fs.J$__v494107025_3154_1557 = function J$__v494107025_3154() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
console.warn('THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \'ANGLE_instanced_arrays\' ).');
return this.extensions.get('ANGLE_instanced_arrays');}),
        'enableScissorTest': ($__.fs.J$__v494107025_3156_1558 = function J$__v494107025_3156(boolean) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
boolean = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
console.warn('THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().');
this.setScissorTest(boolean);}),
        'initMaterial': ($__.fs.J$__v494107025_3158_1559 = function J$__v494107025_3158() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
console.warn('THREE.WebGLRenderer: .initMaterial() has been removed.');}),
        'addPrePlugin': ($__.fs.J$__v494107025_3160_1560 = function J$__v494107025_3160() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
console.warn('THREE.WebGLRenderer: .addPrePlugin() has been removed.');}),
        'addPostPlugin': ($__.fs.J$__v494107025_3162_1561 = function J$__v494107025_3162() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
console.warn('THREE.WebGLRenderer: .addPostPlugin() has been removed.');}),
        'updateShadowMap': ($__.fs.J$__v494107025_3164_1562 = function J$__v494107025_3164() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
console.warn('THREE.WebGLRenderer: .updateShadowMap() has been removed.');})
    });
    Object['defineProperties'](TAJS_restrictToType(WebGLRenderer.prototype, 'object'), $__.os.oid593 = {
        'shadowMapEnabled': $__.os.oid590 = {
            'get': ($__.fs.J$__v494107025_3166_1563 = function J$__v494107025_3166() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return this.shadowMap.enabled;}),
            'set': ($__.fs.J$__v494107025_3168_1564 = function J$__v494107025_3168(value) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
value = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
console.warn('THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.');
this.shadowMap.enabled = value;})
        },
        'shadowMapType': $__.os.oid591 = {
            'get': ($__.fs.J$__v494107025_3170_1565 = function J$__v494107025_3170() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return this.shadowMap.type;}),
            'set': ($__.fs.J$__v494107025_3172_1566 = function J$__v494107025_3172(value) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
value = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
console.warn('THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.');
this.shadowMap.type = value;})
        },
        'shadowMapCullFace': $__.os.oid592 = {
            'get': ($__.fs.J$__v494107025_3174_1567 = function J$__v494107025_3174() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return this.shadowMap.cullFace;}),
            'set': ($__.fs.J$__v494107025_3176_1568 = function J$__v494107025_3176(value) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
value = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
console.warn('THREE.WebGLRenderer: .shadowMapCullFace is now .shadowMap.cullFace.');
this.shadowMap.cullFace = value;})
        }
    });
    Object['defineProperties'](TAJS_restrictToType(WebGLShadowMap.prototype, 'object'), $__.os.oid595 = {
        'cullFace': $__.os.oid594 = {
            'get': ($__.fs.J$__v494107025_3178_1569 = function J$__v494107025_3178() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return this.renderReverseSided ? CullFaceFront : CullFaceBack;}),
            'set': ($__.fs.J$__v494107025_3180_1570 = function J$__v494107025_3180(cullFace) {
var vvv_return, vvv_switch, value;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
cullFace = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
value = cullFace !== CullFaceBack;
console.warn('WebGLRenderer: .shadowMap.cullFace is deprecated. Set .shadowMap.renderReverseSided to ' + value + '.');
this.renderReverseSided = value;})
        }
    });
    Object['defineProperties'](TAJS_restrictToType(WebGLRenderTarget.prototype, 'object'), $__.os.oid606 = {
        'wrapS': $__.os.oid596 = {
            'get': ($__.fs.J$__v494107025_3182_1571 = function J$__v494107025_3182() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
console.warn('THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.');
return this.texture.wrapS;}),
            'set': ($__.fs.J$__v494107025_3184_1572 = function J$__v494107025_3184(value) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
value = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
console.warn('THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.');
this.texture.wrapS = value;})
        },
        'wrapT': $__.os.oid597 = {
            'get': ($__.fs.J$__v494107025_3186_1573 = function J$__v494107025_3186() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
console.warn('THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.');
return this.texture.wrapT;}),
            'set': ($__.fs.J$__v494107025_3188_1574 = function J$__v494107025_3188(value) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
value = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
console.warn('THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.');
this.texture.wrapT = value;})
        },
        'magFilter': $__.os.oid598 = {
            'get': ($__.fs.J$__v494107025_3190_1575 = function J$__v494107025_3190() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
console.warn('THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.');
return this.texture.magFilter;}),
            'set': ($__.fs.J$__v494107025_3192_1576 = function J$__v494107025_3192(value) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
value = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
console.warn('THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.');
this.texture.magFilter = value;})
        },
        'minFilter': $__.os.oid599 = {
            'get': ($__.fs.J$__v494107025_3194_1577 = function J$__v494107025_3194() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
console.warn('THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.');
return this.texture.minFilter;}),
            'set': ($__.fs.J$__v494107025_3196_1578 = function J$__v494107025_3196(value) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
value = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
console.warn('THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.');
this.texture.minFilter = value;})
        },
        'anisotropy': $__.os.oid600 = {
            'get': ($__.fs.J$__v494107025_3198_1579 = function J$__v494107025_3198() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
console.warn('THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.');
return this.texture.anisotropy;}),
            'set': ($__.fs.J$__v494107025_3200_1580 = function J$__v494107025_3200(value) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
value = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
console.warn('THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.');
this.texture.anisotropy = value;})
        },
        'offset': $__.os.oid601 = {
            'get': ($__.fs.J$__v494107025_3202_1581 = function J$__v494107025_3202() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
console.warn('THREE.WebGLRenderTarget: .offset is now .texture.offset.');
return this.texture.offset;}),
            'set': ($__.fs.J$__v494107025_3204_1582 = function J$__v494107025_3204(value) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
value = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
console.warn('THREE.WebGLRenderTarget: .offset is now .texture.offset.');
this.texture.offset = value;})
        },
        'repeat': $__.os.oid602 = {
            'get': ($__.fs.J$__v494107025_3206_1583 = function J$__v494107025_3206() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
console.warn('THREE.WebGLRenderTarget: .repeat is now .texture.repeat.');
return this.texture.repeat;}),
            'set': ($__.fs.J$__v494107025_3208_1584 = function J$__v494107025_3208(value) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
value = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
console.warn('THREE.WebGLRenderTarget: .repeat is now .texture.repeat.');
this.texture.repeat = value;})
        },
        'format': $__.os.oid603 = {
            'get': ($__.fs.J$__v494107025_3210_1585 = function J$__v494107025_3210() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
console.warn('THREE.WebGLRenderTarget: .format is now .texture.format.');
return this.texture.format;}),
            'set': ($__.fs.J$__v494107025_3212_1586 = function J$__v494107025_3212(value) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
value = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
console.warn('THREE.WebGLRenderTarget: .format is now .texture.format.');
this.texture.format = value;})
        },
        'type': $__.os.oid604 = {
            'get': ($__.fs.J$__v494107025_3214_1587 = function J$__v494107025_3214() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
console.warn('THREE.WebGLRenderTarget: .type is now .texture.type.');
return this.texture.type;}),
            'set': ($__.fs.J$__v494107025_3216_1588 = function J$__v494107025_3216(value) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
value = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
console.warn('THREE.WebGLRenderTarget: .type is now .texture.type.');
this.texture.type = value;})
        },
        'generateMipmaps': $__.os.oid605 = {
            'get': ($__.fs.J$__v494107025_3218_1589 = function J$__v494107025_3218() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
console.warn('THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.');
return this.texture.generateMipmaps;}),
            'set': ($__.fs.J$__v494107025_3220_1590 = function J$__v494107025_3220(value) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
value = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
console.warn('THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.');
this.texture.generateMipmaps = value;})
        }
    });
    Object['assign'](TAJS_restrictToType(Audio.prototype, 'object'), $__.os.oid607 = {
        'load': ($__.fs.J$__v494107025_3224_1591 = function J$__v494107025_3224(file) {
var vvv_return, vvv_switch, scope, audioLoader;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
file = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
console.warn('THREE.Audio: .load has been deprecated. Please use THREE.AudioLoader.');
scope = this;
audioLoader = new AudioLoader();
audioLoader.load(file, function (buffer) {
    scope.setBuffer(buffer);
});
return this;})
    });
    Object['assign'](TAJS_restrictToType(AudioAnalyser.prototype, 'object'), $__.os.oid608 = {
        'getData': ($__.fs.J$__v494107025_3226_1592 = function J$__v494107025_3226(file) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
file = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
console.warn('THREE.AudioAnalyser: .getData() is now .getFrequencyData().');
return this.getFrequencyData();})
    });
    GeometryUtils = $__.os.oid609 = {
        'merge': ($__.fs.J$__v494107025_3228_1593 = function J$__v494107025_3228(geometry1, geometry2, materialIndexOffset) {
var vvv_return, vvv_switch, matrix;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
geometry1 = arguments[0], geometry2 = arguments[1], materialIndexOffset = arguments[2];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
console.warn('THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.');
if (geometry2.isMesh) {
    geometry2.matrixAutoUpdate && geometry2.updateMatrix();
    matrix = geometry2.matrix;
    geometry2 = geometry2.geometry;
}
geometry1.merge(geometry2, matrix, materialIndexOffset);}),
        'center': ($__.fs.J$__v494107025_3230_1594 = function J$__v494107025_3230(geometry) {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
geometry = arguments[0];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
console.warn('THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.');
return geometry.center();})
    };
    ImageUtils = $__.os.oid610 = {
        'crossOrigin': undefined,
        'loadTexture': ($__.fs.J$__v494107025_3232_1595 = function J$__v494107025_3232(url, mapping, onLoad, onError) {
var vvv_return, vvv_switch, loader, texture;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
url = arguments[0], mapping = arguments[1], onLoad = arguments[2], onError = arguments[3];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
console.warn('THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.');
loader = new TextureLoader();
loader.setCrossOrigin(this.crossOrigin);
texture = loader.load(url, onLoad, undefined, onError);
if (mapping)
    texture.mapping = mapping;
return texture;}),
        'loadTextureCube': ($__.fs.J$__v494107025_3234_1596 = function J$__v494107025_3234(urls, mapping, onLoad, onError) {
var vvv_return, vvv_switch, loader, texture;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
urls = arguments[0], mapping = arguments[1], onLoad = arguments[2], onError = arguments[3];
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
console.warn('THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.');
loader = new CubeTextureLoader();
loader.setCrossOrigin(this.crossOrigin);
texture = loader.load(urls, onLoad, undefined, onError);
if (mapping)
    texture.mapping = mapping;
return texture;}),
        'loadCompressedTexture': ($__.fs.J$__v494107025_3236_1597 = function J$__v494107025_3236() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
console.error('THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.');}),
        'loadCompressedTextureCube': ($__.fs.J$__v494107025_3238_1598 = function J$__v494107025_3238() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
console.error('THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.');})
    };
    Object['defineProperty'](exports, 'AudioContext', $__.os.oid611 = {
        'get': ($__.fs.J$__v494107025_3256_1599 = function J$__v494107025_3256() {
var vvv_return, vvv_switch;
if (arguments[arguments.length - 1] === $__.uid) {
    $__.refs.pop.call(arguments);
    vvv_return = $__.refs.pop.call(arguments);
    vvv_switch = $__.refs.pop.call(arguments);
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
return exports.getAudioContext();})
    });
    (exports, $__.os.oid0).SpritePlugin = SpritePlugin;
    (exports, $__.os.oid0).LensFlarePlugin = LensFlarePlugin;
    (exports, $__.os.oid0).WebGLUniforms = WebGLUniforms;
    (exports, $__.os.oid0).WebGLTextures = WebGLTextures;
    (exports, $__.os.oid0).WebGLState = WebGLState;
    (exports, $__.os.oid0).WebGLShadowMap = WebGLShadowMap;
    (exports, $__.os.oid0).WebGLShader = WebGLShader;
    (exports, $__.os.oid0).WebGLProperties = WebGLProperties;
    (exports, $__.os.oid0).WebGLPrograms = WebGLPrograms;
    (exports, $__.os.oid0).WebGLProgram = WebGLProgram;
    (exports, $__.os.oid0).WebGLObjects = WebGLObjects;
    (exports, $__.os.oid0).WebGLLights = WebGLLights;
    (exports, $__.os.oid0).WebGLGeometries = WebGLGeometries;
    (exports, $__.os.oid0).WebGLCapabilities = WebGLCapabilities;
    (exports, $__.os.oid0).WebGLExtensions = WebGLExtensions;
    (exports, $__.os.oid0).WebGLIndexedBufferRenderer = WebGLIndexedBufferRenderer;
    (exports, $__.os.oid0).WebGLClipping = WebGLClipping;
    (exports, $__.os.oid0).WebGLBufferRenderer = WebGLBufferRenderer;
    (exports, $__.os.oid0).WebGLRenderTargetCube = WebGLRenderTargetCube;
    (exports, $__.os.oid0).WebGLRenderTarget = WebGLRenderTarget;
    (exports, $__.os.oid0).WebGLRenderer = WebGLRenderer;
    (exports, $__.os.oid0).ShaderLib = ShaderLib;
    (exports, $__.os.oid0).UniformsLib = UniformsLib;
    (exports, $__.os.oid0).ShaderChunk = ShaderChunk;
    (exports, $__.os.oid0).FogExp2 = FogExp2;
    (exports, $__.os.oid0).Fog = Fog;
    (exports, $__.os.oid0).Scene = Scene;
    (exports, $__.os.oid0).LensFlare = LensFlare;
    (exports, $__.os.oid0).Sprite = Sprite;
    (exports, $__.os.oid0).LOD = LOD;
    (exports, $__.os.oid0).SkinnedMesh = SkinnedMesh;
    (exports, $__.os.oid0).Skeleton = Skeleton;
    (exports, $__.os.oid0).Bone = Bone;
    (exports, $__.os.oid0).Mesh = Mesh;
    (exports, $__.os.oid0).LineSegments = LineSegments;
    (exports, $__.os.oid0).Line = Line;
    (exports, $__.os.oid0).Points = Points;
    (exports, $__.os.oid0).Group = Group;
    (exports, $__.os.oid0).VideoTexture = VideoTexture;
    (exports, $__.os.oid0).DataTexture = DataTexture;
    (exports, $__.os.oid0).CompressedTexture = CompressedTexture;
    (exports, $__.os.oid0).CubeTexture = CubeTexture;
    (exports, $__.os.oid0).CanvasTexture = CanvasTexture;
    (exports, $__.os.oid0).DepthTexture = DepthTexture;
    (exports, $__.os.oid0).TextureIdCount = TextureIdCount;
    (exports, $__.os.oid0).Texture = Texture;
    (exports, $__.os.oid0).ShadowMaterial = ShadowMaterial;
    (exports, $__.os.oid0).SpriteMaterial = SpriteMaterial;
    (exports, $__.os.oid0).RawShaderMaterial = RawShaderMaterial;
    (exports, $__.os.oid0).ShaderMaterial = ShaderMaterial;
    (exports, $__.os.oid0).PointsMaterial = PointsMaterial;
    (exports, $__.os.oid0).MultiMaterial = MultiMaterial;
    (exports, $__.os.oid0).MeshPhysicalMaterial = MeshPhysicalMaterial;
    (exports, $__.os.oid0).MeshStandardMaterial = MeshStandardMaterial;
    (exports, $__.os.oid0).MeshPhongMaterial = MeshPhongMaterial;
    (exports, $__.os.oid0).MeshNormalMaterial = MeshNormalMaterial;
    (exports, $__.os.oid0).MeshLambertMaterial = MeshLambertMaterial;
    (exports, $__.os.oid0).MeshDepthMaterial = MeshDepthMaterial;
    (exports, $__.os.oid0).MeshBasicMaterial = MeshBasicMaterial;
    (exports, $__.os.oid0).LineDashedMaterial = LineDashedMaterial;
    (exports, $__.os.oid0).LineBasicMaterial = LineBasicMaterial;
    (exports, $__.os.oid0).MaterialIdCount = MaterialIdCount;
    (exports, $__.os.oid0).Material = Material;
    (exports, $__.os.oid0).CompressedTextureLoader = CompressedTextureLoader;
    (exports, $__.os.oid0).BinaryTextureLoader = BinaryTextureLoader;
    (exports, $__.os.oid0).DataTextureLoader = DataTextureLoader;
    (exports, $__.os.oid0).CubeTextureLoader = CubeTextureLoader;
    (exports, $__.os.oid0).TextureLoader = TextureLoader;
    (exports, $__.os.oid0).ObjectLoader = ObjectLoader;
    (exports, $__.os.oid0).MaterialLoader = MaterialLoader;
    (exports, $__.os.oid0).BufferGeometryLoader = BufferGeometryLoader;
    (exports, $__.os.oid0).LoadingManager = LoadingManager;
    (exports, $__.os.oid0).JSONLoader = JSONLoader;
    (exports, $__.os.oid0).ImageLoader = ImageLoader;
    (exports, $__.os.oid0).FontLoader = FontLoader;
    (exports, $__.os.oid0).XHRLoader = XHRLoader;
    (exports, $__.os.oid0).Loader = Loader;
    (exports, $__.os.oid0).AudioLoader = AudioLoader;
    (exports, $__.os.oid0).SpotLightShadow = SpotLightShadow;
    (exports, $__.os.oid0).SpotLight = SpotLight;
    (exports, $__.os.oid0).PointLight = PointLight;
    (exports, $__.os.oid0).HemisphereLight = HemisphereLight;
    (exports, $__.os.oid0).DirectionalLightShadow = DirectionalLightShadow;
    (exports, $__.os.oid0).DirectionalLight = DirectionalLight;
    (exports, $__.os.oid0).AmbientLight = AmbientLight;
    (exports, $__.os.oid0).LightShadow = LightShadow;
    (exports, $__.os.oid0).Light = Light;
    (exports, $__.os.oid0).StereoCamera = StereoCamera;
    (exports, $__.os.oid0).PerspectiveCamera = PerspectiveCamera;
    (exports, $__.os.oid0).OrthographicCamera = OrthographicCamera;
    (exports, $__.os.oid0).CubeCamera = CubeCamera;
    (exports, $__.os.oid0).Camera = Camera;
    (exports, $__.os.oid0).AudioListener = AudioListener;
    (exports, $__.os.oid0).PositionalAudio = PositionalAudio;
    (exports, $__.os.oid0).getAudioContext = getAudioContext;
    (exports, $__.os.oid0).AudioAnalyser = AudioAnalyser;
    (exports, $__.os.oid0).Audio = Audio;
    (exports, $__.os.oid0).VectorKeyframeTrack = VectorKeyframeTrack;
    (exports, $__.os.oid0).StringKeyframeTrack = StringKeyframeTrack;
    (exports, $__.os.oid0).QuaternionKeyframeTrack = QuaternionKeyframeTrack;
    (exports, $__.os.oid0).NumberKeyframeTrack = NumberKeyframeTrack;
    (exports, $__.os.oid0).ColorKeyframeTrack = ColorKeyframeTrack;
    (exports, $__.os.oid0).BooleanKeyframeTrack = BooleanKeyframeTrack;
    (exports, $__.os.oid0).PropertyMixer = PropertyMixer;
    (exports, $__.os.oid0).PropertyBinding = PropertyBinding;
    (exports, $__.os.oid0).KeyframeTrack = KeyframeTrack;
    (exports, $__.os.oid0).AnimationObjectGroup = AnimationObjectGroup;
    (exports, $__.os.oid0).AnimationMixer = AnimationMixer;
    (exports, $__.os.oid0).AnimationClip = AnimationClip;
    (exports, $__.os.oid0).Uniform = Uniform;
    (exports, $__.os.oid0).InstancedBufferGeometry = InstancedBufferGeometry;
    (exports, $__.os.oid0).BufferGeometry = BufferGeometry;
    (exports, $__.os.oid0).DirectGeometry = DirectGeometry;
    (exports, $__.os.oid0).GeometryIdCount = GeometryIdCount;
    (exports, $__.os.oid0).Geometry = Geometry;
    (exports, $__.os.oid0).InterleavedBufferAttribute = InterleavedBufferAttribute;
    (exports, $__.os.oid0).InstancedInterleavedBuffer = InstancedInterleavedBuffer;
    (exports, $__.os.oid0).InterleavedBuffer = InterleavedBuffer;
    (exports, $__.os.oid0).InstancedBufferAttribute = InstancedBufferAttribute;
    (exports, $__.os.oid0).DynamicBufferAttribute = DynamicBufferAttribute;
    (exports, $__.os.oid0).Float64Attribute = Float64Attribute;
    (exports, $__.os.oid0).Float32Attribute = Float32Attribute;
    (exports, $__.os.oid0).Uint32Attribute = Uint32Attribute;
    (exports, $__.os.oid0).Int32Attribute = Int32Attribute;
    (exports, $__.os.oid0).Uint16Attribute = Uint16Attribute;
    (exports, $__.os.oid0).Int16Attribute = Int16Attribute;
    (exports, $__.os.oid0).Uint8ClampedAttribute = Uint8ClampedAttribute;
    (exports, $__.os.oid0).Uint8Attribute = Uint8Attribute;
    (exports, $__.os.oid0).Int8Attribute = Int8Attribute;
    (exports, $__.os.oid0).BufferAttribute = BufferAttribute;
    (exports, $__.os.oid0).Face3 = Face3;
    (exports, $__.os.oid0).Object3DIdCount = Object3DIdCount;
    (exports, $__.os.oid0).Object3D = Object3D;
    (exports, $__.os.oid0).Raycaster = Raycaster;
    (exports, $__.os.oid0).Layers = Layers;
    (exports, $__.os.oid0).EventDispatcher = EventDispatcher;
    (exports, $__.os.oid0).Clock = Clock;
    (exports, $__.os.oid0).QuaternionLinearInterpolant = QuaternionLinearInterpolant;
    (exports, $__.os.oid0).LinearInterpolant = LinearInterpolant;
    (exports, $__.os.oid0).DiscreteInterpolant = DiscreteInterpolant;
    (exports, $__.os.oid0).CubicInterpolant = CubicInterpolant;
    (exports, $__.os.oid0).Interpolant = Interpolant;
    (exports, $__.os.oid0).Triangle = Triangle;
    (exports, $__.os.oid0).Spline = Spline;
    (exports, $__.os.oid0).Spherical = Spherical;
    (exports, $__.os.oid0).Plane = Plane;
    (exports, $__.os.oid0).Frustum = Frustum;
    (exports, $__.os.oid0).Sphere = Sphere;
    (exports, $__.os.oid0).Ray = Ray;
    (exports, $__.os.oid0).Matrix4 = Matrix4;
    (exports, $__.os.oid0).Matrix3 = Matrix3;
    (exports, $__.os.oid0).Box3 = Box3;
    (exports, $__.os.oid0).Box2 = Box2;
    (exports, $__.os.oid0).Line3 = Line3;
    (exports, $__.os.oid0).Euler = Euler;
    (exports, $__.os.oid0).Vector4 = Vector4;
    (exports, $__.os.oid0).Vector3 = Vector3;
    (exports, $__.os.oid0).Vector2 = Vector2;
    (exports, $__.os.oid0).Quaternion = Quaternion;
    (exports, $__.os.oid0).Color = Color;
    (exports, $__.os.oid0).MorphBlendMesh = MorphBlendMesh;
    (exports, $__.os.oid0).ImmediateRenderObject = ImmediateRenderObject;
    (exports, $__.os.oid0).WireframeHelper = WireframeHelper;
    (exports, $__.os.oid0).VertexNormalsHelper = VertexNormalsHelper;
    (exports, $__.os.oid0).SpotLightHelper = SpotLightHelper;
    (exports, $__.os.oid0).SkeletonHelper = SkeletonHelper;
    (exports, $__.os.oid0).PointLightHelper = PointLightHelper;
    (exports, $__.os.oid0).HemisphereLightHelper = HemisphereLightHelper;
    (exports, $__.os.oid0).GridHelper = GridHelper;
    (exports, $__.os.oid0).FaceNormalsHelper = FaceNormalsHelper;
    (exports, $__.os.oid0).EdgesHelper = EdgesHelper;
    (exports, $__.os.oid0).DirectionalLightHelper = DirectionalLightHelper;
    (exports, $__.os.oid0).CameraHelper = CameraHelper;
    (exports, $__.os.oid0).BoundingBoxHelper = BoundingBoxHelper;
    (exports, $__.os.oid0).BoxHelper = BoxHelper;
    (exports, $__.os.oid0).ArrowHelper = ArrowHelper;
    (exports, $__.os.oid0).AxisHelper = AxisHelper;
    (exports, $__.os.oid0).WireframeGeometry = WireframeGeometry;
    (exports, $__.os.oid0).ParametricGeometry = ParametricGeometry;
    (exports, $__.os.oid0).TetrahedronGeometry = TetrahedronGeometry;
    (exports, $__.os.oid0).OctahedronGeometry = OctahedronGeometry;
    (exports, $__.os.oid0).IcosahedronGeometry = IcosahedronGeometry;
    (exports, $__.os.oid0).DodecahedronGeometry = DodecahedronGeometry;
    (exports, $__.os.oid0).PolyhedronGeometry = PolyhedronGeometry;
    (exports, $__.os.oid0).TubeGeometry = TubeGeometry;
    (exports, $__.os.oid0).TorusKnotGeometry = TorusKnotGeometry;
    (exports, $__.os.oid0).TorusKnotBufferGeometry = TorusKnotBufferGeometry;
    (exports, $__.os.oid0).TorusGeometry = TorusGeometry;
    (exports, $__.os.oid0).TorusBufferGeometry = TorusBufferGeometry;
    (exports, $__.os.oid0).TextGeometry = TextGeometry;
    (exports, $__.os.oid0).SphereBufferGeometry = SphereBufferGeometry;
    (exports, $__.os.oid0).SphereGeometry = SphereGeometry;
    (exports, $__.os.oid0).RingGeometry = RingGeometry;
    (exports, $__.os.oid0).RingBufferGeometry = RingBufferGeometry;
    (exports, $__.os.oid0).PlaneBufferGeometry = PlaneBufferGeometry;
    (exports, $__.os.oid0).PlaneGeometry = PlaneGeometry;
    (exports, $__.os.oid0).LatheGeometry = LatheGeometry;
    (exports, $__.os.oid0).LatheBufferGeometry = LatheBufferGeometry;
    (exports, $__.os.oid0).ShapeGeometry = ShapeGeometry;
    (exports, $__.os.oid0).ExtrudeGeometry = ExtrudeGeometry;
    (exports, $__.os.oid0).EdgesGeometry = EdgesGeometry;
    (exports, $__.os.oid0).ConeGeometry = ConeGeometry;
    (exports, $__.os.oid0).ConeBufferGeometry = ConeBufferGeometry;
    (exports, $__.os.oid0).CylinderGeometry = CylinderGeometry;
    (exports, $__.os.oid0).CylinderBufferGeometry = CylinderBufferGeometry;
    (exports, $__.os.oid0).CircleBufferGeometry = CircleBufferGeometry;
    (exports, $__.os.oid0).CircleGeometry = CircleGeometry;
    (exports, $__.os.oid0).BoxBufferGeometry = BoxBufferGeometry;
    (exports, $__.os.oid0).BoxGeometry = BoxGeometry;
    (exports, $__.os.oid0).ClosedSplineCurve3 = ClosedSplineCurve3;
    (exports, $__.os.oid0).SplineCurve3 = SplineCurve3;
    (exports, $__.os.oid0).ArcCurve = ArcCurve;
    (exports, $__.os.oid0).EllipseCurve = EllipseCurve;
    (exports, $__.os.oid0).SplineCurve = SplineCurve;
    (exports, $__.os.oid0).CubicBezierCurve = CubicBezierCurve;
    (exports, $__.os.oid0).QuadraticBezierCurve = QuadraticBezierCurve;
    (exports, $__.os.oid0).LineCurve = LineCurve;
    (exports, $__.os.oid0).Shape = Shape;
    (exports, $__.os.oid0).ShapePath = ShapePath;
    (exports, $__.os.oid0).Path = Path;
    (exports, $__.os.oid0).Font = Font;
    (exports, $__.os.oid0).CurvePath = CurvePath;
    (exports, $__.os.oid0).Curve = Curve;
    (exports, $__.os.oid0).REVISION = REVISION;
    (exports, $__.os.oid0).MOUSE = MOUSE;
    (exports, $__.os.oid0).CullFaceNone = CullFaceNone;
    (exports, $__.os.oid0).CullFaceBack = CullFaceBack;
    (exports, $__.os.oid0).CullFaceFront = CullFaceFront;
    (exports, $__.os.oid0).CullFaceFrontBack = CullFaceFrontBack;
    (exports, $__.os.oid0).FrontFaceDirectionCW = FrontFaceDirectionCW;
    (exports, $__.os.oid0).FrontFaceDirectionCCW = FrontFaceDirectionCCW;
    (exports, $__.os.oid0).BasicShadowMap = BasicShadowMap;
    (exports, $__.os.oid0).PCFShadowMap = PCFShadowMap;
    (exports, $__.os.oid0).PCFSoftShadowMap = PCFSoftShadowMap;
    (exports, $__.os.oid0).FrontSide = FrontSide;
    (exports, $__.os.oid0).BackSide = BackSide;
    (exports, $__.os.oid0).DoubleSide = DoubleSide;
    (exports, $__.os.oid0).FlatShading = FlatShading;
    (exports, $__.os.oid0).SmoothShading = SmoothShading;
    (exports, $__.os.oid0).NoColors = NoColors;
    (exports, $__.os.oid0).FaceColors = FaceColors;
    (exports, $__.os.oid0).VertexColors = VertexColors;
    (exports, $__.os.oid0).NoBlending = NoBlending;
    (exports, $__.os.oid0).NormalBlending = NormalBlending;
    (exports, $__.os.oid0).AdditiveBlending = AdditiveBlending;
    (exports, $__.os.oid0).SubtractiveBlending = SubtractiveBlending;
    (exports, $__.os.oid0).MultiplyBlending = MultiplyBlending;
    (exports, $__.os.oid0).CustomBlending = CustomBlending;
    (exports, $__.os.oid0).AddEquation = AddEquation;
    (exports, $__.os.oid0).SubtractEquation = SubtractEquation;
    (exports, $__.os.oid0).ReverseSubtractEquation = ReverseSubtractEquation;
    (exports, $__.os.oid0).MinEquation = MinEquation;
    (exports, $__.os.oid0).MaxEquation = MaxEquation;
    (exports, $__.os.oid0).ZeroFactor = ZeroFactor;
    (exports, $__.os.oid0).OneFactor = OneFactor;
    (exports, $__.os.oid0).SrcColorFactor = SrcColorFactor;
    (exports, $__.os.oid0).OneMinusSrcColorFactor = OneMinusSrcColorFactor;
    (exports, $__.os.oid0).SrcAlphaFactor = SrcAlphaFactor;
    (exports, $__.os.oid0).OneMinusSrcAlphaFactor = OneMinusSrcAlphaFactor;
    (exports, $__.os.oid0).DstAlphaFactor = DstAlphaFactor;
    (exports, $__.os.oid0).OneMinusDstAlphaFactor = OneMinusDstAlphaFactor;
    (exports, $__.os.oid0).DstColorFactor = DstColorFactor;
    (exports, $__.os.oid0).OneMinusDstColorFactor = OneMinusDstColorFactor;
    (exports, $__.os.oid0).SrcAlphaSaturateFactor = SrcAlphaSaturateFactor;
    (exports, $__.os.oid0).NeverDepth = NeverDepth;
    (exports, $__.os.oid0).AlwaysDepth = AlwaysDepth;
    (exports, $__.os.oid0).LessDepth = LessDepth;
    (exports, $__.os.oid0).LessEqualDepth = LessEqualDepth;
    (exports, $__.os.oid0).EqualDepth = EqualDepth;
    (exports, $__.os.oid0).GreaterEqualDepth = GreaterEqualDepth;
    (exports, $__.os.oid0).GreaterDepth = GreaterDepth;
    (exports, $__.os.oid0).NotEqualDepth = NotEqualDepth;
    (exports, $__.os.oid0).MultiplyOperation = MultiplyOperation;
    (exports, $__.os.oid0).MixOperation = MixOperation;
    (exports, $__.os.oid0).AddOperation = AddOperation;
    (exports, $__.os.oid0).NoToneMapping = NoToneMapping;
    (exports, $__.os.oid0).LinearToneMapping = LinearToneMapping;
    (exports, $__.os.oid0).ReinhardToneMapping = ReinhardToneMapping;
    (exports, $__.os.oid0).Uncharted2ToneMapping = Uncharted2ToneMapping;
    (exports, $__.os.oid0).CineonToneMapping = CineonToneMapping;
    (exports, $__.os.oid0).UVMapping = UVMapping;
    (exports, $__.os.oid0).CubeReflectionMapping = CubeReflectionMapping;
    (exports, $__.os.oid0).CubeRefractionMapping = CubeRefractionMapping;
    (exports, $__.os.oid0).EquirectangularReflectionMapping = EquirectangularReflectionMapping;
    (exports, $__.os.oid0).EquirectangularRefractionMapping = EquirectangularRefractionMapping;
    (exports, $__.os.oid0).SphericalReflectionMapping = SphericalReflectionMapping;
    (exports, $__.os.oid0).CubeUVReflectionMapping = CubeUVReflectionMapping;
    (exports, $__.os.oid0).CubeUVRefractionMapping = CubeUVRefractionMapping;
    (exports, $__.os.oid0).RepeatWrapping = RepeatWrapping;
    (exports, $__.os.oid0).ClampToEdgeWrapping = ClampToEdgeWrapping;
    (exports, $__.os.oid0).MirroredRepeatWrapping = MirroredRepeatWrapping;
    (exports, $__.os.oid0).NearestFilter = NearestFilter;
    (exports, $__.os.oid0).NearestMipMapNearestFilter = NearestMipMapNearestFilter;
    (exports, $__.os.oid0).NearestMipMapLinearFilter = NearestMipMapLinearFilter;
    (exports, $__.os.oid0).LinearFilter = LinearFilter;
    (exports, $__.os.oid0).LinearMipMapNearestFilter = LinearMipMapNearestFilter;
    (exports, $__.os.oid0).LinearMipMapLinearFilter = LinearMipMapLinearFilter;
    (exports, $__.os.oid0).UnsignedByteType = UnsignedByteType;
    (exports, $__.os.oid0).ByteType = ByteType;
    (exports, $__.os.oid0).ShortType = ShortType;
    (exports, $__.os.oid0).UnsignedShortType = UnsignedShortType;
    (exports, $__.os.oid0).IntType = IntType;
    (exports, $__.os.oid0).UnsignedIntType = UnsignedIntType;
    (exports, $__.os.oid0).FloatType = FloatType;
    (exports, $__.os.oid0).HalfFloatType = HalfFloatType;
    (exports, $__.os.oid0).UnsignedShort4444Type = UnsignedShort4444Type;
    (exports, $__.os.oid0).UnsignedShort5551Type = UnsignedShort5551Type;
    (exports, $__.os.oid0).UnsignedShort565Type = UnsignedShort565Type;
    (exports, $__.os.oid0).UnsignedInt248Type = UnsignedInt248Type;
    (exports, $__.os.oid0).AlphaFormat = AlphaFormat;
    (exports, $__.os.oid0).RGBFormat = RGBFormat;
    (exports, $__.os.oid0).RGBAFormat = RGBAFormat;
    (exports, $__.os.oid0).LuminanceFormat = LuminanceFormat;
    (exports, $__.os.oid0).LuminanceAlphaFormat = LuminanceAlphaFormat;
    (exports, $__.os.oid0).RGBEFormat = RGBEFormat;
    (exports, $__.os.oid0).DepthFormat = DepthFormat;
    (exports, $__.os.oid0).DepthStencilFormat = DepthStencilFormat;
    (exports, $__.os.oid0).RGB_S3TC_DXT1_Format = RGB_S3TC_DXT1_Format;
    (exports, $__.os.oid0).RGBA_S3TC_DXT1_Format = RGBA_S3TC_DXT1_Format;
    (exports, $__.os.oid0).RGBA_S3TC_DXT3_Format = RGBA_S3TC_DXT3_Format;
    (exports, $__.os.oid0).RGBA_S3TC_DXT5_Format = RGBA_S3TC_DXT5_Format;
    (exports, $__.os.oid0).RGB_PVRTC_4BPPV1_Format = RGB_PVRTC_4BPPV1_Format;
    (exports, $__.os.oid0).RGB_PVRTC_2BPPV1_Format = RGB_PVRTC_2BPPV1_Format;
    (exports, $__.os.oid0).RGBA_PVRTC_4BPPV1_Format = RGBA_PVRTC_4BPPV1_Format;
    (exports, $__.os.oid0).RGBA_PVRTC_2BPPV1_Format = RGBA_PVRTC_2BPPV1_Format;
    (exports, $__.os.oid0).RGB_ETC1_Format = RGB_ETC1_Format;
    (exports, $__.os.oid0).LoopOnce = LoopOnce;
    (exports, $__.os.oid0).LoopRepeat = LoopRepeat;
    (exports, $__.os.oid0).LoopPingPong = LoopPingPong;
    (exports, $__.os.oid0).InterpolateDiscrete = InterpolateDiscrete;
    (exports, $__.os.oid0).InterpolateLinear = InterpolateLinear;
    (exports, $__.os.oid0).InterpolateSmooth = InterpolateSmooth;
    (exports, $__.os.oid0).ZeroCurvatureEnding = ZeroCurvatureEnding;
    (exports, $__.os.oid0).ZeroSlopeEnding = ZeroSlopeEnding;
    (exports, $__.os.oid0).WrapAroundEnding = WrapAroundEnding;
    (exports, $__.os.oid0).TrianglesDrawMode = TrianglesDrawMode;
    (exports, $__.os.oid0).TriangleStripDrawMode = TriangleStripDrawMode;
    (exports, $__.os.oid0).TriangleFanDrawMode = TriangleFanDrawMode;
    (exports, $__.os.oid0).LinearEncoding = LinearEncoding;
    (exports, $__.os.oid0).sRGBEncoding = sRGBEncoding;
    (exports, $__.os.oid0).GammaEncoding = GammaEncoding;
    (exports, $__.os.oid0).RGBEEncoding = RGBEEncoding;
    (exports, $__.os.oid0).LogLuvEncoding = LogLuvEncoding;
    (exports, $__.os.oid0).RGBM7Encoding = RGBM7Encoding;
    (exports, $__.os.oid0).RGBM16Encoding = RGBM16Encoding;
    (exports, $__.os.oid0).RGBDEncoding = RGBDEncoding;
    (exports, $__.os.oid0).BasicDepthPacking = BasicDepthPacking;
    (exports, $__.os.oid0).RGBADepthPacking = RGBADepthPacking;
    (exports, $__.os.oid0).CubeGeometry = BoxGeometry;
    (exports, $__.os.oid0).Face4 = Face4;
    (exports, $__.os.oid0).LineStrip = LineStrip;
    (exports, $__.os.oid0).LinePieces = LinePieces;
    (exports, $__.os.oid0).MeshFaceMaterial = MultiMaterial;
    (exports, $__.os.oid0).PointCloud = PointCloud;
    (exports, $__.os.oid0).Particle = Sprite;
    (exports, $__.os.oid0).ParticleSystem = ParticleSystem;
    (exports, $__.os.oid0).PointCloudMaterial = PointCloudMaterial;
    (exports, $__.os.oid0).ParticleBasicMaterial = ParticleBasicMaterial;
    (exports, $__.os.oid0).ParticleSystemMaterial = ParticleSystemMaterial;
    (exports, $__.os.oid0).Vertex = Vertex;
    (exports, $__.os.oid0).GeometryUtils = GeometryUtils;
    (exports, $__.os.oid0).ImageUtils = ImageUtils;
    (exports, $__.os.oid0).Projector = Projector;
    (exports, $__.os.oid0).CanvasRenderer = CanvasRenderer;
    Object['defineProperty'](exports, '__esModule', $__.os.oid612 = {
        'value': true
    });
    return;
}
if (vvv_return)
    return;
TAJS_dumpValue('Not ' + 'reachable');
if (Number.EPSILON === undefined) {
    Number.EPSILON = Math.pow(2, -52);
}
if (Math.sign === undefined) {
    Math.sign = function (x) {
        return x < 0 ? -1 : x > 0 ? 1 : +x;
    };
}
if (Function.prototype.name === undefined) {
    Object.defineProperty(Function.prototype, 'name', {
        get: function () {
            return this.toString().match(/^\s*function\s*(\S*)\s*\(/)[1];
        }
    });
}
if (Object.assign === undefined) {
    (function () {
        Object.assign = function (target) {
            'use strict';
            if (target === undefined || target === null) {
                throw new TypeError('Cannot convert undefined or null to object');
            }
            var output = Object(target);
            for (var index = 1; index < arguments.length; index++) {
                var source = arguments[index];
                if (source !== undefined && source !== null) {
                    for (var nextKey in source) {
                        if (Object.prototype.hasOwnProperty.call(source, nextKey)) {
                            output[nextKey] = source[nextKey];
                        }
                    }
                }
            }
            return output;
        };
    }());
}
Object.assign(EventDispatcher.prototype, {
    addEventListener: function (type, listener) {
        if (this._listeners === undefined)
            this._listeners = {};
        var listeners = this._listeners;
        if (listeners[type] === undefined) {
            listeners[type] = [];
        }
        if (listeners[type].indexOf(listener) === -1) {
            listeners[type].push(listener);
        }
    },
    hasEventListener: function (type, listener) {
        if (this._listeners === undefined)
            return false;
        var listeners = this._listeners;
        if (listeners[type] !== undefined && listeners[type].indexOf(listener) !== -1) {
            return true;
        }
        return false;
    },
    removeEventListener: function (type, listener) {
        if (this._listeners === undefined)
            return;
        var listeners = this._listeners;
        var listenerArray = listeners[type];
        if (listenerArray !== undefined) {
            var index = listenerArray.indexOf(listener);
            if (index !== -1) {
                listenerArray.splice(index, 1);
            }
        }
    },
    dispatchEvent: function (event) {
        if (this._listeners === undefined)
            return;
        var listeners = this._listeners;
        var listenerArray = listeners[event.type];
        if (listenerArray !== undefined) {
            event.target = this;
            var array = [], i = 0;
            var length = listenerArray.length;
            for (i = 0; i < length; i++) {
                array[i] = listenerArray[i];
            }
            for (i = 0; i < length; i++) {
                array[i].call(this, event);
            }
        }
    }
});
REVISION = '80';
MOUSE = {
    LEFT: 0,
    MIDDLE: 1,
    RIGHT: 2
};
CullFaceNone = 0;
CullFaceBack = 1;
CullFaceFront = 2;
CullFaceFrontBack = 3;
FrontFaceDirectionCW = 0;
FrontFaceDirectionCCW = 1;
BasicShadowMap = 0;
PCFShadowMap = 1;
PCFSoftShadowMap = 2;
FrontSide = 0;
BackSide = 1;
DoubleSide = 2;
FlatShading = 1;
SmoothShading = 2;
NoColors = 0;
FaceColors = 1;
VertexColors = 2;
NoBlending = 0;
NormalBlending = 1;
AdditiveBlending = 2;
SubtractiveBlending = 3;
MultiplyBlending = 4;
CustomBlending = 5;
AddEquation = 100;
SubtractEquation = 101;
ReverseSubtractEquation = 102;
MinEquation = 103;
MaxEquation = 104;
ZeroFactor = 200;
OneFactor = 201;
SrcColorFactor = 202;
OneMinusSrcColorFactor = 203;
SrcAlphaFactor = 204;
OneMinusSrcAlphaFactor = 205;
DstAlphaFactor = 206;
OneMinusDstAlphaFactor = 207;
DstColorFactor = 208;
OneMinusDstColorFactor = 209;
SrcAlphaSaturateFactor = 210;
NeverDepth = 0;
AlwaysDepth = 1;
LessDepth = 2;
LessEqualDepth = 3;
EqualDepth = 4;
GreaterEqualDepth = 5;
GreaterDepth = 6;
NotEqualDepth = 7;
MultiplyOperation = 0;
MixOperation = 1;
AddOperation = 2;
NoToneMapping = 0;
LinearToneMapping = 1;
ReinhardToneMapping = 2;
Uncharted2ToneMapping = 3;
CineonToneMapping = 4;
UVMapping = 300;
CubeReflectionMapping = 301;
CubeRefractionMapping = 302;
EquirectangularReflectionMapping = 303;
EquirectangularRefractionMapping = 304;
SphericalReflectionMapping = 305;
CubeUVReflectionMapping = 306;
CubeUVRefractionMapping = 307;
RepeatWrapping = 1000;
ClampToEdgeWrapping = 1001;
MirroredRepeatWrapping = 1002;
NearestFilter = 1003;
NearestMipMapNearestFilter = 1004;
NearestMipMapLinearFilter = 1005;
LinearFilter = 1006;
LinearMipMapNearestFilter = 1007;
LinearMipMapLinearFilter = 1008;
UnsignedByteType = 1009;
ByteType = 1010;
ShortType = 1011;
UnsignedShortType = 1012;
IntType = 1013;
UnsignedIntType = 1014;
FloatType = 1015;
HalfFloatType = 1016;
UnsignedShort4444Type = 1017;
UnsignedShort5551Type = 1018;
UnsignedShort565Type = 1019;
UnsignedInt248Type = 1020;
AlphaFormat = 1021;
RGBFormat = 1022;
RGBAFormat = 1023;
LuminanceFormat = 1024;
LuminanceAlphaFormat = 1025;
RGBEFormat = RGBAFormat;
DepthFormat = 1026;
DepthStencilFormat = 1027;
RGB_S3TC_DXT1_Format = 2001;
RGBA_S3TC_DXT1_Format = 2002;
RGBA_S3TC_DXT3_Format = 2003;
RGBA_S3TC_DXT5_Format = 2004;
RGB_PVRTC_4BPPV1_Format = 2100;
RGB_PVRTC_2BPPV1_Format = 2101;
RGBA_PVRTC_4BPPV1_Format = 2102;
RGBA_PVRTC_2BPPV1_Format = 2103;
RGB_ETC1_Format = 2151;
LoopOnce = 2200;
LoopRepeat = 2201;
LoopPingPong = 2202;
InterpolateDiscrete = 2300;
InterpolateLinear = 2301;
InterpolateSmooth = 2302;
ZeroCurvatureEnding = 2400;
ZeroSlopeEnding = 2401;
WrapAroundEnding = 2402;
TrianglesDrawMode = 0;
TriangleStripDrawMode = 1;
TriangleFanDrawMode = 2;
LinearEncoding = 3000;
sRGBEncoding = 3001;
GammaEncoding = 3007;
RGBEEncoding = 3002;
LogLuvEncoding = 3003;
RGBM7Encoding = 3004;
RGBM16Encoding = 3005;
RGBDEncoding = 3006;
BasicDepthPacking = 3200;
RGBADepthPacking = 3201;
exports.Math = {
    DEG2RAD: Math.PI / 180,
    RAD2DEG: 180 / Math.PI,
    generateUUID: function () {
        var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split('');
        var uuid = new Array(36);
        var rnd = 0, r;
        return function generateUUID() {
            for (var i = 0; i < 36; i++) {
                if (i === 8 || i === 13 || i === 18 || i === 23) {
                    uuid[i] = '-';
                } else if (i === 14) {
                    uuid[i] = '4';
                } else {
                    if (rnd <= 2)
                        rnd = 33554432 + Math.random() * 16777216 | 0;
                    r = rnd & 15;
                    rnd = rnd >> 4;
                    uuid[i] = chars[i === 19 ? r & 3 | 8 : r];
                }
            }
            return uuid.join('');
        };
    }(),
    clamp: function (value, min, max) {
        return Math.max(min, Math.min(max, value));
    },
    euclideanModulo: function (n, m) {
        return (n % m + m) % m;
    },
    mapLinear: function (x, a1, a2, b1, b2) {
        return b1 + (x - a1) * (b2 - b1) / (a2 - a1);
    },
    smoothstep: function (x, min, max) {
        if (x <= min)
            return 0;
        if (x >= max)
            return 1;
        x = (x - min) / (max - min);
        return x * x * (3 - 2 * x);
    },
    smootherstep: function (x, min, max) {
        if (x <= min)
            return 0;
        if (x >= max)
            return 1;
        x = (x - min) / (max - min);
        return x * x * x * (x * (x * 6 - 15) + 10);
    },
    random16: function () {
        console.warn('THREE.Math.random16() has been deprecated. Use Math.random() instead.');
        return Math.random();
    },
    randInt: function (low, high) {
        return low + Math.floor(Math.random() * (high - low + 1));
    },
    randFloat: function (low, high) {
        return low + Math.random() * (high - low);
    },
    randFloatSpread: function (range) {
        return range * (0.5 - Math.random());
    },
    degToRad: function (degrees) {
        return degrees * exports.Math.DEG2RAD;
    },
    radToDeg: function (radians) {
        return radians * exports.Math.RAD2DEG;
    },
    isPowerOfTwo: function (value) {
        return (value & value - 1) === 0 && value !== 0;
    },
    nearestPowerOfTwo: function (value) {
        return Math.pow(2, Math.round(Math.log(value) / Math.LN2));
    },
    nextPowerOfTwo: function (value) {
        value--;
        value |= value >> 1;
        value |= value >> 2;
        value |= value >> 4;
        value |= value >> 8;
        value |= value >> 16;
        value++;
        return value;
    }
};
Vector2.prototype = {
    constructor: Vector2,
    isVector2: true,
    get width() {
        return this.x;
    },
    set width(value) {
        this.x = value;
    },
    get height() {
        return this.y;
    },
    set height(value) {
        this.y = value;
    },
    set: function (x, y) {
        this.x = x;
        this.y = y;
        return this;
    },
    setScalar: function (scalar) {
        this.x = scalar;
        this.y = scalar;
        return this;
    },
    setX: function (x) {
        this.x = x;
        return this;
    },
    setY: function (y) {
        this.y = y;
        return this;
    },
    setComponent: function (index, value) {
        switch (index) {
        case 0:
            this.x = value;
            break;
        case 1:
            this.y = value;
            break;
        default:
            throw new Error('index is out of range: ' + index);
        }
    },
    getComponent: function (index) {
        switch (index) {
        case 0:
            return this.x;
        case 1:
            return this.y;
        default:
            throw new Error('index is out of range: ' + index);
        }
    },
    clone: function () {
        return new this.constructor(this.x, this.y);
    },
    copy: function (v) {
        this.x = v.x;
        this.y = v.y;
        return this;
    },
    add: function (v, w) {
        if (w !== undefined) {
            console.warn('THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');
            return this.addVectors(v, w);
        }
        this.x += v.x;
        this.y += v.y;
        return this;
    },
    addScalar: function (s) {
        this.x += s;
        this.y += s;
        return this;
    },
    addVectors: function (a, b) {
        this.x = a.x + b.x;
        this.y = a.y + b.y;
        return this;
    },
    addScaledVector: function (v, s) {
        this.x += v.x * s;
        this.y += v.y * s;
        return this;
    },
    sub: function (v, w) {
        if (w !== undefined) {
            console.warn('THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');
            return this.subVectors(v, w);
        }
        this.x -= v.x;
        this.y -= v.y;
        return this;
    },
    subScalar: function (s) {
        this.x -= s;
        this.y -= s;
        return this;
    },
    subVectors: function (a, b) {
        this.x = a.x - b.x;
        this.y = a.y - b.y;
        return this;
    },
    multiply: function (v) {
        this.x *= v.x;
        this.y *= v.y;
        return this;
    },
    multiplyScalar: function (scalar) {
        if (isFinite(scalar)) {
            this.x *= scalar;
            this.y *= scalar;
        } else {
            this.x = 0;
            this.y = 0;
        }
        return this;
    },
    divide: function (v) {
        this.x /= v.x;
        this.y /= v.y;
        return this;
    },
    divideScalar: function (scalar) {
        return this.multiplyScalar(1 / scalar);
    },
    min: function (v) {
        this.x = Math.min(this.x, v.x);
        this.y = Math.min(this.y, v.y);
        return this;
    },
    max: function (v) {
        this.x = Math.max(this.x, v.x);
        this.y = Math.max(this.y, v.y);
        return this;
    },
    clamp: function (min, max) {
        this.x = Math.max(min.x, Math.min(max.x, this.x));
        this.y = Math.max(min.y, Math.min(max.y, this.y));
        return this;
    },
    clampScalar: function () {
        var min, max;
        return function clampScalar(minVal, maxVal) {
            if (min === undefined) {
                min = new Vector2();
                max = new Vector2();
            }
            min.set(minVal, minVal);
            max.set(maxVal, maxVal);
            return this.clamp(min, max);
        };
    }(),
    clampLength: function (min, max) {
        var length = this.length();
        return this.multiplyScalar(Math.max(min, Math.min(max, length)) / length);
    },
    floor: function () {
        this.x = Math.floor(this.x);
        this.y = Math.floor(this.y);
        return this;
    },
    ceil: function () {
        this.x = Math.ceil(this.x);
        this.y = Math.ceil(this.y);
        return this;
    },
    round: function () {
        this.x = Math.round(this.x);
        this.y = Math.round(this.y);
        return this;
    },
    roundToZero: function () {
        this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
        this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
        return this;
    },
    negate: function () {
        this.x = -this.x;
        this.y = -this.y;
        return this;
    },
    dot: function (v) {
        return this.x * v.x + this.y * v.y;
    },
    lengthSq: function () {
        return this.x * this.x + this.y * this.y;
    },
    length: function () {
        return Math.sqrt(this.x * this.x + this.y * this.y);
    },
    lengthManhattan: function () {
        return Math.abs(this.x) + Math.abs(this.y);
    },
    normalize: function () {
        return this.divideScalar(this.length());
    },
    angle: function () {
        var angle = Math.atan2(this.y, this.x);
        if (angle < 0)
            angle += 2 * Math.PI;
        return angle;
    },
    distanceTo: function (v) {
        return Math.sqrt(this.distanceToSquared(v));
    },
    distanceToSquared: function (v) {
        var dx = this.x - v.x, dy = this.y - v.y;
        return dx * dx + dy * dy;
    },
    distanceToManhattan: function (v) {
        return Math.abs(this.x - v.x) + Math.abs(this.y - v.y);
    },
    setLength: function (length) {
        return this.multiplyScalar(length / this.length());
    },
    lerp: function (v, alpha) {
        this.x += (v.x - this.x) * alpha;
        this.y += (v.y - this.y) * alpha;
        return this;
    },
    lerpVectors: function (v1, v2, alpha) {
        return this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);
    },
    equals: function (v) {
        return v.x === this.x && v.y === this.y;
    },
    fromArray: function (array, offset) {
        if (offset === undefined)
            offset = 0;
        this.x = array[offset];
        this.y = array[offset + 1];
        return this;
    },
    toArray: function (array, offset) {
        if (array === undefined)
            array = [];
        if (offset === undefined)
            offset = 0;
        array[offset] = this.x;
        array[offset + 1] = this.y;
        return array;
    },
    fromAttribute: function (attribute, index, offset) {
        if (offset === undefined)
            offset = 0;
        index = index * attribute.itemSize + offset;
        this.x = attribute.array[index];
        this.y = attribute.array[index + 1];
        return this;
    },
    rotateAround: function (center, angle) {
        var c = Math.cos(angle), s = Math.sin(angle);
        var x = this.x - center.x;
        var y = this.y - center.y;
        this.x = x * c - y * s + center.x;
        this.y = x * s + y * c + center.y;
        return this;
    }
};
Texture.DEFAULT_IMAGE = undefined;
Texture.DEFAULT_MAPPING = UVMapping;
Texture.prototype = {
    constructor: Texture,
    isTexture: true,
    set needsUpdate(value) {
        if (value === true)
            this.version++;
    },
    clone: function () {
        return new this.constructor().copy(this);
    },
    copy: function (source) {
        this.image = source.image;
        this.mipmaps = source.mipmaps.slice(0);
        this.mapping = source.mapping;
        this.wrapS = source.wrapS;
        this.wrapT = source.wrapT;
        this.magFilter = source.magFilter;
        this.minFilter = source.minFilter;
        this.anisotropy = source.anisotropy;
        this.format = source.format;
        this.type = source.type;
        this.offset.copy(source.offset);
        this.repeat.copy(source.repeat);
        this.generateMipmaps = source.generateMipmaps;
        this.premultiplyAlpha = source.premultiplyAlpha;
        this.flipY = source.flipY;
        this.unpackAlignment = source.unpackAlignment;
        this.encoding = source.encoding;
        return this;
    },
    toJSON: function (meta) {
        if (meta.textures[this.uuid] !== undefined) {
            return meta.textures[this.uuid];
        }
        function getDataURL(image) {
            var canvas;
            if (image.toDataURL !== undefined) {
                canvas = image;
            } else {
                canvas = document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');
                canvas.width = image.width;
                canvas.height = image.height;
                canvas.getContext('2d').drawImage(image, 0, 0, image.width, image.height);
            }
            if (canvas.width > 2048 || canvas.height > 2048) {
                return canvas.toDataURL('image/jpeg', 0.6);
            } else {
                return canvas.toDataURL('image/png');
            }
        }
        var output = {
            metadata: {
                version: 4.4,
                type: 'Texture',
                generator: 'Texture.toJSON'
            },
            uuid: this.uuid,
            name: this.name,
            mapping: this.mapping,
            repeat: [
                this.repeat.x,
                this.repeat.y
            ],
            offset: [
                this.offset.x,
                this.offset.y
            ],
            wrap: [
                this.wrapS,
                this.wrapT
            ],
            minFilter: this.minFilter,
            magFilter: this.magFilter,
            anisotropy: this.anisotropy,
            flipY: this.flipY
        };
        if (this.image !== undefined) {
            var image = this.image;
            if (image.uuid === undefined) {
                image.uuid = exports.Math.generateUUID();
            }
            if (meta.images[image.uuid] === undefined) {
                meta.images[image.uuid] = {
                    uuid: image.uuid,
                    url: getDataURL(image)
                };
            }
            output.image = image.uuid;
        }
        meta.textures[this.uuid] = output;
        return output;
    },
    dispose: function () {
        this.dispatchEvent({
            type: 'dispose'
        });
    },
    transformUv: function (uv) {
        if (this.mapping !== UVMapping)
            return;
        uv.multiply(this.repeat);
        uv.add(this.offset);
        if (uv.x < 0 || uv.x > 1) {
            switch (this.wrapS) {
            case RepeatWrapping:
                uv.x = uv.x - Math.floor(uv.x);
                break;
            case ClampToEdgeWrapping:
                uv.x = uv.x < 0 ? 0 : 1;
                break;
            case MirroredRepeatWrapping:
                if (Math.abs(Math.floor(uv.x) % 2) === 1) {
                    uv.x = Math.ceil(uv.x) - uv.x;
                } else {
                    uv.x = uv.x - Math.floor(uv.x);
                }
                break;
            }
        }
        if (uv.y < 0 || uv.y > 1) {
            switch (this.wrapT) {
            case RepeatWrapping:
                uv.y = uv.y - Math.floor(uv.y);
                break;
            case ClampToEdgeWrapping:
                uv.y = uv.y < 0 ? 0 : 1;
                break;
            case MirroredRepeatWrapping:
                if (Math.abs(Math.floor(uv.y) % 2) === 1) {
                    uv.y = Math.ceil(uv.y) - uv.y;
                } else {
                    uv.y = uv.y - Math.floor(uv.y);
                }
                break;
            }
        }
        if (this.flipY) {
            uv.y = 1 - uv.y;
        }
    }
};
Object.assign(Texture.prototype, EventDispatcher.prototype);
count = 0;
;
Matrix4.prototype = {
    constructor: Matrix4,
    isMatrix4: true,
    set: function (n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
        var te = this.elements;
        te[0] = n11;
        te[4] = n12;
        te[8] = n13;
        te[12] = n14;
        te[1] = n21;
        te[5] = n22;
        te[9] = n23;
        te[13] = n24;
        te[2] = n31;
        te[6] = n32;
        te[10] = n33;
        te[14] = n34;
        te[3] = n41;
        te[7] = n42;
        te[11] = n43;
        te[15] = n44;
        return this;
    },
    identity: function () {
        this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
        return this;
    },
    clone: function () {
        return new Matrix4().fromArray(this.elements);
    },
    copy: function (m) {
        this.elements.set(m.elements);
        return this;
    },
    copyPosition: function (m) {
        var te = this.elements;
        var me = m.elements;
        te[12] = me[12];
        te[13] = me[13];
        te[14] = me[14];
        return this;
    },
    extractBasis: function (xAxis, yAxis, zAxis) {
        xAxis.setFromMatrixColumn(this, 0);
        yAxis.setFromMatrixColumn(this, 1);
        zAxis.setFromMatrixColumn(this, 2);
        return this;
    },
    makeBasis: function (xAxis, yAxis, zAxis) {
        this.set(xAxis.x, yAxis.x, zAxis.x, 0, xAxis.y, yAxis.y, zAxis.y, 0, xAxis.z, yAxis.z, zAxis.z, 0, 0, 0, 0, 1);
        return this;
    },
    extractRotation: function () {
        var v1;
        return function extractRotation(m) {
            if (v1 === undefined)
                v1 = new Vector3();
            var te = this.elements;
            var me = m.elements;
            var scaleX = 1 / v1.setFromMatrixColumn(m, 0).length();
            var scaleY = 1 / v1.setFromMatrixColumn(m, 1).length();
            var scaleZ = 1 / v1.setFromMatrixColumn(m, 2).length();
            te[0] = me[0] * scaleX;
            te[1] = me[1] * scaleX;
            te[2] = me[2] * scaleX;
            te[4] = me[4] * scaleY;
            te[5] = me[5] * scaleY;
            te[6] = me[6] * scaleY;
            te[8] = me[8] * scaleZ;
            te[9] = me[9] * scaleZ;
            te[10] = me[10] * scaleZ;
            return this;
        };
    }(),
    makeRotationFromEuler: function (euler) {
        if ((euler && euler.isEuler) === false) {
            console.error('THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.');
        }
        var te = this.elements;
        var x = euler.x, y = euler.y, z = euler.z;
        var a = Math.cos(x), b = Math.sin(x);
        var c = Math.cos(y), d = Math.sin(y);
        var e = Math.cos(z), f = Math.sin(z);
        if (euler.order === 'XYZ') {
            var ae = a * e, af = a * f, be = b * e, bf = b * f;
            te[0] = c * e;
            te[4] = -c * f;
            te[8] = d;
            te[1] = af + be * d;
            te[5] = ae - bf * d;
            te[9] = -b * c;
            te[2] = bf - ae * d;
            te[6] = be + af * d;
            te[10] = a * c;
        } else if (euler.order === 'YXZ') {
            var ce = c * e, cf = c * f, de = d * e, df = d * f;
            te[0] = ce + df * b;
            te[4] = de * b - cf;
            te[8] = a * d;
            te[1] = a * f;
            te[5] = a * e;
            te[9] = -b;
            te[2] = cf * b - de;
            te[6] = df + ce * b;
            te[10] = a * c;
        } else if (euler.order === 'ZXY') {
            var ce = c * e, cf = c * f, de = d * e, df = d * f;
            te[0] = ce - df * b;
            te[4] = -a * f;
            te[8] = de + cf * b;
            te[1] = cf + de * b;
            te[5] = a * e;
            te[9] = df - ce * b;
            te[2] = -a * d;
            te[6] = b;
            te[10] = a * c;
        } else if (euler.order === 'ZYX') {
            var ae = a * e, af = a * f, be = b * e, bf = b * f;
            te[0] = c * e;
            te[4] = be * d - af;
            te[8] = ae * d + bf;
            te[1] = c * f;
            te[5] = bf * d + ae;
            te[9] = af * d - be;
            te[2] = -d;
            te[6] = b * c;
            te[10] = a * c;
        } else if (euler.order === 'YZX') {
            var ac = a * c, ad = a * d, bc = b * c, bd = b * d;
            te[0] = c * e;
            te[4] = bd - ac * f;
            te[8] = bc * f + ad;
            te[1] = f;
            te[5] = a * e;
            te[9] = -b * e;
            te[2] = -d * e;
            te[6] = ad * f + bc;
            te[10] = ac - bd * f;
        } else if (euler.order === 'XZY') {
            var ac = a * c, ad = a * d, bc = b * c, bd = b * d;
            te[0] = c * e;
            te[4] = -f;
            te[8] = d * e;
            te[1] = ac * f + bd;
            te[5] = a * e;
            te[9] = ad * f - bc;
            te[2] = bc * f - ad;
            te[6] = b * e;
            te[10] = bd * f + ac;
        }
        te[3] = 0;
        te[7] = 0;
        te[11] = 0;
        te[12] = 0;
        te[13] = 0;
        te[14] = 0;
        te[15] = 1;
        return this;
    },
    makeRotationFromQuaternion: function (q) {
        var te = this.elements;
        var x = q.x, y = q.y, z = q.z, w = q.w;
        var x2 = x + x, y2 = y + y, z2 = z + z;
        var xx = x * x2, xy = x * y2, xz = x * z2;
        var yy = y * y2, yz = y * z2, zz = z * z2;
        var wx = w * x2, wy = w * y2, wz = w * z2;
        te[0] = 1 - (yy + zz);
        te[4] = xy - wz;
        te[8] = xz + wy;
        te[1] = xy + wz;
        te[5] = 1 - (xx + zz);
        te[9] = yz - wx;
        te[2] = xz - wy;
        te[6] = yz + wx;
        te[10] = 1 - (xx + yy);
        te[3] = 0;
        te[7] = 0;
        te[11] = 0;
        te[12] = 0;
        te[13] = 0;
        te[14] = 0;
        te[15] = 1;
        return this;
    },
    lookAt: function () {
        var x, y, z;
        return function lookAt(eye, target, up) {
            if (x === undefined) {
                x = new Vector3();
                y = new Vector3();
                z = new Vector3();
            }
            var te = this.elements;
            z.subVectors(eye, target).normalize();
            if (z.lengthSq() === 0) {
                z.z = 1;
            }
            x.crossVectors(up, z).normalize();
            if (x.lengthSq() === 0) {
                z.z += 0.0001;
                x.crossVectors(up, z).normalize();
            }
            y.crossVectors(z, x);
            te[0] = x.x;
            te[4] = y.x;
            te[8] = z.x;
            te[1] = x.y;
            te[5] = y.y;
            te[9] = z.y;
            te[2] = x.z;
            te[6] = y.z;
            te[10] = z.z;
            return this;
        };
    }(),
    multiply: function (m, n) {
        if (n !== undefined) {
            console.warn('THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.');
            return this.multiplyMatrices(m, n);
        }
        return this.multiplyMatrices(this, m);
    },
    premultiply: function (m) {
        return this.multiplyMatrices(m, this);
    },
    multiplyMatrices: function (a, b) {
        var ae = a.elements;
        var be = b.elements;
        var te = this.elements;
        var a11 = ae[0], a12 = ae[4], a13 = ae[8], a14 = ae[12];
        var a21 = ae[1], a22 = ae[5], a23 = ae[9], a24 = ae[13];
        var a31 = ae[2], a32 = ae[6], a33 = ae[10], a34 = ae[14];
        var a41 = ae[3], a42 = ae[7], a43 = ae[11], a44 = ae[15];
        var b11 = be[0], b12 = be[4], b13 = be[8], b14 = be[12];
        var b21 = be[1], b22 = be[5], b23 = be[9], b24 = be[13];
        var b31 = be[2], b32 = be[6], b33 = be[10], b34 = be[14];
        var b41 = be[3], b42 = be[7], b43 = be[11], b44 = be[15];
        te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
        te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
        te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
        te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
        te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
        te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
        te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
        te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
        te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
        te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
        te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
        te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
        te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
        te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
        te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
        te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
        return this;
    },
    multiplyToArray: function (a, b, r) {
        var te = this.elements;
        this.multiplyMatrices(a, b);
        r[0] = te[0];
        r[1] = te[1];
        r[2] = te[2];
        r[3] = te[3];
        r[4] = te[4];
        r[5] = te[5];
        r[6] = te[6];
        r[7] = te[7];
        r[8] = te[8];
        r[9] = te[9];
        r[10] = te[10];
        r[11] = te[11];
        r[12] = te[12];
        r[13] = te[13];
        r[14] = te[14];
        r[15] = te[15];
        return this;
    },
    multiplyScalar: function (s) {
        var te = this.elements;
        te[0] *= s;
        te[4] *= s;
        te[8] *= s;
        te[12] *= s;
        te[1] *= s;
        te[5] *= s;
        te[9] *= s;
        te[13] *= s;
        te[2] *= s;
        te[6] *= s;
        te[10] *= s;
        te[14] *= s;
        te[3] *= s;
        te[7] *= s;
        te[11] *= s;
        te[15] *= s;
        return this;
    },
    applyToVector3Array: function () {
        var v1;
        return function applyToVector3Array(array, offset, length) {
            if (v1 === undefined)
                v1 = new Vector3();
            if (offset === undefined)
                offset = 0;
            if (length === undefined)
                length = array.length;
            for (var i = 0, j = offset; i < length; i += 3, j += 3) {
                v1.fromArray(array, j);
                v1.applyMatrix4(this);
                v1.toArray(array, j);
            }
            return array;
        };
    }(),
    applyToBuffer: function () {
        var v1;
        return function applyToBuffer(buffer, offset, length) {
            if (v1 === undefined)
                v1 = new Vector3();
            if (offset === undefined)
                offset = 0;
            if (length === undefined)
                length = buffer.length / buffer.itemSize;
            for (var i = 0, j = offset; i < length; i++, j++) {
                v1.x = buffer.getX(j);
                v1.y = buffer.getY(j);
                v1.z = buffer.getZ(j);
                v1.applyMatrix4(this);
                buffer.setXYZ(v1.x, v1.y, v1.z);
            }
            return buffer;
        };
    }(),
    determinant: function () {
        var te = this.elements;
        var n11 = te[0], n12 = te[4], n13 = te[8], n14 = te[12];
        var n21 = te[1], n22 = te[5], n23 = te[9], n24 = te[13];
        var n31 = te[2], n32 = te[6], n33 = te[10], n34 = te[14];
        var n41 = te[3], n42 = te[7], n43 = te[11], n44 = te[15];
        return n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31);
    },
    transpose: function () {
        var te = this.elements;
        var tmp;
        tmp = te[1];
        te[1] = te[4];
        te[4] = tmp;
        tmp = te[2];
        te[2] = te[8];
        te[8] = tmp;
        tmp = te[6];
        te[6] = te[9];
        te[9] = tmp;
        tmp = te[3];
        te[3] = te[12];
        te[12] = tmp;
        tmp = te[7];
        te[7] = te[13];
        te[13] = tmp;
        tmp = te[11];
        te[11] = te[14];
        te[14] = tmp;
        return this;
    },
    flattenToArrayOffset: function (array, offset) {
        console.warn('THREE.Matrix3: .flattenToArrayOffset is deprecated ' + '- just use .toArray instead.');
        return this.toArray(array, offset);
    },
    getPosition: function () {
        var v1;
        return function getPosition() {
            if (v1 === undefined)
                v1 = new Vector3();
            console.warn('THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.');
            return v1.setFromMatrixColumn(this, 3);
        };
    }(),
    setPosition: function (v) {
        var te = this.elements;
        te[12] = v.x;
        te[13] = v.y;
        te[14] = v.z;
        return this;
    },
    getInverse: function (m, throwOnDegenerate) {
        var te = this.elements, me = m.elements, n11 = me[0], n21 = me[1], n31 = me[2], n41 = me[3], n12 = me[4], n22 = me[5], n32 = me[6], n42 = me[7], n13 = me[8], n23 = me[9], n33 = me[10], n43 = me[11], n14 = me[12], n24 = me[13], n34 = me[14], n44 = me[15], t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44, t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44, t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44, t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
        var det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
        if (det === 0) {
            var msg = 'THREE.Matrix4.getInverse(): can\'t invert matrix, determinant is 0';
            if (throwOnDegenerate === true) {
                throw new Error(msg);
            } else {
                console.warn(msg);
            }
            return this.identity();
        }
        var detInv = 1 / det;
        te[0] = t11 * detInv;
        te[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;
        te[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;
        te[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;
        te[4] = t12 * detInv;
        te[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;
        te[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;
        te[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;
        te[8] = t13 * detInv;
        te[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;
        te[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;
        te[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;
        te[12] = t14 * detInv;
        te[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;
        te[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;
        te[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;
        return this;
    },
    scale: function (v) {
        var te = this.elements;
        var x = v.x, y = v.y, z = v.z;
        te[0] *= x;
        te[4] *= y;
        te[8] *= z;
        te[1] *= x;
        te[5] *= y;
        te[9] *= z;
        te[2] *= x;
        te[6] *= y;
        te[10] *= z;
        te[3] *= x;
        te[7] *= y;
        te[11] *= z;
        return this;
    },
    getMaxScaleOnAxis: function () {
        var te = this.elements;
        var scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];
        var scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];
        var scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];
        return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
    },
    makeTranslation: function (x, y, z) {
        this.set(1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z, 0, 0, 0, 1);
        return this;
    },
    makeRotationX: function (theta) {
        var c = Math.cos(theta), s = Math.sin(theta);
        this.set(1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1);
        return this;
    },
    makeRotationY: function (theta) {
        var c = Math.cos(theta), s = Math.sin(theta);
        this.set(c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1);
        return this;
    },
    makeRotationZ: function (theta) {
        var c = Math.cos(theta), s = Math.sin(theta);
        this.set(c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
        return this;
    },
    makeRotationAxis: function (axis, angle) {
        var c = Math.cos(angle);
        var s = Math.sin(angle);
        var t = 1 - c;
        var x = axis.x, y = axis.y, z = axis.z;
        var tx = t * x, ty = t * y;
        this.set(tx * x + c, tx * y - s * z, tx * z + s * y, 0, tx * y + s * z, ty * y + c, ty * z - s * x, 0, tx * z - s * y, ty * z + s * x, t * z * z + c, 0, 0, 0, 0, 1);
        return this;
    },
    makeScale: function (x, y, z) {
        this.set(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1);
        return this;
    },
    compose: function (position, quaternion, scale) {
        this.makeRotationFromQuaternion(quaternion);
        this.scale(scale);
        this.setPosition(position);
        return this;
    },
    decompose: function () {
        var vector, matrix;
        return function decompose(position, quaternion, scale) {
            if (vector === undefined) {
                vector = new Vector3();
                matrix = new Matrix4();
            }
            var te = this.elements;
            var sx = vector.set(te[0], te[1], te[2]).length();
            var sy = vector.set(te[4], te[5], te[6]).length();
            var sz = vector.set(te[8], te[9], te[10]).length();
            var det = this.determinant();
            if (det < 0) {
                sx = -sx;
            }
            position.x = te[12];
            position.y = te[13];
            position.z = te[14];
            matrix.elements.set(this.elements);
            var invSX = 1 / sx;
            var invSY = 1 / sy;
            var invSZ = 1 / sz;
            matrix.elements[0] *= invSX;
            matrix.elements[1] *= invSX;
            matrix.elements[2] *= invSX;
            matrix.elements[4] *= invSY;
            matrix.elements[5] *= invSY;
            matrix.elements[6] *= invSY;
            matrix.elements[8] *= invSZ;
            matrix.elements[9] *= invSZ;
            matrix.elements[10] *= invSZ;
            quaternion.setFromRotationMatrix(matrix);
            scale.x = sx;
            scale.y = sy;
            scale.z = sz;
            return this;
        };
    }(),
    makeFrustum: function (left, right, bottom, top, near, far) {
        var te = this.elements;
        var x = 2 * near / (right - left);
        var y = 2 * near / (top - bottom);
        var a = (right + left) / (right - left);
        var b = (top + bottom) / (top - bottom);
        var c = -(far + near) / (far - near);
        var d = -2 * far * near / (far - near);
        te[0] = x;
        te[4] = 0;
        te[8] = a;
        te[12] = 0;
        te[1] = 0;
        te[5] = y;
        te[9] = b;
        te[13] = 0;
        te[2] = 0;
        te[6] = 0;
        te[10] = c;
        te[14] = d;
        te[3] = 0;
        te[7] = 0;
        te[11] = -1;
        te[15] = 0;
        return this;
    },
    makePerspective: function (fov, aspect, near, far) {
        var ymax = near * Math.tan(exports.Math.DEG2RAD * fov * 0.5);
        var ymin = -ymax;
        var xmin = ymin * aspect;
        var xmax = ymax * aspect;
        return this.makeFrustum(xmin, xmax, ymin, ymax, near, far);
    },
    makeOrthographic: function (left, right, top, bottom, near, far) {
        var te = this.elements;
        var w = 1 / (right - left);
        var h = 1 / (top - bottom);
        var p = 1 / (far - near);
        var x = (right + left) * w;
        var y = (top + bottom) * h;
        var z = (far + near) * p;
        te[0] = 2 * w;
        te[4] = 0;
        te[8] = 0;
        te[12] = -x;
        te[1] = 0;
        te[5] = 2 * h;
        te[9] = 0;
        te[13] = -y;
        te[2] = 0;
        te[6] = 0;
        te[10] = -2 * p;
        te[14] = -z;
        te[3] = 0;
        te[7] = 0;
        te[11] = 0;
        te[15] = 1;
        return this;
    },
    equals: function (matrix) {
        var te = this.elements;
        var me = matrix.elements;
        for (var i = 0; i < 16; i++) {
            if (te[i] !== me[i])
                return false;
        }
        return true;
    },
    fromArray: function (array) {
        this.elements.set(array);
        return this;
    },
    toArray: function (array, offset) {
        if (array === undefined)
            array = [];
        if (offset === undefined)
            offset = 0;
        var te = this.elements;
        array[offset] = te[0];
        array[offset + 1] = te[1];
        array[offset + 2] = te[2];
        array[offset + 3] = te[3];
        array[offset + 4] = te[4];
        array[offset + 5] = te[5];
        array[offset + 6] = te[6];
        array[offset + 7] = te[7];
        array[offset + 8] = te[8];
        array[offset + 9] = te[9];
        array[offset + 10] = te[10];
        array[offset + 11] = te[11];
        array[offset + 12] = te[12];
        array[offset + 13] = te[13];
        array[offset + 14] = te[14];
        array[offset + 15] = te[15];
        return array;
    }
};
Quaternion.prototype = {
    constructor: Quaternion,
    get x() {
        return this._x;
    },
    set x(value) {
        this._x = value;
        this.onChangeCallback();
    },
    get y() {
        return this._y;
    },
    set y(value) {
        this._y = value;
        this.onChangeCallback();
    },
    get z() {
        return this._z;
    },
    set z(value) {
        this._z = value;
        this.onChangeCallback();
    },
    get w() {
        return this._w;
    },
    set w(value) {
        this._w = value;
        this.onChangeCallback();
    },
    set: function (x, y, z, w) {
        this._x = x;
        this._y = y;
        this._z = z;
        this._w = w;
        this.onChangeCallback();
        return this;
    },
    clone: function () {
        return new this.constructor(this._x, this._y, this._z, this._w);
    },
    copy: function (quaternion) {
        this._x = quaternion.x;
        this._y = quaternion.y;
        this._z = quaternion.z;
        this._w = quaternion.w;
        this.onChangeCallback();
        return this;
    },
    setFromEuler: function (euler, update) {
        if ((euler && euler.isEuler) === false) {
            throw new Error('THREE.Quaternion: .setFromEuler() now expects a Euler rotation rather than a Vector3 and order.');
        }
        var c1 = Math.cos(euler._x / 2);
        var c2 = Math.cos(euler._y / 2);
        var c3 = Math.cos(euler._z / 2);
        var s1 = Math.sin(euler._x / 2);
        var s2 = Math.sin(euler._y / 2);
        var s3 = Math.sin(euler._z / 2);
        var order = euler.order;
        if (order === 'XYZ') {
            this._x = s1 * c2 * c3 + c1 * s2 * s3;
            this._y = c1 * s2 * c3 - s1 * c2 * s3;
            this._z = c1 * c2 * s3 + s1 * s2 * c3;
            this._w = c1 * c2 * c3 - s1 * s2 * s3;
        } else if (order === 'YXZ') {
            this._x = s1 * c2 * c3 + c1 * s2 * s3;
            this._y = c1 * s2 * c3 - s1 * c2 * s3;
            this._z = c1 * c2 * s3 - s1 * s2 * c3;
            this._w = c1 * c2 * c3 + s1 * s2 * s3;
        } else if (order === 'ZXY') {
            this._x = s1 * c2 * c3 - c1 * s2 * s3;
            this._y = c1 * s2 * c3 + s1 * c2 * s3;
            this._z = c1 * c2 * s3 + s1 * s2 * c3;
            this._w = c1 * c2 * c3 - s1 * s2 * s3;
        } else if (order === 'ZYX') {
            this._x = s1 * c2 * c3 - c1 * s2 * s3;
            this._y = c1 * s2 * c3 + s1 * c2 * s3;
            this._z = c1 * c2 * s3 - s1 * s2 * c3;
            this._w = c1 * c2 * c3 + s1 * s2 * s3;
        } else if (order === 'YZX') {
            this._x = s1 * c2 * c3 + c1 * s2 * s3;
            this._y = c1 * s2 * c3 + s1 * c2 * s3;
            this._z = c1 * c2 * s3 - s1 * s2 * c3;
            this._w = c1 * c2 * c3 - s1 * s2 * s3;
        } else if (order === 'XZY') {
            this._x = s1 * c2 * c3 - c1 * s2 * s3;
            this._y = c1 * s2 * c3 - s1 * c2 * s3;
            this._z = c1 * c2 * s3 + s1 * s2 * c3;
            this._w = c1 * c2 * c3 + s1 * s2 * s3;
        }
        if (update !== false)
            this.onChangeCallback();
        return this;
    },
    setFromAxisAngle: function (axis, angle) {
        var halfAngle = angle / 2, s = Math.sin(halfAngle);
        this._x = axis.x * s;
        this._y = axis.y * s;
        this._z = axis.z * s;
        this._w = Math.cos(halfAngle);
        this.onChangeCallback();
        return this;
    },
    setFromRotationMatrix: function (m) {
        var te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10], trace = m11 + m22 + m33, s;
        if (trace > 0) {
            s = 0.5 / Math.sqrt(trace + 1);
            this._w = 0.25 / s;
            this._x = (m32 - m23) * s;
            this._y = (m13 - m31) * s;
            this._z = (m21 - m12) * s;
        } else if (m11 > m22 && m11 > m33) {
            s = 2 * Math.sqrt(1 + m11 - m22 - m33);
            this._w = (m32 - m23) / s;
            this._x = 0.25 * s;
            this._y = (m12 + m21) / s;
            this._z = (m13 + m31) / s;
        } else if (m22 > m33) {
            s = 2 * Math.sqrt(1 + m22 - m11 - m33);
            this._w = (m13 - m31) / s;
            this._x = (m12 + m21) / s;
            this._y = 0.25 * s;
            this._z = (m23 + m32) / s;
        } else {
            s = 2 * Math.sqrt(1 + m33 - m11 - m22);
            this._w = (m21 - m12) / s;
            this._x = (m13 + m31) / s;
            this._y = (m23 + m32) / s;
            this._z = 0.25 * s;
        }
        this.onChangeCallback();
        return this;
    },
    setFromUnitVectors: function () {
        var v1, r;
        var EPS = 0.000001;
        return function setFromUnitVectors(vFrom, vTo) {
            if (v1 === undefined)
                v1 = new Vector3();
            r = vFrom.dot(vTo) + 1;
            if (r < EPS) {
                r = 0;
                if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {
                    v1.set(-vFrom.y, vFrom.x, 0);
                } else {
                    v1.set(0, -vFrom.z, vFrom.y);
                }
            } else {
                v1.crossVectors(vFrom, vTo);
            }
            this._x = v1.x;
            this._y = v1.y;
            this._z = v1.z;
            this._w = r;
            return this.normalize();
        };
    }(),
    inverse: function () {
        return this.conjugate().normalize();
    },
    conjugate: function () {
        this._x *= -1;
        this._y *= -1;
        this._z *= -1;
        this.onChangeCallback();
        return this;
    },
    dot: function (v) {
        return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;
    },
    lengthSq: function () {
        return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
    },
    length: function () {
        return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
    },
    normalize: function () {
        var l = this.length();
        if (l === 0) {
            this._x = 0;
            this._y = 0;
            this._z = 0;
            this._w = 1;
        } else {
            l = 1 / l;
            this._x = this._x * l;
            this._y = this._y * l;
            this._z = this._z * l;
            this._w = this._w * l;
        }
        this.onChangeCallback();
        return this;
    },
    multiply: function (q, p) {
        if (p !== undefined) {
            console.warn('THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.');
            return this.multiplyQuaternions(q, p);
        }
        return this.multiplyQuaternions(this, q);
    },
    premultiply: function (q) {
        return this.multiplyQuaternions(q, this);
    },
    multiplyQuaternions: function (a, b) {
        var qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
        var qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;
        this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
        this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
        this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
        this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
        this.onChangeCallback();
        return this;
    },
    slerp: function (qb, t) {
        if (t === 0)
            return this;
        if (t === 1)
            return this.copy(qb);
        var x = this._x, y = this._y, z = this._z, w = this._w;
        var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;
        if (cosHalfTheta < 0) {
            this._w = -qb._w;
            this._x = -qb._x;
            this._y = -qb._y;
            this._z = -qb._z;
            cosHalfTheta = -cosHalfTheta;
        } else {
            this.copy(qb);
        }
        if (cosHalfTheta >= 1) {
            this._w = w;
            this._x = x;
            this._y = y;
            this._z = z;
            return this;
        }
        var sinHalfTheta = Math.sqrt(1 - cosHalfTheta * cosHalfTheta);
        if (Math.abs(sinHalfTheta) < 0.001) {
            this._w = 0.5 * (w + this._w);
            this._x = 0.5 * (x + this._x);
            this._y = 0.5 * (y + this._y);
            this._z = 0.5 * (z + this._z);
            return this;
        }
        var halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
        var ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta, ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
        this._w = w * ratioA + this._w * ratioB;
        this._x = x * ratioA + this._x * ratioB;
        this._y = y * ratioA + this._y * ratioB;
        this._z = z * ratioA + this._z * ratioB;
        this.onChangeCallback();
        return this;
    },
    equals: function (quaternion) {
        return quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w;
    },
    fromArray: function (array, offset) {
        if (offset === undefined)
            offset = 0;
        this._x = array[offset];
        this._y = array[offset + 1];
        this._z = array[offset + 2];
        this._w = array[offset + 3];
        this.onChangeCallback();
        return this;
    },
    toArray: function (array, offset) {
        if (array === undefined)
            array = [];
        if (offset === undefined)
            offset = 0;
        array[offset] = this._x;
        array[offset + 1] = this._y;
        array[offset + 2] = this._z;
        array[offset + 3] = this._w;
        return array;
    },
    onChange: function (callback) {
        this.onChangeCallback = callback;
        return this;
    },
    onChangeCallback: function () {
    }
};
Object.assign(Quaternion, {
    slerp: function (qa, qb, qm, t) {
        return qm.copy(qa).slerp(qb, t);
    },
    slerpFlat: function (dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) {
        var x0 = src0[srcOffset0 + 0], y0 = src0[srcOffset0 + 1], z0 = src0[srcOffset0 + 2], w0 = src0[srcOffset0 + 3], x1 = src1[srcOffset1 + 0], y1 = src1[srcOffset1 + 1], z1 = src1[srcOffset1 + 2], w1 = src1[srcOffset1 + 3];
        if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {
            var s = 1 - t, cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1, dir = cos >= 0 ? 1 : -1, sqrSin = 1 - cos * cos;
            if (sqrSin > Number.EPSILON) {
                var sin = Math.sqrt(sqrSin), len = Math.atan2(sin, cos * dir);
                s = Math.sin(s * len) / sin;
                t = Math.sin(t * len) / sin;
            }
            var tDir = t * dir;
            x0 = x0 * s + x1 * tDir;
            y0 = y0 * s + y1 * tDir;
            z0 = z0 * s + z1 * tDir;
            w0 = w0 * s + w1 * tDir;
            if (s === 1 - t) {
                var f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);
                x0 *= f;
                y0 *= f;
                z0 *= f;
                w0 *= f;
            }
        }
        dst[dstOffset] = x0;
        dst[dstOffset + 1] = y0;
        dst[dstOffset + 2] = z0;
        dst[dstOffset + 3] = w0;
    }
});
Vector3.prototype = {
    constructor: Vector3,
    isVector3: true,
    set: function (x, y, z) {
        this.x = x;
        this.y = y;
        this.z = z;
        return this;
    },
    setScalar: function (scalar) {
        this.x = scalar;
        this.y = scalar;
        this.z = scalar;
        return this;
    },
    setX: function (x) {
        this.x = x;
        return this;
    },
    setY: function (y) {
        this.y = y;
        return this;
    },
    setZ: function (z) {
        this.z = z;
        return this;
    },
    setComponent: function (index, value) {
        switch (index) {
        case 0:
            this.x = value;
            break;
        case 1:
            this.y = value;
            break;
        case 2:
            this.z = value;
            break;
        default:
            throw new Error('index is out of range: ' + index);
        }
    },
    getComponent: function (index) {
        switch (index) {
        case 0:
            return this.x;
        case 1:
            return this.y;
        case 2:
            return this.z;
        default:
            throw new Error('index is out of range: ' + index);
        }
    },
    clone: function () {
        return new this.constructor(this.x, this.y, this.z);
    },
    copy: function (v) {
        this.x = v.x;
        this.y = v.y;
        this.z = v.z;
        return this;
    },
    add: function (v, w) {
        if (w !== undefined) {
            console.warn('THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');
            return this.addVectors(v, w);
        }
        this.x += v.x;
        this.y += v.y;
        this.z += v.z;
        return this;
    },
    addScalar: function (s) {
        this.x += s;
        this.y += s;
        this.z += s;
        return this;
    },
    addVectors: function (a, b) {
        this.x = a.x + b.x;
        this.y = a.y + b.y;
        this.z = a.z + b.z;
        return this;
    },
    addScaledVector: function (v, s) {
        this.x += v.x * s;
        this.y += v.y * s;
        this.z += v.z * s;
        return this;
    },
    sub: function (v, w) {
        if (w !== undefined) {
            console.warn('THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');
            return this.subVectors(v, w);
        }
        this.x -= v.x;
        this.y -= v.y;
        this.z -= v.z;
        return this;
    },
    subScalar: function (s) {
        this.x -= s;
        this.y -= s;
        this.z -= s;
        return this;
    },
    subVectors: function (a, b) {
        this.x = a.x - b.x;
        this.y = a.y - b.y;
        this.z = a.z - b.z;
        return this;
    },
    multiply: function (v, w) {
        if (w !== undefined) {
            console.warn('THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.');
            return this.multiplyVectors(v, w);
        }
        this.x *= v.x;
        this.y *= v.y;
        this.z *= v.z;
        return this;
    },
    multiplyScalar: function (scalar) {
        if (isFinite(scalar)) {
            this.x *= scalar;
            this.y *= scalar;
            this.z *= scalar;
        } else {
            this.x = 0;
            this.y = 0;
            this.z = 0;
        }
        return this;
    },
    multiplyVectors: function (a, b) {
        this.x = a.x * b.x;
        this.y = a.y * b.y;
        this.z = a.z * b.z;
        return this;
    },
    applyEuler: function () {
        var quaternion;
        return function applyEuler(euler) {
            if ((euler && euler.isEuler) === false) {
                console.error('THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.');
            }
            if (quaternion === undefined)
                quaternion = new Quaternion();
            return this.applyQuaternion(quaternion.setFromEuler(euler));
        };
    }(),
    applyAxisAngle: function () {
        var quaternion;
        return function applyAxisAngle(axis, angle) {
            if (quaternion === undefined)
                quaternion = new Quaternion();
            return this.applyQuaternion(quaternion.setFromAxisAngle(axis, angle));
        };
    }(),
    applyMatrix3: function (m) {
        var x = this.x, y = this.y, z = this.z;
        var e = m.elements;
        this.x = e[0] * x + e[3] * y + e[6] * z;
        this.y = e[1] * x + e[4] * y + e[7] * z;
        this.z = e[2] * x + e[5] * y + e[8] * z;
        return this;
    },
    applyMatrix4: function (m) {
        var x = this.x, y = this.y, z = this.z;
        var e = m.elements;
        this.x = e[0] * x + e[4] * y + e[8] * z + e[12];
        this.y = e[1] * x + e[5] * y + e[9] * z + e[13];
        this.z = e[2] * x + e[6] * y + e[10] * z + e[14];
        return this;
    },
    applyProjection: function (m) {
        var x = this.x, y = this.y, z = this.z;
        var e = m.elements;
        var d = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);
        this.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * d;
        this.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * d;
        this.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * d;
        return this;
    },
    applyQuaternion: function (q) {
        var x = this.x, y = this.y, z = this.z;
        var qx = q.x, qy = q.y, qz = q.z, qw = q.w;
        var ix = qw * x + qy * z - qz * y;
        var iy = qw * y + qz * x - qx * z;
        var iz = qw * z + qx * y - qy * x;
        var iw = -qx * x - qy * y - qz * z;
        this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
        this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
        this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
        return this;
    },
    project: function () {
        var matrix;
        return function project(camera) {
            if (matrix === undefined)
                matrix = new Matrix4();
            matrix.multiplyMatrices(camera.projectionMatrix, matrix.getInverse(camera.matrixWorld));
            return this.applyProjection(matrix);
        };
    }(),
    unproject: function () {
        var matrix;
        return function unproject(camera) {
            if (matrix === undefined)
                matrix = new Matrix4();
            matrix.multiplyMatrices(camera.matrixWorld, matrix.getInverse(camera.projectionMatrix));
            return this.applyProjection(matrix);
        };
    }(),
    transformDirection: function (m) {
        var x = this.x, y = this.y, z = this.z;
        var e = m.elements;
        this.x = e[0] * x + e[4] * y + e[8] * z;
        this.y = e[1] * x + e[5] * y + e[9] * z;
        this.z = e[2] * x + e[6] * y + e[10] * z;
        return this.normalize();
    },
    divide: function (v) {
        this.x /= v.x;
        this.y /= v.y;
        this.z /= v.z;
        return this;
    },
    divideScalar: function (scalar) {
        return this.multiplyScalar(1 / scalar);
    },
    min: function (v) {
        this.x = Math.min(this.x, v.x);
        this.y = Math.min(this.y, v.y);
        this.z = Math.min(this.z, v.z);
        return this;
    },
    max: function (v) {
        this.x = Math.max(this.x, v.x);
        this.y = Math.max(this.y, v.y);
        this.z = Math.max(this.z, v.z);
        return this;
    },
    clamp: function (min, max) {
        this.x = Math.max(min.x, Math.min(max.x, this.x));
        this.y = Math.max(min.y, Math.min(max.y, this.y));
        this.z = Math.max(min.z, Math.min(max.z, this.z));
        return this;
    },
    clampScalar: function () {
        var min, max;
        return function clampScalar(minVal, maxVal) {
            if (min === undefined) {
                min = new Vector3();
                max = new Vector3();
            }
            min.set(minVal, minVal, minVal);
            max.set(maxVal, maxVal, maxVal);
            return this.clamp(min, max);
        };
    }(),
    clampLength: function (min, max) {
        var length = this.length();
        return this.multiplyScalar(Math.max(min, Math.min(max, length)) / length);
    },
    floor: function () {
        this.x = Math.floor(this.x);
        this.y = Math.floor(this.y);
        this.z = Math.floor(this.z);
        return this;
    },
    ceil: function () {
        this.x = Math.ceil(this.x);
        this.y = Math.ceil(this.y);
        this.z = Math.ceil(this.z);
        return this;
    },
    round: function () {
        this.x = Math.round(this.x);
        this.y = Math.round(this.y);
        this.z = Math.round(this.z);
        return this;
    },
    roundToZero: function () {
        this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
        this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
        this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
        return this;
    },
    negate: function () {
        this.x = -this.x;
        this.y = -this.y;
        this.z = -this.z;
        return this;
    },
    dot: function (v) {
        return this.x * v.x + this.y * v.y + this.z * v.z;
    },
    lengthSq: function () {
        return this.x * this.x + this.y * this.y + this.z * this.z;
    },
    length: function () {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
    },
    lengthManhattan: function () {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
    },
    normalize: function () {
        return this.divideScalar(this.length());
    },
    setLength: function (length) {
        return this.multiplyScalar(length / this.length());
    },
    lerp: function (v, alpha) {
        this.x += (v.x - this.x) * alpha;
        this.y += (v.y - this.y) * alpha;
        this.z += (v.z - this.z) * alpha;
        return this;
    },
    lerpVectors: function (v1, v2, alpha) {
        return this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);
    },
    cross: function (v, w) {
        if (w !== undefined) {
            console.warn('THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.');
            return this.crossVectors(v, w);
        }
        var x = this.x, y = this.y, z = this.z;
        this.x = y * v.z - z * v.y;
        this.y = z * v.x - x * v.z;
        this.z = x * v.y - y * v.x;
        return this;
    },
    crossVectors: function (a, b) {
        var ax = a.x, ay = a.y, az = a.z;
        var bx = b.x, by = b.y, bz = b.z;
        this.x = ay * bz - az * by;
        this.y = az * bx - ax * bz;
        this.z = ax * by - ay * bx;
        return this;
    },
    projectOnVector: function (vector) {
        var scalar = vector.dot(this) / vector.lengthSq();
        return this.copy(vector).multiplyScalar(scalar);
    },
    projectOnPlane: function () {
        var v1;
        return function projectOnPlane(planeNormal) {
            if (v1 === undefined)
                v1 = new Vector3();
            v1.copy(this).projectOnVector(planeNormal);
            return this.sub(v1);
        };
    }(),
    reflect: function () {
        var v1;
        return function reflect(normal) {
            if (v1 === undefined)
                v1 = new Vector3();
            return this.sub(v1.copy(normal).multiplyScalar(2 * this.dot(normal)));
        };
    }(),
    angleTo: function (v) {
        var theta = this.dot(v) / Math.sqrt(this.lengthSq() * v.lengthSq());
        return Math.acos(exports.Math.clamp(theta, -1, 1));
    },
    distanceTo: function (v) {
        return Math.sqrt(this.distanceToSquared(v));
    },
    distanceToSquared: function (v) {
        var dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;
        return dx * dx + dy * dy + dz * dz;
    },
    distanceToManhattan: function (v) {
        return Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z);
    },
    setFromSpherical: function (s) {
        var sinPhiRadius = Math.sin(s.phi) * s.radius;
        this.x = sinPhiRadius * Math.sin(s.theta);
        this.y = Math.cos(s.phi) * s.radius;
        this.z = sinPhiRadius * Math.cos(s.theta);
        return this;
    },
    setFromMatrixPosition: function (m) {
        return this.setFromMatrixColumn(m, 3);
    },
    setFromMatrixScale: function (m) {
        var sx = this.setFromMatrixColumn(m, 0).length();
        var sy = this.setFromMatrixColumn(m, 1).length();
        var sz = this.setFromMatrixColumn(m, 2).length();
        this.x = sx;
        this.y = sy;
        this.z = sz;
        return this;
    },
    setFromMatrixColumn: function (m, index) {
        if (typeof m === 'number') {
            console.warn('THREE.Vector3: setFromMatrixColumn now expects ( matrix, index ).');
            var temp = m;
            m = index;
            index = temp;
        }
        return this.fromArray(m.elements, index * 4);
    },
    equals: function (v) {
        return v.x === this.x && v.y === this.y && v.z === this.z;
    },
    fromArray: function (array, offset) {
        if (offset === undefined)
            offset = 0;
        this.x = array[offset];
        this.y = array[offset + 1];
        this.z = array[offset + 2];
        return this;
    },
    toArray: function (array, offset) {
        if (array === undefined)
            array = [];
        if (offset === undefined)
            offset = 0;
        array[offset] = this.x;
        array[offset + 1] = this.y;
        array[offset + 2] = this.z;
        return array;
    },
    fromAttribute: function (attribute, index, offset) {
        if (offset === undefined)
            offset = 0;
        index = index * attribute.itemSize + offset;
        this.x = attribute.array[index];
        this.y = attribute.array[index + 1];
        this.z = attribute.array[index + 2];
        return this;
    }
};
Box2.prototype = {
    constructor: Box2,
    set: function (min, max) {
        this.min.copy(min);
        this.max.copy(max);
        return this;
    },
    setFromPoints: function (points) {
        this.makeEmpty();
        for (var i = 0, il = points.length; i < il; i++) {
            this.expandByPoint(points[i]);
        }
        return this;
    },
    setFromCenterAndSize: function () {
        var v1 = new Vector2();
        return function setFromCenterAndSize(center, size) {
            var halfSize = v1.copy(size).multiplyScalar(0.5);
            this.min.copy(center).sub(halfSize);
            this.max.copy(center).add(halfSize);
            return this;
        };
    }(),
    clone: function () {
        return new this.constructor().copy(this);
    },
    copy: function (box) {
        this.min.copy(box.min);
        this.max.copy(box.max);
        return this;
    },
    makeEmpty: function () {
        this.min.x = this.min.y = +Infinity;
        this.max.x = this.max.y = -Infinity;
        return this;
    },
    isEmpty: function () {
        return this.max.x < this.min.x || this.max.y < this.min.y;
    },
    center: function (optionalTarget) {
        var result = optionalTarget || new Vector2();
        return result.addVectors(this.min, this.max).multiplyScalar(0.5);
    },
    size: function (optionalTarget) {
        var result = optionalTarget || new Vector2();
        return result.subVectors(this.max, this.min);
    },
    expandByPoint: function (point) {
        this.min.min(point);
        this.max.max(point);
        return this;
    },
    expandByVector: function (vector) {
        this.min.sub(vector);
        this.max.add(vector);
        return this;
    },
    expandByScalar: function (scalar) {
        this.min.addScalar(-scalar);
        this.max.addScalar(scalar);
        return this;
    },
    containsPoint: function (point) {
        if (point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y) {
            return false;
        }
        return true;
    },
    containsBox: function (box) {
        if (this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y) {
            return true;
        }
        return false;
    },
    getParameter: function (point, optionalTarget) {
        var result = optionalTarget || new Vector2();
        return result.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y));
    },
    intersectsBox: function (box) {
        if (box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y) {
            return false;
        }
        return true;
    },
    clampPoint: function (point, optionalTarget) {
        var result = optionalTarget || new Vector2();
        return result.copy(point).clamp(this.min, this.max);
    },
    distanceToPoint: function () {
        var v1 = new Vector2();
        return function distanceToPoint(point) {
            var clampedPoint = v1.copy(point).clamp(this.min, this.max);
            return clampedPoint.sub(point).length();
        };
    }(),
    intersect: function (box) {
        this.min.max(box.min);
        this.max.min(box.max);
        return this;
    },
    union: function (box) {
        this.min.min(box.min);
        this.max.max(box.max);
        return this;
    },
    translate: function (offset) {
        this.min.add(offset);
        this.max.add(offset);
        return this;
    },
    equals: function (box) {
        return box.min.equals(this.min) && box.max.equals(this.max);
    }
};
CubeTexture.prototype = Object.create(Texture.prototype);
CubeTexture.prototype.constructor = CubeTexture;
CubeTexture.prototype.isCubeTexture = true;
Object.defineProperty(CubeTexture.prototype, 'images', {
    get: function () {
        return this.image;
    },
    set: function (value) {
        this.image = value;
    }
});
emptyTexture = new Texture();
emptyCubeTexture = new CubeTexture();
arrayCacheF32 = [];
arrayCacheI32 = [];
StructuredUniform.prototype.setValue = function (gl, value) {
    var seq = this.seq;
    for (var i = 0, n = seq.length; i !== n; ++i) {
        var u = seq[i];
        u.setValue(gl, value[u.id]);
    }
};
RePathPart = /([\w\d_]+)(\])?(\[|\.)?/g;
WebGLUniforms.prototype.setValue = function (gl, name, value) {
    var u = this.map[name];
    if (u !== undefined)
        u.setValue(gl, value, this.renderer);
};
WebGLUniforms.prototype.set = function (gl, object, name) {
    var u = this.map[name];
    if (u !== undefined)
        u.setValue(gl, object[name], this.renderer);
};
WebGLUniforms.prototype.setOptional = function (gl, object, name) {
    var v = object[name];
    if (v !== undefined)
        this.setValue(gl, name, v);
};
WebGLUniforms.upload = function (gl, seq, values, renderer) {
    for (var i = 0, n = seq.length; i !== n; ++i) {
        var u = seq[i], v = values[u.id];
        if (v.needsUpdate !== false) {
            u.setValue(gl, v.value, renderer);
        }
    }
};
WebGLUniforms.seqWithValue = function (seq, values) {
    var r = [];
    for (var i = 0, n = seq.length; i !== n; ++i) {
        var u = seq[i];
        if (u.id in values)
            r.push(u);
    }
    return r;
};
WebGLUniforms.splitDynamic = function (seq, values) {
    var r = null, n = seq.length, w = 0;
    for (var i = 0; i !== n; ++i) {
        var u = seq[i], v = values[u.id];
        if (v && v.dynamic === true) {
            if (r === null)
                r = [];
            r.push(u);
        } else {
            if (w < i)
                seq[w] = u;
            ++w;
        }
    }
    if (w < n)
        seq.length = w;
    return r;
};
WebGLUniforms.evalDynamic = function (seq, values, object, camera) {
    for (var i = 0, n = seq.length; i !== n; ++i) {
        var v = values[seq[i].id], f = v.onUpdateCallback;
        if (f !== undefined)
            f.call(v, object, camera);
    }
};
Vector4.prototype = {
    constructor: Vector4,
    isVector4: true,
    set: function (x, y, z, w) {
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
        return this;
    },
    setScalar: function (scalar) {
        this.x = scalar;
        this.y = scalar;
        this.z = scalar;
        this.w = scalar;
        return this;
    },
    setX: function (x) {
        this.x = x;
        return this;
    },
    setY: function (y) {
        this.y = y;
        return this;
    },
    setZ: function (z) {
        this.z = z;
        return this;
    },
    setW: function (w) {
        this.w = w;
        return this;
    },
    setComponent: function (index, value) {
        switch (index) {
        case 0:
            this.x = value;
            break;
        case 1:
            this.y = value;
            break;
        case 2:
            this.z = value;
            break;
        case 3:
            this.w = value;
            break;
        default:
            throw new Error('index is out of range: ' + index);
        }
    },
    getComponent: function (index) {
        switch (index) {
        case 0:
            return this.x;
        case 1:
            return this.y;
        case 2:
            return this.z;
        case 3:
            return this.w;
        default:
            throw new Error('index is out of range: ' + index);
        }
    },
    clone: function () {
        return new this.constructor(this.x, this.y, this.z, this.w);
    },
    copy: function (v) {
        this.x = v.x;
        this.y = v.y;
        this.z = v.z;
        this.w = v.w !== undefined ? v.w : 1;
        return this;
    },
    add: function (v, w) {
        if (w !== undefined) {
            console.warn('THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');
            return this.addVectors(v, w);
        }
        this.x += v.x;
        this.y += v.y;
        this.z += v.z;
        this.w += v.w;
        return this;
    },
    addScalar: function (s) {
        this.x += s;
        this.y += s;
        this.z += s;
        this.w += s;
        return this;
    },
    addVectors: function (a, b) {
        this.x = a.x + b.x;
        this.y = a.y + b.y;
        this.z = a.z + b.z;
        this.w = a.w + b.w;
        return this;
    },
    addScaledVector: function (v, s) {
        this.x += v.x * s;
        this.y += v.y * s;
        this.z += v.z * s;
        this.w += v.w * s;
        return this;
    },
    sub: function (v, w) {
        if (w !== undefined) {
            console.warn('THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');
            return this.subVectors(v, w);
        }
        this.x -= v.x;
        this.y -= v.y;
        this.z -= v.z;
        this.w -= v.w;
        return this;
    },
    subScalar: function (s) {
        this.x -= s;
        this.y -= s;
        this.z -= s;
        this.w -= s;
        return this;
    },
    subVectors: function (a, b) {
        this.x = a.x - b.x;
        this.y = a.y - b.y;
        this.z = a.z - b.z;
        this.w = a.w - b.w;
        return this;
    },
    multiplyScalar: function (scalar) {
        if (isFinite(scalar)) {
            this.x *= scalar;
            this.y *= scalar;
            this.z *= scalar;
            this.w *= scalar;
        } else {
            this.x = 0;
            this.y = 0;
            this.z = 0;
            this.w = 0;
        }
        return this;
    },
    applyMatrix4: function (m) {
        var x = this.x, y = this.y, z = this.z, w = this.w;
        var e = m.elements;
        this.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w;
        this.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w;
        this.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w;
        this.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w;
        return this;
    },
    divideScalar: function (scalar) {
        return this.multiplyScalar(1 / scalar);
    },
    setAxisAngleFromQuaternion: function (q) {
        this.w = 2 * Math.acos(q.w);
        var s = Math.sqrt(1 - q.w * q.w);
        if (s < 0.0001) {
            this.x = 1;
            this.y = 0;
            this.z = 0;
        } else {
            this.x = q.x / s;
            this.y = q.y / s;
            this.z = q.z / s;
        }
        return this;
    },
    setAxisAngleFromRotationMatrix: function (m) {
        var angle, x, y, z, epsilon = 0.01, epsilon2 = 0.1, te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10];
        if (Math.abs(m12 - m21) < epsilon && Math.abs(m13 - m31) < epsilon && Math.abs(m23 - m32) < epsilon) {
            if (Math.abs(m12 + m21) < epsilon2 && Math.abs(m13 + m31) < epsilon2 && Math.abs(m23 + m32) < epsilon2 && Math.abs(m11 + m22 + m33 - 3) < epsilon2) {
                this.set(1, 0, 0, 0);
                return this;
            }
            angle = Math.PI;
            var xx = (m11 + 1) / 2;
            var yy = (m22 + 1) / 2;
            var zz = (m33 + 1) / 2;
            var xy = (m12 + m21) / 4;
            var xz = (m13 + m31) / 4;
            var yz = (m23 + m32) / 4;
            if (xx > yy && xx > zz) {
                if (xx < epsilon) {
                    x = 0;
                    y = 0.707106781;
                    z = 0.707106781;
                } else {
                    x = Math.sqrt(xx);
                    y = xy / x;
                    z = xz / x;
                }
            } else if (yy > zz) {
                if (yy < epsilon) {
                    x = 0.707106781;
                    y = 0;
                    z = 0.707106781;
                } else {
                    y = Math.sqrt(yy);
                    x = xy / y;
                    z = yz / y;
                }
            } else {
                if (zz < epsilon) {
                    x = 0.707106781;
                    y = 0.707106781;
                    z = 0;
                } else {
                    z = Math.sqrt(zz);
                    x = xz / z;
                    y = yz / z;
                }
            }
            this.set(x, y, z, angle);
            return this;
        }
        var s = Math.sqrt((m32 - m23) * (m32 - m23) + (m13 - m31) * (m13 - m31) + (m21 - m12) * (m21 - m12));
        if (Math.abs(s) < 0.001)
            s = 1;
        this.x = (m32 - m23) / s;
        this.y = (m13 - m31) / s;
        this.z = (m21 - m12) / s;
        this.w = Math.acos((m11 + m22 + m33 - 1) / 2);
        return this;
    },
    min: function (v) {
        this.x = Math.min(this.x, v.x);
        this.y = Math.min(this.y, v.y);
        this.z = Math.min(this.z, v.z);
        this.w = Math.min(this.w, v.w);
        return this;
    },
    max: function (v) {
        this.x = Math.max(this.x, v.x);
        this.y = Math.max(this.y, v.y);
        this.z = Math.max(this.z, v.z);
        this.w = Math.max(this.w, v.w);
        return this;
    },
    clamp: function (min, max) {
        this.x = Math.max(min.x, Math.min(max.x, this.x));
        this.y = Math.max(min.y, Math.min(max.y, this.y));
        this.z = Math.max(min.z, Math.min(max.z, this.z));
        this.w = Math.max(min.w, Math.min(max.w, this.w));
        return this;
    },
    clampScalar: function () {
        var min, max;
        return function clampScalar(minVal, maxVal) {
            if (min === undefined) {
                min = new Vector4();
                max = new Vector4();
            }
            min.set(minVal, minVal, minVal, minVal);
            max.set(maxVal, maxVal, maxVal, maxVal);
            return this.clamp(min, max);
        };
    }(),
    floor: function () {
        this.x = Math.floor(this.x);
        this.y = Math.floor(this.y);
        this.z = Math.floor(this.z);
        this.w = Math.floor(this.w);
        return this;
    },
    ceil: function () {
        this.x = Math.ceil(this.x);
        this.y = Math.ceil(this.y);
        this.z = Math.ceil(this.z);
        this.w = Math.ceil(this.w);
        return this;
    },
    round: function () {
        this.x = Math.round(this.x);
        this.y = Math.round(this.y);
        this.z = Math.round(this.z);
        this.w = Math.round(this.w);
        return this;
    },
    roundToZero: function () {
        this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
        this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
        this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
        this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w);
        return this;
    },
    negate: function () {
        this.x = -this.x;
        this.y = -this.y;
        this.z = -this.z;
        this.w = -this.w;
        return this;
    },
    dot: function (v) {
        return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
    },
    lengthSq: function () {
        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
    },
    length: function () {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
    },
    lengthManhattan: function () {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
    },
    normalize: function () {
        return this.divideScalar(this.length());
    },
    setLength: function (length) {
        return this.multiplyScalar(length / this.length());
    },
    lerp: function (v, alpha) {
        this.x += (v.x - this.x) * alpha;
        this.y += (v.y - this.y) * alpha;
        this.z += (v.z - this.z) * alpha;
        this.w += (v.w - this.w) * alpha;
        return this;
    },
    lerpVectors: function (v1, v2, alpha) {
        return this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);
    },
    equals: function (v) {
        return v.x === this.x && v.y === this.y && v.z === this.z && v.w === this.w;
    },
    fromArray: function (array, offset) {
        if (offset === undefined)
            offset = 0;
        this.x = array[offset];
        this.y = array[offset + 1];
        this.z = array[offset + 2];
        this.w = array[offset + 3];
        return this;
    },
    toArray: function (array, offset) {
        if (array === undefined)
            array = [];
        if (offset === undefined)
            offset = 0;
        array[offset] = this.x;
        array[offset + 1] = this.y;
        array[offset + 2] = this.z;
        array[offset + 3] = this.w;
        return array;
    },
    fromAttribute: function (attribute, index, offset) {
        if (offset === undefined)
            offset = 0;
        index = index * attribute.itemSize + offset;
        this.x = attribute.array[index];
        this.y = attribute.array[index + 1];
        this.z = attribute.array[index + 2];
        this.w = attribute.array[index + 3];
        return this;
    }
};
Object.assign(WebGLRenderTarget.prototype, EventDispatcher.prototype, {
    isWebGLRenderTarget: true,
    setSize: function (width, height) {
        if (this.width !== width || this.height !== height) {
            this.width = width;
            this.height = height;
            this.dispose();
        }
        this.viewport.set(0, 0, width, height);
        this.scissor.set(0, 0, width, height);
    },
    clone: function () {
        return new this.constructor().copy(this);
    },
    copy: function (source) {
        this.width = source.width;
        this.height = source.height;
        this.viewport.copy(source.viewport);
        this.texture = source.texture.clone();
        this.depthBuffer = source.depthBuffer;
        this.stencilBuffer = source.stencilBuffer;
        this.depthTexture = source.depthTexture;
        return this;
    },
    dispose: function () {
        this.dispatchEvent({
            type: 'dispose'
        });
    }
});
Material.prototype = {
    constructor: Material,
    isMaterial: true,
    get needsUpdate() {
        return this._needsUpdate;
    },
    set needsUpdate(value) {
        if (value === true)
            this.update();
        this._needsUpdate = value;
    },
    setValues: function (values) {
        if (values === undefined)
            return;
        for (var key in values) {
            var newValue = values[key];
            if (newValue === undefined) {
                console.warn('THREE.Material: \'' + key + '\' parameter is undefined.');
                continue;
            }
            var currentValue = this[key];
            if (currentValue === undefined) {
                console.warn('THREE.' + this.type + ': \'' + key + '\' is not a property of this material.');
                continue;
            }
            if (currentValue && currentValue.isColor) {
                currentValue.set(newValue);
            } else if (currentValue && currentValue.isVector3 && (newValue && newValue.isVector3)) {
                currentValue.copy(newValue);
            } else if (key === 'overdraw') {
                this[key] = Number(newValue);
            } else {
                this[key] = newValue;
            }
        }
    },
    toJSON: function (meta) {
        var isRoot = meta === undefined;
        if (isRoot) {
            meta = {
                textures: {},
                images: {}
            };
        }
        var data = {
            metadata: {
                version: 4.4,
                type: 'Material',
                generator: 'Material.toJSON'
            }
        };
        data.uuid = this.uuid;
        data.type = this.type;
        if (this.name !== '')
            data.name = this.name;
        if (this.color && this.color.isColor)
            data.color = this.color.getHex();
        if (this.roughness !== undefined)
            data.roughness = this.roughness;
        if (this.metalness !== undefined)
            data.metalness = this.metalness;
        if (this.emissive && this.emissive.isColor)
            data.emissive = this.emissive.getHex();
        if (this.specular && this.specular.isColor)
            data.specular = this.specular.getHex();
        if (this.shininess !== undefined)
            data.shininess = this.shininess;
        if (this.map && this.map.isTexture)
            data.map = this.map.toJSON(meta).uuid;
        if (this.alphaMap && this.alphaMap.isTexture)
            data.alphaMap = this.alphaMap.toJSON(meta).uuid;
        if (this.lightMap && this.lightMap.isTexture)
            data.lightMap = this.lightMap.toJSON(meta).uuid;
        if (this.bumpMap && this.bumpMap.isTexture) {
            data.bumpMap = this.bumpMap.toJSON(meta).uuid;
            data.bumpScale = this.bumpScale;
        }
        if (this.normalMap && this.normalMap.isTexture) {
            data.normalMap = this.normalMap.toJSON(meta).uuid;
            data.normalScale = this.normalScale.toArray();
        }
        if (this.displacementMap && this.displacementMap.isTexture) {
            data.displacementMap = this.displacementMap.toJSON(meta).uuid;
            data.displacementScale = this.displacementScale;
            data.displacementBias = this.displacementBias;
        }
        if (this.roughnessMap && this.roughnessMap.isTexture)
            data.roughnessMap = this.roughnessMap.toJSON(meta).uuid;
        if (this.metalnessMap && this.metalnessMap.isTexture)
            data.metalnessMap = this.metalnessMap.toJSON(meta).uuid;
        if (this.emissiveMap && this.emissiveMap.isTexture)
            data.emissiveMap = this.emissiveMap.toJSON(meta).uuid;
        if (this.specularMap && this.specularMap.isTexture)
            data.specularMap = this.specularMap.toJSON(meta).uuid;
        if (this.envMap && this.envMap.isTexture) {
            data.envMap = this.envMap.toJSON(meta).uuid;
            data.reflectivity = this.reflectivity;
        }
        if (this.size !== undefined)
            data.size = this.size;
        if (this.sizeAttenuation !== undefined)
            data.sizeAttenuation = this.sizeAttenuation;
        if (this.blending !== NormalBlending)
            data.blending = this.blending;
        if (this.shading !== SmoothShading)
            data.shading = this.shading;
        if (this.side !== FrontSide)
            data.side = this.side;
        if (this.vertexColors !== NoColors)
            data.vertexColors = this.vertexColors;
        if (this.opacity < 1)
            data.opacity = this.opacity;
        if (this.transparent === true)
            data.transparent = this.transparent;
        data.depthFunc = this.depthFunc;
        data.depthTest = this.depthTest;
        data.depthWrite = this.depthWrite;
        if (this.alphaTest > 0)
            data.alphaTest = this.alphaTest;
        if (this.premultipliedAlpha === true)
            data.premultipliedAlpha = this.premultipliedAlpha;
        if (this.wireframe === true)
            data.wireframe = this.wireframe;
        if (this.wireframeLinewidth > 1)
            data.wireframeLinewidth = this.wireframeLinewidth;
        if (this.wireframeLinecap !== 'round')
            data.wireframeLinecap = this.wireframeLinecap;
        if (this.wireframeLinejoin !== 'round')
            data.wireframeLinejoin = this.wireframeLinejoin;
        data.skinning = this.skinning;
        data.morphTargets = this.morphTargets;
        function extractFromCache(cache) {
            var values = [];
            for (var key in cache) {
                var data = cache[key];
                delete data.metadata;
                values.push(data);
            }
            return values;
        }
        if (isRoot) {
            var textures = extractFromCache(meta.textures);
            var images = extractFromCache(meta.images);
            if (textures.length > 0)
                data.textures = textures;
            if (images.length > 0)
                data.images = images;
        }
        return data;
    },
    clone: function () {
        return new this.constructor().copy(this);
    },
    copy: function (source) {
        this.name = source.name;
        this.fog = source.fog;
        this.lights = source.lights;
        this.blending = source.blending;
        this.side = source.side;
        this.shading = source.shading;
        this.vertexColors = source.vertexColors;
        this.opacity = source.opacity;
        this.transparent = source.transparent;
        this.blendSrc = source.blendSrc;
        this.blendDst = source.blendDst;
        this.blendEquation = source.blendEquation;
        this.blendSrcAlpha = source.blendSrcAlpha;
        this.blendDstAlpha = source.blendDstAlpha;
        this.blendEquationAlpha = source.blendEquationAlpha;
        this.depthFunc = source.depthFunc;
        this.depthTest = source.depthTest;
        this.depthWrite = source.depthWrite;
        this.colorWrite = source.colorWrite;
        this.precision = source.precision;
        this.polygonOffset = source.polygonOffset;
        this.polygonOffsetFactor = source.polygonOffsetFactor;
        this.polygonOffsetUnits = source.polygonOffsetUnits;
        this.alphaTest = source.alphaTest;
        this.premultipliedAlpha = source.premultipliedAlpha;
        this.overdraw = source.overdraw;
        this.visible = source.visible;
        this.clipShadows = source.clipShadows;
        var srcPlanes = source.clippingPlanes, dstPlanes = null;
        if (srcPlanes !== null) {
            var n = srcPlanes.length;
            dstPlanes = new Array(n);
            for (var i = 0; i !== n; ++i)
                dstPlanes[i] = srcPlanes[i].clone();
        }
        this.clippingPlanes = dstPlanes;
        return this;
    },
    update: function () {
        this.dispatchEvent({
            type: 'update'
        });
    },
    dispose: function () {
        this.dispatchEvent({
            type: 'dispose'
        });
    }
};
Object.assign(Material.prototype, EventDispatcher.prototype);
count$1 = 0;
;
exports.UniformsUtils = {
    merge: function (uniforms) {
        var merged = {};
        for (var u = 0; u < uniforms.length; u++) {
            var tmp = this.clone(uniforms[u]);
            for (var p in tmp) {
                merged[p] = tmp[p];
            }
        }
        return merged;
    },
    clone: function (uniforms_src) {
        var uniforms_dst = {};
        for (var u in uniforms_src) {
            uniforms_dst[u] = {};
            for (var p in uniforms_src[u]) {
                var parameter_src = uniforms_src[u][p];
                if (parameter_src && parameter_src.isColor || parameter_src && parameter_src.isVector2 || parameter_src && parameter_src.isVector3 || parameter_src && parameter_src.isVector4 || parameter_src && parameter_src.isMatrix3 || parameter_src && parameter_src.isMatrix4 || parameter_src && parameter_src.isTexture) {
                    uniforms_dst[u][p] = parameter_src.clone();
                } else if (Array.isArray(parameter_src)) {
                    uniforms_dst[u][p] = parameter_src.slice();
                } else {
                    uniforms_dst[u][p] = parameter_src;
                }
            }
        }
        return uniforms_dst;
    }
};
ShaderMaterial.prototype = Object.create(Material.prototype);
ShaderMaterial.prototype.constructor = ShaderMaterial;
ShaderMaterial.prototype.isShaderMaterial = true;
ShaderMaterial.prototype.copy = function (source) {
    Material.prototype.copy.call(this, source);
    this.fragmentShader = source.fragmentShader;
    this.vertexShader = source.vertexShader;
    this.uniforms = exports.UniformsUtils.clone(source.uniforms);
    this.defines = source.defines;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.lights = source.lights;
    this.clipping = source.clipping;
    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    this.morphNormals = source.morphNormals;
    this.extensions = source.extensions;
    return this;
};
ShaderMaterial.prototype.toJSON = function (meta) {
    var data = Material.prototype.toJSON.call(this, meta);
    data.uniforms = this.uniforms;
    data.vertexShader = this.vertexShader;
    data.fragmentShader = this.fragmentShader;
    return data;
};
alphamap_fragment = '#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n';
alphamap_pars_fragment = '#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif\n';
alphatest_fragment = '#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif\n';
aomap_fragment = '#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif\n';
aomap_pars_fragment = '#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif';
begin_vertex = '\nvec3 transformed = vec3( position );\n';
beginnormal_vertex = '\nvec3 objectNormal = vec3( normal );\n';
bsdfs = 'bool testLightInRange( const in float lightDistance, const in float cutoffDistance ) {\n\treturn any( bvec2( cutoffDistance == 0.0, lightDistance < cutoffDistance ) );\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t\tif( decayExponent > 0.0 ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\t\tfloat maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t\treturn distanceFalloff * maxDistanceCutoffFactor;\n#else\n\t\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n#endif\n\t\t}\n\t\treturn 1.0;\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\treturn specularColor * AB.x + AB.y;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n';
bumpmap_pars_fragment = '#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = dFdx( surf_pos );\n\t\tvec3 vSigmaY = dFdy( surf_pos );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif\n';
clipping_planes_fragment = '#if NUM_CLIPPING_PLANES > 0\n\tfor ( int i = 0; i < NUM_CLIPPING_PLANES; ++ i ) {\n\t\tvec4 plane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n#endif\n';
clipping_planes_pars_fragment = '#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( PHYSICAL ) && ! defined( PHONG )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif\n';
clipping_planes_pars_vertex = '#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvarying vec3 vViewPosition;\n#endif\n';
clipping_planes_vertex = '#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n';
color_fragment = '#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif';
color_pars_fragment = '#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif\n';
color_pars_vertex = '#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif';
color_vertex = '#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif';
common = '#define PI 3.14159265359\n#define PI2 6.28318530718\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\n';
cube_uv_reflection_fragment = '#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction);\n\tint face = -1;\n\tif( absDirection.x > absDirection.z ) {\n\t\tif(absDirection.x > absDirection.y )\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z > absDirection.y )\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes && (scale < a) ? a : scale;\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\tfloat rcpPowScale = 1.0 / powScale;\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV(vec3 reflectedDirection, float roughness ) {\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n\tfloat s = mipInfo.y;\n\tfloat level0 = mipInfo.x;\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\tvec4 result = mix(color10, color20, t);\n\treturn vec4(result.rgb, 1.0);\n}\n#endif\n';
defaultnormal_vertex = '#ifdef FLIP_SIDED\n\tobjectNormal = -objectNormal;\n#endif\nvec3 transformedNormal = normalMatrix * objectNormal;\n';
displacementmap_pars_vertex = '#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif\n';
displacementmap_vertex = '#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normal * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif\n';
emissivemap_fragment = '#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif\n';
emissivemap_pars_fragment = '#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif\n';
encodings_fragment = '  gl_FragColor = linearToOutputTexel( gl_FragColor );\n';
encodings_pars_fragment = '\nvec4 LinearToLinear( in vec4 value ) {\n  return value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n  return vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n  return vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n  return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n  return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n  return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n  float maxComponent = max( max( value.r, value.g ), value.b );\n  float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n  return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n  return vec4( value.xyz * value.w * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n  float maxRGB = max( value.x, max( value.g, value.b ) );\n  float M      = clamp( maxRGB / maxRange, 0.0, 1.0 );\n  M            = ceil( M * 255.0 ) / 255.0;\n  return vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n    return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n    float maxRGB = max( value.x, max( value.g, value.b ) );\n    float D      = max( maxRange / maxRGB, 1.0 );\n    D            = min( floor( D ) / 255.0, 1.0 );\n    return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n  vec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\n  Xp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\n  vec4 vResult;\n  vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n  float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n  vResult.w = fract(Le);\n  vResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;\n  return vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n  float Le = value.z * 255.0 + value.w;\n  vec3 Xp_Y_XYZp;\n  Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\n  Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n  Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n  vec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\n  return vec4( max(vRGB, 0.0), 1.0 );\n}\n';
envmap_fragment = '#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\tsampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\n\t\tsampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\tvec3 reflectView = flipNormal * normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\tenvColor = envMapTexelToLinear( envColor );\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif\n';
envmap_pars_fragment = '#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n\tuniform float reflectivity;\n\tuniform float envMapIntenstiy;\n#endif\n#ifdef USE_ENVMAP\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n\t\tvarying vec3 vWorldPosition;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\tuniform float flipEnvMap;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif\n';
envmap_pars_vertex = '#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif\n';
envmap_vertex = '#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif\n';
fog_fragment = '#ifdef USE_FOG\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tfloat depth = gl_FragDepthEXT / gl_FragCoord.w;\n\t#else\n\t\tfloat depth = gl_FragCoord.z / gl_FragCoord.w;\n\t#endif\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * depth * depth * LOG2 ) );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, depth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n';
fog_pars_fragment = '#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif';
lightmap_fragment = '#ifdef USE_LIGHTMAP\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif\n';
lightmap_pars_fragment = '#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif';
lights_lambert_vertex = 'vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif\n';
lights_pars = 'uniform vec3 ambientLightColor;\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tif ( testLightInRange( lightDistance, pointLight.distance ) ) {\n\t\t\tdirectLight.color = pointLight.color;\n\t\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( all( bvec2( angleCos > spotLight.coneCos, testLightInRange( lightDistance, spotLight.distance ) ) ) ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif\n#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\t#include <normal_flip>\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = flipNormal * vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = flipNormal * vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar - 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\t\t#endif\n\t\t#include <normal_flip>\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryReflectVec = flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV(queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent));\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\n\t\t\tsampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = flipNormal * normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif\n';
lights_phong_fragment = 'BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;\n';
lights_phong_pars_fragment = 'varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)\n';
lights_physical_fragment = 'PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.clearCoat = saturate( clearCoat );\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n#endif\n';
lights_physical_pars_fragment = 'struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n\t#ifndef STANDARD\n\t\tfloat clearCoat;\n\t\tfloat clearCoatRoughness;\n\t#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifndef STANDARD\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#ifndef STANDARD\n\t\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifndef STANDARD\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\tfloat dotNL = dotNV;\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR ) * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n\t#ifndef STANDARD\n\t\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}\n';
lights_template = '\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#ifdef USE_LIGHTMAP\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t \tirradiance += getLightProbeIndirectIrradiance( geometry, 8 );\n\t#endif\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tvec3 radiance = getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), 8 );\n\t#ifndef STANDARD\n\t\tvec3 clearCoatRadiance = getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), 8 );\n\t#else\n\t\tvec3 clearCoatRadiance = vec3( 0.0 );\n\t#endif\n\t\t\n\tRE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );\n#endif\n';
logdepthbuf_fragment = '#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n\tgl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n#endif';
logdepthbuf_pars_fragment = '#ifdef USE_LOGDEPTHBUF\n\tuniform float logDepthBufFC;\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n#endif\n';
logdepthbuf_pars_vertex = '#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n\tuniform float logDepthBufFC;\n#endif';
logdepthbuf_vertex = '#ifdef USE_LOGDEPTHBUF\n\tgl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t#else\n\t\tgl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\n\t#endif\n#endif\n';
map_fragment = '#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif\n';
map_pars_fragment = '#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n';
map_particle_fragment = '#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) * offsetRepeat.zw + offsetRepeat.xy );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n';
map_particle_pars_fragment = '#ifdef USE_MAP\n\tuniform vec4 offsetRepeat;\n\tuniform sampler2D map;\n#endif\n';
metalnessmap_fragment = 'float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.r;\n#endif\n';
metalnessmap_pars_fragment = '#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif';
morphnormal_vertex = '#ifdef USE_MORPHNORMALS\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif\n';
morphtarget_pars_vertex = '#ifdef USE_MORPHTARGETS\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif';
morphtarget_vertex = '#ifdef USE_MORPHTARGETS\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\t#endif\n#endif\n';
normal_flip = '#ifdef DOUBLE_SIDED\n\tfloat flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n#else\n\tfloat flipNormal = 1.0;\n#endif\n';
normal_fragment = '#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal ) * flipNormal;\n#endif\n#ifdef USE_NORMALMAP\n\tnormal = perturbNormal2Arb( -vViewPosition, normal );\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif\n';
normalmap_pars_fragment = '#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 S = normalize( q0 * st1.t - q1 * st0.t );\n\t\tvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\n\t\tvec3 N = normalize( surf_norm );\n\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\tmapN.xy = normalScale * mapN.xy;\n\t\tmat3 tsn = mat3( S, T, N );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif\n';
packing = 'vec3 packNormalToRGB( const in vec3 normal ) {\n  return normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n  return 1.0 - 2.0 * rgb.xyz;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n  return ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n  return linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n  return (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n  return ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n';
premultiplied_alpha_fragment = '#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif\n';
project_vertex = '#ifdef USE_SKINNING\n\tvec4 mvPosition = modelViewMatrix * skinned;\n#else\n\tvec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\n#endif\ngl_Position = projectionMatrix * mvPosition;\n';
roughnessmap_fragment = 'float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.r;\n#endif\n';
roughnessmap_pars_fragment = '#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif';
shadowmap_pars_fragment = '#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\treturn (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn 1.0;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\tfloat dp = ( length( lightToPosition ) - shadowBias ) / 1000.0;\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif\n';
shadowmap_pars_vertex = '#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n#endif\n';
shadowmap_vertex = '#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif\n';
shadowmask_pars_fragment = 'float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tDirectionalLight directionalLight;\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tSpotLight spotLight;\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tPointLight pointLight;\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}\n';
skinbase_vertex = '#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif';
skinning_pars_vertex = '#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform sampler2D boneTexture;\n\t\tuniform int boneTextureWidth;\n\t\tuniform int boneTextureHeight;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureWidth ) );\n\t\t\tfloat y = floor( j / float( boneTextureWidth ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureWidth );\n\t\t\tfloat dy = 1.0 / float( boneTextureHeight );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif\n';
skinning_vertex = '#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\tskinned  = bindMatrixInverse * skinned;\n#endif\n';
skinnormal_vertex = '#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n#endif\n';
specularmap_fragment = 'float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif';
specularmap_pars_fragment = '#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif';
tonemapping_fragment = '#if defined( TONE_MAPPING )\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif\n';
tonemapping_pars_fragment = '#define saturate(a) clamp( a, 0.0, 1.0 )\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n  return toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n  color *= toneMappingExposure;\n  return saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n  color *= toneMappingExposure;\n  return saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n  color *= toneMappingExposure;\n  color = max( vec3( 0.0 ), color - 0.004 );\n  return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\n';
uv_pars_fragment = '#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n#endif';
uv_pars_vertex = '#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n\tuniform vec4 offsetRepeat;\n#endif\n';
uv_vertex = '#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvUv = uv * offsetRepeat.zw + offsetRepeat.xy;\n#endif';
uv2_pars_fragment = '#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif';
uv2_pars_vertex = '#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n#endif';
uv2_vertex = '#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = uv2;\n#endif';
worldpos_vertex = '#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( PHYSICAL ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\n\t#ifdef USE_SKINNING\n\t\tvec4 worldPosition = modelMatrix * skinned;\n\t#else\n\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n\t#endif\n#endif\n';
cube_frag = 'uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\n\tgl_FragColor.a *= opacity;\n}\n';
cube_vert = 'varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}\n';
depth_frag = '#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( gl_FragCoord.z ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\t#endif\n}\n';
depth_vert = '#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}\n';
distanceRGBA_frag = 'uniform vec3 lightPos;\nvarying vec4 vWorldPosition;\n#include <common>\n#include <packing>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tgl_FragColor = packDepthToRGBA( length( vWorldPosition.xyz - lightPos.xyz ) / 1000.0 );\n}\n';
distanceRGBA_vert = 'varying vec4 vWorldPosition;\n#include <common>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <skinbase_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition;\n}\n';
equirect_frag = 'uniform sampler2D tEquirect;\nuniform float tFlip;\nvarying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldPosition );\n\tvec2 sampleUV;\n\tsampleUV.y = saturate( tFlip * direction.y * -0.5 + 0.5 );\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n}\n';
equirect_vert = 'varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}\n';
linedashed_frag = 'uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n';
linedashed_vert = 'uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}\n';
meshbasic_frag = 'uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight;\n\treflectedLight.directDiffuse = vec3( 0.0 );\n\treflectedLight.directSpecular = vec3( 0.0 );\n\treflectedLight.indirectDiffuse = diffuseColor.rgb;\n\treflectedLight.indirectSpecular = vec3( 0.0 );\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <normal_flip>\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n';
meshbasic_vert = '#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n}\n';
meshlambert_frag = 'uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <normal_flip>\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n';
meshlambert_vert = '#define LAMBERT\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars>\n#include <color_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n}\n';
meshphong_frag = '#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_flip>\n\t#include <normal_fragment>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_template>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n';
meshphong_vert = '#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n}\n';
meshphysical_frag = '#define PHYSICAL\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifndef STANDARD\n\tuniform float clearCoat;\n\tuniform float clearCoatRoughness;\n#endif\nuniform float envMapIntensity;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <lights_pars>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_flip>\n\t#include <normal_fragment>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_template>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n';
meshphysical_vert = '#define PHYSICAL\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n}\n';
normal_frag = 'uniform float opacity;\nvarying vec3 vNormal;\n#include <common>\n#include <packing>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tgl_FragColor = vec4( packNormalToRGB( vNormal ), opacity );\n\t#include <logdepthbuf_fragment>\n}\n';
normal_vert = 'varying vec3 vNormal;\n#include <common>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvNormal = normalize( normalMatrix * normal );\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}\n';
points_frag = 'uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n';
points_vert = 'uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#ifdef USE_SIZEATTENUATION\n\t\tgl_PointSize = size * ( scale / - mvPosition.z );\n\t#else\n\t\tgl_PointSize = size;\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n}\n';
shadow_frag = 'uniform float opacity;\n#include <common>\n#include <packing>\n#include <bsdfs>\n#include <lights_pars>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( 0.0, 0.0, 0.0, opacity * ( 1.0  - getShadowMask() ) );\n}\n';
shadow_vert = '#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n}\n';
ShaderChunk = {
    alphamap_fragment: alphamap_fragment,
    alphamap_pars_fragment: alphamap_pars_fragment,
    alphatest_fragment: alphatest_fragment,
    aomap_fragment: aomap_fragment,
    aomap_pars_fragment: aomap_pars_fragment,
    begin_vertex: begin_vertex,
    beginnormal_vertex: beginnormal_vertex,
    bsdfs: bsdfs,
    bumpmap_pars_fragment: bumpmap_pars_fragment,
    clipping_planes_fragment: clipping_planes_fragment,
    clipping_planes_pars_fragment: clipping_planes_pars_fragment,
    clipping_planes_pars_vertex: clipping_planes_pars_vertex,
    clipping_planes_vertex: clipping_planes_vertex,
    color_fragment: color_fragment,
    color_pars_fragment: color_pars_fragment,
    color_pars_vertex: color_pars_vertex,
    color_vertex: color_vertex,
    common: common,
    cube_uv_reflection_fragment: cube_uv_reflection_fragment,
    defaultnormal_vertex: defaultnormal_vertex,
    displacementmap_pars_vertex: displacementmap_pars_vertex,
    displacementmap_vertex: displacementmap_vertex,
    emissivemap_fragment: emissivemap_fragment,
    emissivemap_pars_fragment: emissivemap_pars_fragment,
    encodings_fragment: encodings_fragment,
    encodings_pars_fragment: encodings_pars_fragment,
    envmap_fragment: envmap_fragment,
    envmap_pars_fragment: envmap_pars_fragment,
    envmap_pars_vertex: envmap_pars_vertex,
    envmap_vertex: envmap_vertex,
    fog_fragment: fog_fragment,
    fog_pars_fragment: fog_pars_fragment,
    lightmap_fragment: lightmap_fragment,
    lightmap_pars_fragment: lightmap_pars_fragment,
    lights_lambert_vertex: lights_lambert_vertex,
    lights_pars: lights_pars,
    lights_phong_fragment: lights_phong_fragment,
    lights_phong_pars_fragment: lights_phong_pars_fragment,
    lights_physical_fragment: lights_physical_fragment,
    lights_physical_pars_fragment: lights_physical_pars_fragment,
    lights_template: lights_template,
    logdepthbuf_fragment: logdepthbuf_fragment,
    logdepthbuf_pars_fragment: logdepthbuf_pars_fragment,
    logdepthbuf_pars_vertex: logdepthbuf_pars_vertex,
    logdepthbuf_vertex: logdepthbuf_vertex,
    map_fragment: map_fragment,
    map_pars_fragment: map_pars_fragment,
    map_particle_fragment: map_particle_fragment,
    map_particle_pars_fragment: map_particle_pars_fragment,
    metalnessmap_fragment: metalnessmap_fragment,
    metalnessmap_pars_fragment: metalnessmap_pars_fragment,
    morphnormal_vertex: morphnormal_vertex,
    morphtarget_pars_vertex: morphtarget_pars_vertex,
    morphtarget_vertex: morphtarget_vertex,
    normal_flip: normal_flip,
    normal_fragment: normal_fragment,
    normalmap_pars_fragment: normalmap_pars_fragment,
    packing: packing,
    premultiplied_alpha_fragment: premultiplied_alpha_fragment,
    project_vertex: project_vertex,
    roughnessmap_fragment: roughnessmap_fragment,
    roughnessmap_pars_fragment: roughnessmap_pars_fragment,
    shadowmap_pars_fragment: shadowmap_pars_fragment,
    shadowmap_pars_vertex: shadowmap_pars_vertex,
    shadowmap_vertex: shadowmap_vertex,
    shadowmask_pars_fragment: shadowmask_pars_fragment,
    skinbase_vertex: skinbase_vertex,
    skinning_pars_vertex: skinning_pars_vertex,
    skinning_vertex: skinning_vertex,
    skinnormal_vertex: skinnormal_vertex,
    specularmap_fragment: specularmap_fragment,
    specularmap_pars_fragment: specularmap_pars_fragment,
    tonemapping_fragment: tonemapping_fragment,
    tonemapping_pars_fragment: tonemapping_pars_fragment,
    uv_pars_fragment: uv_pars_fragment,
    uv_pars_vertex: uv_pars_vertex,
    uv_vertex: uv_vertex,
    uv2_pars_fragment: uv2_pars_fragment,
    uv2_pars_vertex: uv2_pars_vertex,
    uv2_vertex: uv2_vertex,
    worldpos_vertex: worldpos_vertex,
    cube_frag: cube_frag,
    cube_vert: cube_vert,
    depth_frag: depth_frag,
    depth_vert: depth_vert,
    distanceRGBA_frag: distanceRGBA_frag,
    distanceRGBA_vert: distanceRGBA_vert,
    equirect_frag: equirect_frag,
    equirect_vert: equirect_vert,
    linedashed_frag: linedashed_frag,
    linedashed_vert: linedashed_vert,
    meshbasic_frag: meshbasic_frag,
    meshbasic_vert: meshbasic_vert,
    meshlambert_frag: meshlambert_frag,
    meshlambert_vert: meshlambert_vert,
    meshphong_frag: meshphong_frag,
    meshphong_vert: meshphong_vert,
    meshphysical_frag: meshphysical_frag,
    meshphysical_vert: meshphysical_vert,
    normal_frag: normal_frag,
    normal_vert: normal_vert,
    points_frag: points_frag,
    points_vert: points_vert,
    shadow_frag: shadow_frag,
    shadow_vert: shadow_vert
};
Color.prototype = {
    constructor: Color,
    isColor: true,
    r: 1,
    g: 1,
    b: 1,
    set: function (value) {
        if (value && value.isColor) {
            this.copy(value);
        } else if (typeof value === 'number') {
            this.setHex(value);
        } else if (typeof value === 'string') {
            this.setStyle(value);
        }
        return this;
    },
    setScalar: function (scalar) {
        this.r = scalar;
        this.g = scalar;
        this.b = scalar;
    },
    setHex: function (hex) {
        hex = Math.floor(hex);
        this.r = (hex >> 16 & 255) / 255;
        this.g = (hex >> 8 & 255) / 255;
        this.b = (hex & 255) / 255;
        return this;
    },
    setRGB: function (r, g, b) {
        this.r = r;
        this.g = g;
        this.b = b;
        return this;
    },
    setHSL: function () {
        function hue2rgb(p, q, t) {
            if (t < 0)
                t += 1;
            if (t > 1)
                t -= 1;
            if (t < 1 / 6)
                return p + (q - p) * 6 * t;
            if (t < 1 / 2)
                return q;
            if (t < 2 / 3)
                return p + (q - p) * 6 * (2 / 3 - t);
            return p;
        }
        return function setHSL(h, s, l) {
            h = exports.Math.euclideanModulo(h, 1);
            s = exports.Math.clamp(s, 0, 1);
            l = exports.Math.clamp(l, 0, 1);
            if (s === 0) {
                this.r = this.g = this.b = l;
            } else {
                var p = l <= 0.5 ? l * (1 + s) : l + s - l * s;
                var q = 2 * l - p;
                this.r = hue2rgb(q, p, h + 1 / 3);
                this.g = hue2rgb(q, p, h);
                this.b = hue2rgb(q, p, h - 1 / 3);
            }
            return this;
        };
    }(),
    setStyle: function (style) {
        function handleAlpha(string) {
            if (string === undefined)
                return;
            if (parseFloat(string) < 1) {
                console.warn('THREE.Color: Alpha component of ' + style + ' will be ignored.');
            }
        }
        var m;
        if (m = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(style)) {
            var color;
            var name = m[1];
            var components = m[2];
            switch (name) {
            case 'rgb':
            case 'rgba':
                if (color = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)) {
                    this.r = Math.min(255, parseInt(color[1], 10)) / 255;
                    this.g = Math.min(255, parseInt(color[2], 10)) / 255;
                    this.b = Math.min(255, parseInt(color[3], 10)) / 255;
                    handleAlpha(color[5]);
                    return this;
                }
                if (color = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)) {
                    this.r = Math.min(100, parseInt(color[1], 10)) / 100;
                    this.g = Math.min(100, parseInt(color[2], 10)) / 100;
                    this.b = Math.min(100, parseInt(color[3], 10)) / 100;
                    handleAlpha(color[5]);
                    return this;
                }
                break;
            case 'hsl':
            case 'hsla':
                if (color = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)) {
                    var h = parseFloat(color[1]) / 360;
                    var s = parseInt(color[2], 10) / 100;
                    var l = parseInt(color[3], 10) / 100;
                    handleAlpha(color[5]);
                    return this.setHSL(h, s, l);
                }
                break;
            }
        } else if (m = /^\#([A-Fa-f0-9]+)$/.exec(style)) {
            var hex = m[1];
            var size = hex.length;
            if (size === 3) {
                this.r = parseInt(hex.charAt(0) + hex.charAt(0), 16) / 255;
                this.g = parseInt(hex.charAt(1) + hex.charAt(1), 16) / 255;
                this.b = parseInt(hex.charAt(2) + hex.charAt(2), 16) / 255;
                return this;
            } else if (size === 6) {
                this.r = parseInt(hex.charAt(0) + hex.charAt(1), 16) / 255;
                this.g = parseInt(hex.charAt(2) + hex.charAt(3), 16) / 255;
                this.b = parseInt(hex.charAt(4) + hex.charAt(5), 16) / 255;
                return this;
            }
        }
        if (style && style.length > 0) {
            var hex = exports.ColorKeywords[style];
            if (hex !== undefined) {
                this.setHex(hex);
            } else {
                console.warn('THREE.Color: Unknown color ' + style);
            }
        }
        return this;
    },
    clone: function () {
        return new this.constructor(this.r, this.g, this.b);
    },
    copy: function (color) {
        this.r = color.r;
        this.g = color.g;
        this.b = color.b;
        return this;
    },
    copyGammaToLinear: function (color, gammaFactor) {
        if (gammaFactor === undefined)
            gammaFactor = 2;
        this.r = Math.pow(color.r, gammaFactor);
        this.g = Math.pow(color.g, gammaFactor);
        this.b = Math.pow(color.b, gammaFactor);
        return this;
    },
    copyLinearToGamma: function (color, gammaFactor) {
        if (gammaFactor === undefined)
            gammaFactor = 2;
        var safeInverse = gammaFactor > 0 ? 1 / gammaFactor : 1;
        this.r = Math.pow(color.r, safeInverse);
        this.g = Math.pow(color.g, safeInverse);
        this.b = Math.pow(color.b, safeInverse);
        return this;
    },
    convertGammaToLinear: function () {
        var r = this.r, g = this.g, b = this.b;
        this.r = r * r;
        this.g = g * g;
        this.b = b * b;
        return this;
    },
    convertLinearToGamma: function () {
        this.r = Math.sqrt(this.r);
        this.g = Math.sqrt(this.g);
        this.b = Math.sqrt(this.b);
        return this;
    },
    getHex: function () {
        return this.r * 255 << 16 ^ this.g * 255 << 8 ^ this.b * 255 << 0;
    },
    getHexString: function () {
        return ('000000' + this.getHex().toString(16)).slice(-6);
    },
    getHSL: function (optionalTarget) {
        var hsl = optionalTarget || {
            h: 0,
            s: 0,
            l: 0
        };
        var r = this.r, g = this.g, b = this.b;
        var max = Math.max(r, g, b);
        var min = Math.min(r, g, b);
        var hue, saturation;
        var lightness = (min + max) / 2;
        if (min === max) {
            hue = 0;
            saturation = 0;
        } else {
            var delta = max - min;
            saturation = lightness <= 0.5 ? delta / (max + min) : delta / (2 - max - min);
            switch (max) {
            case r:
                hue = (g - b) / delta + (g < b ? 6 : 0);
                break;
            case g:
                hue = (b - r) / delta + 2;
                break;
            case b:
                hue = (r - g) / delta + 4;
                break;
            }
            hue /= 6;
        }
        hsl.h = hue;
        hsl.s = saturation;
        hsl.l = lightness;
        return hsl;
    },
    getStyle: function () {
        return 'rgb(' + (this.r * 255 | 0) + ',' + (this.g * 255 | 0) + ',' + (this.b * 255 | 0) + ')';
    },
    offsetHSL: function (h, s, l) {
        var hsl = this.getHSL();
        hsl.h += h;
        hsl.s += s;
        hsl.l += l;
        this.setHSL(hsl.h, hsl.s, hsl.l);
        return this;
    },
    add: function (color) {
        this.r += color.r;
        this.g += color.g;
        this.b += color.b;
        return this;
    },
    addColors: function (color1, color2) {
        this.r = color1.r + color2.r;
        this.g = color1.g + color2.g;
        this.b = color1.b + color2.b;
        return this;
    },
    addScalar: function (s) {
        this.r += s;
        this.g += s;
        this.b += s;
        return this;
    },
    sub: function (color) {
        this.r = Math.max(0, this.r - color.r);
        this.g = Math.max(0, this.g - color.g);
        this.b = Math.max(0, this.b - color.b);
        return this;
    },
    multiply: function (color) {
        this.r *= color.r;
        this.g *= color.g;
        this.b *= color.b;
        return this;
    },
    multiplyScalar: function (s) {
        this.r *= s;
        this.g *= s;
        this.b *= s;
        return this;
    },
    lerp: function (color, alpha) {
        this.r += (color.r - this.r) * alpha;
        this.g += (color.g - this.g) * alpha;
        this.b += (color.b - this.b) * alpha;
        return this;
    },
    equals: function (c) {
        return c.r === this.r && c.g === this.g && c.b === this.b;
    },
    fromArray: function (array, offset) {
        if (offset === undefined)
            offset = 0;
        this.r = array[offset];
        this.g = array[offset + 1];
        this.b = array[offset + 2];
        return this;
    },
    toArray: function (array, offset) {
        if (array === undefined)
            array = [];
        if (offset === undefined)
            offset = 0;
        array[offset] = this.r;
        array[offset + 1] = this.g;
        array[offset + 2] = this.b;
        return array;
    },
    toJSON: function () {
        return this.getHex();
    }
};
exports.ColorKeywords = {
    'aliceblue': 15792383,
    'antiquewhite': 16444375,
    'aqua': 65535,
    'aquamarine': 8388564,
    'azure': 15794175,
    'beige': 16119260,
    'bisque': 16770244,
    'black': 0,
    'blanchedalmond': 16772045,
    'blue': 255,
    'blueviolet': 9055202,
    'brown': 10824234,
    'burlywood': 14596231,
    'cadetblue': 6266528,
    'chartreuse': 8388352,
    'chocolate': 13789470,
    'coral': 16744272,
    'cornflowerblue': 6591981,
    'cornsilk': 16775388,
    'crimson': 14423100,
    'cyan': 65535,
    'darkblue': 139,
    'darkcyan': 35723,
    'darkgoldenrod': 12092939,
    'darkgray': 11119017,
    'darkgreen': 25600,
    'darkgrey': 11119017,
    'darkkhaki': 12433259,
    'darkmagenta': 9109643,
    'darkolivegreen': 5597999,
    'darkorange': 16747520,
    'darkorchid': 10040012,
    'darkred': 9109504,
    'darksalmon': 15308410,
    'darkseagreen': 9419919,
    'darkslateblue': 4734347,
    'darkslategray': 3100495,
    'darkslategrey': 3100495,
    'darkturquoise': 52945,
    'darkviolet': 9699539,
    'deeppink': 16716947,
    'deepskyblue': 49151,
    'dimgray': 6908265,
    'dimgrey': 6908265,
    'dodgerblue': 2003199,
    'firebrick': 11674146,
    'floralwhite': 16775920,
    'forestgreen': 2263842,
    'fuchsia': 16711935,
    'gainsboro': 14474460,
    'ghostwhite': 16316671,
    'gold': 16766720,
    'goldenrod': 14329120,
    'gray': 8421504,
    'green': 32768,
    'greenyellow': 11403055,
    'grey': 8421504,
    'honeydew': 15794160,
    'hotpink': 16738740,
    'indianred': 13458524,
    'indigo': 4915330,
    'ivory': 16777200,
    'khaki': 15787660,
    'lavender': 15132410,
    'lavenderblush': 16773365,
    'lawngreen': 8190976,
    'lemonchiffon': 16775885,
    'lightblue': 11393254,
    'lightcoral': 15761536,
    'lightcyan': 14745599,
    'lightgoldenrodyellow': 16448210,
    'lightgray': 13882323,
    'lightgreen': 9498256,
    'lightgrey': 13882323,
    'lightpink': 16758465,
    'lightsalmon': 16752762,
    'lightseagreen': 2142890,
    'lightskyblue': 8900346,
    'lightslategray': 7833753,
    'lightslategrey': 7833753,
    'lightsteelblue': 11584734,
    'lightyellow': 16777184,
    'lime': 65280,
    'limegreen': 3329330,
    'linen': 16445670,
    'magenta': 16711935,
    'maroon': 8388608,
    'mediumaquamarine': 6737322,
    'mediumblue': 205,
    'mediumorchid': 12211667,
    'mediumpurple': 9662683,
    'mediumseagreen': 3978097,
    'mediumslateblue': 8087790,
    'mediumspringgreen': 64154,
    'mediumturquoise': 4772300,
    'mediumvioletred': 13047173,
    'midnightblue': 1644912,
    'mintcream': 16121850,
    'mistyrose': 16770273,
    'moccasin': 16770229,
    'navajowhite': 16768685,
    'navy': 128,
    'oldlace': 16643558,
    'olive': 8421376,
    'olivedrab': 7048739,
    'orange': 16753920,
    'orangered': 16729344,
    'orchid': 14315734,
    'palegoldenrod': 15657130,
    'palegreen': 10025880,
    'paleturquoise': 11529966,
    'palevioletred': 14381203,
    'papayawhip': 16773077,
    'peachpuff': 16767673,
    'peru': 13468991,
    'pink': 16761035,
    'plum': 14524637,
    'powderblue': 11591910,
    'purple': 8388736,
    'red': 16711680,
    'rosybrown': 12357519,
    'royalblue': 4286945,
    'saddlebrown': 9127187,
    'salmon': 16416882,
    'sandybrown': 16032864,
    'seagreen': 3050327,
    'seashell': 16774638,
    'sienna': 10506797,
    'silver': 12632256,
    'skyblue': 8900331,
    'slateblue': 6970061,
    'slategray': 7372944,
    'slategrey': 7372944,
    'snow': 16775930,
    'springgreen': 65407,
    'steelblue': 4620980,
    'tan': 13808780,
    'teal': 32896,
    'thistle': 14204888,
    'tomato': 16737095,
    'turquoise': 4251856,
    'violet': 15631086,
    'wheat': 16113331,
    'white': 16777215,
    'whitesmoke': 16119285,
    'yellow': 16776960,
    'yellowgreen': 10145074
};
UniformsLib = {
    common: {
        diffuse: {
            value: new Color(15658734)
        },
        opacity: {
            value: 1
        },
        map: {
            value: null
        },
        offsetRepeat: {
            value: new Vector4(0, 0, 1, 1)
        },
        specularMap: {
            value: null
        },
        alphaMap: {
            value: null
        },
        envMap: {
            value: null
        },
        flipEnvMap: {
            value: -1
        },
        reflectivity: {
            value: 1
        },
        refractionRatio: {
            value: 0.98
        }
    },
    aomap: {
        aoMap: {
            value: null
        },
        aoMapIntensity: {
            value: 1
        }
    },
    lightmap: {
        lightMap: {
            value: null
        },
        lightMapIntensity: {
            value: 1
        }
    },
    emissivemap: {
        emissiveMap: {
            value: null
        }
    },
    bumpmap: {
        bumpMap: {
            value: null
        },
        bumpScale: {
            value: 1
        }
    },
    normalmap: {
        normalMap: {
            value: null
        },
        normalScale: {
            value: new Vector2(1, 1)
        }
    },
    displacementmap: {
        displacementMap: {
            value: null
        },
        displacementScale: {
            value: 1
        },
        displacementBias: {
            value: 0
        }
    },
    roughnessmap: {
        roughnessMap: {
            value: null
        }
    },
    metalnessmap: {
        metalnessMap: {
            value: null
        }
    },
    fog: {
        fogDensity: {
            value: 0.00025
        },
        fogNear: {
            value: 1
        },
        fogFar: {
            value: 2000
        },
        fogColor: {
            value: new Color(16777215)
        }
    },
    lights: {
        ambientLightColor: {
            value: []
        },
        directionalLights: {
            value: [],
            properties: {
                direction: {},
                color: {},
                shadow: {},
                shadowBias: {},
                shadowRadius: {},
                shadowMapSize: {}
            }
        },
        directionalShadowMap: {
            value: []
        },
        directionalShadowMatrix: {
            value: []
        },
        spotLights: {
            value: [],
            properties: {
                color: {},
                position: {},
                direction: {},
                distance: {},
                coneCos: {},
                penumbraCos: {},
                decay: {},
                shadow: {},
                shadowBias: {},
                shadowRadius: {},
                shadowMapSize: {}
            }
        },
        spotShadowMap: {
            value: []
        },
        spotShadowMatrix: {
            value: []
        },
        pointLights: {
            value: [],
            properties: {
                color: {},
                position: {},
                decay: {},
                distance: {},
                shadow: {},
                shadowBias: {},
                shadowRadius: {},
                shadowMapSize: {}
            }
        },
        pointShadowMap: {
            value: []
        },
        pointShadowMatrix: {
            value: []
        },
        hemisphereLights: {
            value: [],
            properties: {
                direction: {},
                skyColor: {},
                groundColor: {}
            }
        }
    },
    points: {
        diffuse: {
            value: new Color(15658734)
        },
        opacity: {
            value: 1
        },
        size: {
            value: 1
        },
        scale: {
            value: 1
        },
        map: {
            value: null
        },
        offsetRepeat: {
            value: new Vector4(0, 0, 1, 1)
        }
    }
};
ShaderLib = {
    basic: {
        uniforms: exports.UniformsUtils.merge([
            UniformsLib.common,
            UniformsLib.aomap,
            UniformsLib.fog
        ]),
        vertexShader: ShaderChunk.meshbasic_vert,
        fragmentShader: ShaderChunk.meshbasic_frag
    },
    lambert: {
        uniforms: exports.UniformsUtils.merge([
            UniformsLib.common,
            UniformsLib.aomap,
            UniformsLib.lightmap,
            UniformsLib.emissivemap,
            UniformsLib.fog,
            UniformsLib.lights,
            {
                emissive: {
                    value: new Color(0)
                }
            }
        ]),
        vertexShader: ShaderChunk.meshlambert_vert,
        fragmentShader: ShaderChunk.meshlambert_frag
    },
    phong: {
        uniforms: exports.UniformsUtils.merge([
            UniformsLib.common,
            UniformsLib.aomap,
            UniformsLib.lightmap,
            UniformsLib.emissivemap,
            UniformsLib.bumpmap,
            UniformsLib.normalmap,
            UniformsLib.displacementmap,
            UniformsLib.fog,
            UniformsLib.lights,
            {
                emissive: {
                    value: new Color(0)
                },
                specular: {
                    value: new Color(1118481)
                },
                shininess: {
                    value: 30
                }
            }
        ]),
        vertexShader: ShaderChunk.meshphong_vert,
        fragmentShader: ShaderChunk.meshphong_frag
    },
    standard: {
        uniforms: exports.UniformsUtils.merge([
            UniformsLib.common,
            UniformsLib.aomap,
            UniformsLib.lightmap,
            UniformsLib.emissivemap,
            UniformsLib.bumpmap,
            UniformsLib.normalmap,
            UniformsLib.displacementmap,
            UniformsLib.roughnessmap,
            UniformsLib.metalnessmap,
            UniformsLib.fog,
            UniformsLib.lights,
            {
                emissive: {
                    value: new Color(0)
                },
                roughness: {
                    value: 0.5
                },
                metalness: {
                    value: 0
                },
                envMapIntensity: {
                    value: 1
                }
            }
        ]),
        vertexShader: ShaderChunk.meshphysical_vert,
        fragmentShader: ShaderChunk.meshphysical_frag
    },
    points: {
        uniforms: exports.UniformsUtils.merge([
            UniformsLib.points,
            UniformsLib.fog
        ]),
        vertexShader: ShaderChunk.points_vert,
        fragmentShader: ShaderChunk.points_frag
    },
    dashed: {
        uniforms: exports.UniformsUtils.merge([
            UniformsLib.common,
            UniformsLib.fog,
            {
                scale: {
                    value: 1
                },
                dashSize: {
                    value: 1
                },
                totalSize: {
                    value: 2
                }
            }
        ]),
        vertexShader: ShaderChunk.linedashed_vert,
        fragmentShader: ShaderChunk.linedashed_frag
    },
    depth: {
        uniforms: exports.UniformsUtils.merge([
            UniformsLib.common,
            UniformsLib.displacementmap
        ]),
        vertexShader: ShaderChunk.depth_vert,
        fragmentShader: ShaderChunk.depth_frag
    },
    normal: {
        uniforms: {
            opacity: {
                value: 1
            }
        },
        vertexShader: ShaderChunk.normal_vert,
        fragmentShader: ShaderChunk.normal_frag
    },
    cube: {
        uniforms: {
            tCube: {
                value: null
            },
            tFlip: {
                value: -1
            },
            opacity: {
                value: 1
            }
        },
        vertexShader: ShaderChunk.cube_vert,
        fragmentShader: ShaderChunk.cube_frag
    },
    equirect: {
        uniforms: {
            tEquirect: {
                value: null
            },
            tFlip: {
                value: -1
            }
        },
        vertexShader: ShaderChunk.equirect_vert,
        fragmentShader: ShaderChunk.equirect_frag
    },
    distanceRGBA: {
        uniforms: {
            lightPos: {
                value: new Vector3()
            }
        },
        vertexShader: ShaderChunk.distanceRGBA_vert,
        fragmentShader: ShaderChunk.distanceRGBA_frag
    }
};
ShaderLib.physical = {
    uniforms: exports.UniformsUtils.merge([
        ShaderLib.standard.uniforms,
        {
            clearCoat: {
                value: 0
            },
            clearCoatRoughness: {
                value: 0
            }
        }
    ]),
    vertexShader: ShaderChunk.meshphysical_vert,
    fragmentShader: ShaderChunk.meshphysical_frag
};
MeshDepthMaterial.prototype = Object.create(Material.prototype);
MeshDepthMaterial.prototype.constructor = MeshDepthMaterial;
MeshDepthMaterial.prototype.isMeshDepthMaterial = true;
MeshDepthMaterial.prototype.copy = function (source) {
    Material.prototype.copy.call(this, source);
    this.depthPacking = source.depthPacking;
    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    this.map = source.map;
    this.alphaMap = source.alphaMap;
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    return this;
};
Box3.prototype = {
    constructor: Box3,
    isBox3: true,
    set: function (min, max) {
        this.min.copy(min);
        this.max.copy(max);
        return this;
    },
    setFromArray: function (array) {
        var minX = +Infinity;
        var minY = +Infinity;
        var minZ = +Infinity;
        var maxX = -Infinity;
        var maxY = -Infinity;
        var maxZ = -Infinity;
        for (var i = 0, l = array.length; i < l; i += 3) {
            var x = array[i];
            var y = array[i + 1];
            var z = array[i + 2];
            if (x < minX)
                minX = x;
            if (y < minY)
                minY = y;
            if (z < minZ)
                minZ = z;
            if (x > maxX)
                maxX = x;
            if (y > maxY)
                maxY = y;
            if (z > maxZ)
                maxZ = z;
        }
        this.min.set(minX, minY, minZ);
        this.max.set(maxX, maxY, maxZ);
    },
    setFromPoints: function (points) {
        this.makeEmpty();
        for (var i = 0, il = points.length; i < il; i++) {
            this.expandByPoint(points[i]);
        }
        return this;
    },
    setFromCenterAndSize: function () {
        var v1 = new Vector3();
        return function setFromCenterAndSize(center, size) {
            var halfSize = v1.copy(size).multiplyScalar(0.5);
            this.min.copy(center).sub(halfSize);
            this.max.copy(center).add(halfSize);
            return this;
        };
    }(),
    setFromObject: function () {
        var v1 = new Vector3();
        return function setFromObject(object) {
            var scope = this;
            object.updateMatrixWorld(true);
            this.makeEmpty();
            object.traverse(function (node) {
                var geometry = node.geometry;
                if (geometry !== undefined) {
                    if (geometry && geometry.isGeometry) {
                        var vertices = geometry.vertices;
                        for (var i = 0, il = vertices.length; i < il; i++) {
                            v1.copy(vertices[i]);
                            v1.applyMatrix4(node.matrixWorld);
                            scope.expandByPoint(v1);
                        }
                    } else if (geometry && geometry.isBufferGeometry) {
                        var attribute = geometry.attributes.position;
                        if (attribute !== undefined) {
                            var array, offset, stride;
                            if (attribute && attribute.isInterleavedBufferAttribute) {
                                array = attribute.data.array;
                                offset = attribute.offset;
                                stride = attribute.data.stride;
                            } else {
                                array = attribute.array;
                                offset = 0;
                                stride = 3;
                            }
                            for (var i = offset, il = array.length; i < il; i += stride) {
                                v1.fromArray(array, i);
                                v1.applyMatrix4(node.matrixWorld);
                                scope.expandByPoint(v1);
                            }
                        }
                    }
                }
            });
            return this;
        };
    }(),
    clone: function () {
        return new this.constructor().copy(this);
    },
    copy: function (box) {
        this.min.copy(box.min);
        this.max.copy(box.max);
        return this;
    },
    makeEmpty: function () {
        this.min.x = this.min.y = this.min.z = +Infinity;
        this.max.x = this.max.y = this.max.z = -Infinity;
        return this;
    },
    isEmpty: function () {
        return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
    },
    center: function (optionalTarget) {
        var result = optionalTarget || new Vector3();
        return result.addVectors(this.min, this.max).multiplyScalar(0.5);
    },
    size: function (optionalTarget) {
        var result = optionalTarget || new Vector3();
        return result.subVectors(this.max, this.min);
    },
    expandByPoint: function (point) {
        this.min.min(point);
        this.max.max(point);
        return this;
    },
    expandByVector: function (vector) {
        this.min.sub(vector);
        this.max.add(vector);
        return this;
    },
    expandByScalar: function (scalar) {
        this.min.addScalar(-scalar);
        this.max.addScalar(scalar);
        return this;
    },
    containsPoint: function (point) {
        if (point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y || point.z < this.min.z || point.z > this.max.z) {
            return false;
        }
        return true;
    },
    containsBox: function (box) {
        if (this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z) {
            return true;
        }
        return false;
    },
    getParameter: function (point, optionalTarget) {
        var result = optionalTarget || new Vector3();
        return result.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y), (point.z - this.min.z) / (this.max.z - this.min.z));
    },
    intersectsBox: function (box) {
        if (box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y || box.max.z < this.min.z || box.min.z > this.max.z) {
            return false;
        }
        return true;
    },
    intersectsSphere: function () {
        var closestPoint;
        return function intersectsSphere(sphere) {
            if (closestPoint === undefined)
                closestPoint = new Vector3();
            this.clampPoint(sphere.center, closestPoint);
            return closestPoint.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;
        };
    }(),
    intersectsPlane: function (plane) {
        var min, max;
        if (plane.normal.x > 0) {
            min = plane.normal.x * this.min.x;
            max = plane.normal.x * this.max.x;
        } else {
            min = plane.normal.x * this.max.x;
            max = plane.normal.x * this.min.x;
        }
        if (plane.normal.y > 0) {
            min += plane.normal.y * this.min.y;
            max += plane.normal.y * this.max.y;
        } else {
            min += plane.normal.y * this.max.y;
            max += plane.normal.y * this.min.y;
        }
        if (plane.normal.z > 0) {
            min += plane.normal.z * this.min.z;
            max += plane.normal.z * this.max.z;
        } else {
            min += plane.normal.z * this.max.z;
            max += plane.normal.z * this.min.z;
        }
        return min <= plane.constant && max >= plane.constant;
    },
    clampPoint: function (point, optionalTarget) {
        var result = optionalTarget || new Vector3();
        return result.copy(point).clamp(this.min, this.max);
    },
    distanceToPoint: function () {
        var v1 = new Vector3();
        return function distanceToPoint(point) {
            var clampedPoint = v1.copy(point).clamp(this.min, this.max);
            return clampedPoint.sub(point).length();
        };
    }(),
    getBoundingSphere: function () {
        var v1 = new Vector3();
        return function getBoundingSphere(optionalTarget) {
            var result = optionalTarget || new Sphere();
            result.center = this.center();
            result.radius = this.size(v1).length() * 0.5;
            return result;
        };
    }(),
    intersect: function (box) {
        this.min.max(box.min);
        this.max.min(box.max);
        if (this.isEmpty())
            this.makeEmpty();
        return this;
    },
    union: function (box) {
        this.min.min(box.min);
        this.max.max(box.max);
        return this;
    },
    applyMatrix4: function () {
        var points = [
            new Vector3(),
            new Vector3(),
            new Vector3(),
            new Vector3(),
            new Vector3(),
            new Vector3(),
            new Vector3(),
            new Vector3()
        ];
        return function applyMatrix4(matrix) {
            if (this.isEmpty())
                return this;
            points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix);
            points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix);
            points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix);
            points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix);
            points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix);
            points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix);
            points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix);
            points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix);
            this.setFromPoints(points);
            return this;
        };
    }(),
    translate: function (offset) {
        this.min.add(offset);
        this.max.add(offset);
        return this;
    },
    equals: function (box) {
        return box.min.equals(this.min) && box.max.equals(this.max);
    }
};
Sphere.prototype = {
    constructor: Sphere,
    set: function (center, radius) {
        this.center.copy(center);
        this.radius = radius;
        return this;
    },
    setFromPoints: function () {
        var box = new Box3();
        return function setFromPoints(points, optionalCenter) {
            var center = this.center;
            if (optionalCenter !== undefined) {
                center.copy(optionalCenter);
            } else {
                box.setFromPoints(points).center(center);
            }
            var maxRadiusSq = 0;
            for (var i = 0, il = points.length; i < il; i++) {
                maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i]));
            }
            this.radius = Math.sqrt(maxRadiusSq);
            return this;
        };
    }(),
    clone: function () {
        return new this.constructor().copy(this);
    },
    copy: function (sphere) {
        this.center.copy(sphere.center);
        this.radius = sphere.radius;
        return this;
    },
    empty: function () {
        return this.radius <= 0;
    },
    containsPoint: function (point) {
        return point.distanceToSquared(this.center) <= this.radius * this.radius;
    },
    distanceToPoint: function (point) {
        return point.distanceTo(this.center) - this.radius;
    },
    intersectsSphere: function (sphere) {
        var radiusSum = this.radius + sphere.radius;
        return sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum;
    },
    intersectsBox: function (box) {
        return box.intersectsSphere(this);
    },
    intersectsPlane: function (plane) {
        return Math.abs(this.center.dot(plane.normal) - plane.constant) <= this.radius;
    },
    clampPoint: function (point, optionalTarget) {
        var deltaLengthSq = this.center.distanceToSquared(point);
        var result = optionalTarget || new Vector3();
        result.copy(point);
        if (deltaLengthSq > this.radius * this.radius) {
            result.sub(this.center).normalize();
            result.multiplyScalar(this.radius).add(this.center);
        }
        return result;
    },
    getBoundingBox: function (optionalTarget) {
        var box = optionalTarget || new Box3();
        box.set(this.center, this.center);
        box.expandByScalar(this.radius);
        return box;
    },
    applyMatrix4: function (matrix) {
        this.center.applyMatrix4(matrix);
        this.radius = this.radius * matrix.getMaxScaleOnAxis();
        return this;
    },
    translate: function (offset) {
        this.center.add(offset);
        return this;
    },
    equals: function (sphere) {
        return sphere.center.equals(this.center) && sphere.radius === this.radius;
    }
};
Matrix3.prototype = {
    constructor: Matrix3,
    isMatrix3: true,
    set: function (n11, n12, n13, n21, n22, n23, n31, n32, n33) {
        var te = this.elements;
        te[0] = n11;
        te[1] = n21;
        te[2] = n31;
        te[3] = n12;
        te[4] = n22;
        te[5] = n32;
        te[6] = n13;
        te[7] = n23;
        te[8] = n33;
        return this;
    },
    identity: function () {
        this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);
        return this;
    },
    clone: function () {
        return new this.constructor().fromArray(this.elements);
    },
    copy: function (m) {
        var me = m.elements;
        this.set(me[0], me[3], me[6], me[1], me[4], me[7], me[2], me[5], me[8]);
        return this;
    },
    setFromMatrix4: function (m) {
        var me = m.elements;
        this.set(me[0], me[4], me[8], me[1], me[5], me[9], me[2], me[6], me[10]);
        return this;
    },
    applyToVector3Array: function () {
        var v1;
        return function applyToVector3Array(array, offset, length) {
            if (v1 === undefined)
                v1 = new Vector3();
            if (offset === undefined)
                offset = 0;
            if (length === undefined)
                length = array.length;
            for (var i = 0, j = offset; i < length; i += 3, j += 3) {
                v1.fromArray(array, j);
                v1.applyMatrix3(this);
                v1.toArray(array, j);
            }
            return array;
        };
    }(),
    applyToBuffer: function () {
        var v1;
        return function applyToBuffer(buffer, offset, length) {
            if (v1 === undefined)
                v1 = new Vector3();
            if (offset === undefined)
                offset = 0;
            if (length === undefined)
                length = buffer.length / buffer.itemSize;
            for (var i = 0, j = offset; i < length; i++, j++) {
                v1.x = buffer.getX(j);
                v1.y = buffer.getY(j);
                v1.z = buffer.getZ(j);
                v1.applyMatrix3(this);
                buffer.setXYZ(v1.x, v1.y, v1.z);
            }
            return buffer;
        };
    }(),
    multiplyScalar: function (s) {
        var te = this.elements;
        te[0] *= s;
        te[3] *= s;
        te[6] *= s;
        te[1] *= s;
        te[4] *= s;
        te[7] *= s;
        te[2] *= s;
        te[5] *= s;
        te[8] *= s;
        return this;
    },
    determinant: function () {
        var te = this.elements;
        var a = te[0], b = te[1], c = te[2], d = te[3], e = te[4], f = te[5], g = te[6], h = te[7], i = te[8];
        return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;
    },
    getInverse: function (matrix, throwOnDegenerate) {
        if (matrix && matrix.isMatrix4) {
            console.error('THREE.Matrix3.getInverse no longer takes a Matrix4 argument.');
        }
        var me = matrix.elements, te = this.elements, n11 = me[0], n21 = me[1], n31 = me[2], n12 = me[3], n22 = me[4], n32 = me[5], n13 = me[6], n23 = me[7], n33 = me[8], t11 = n33 * n22 - n32 * n23, t12 = n32 * n13 - n33 * n12, t13 = n23 * n12 - n22 * n13, det = n11 * t11 + n21 * t12 + n31 * t13;
        if (det === 0) {
            var msg = 'THREE.Matrix3.getInverse(): can\'t invert matrix, determinant is 0';
            if (throwOnDegenerate === true) {
                throw new Error(msg);
            } else {
                console.warn(msg);
            }
            return this.identity();
        }
        var detInv = 1 / det;
        te[0] = t11 * detInv;
        te[1] = (n31 * n23 - n33 * n21) * detInv;
        te[2] = (n32 * n21 - n31 * n22) * detInv;
        te[3] = t12 * detInv;
        te[4] = (n33 * n11 - n31 * n13) * detInv;
        te[5] = (n31 * n12 - n32 * n11) * detInv;
        te[6] = t13 * detInv;
        te[7] = (n21 * n13 - n23 * n11) * detInv;
        te[8] = (n22 * n11 - n21 * n12) * detInv;
        return this;
    },
    transpose: function () {
        var tmp, m = this.elements;
        tmp = m[1];
        m[1] = m[3];
        m[3] = tmp;
        tmp = m[2];
        m[2] = m[6];
        m[6] = tmp;
        tmp = m[5];
        m[5] = m[7];
        m[7] = tmp;
        return this;
    },
    flattenToArrayOffset: function (array, offset) {
        console.warn('THREE.Matrix3: .flattenToArrayOffset is deprecated ' + '- just use .toArray instead.');
        return this.toArray(array, offset);
    },
    getNormalMatrix: function (matrix4) {
        return this.setFromMatrix4(matrix4).getInverse(this).transpose();
    },
    transposeIntoArray: function (r) {
        var m = this.elements;
        r[0] = m[0];
        r[1] = m[3];
        r[2] = m[6];
        r[3] = m[1];
        r[4] = m[4];
        r[5] = m[7];
        r[6] = m[2];
        r[7] = m[5];
        r[8] = m[8];
        return this;
    },
    fromArray: function (array) {
        this.elements.set(array);
        return this;
    },
    toArray: function (array, offset) {
        if (array === undefined)
            array = [];
        if (offset === undefined)
            offset = 0;
        var te = this.elements;
        array[offset] = te[0];
        array[offset + 1] = te[1];
        array[offset + 2] = te[2];
        array[offset + 3] = te[3];
        array[offset + 4] = te[4];
        array[offset + 5] = te[5];
        array[offset + 6] = te[6];
        array[offset + 7] = te[7];
        array[offset + 8] = te[8];
        return array;
    }
};
Plane.prototype = {
    constructor: Plane,
    set: function (normal, constant) {
        this.normal.copy(normal);
        this.constant = constant;
        return this;
    },
    setComponents: function (x, y, z, w) {
        this.normal.set(x, y, z);
        this.constant = w;
        return this;
    },
    setFromNormalAndCoplanarPoint: function (normal, point) {
        this.normal.copy(normal);
        this.constant = -point.dot(this.normal);
        return this;
    },
    setFromCoplanarPoints: function () {
        var v1 = new Vector3();
        var v2 = new Vector3();
        return function setFromCoplanarPoints(a, b, c) {
            var normal = v1.subVectors(c, b).cross(v2.subVectors(a, b)).normalize();
            this.setFromNormalAndCoplanarPoint(normal, a);
            return this;
        };
    }(),
    clone: function () {
        return new this.constructor().copy(this);
    },
    copy: function (plane) {
        this.normal.copy(plane.normal);
        this.constant = plane.constant;
        return this;
    },
    normalize: function () {
        var inverseNormalLength = 1 / this.normal.length();
        this.normal.multiplyScalar(inverseNormalLength);
        this.constant *= inverseNormalLength;
        return this;
    },
    negate: function () {
        this.constant *= -1;
        this.normal.negate();
        return this;
    },
    distanceToPoint: function (point) {
        return this.normal.dot(point) + this.constant;
    },
    distanceToSphere: function (sphere) {
        return this.distanceToPoint(sphere.center) - sphere.radius;
    },
    projectPoint: function (point, optionalTarget) {
        return this.orthoPoint(point, optionalTarget).sub(point).negate();
    },
    orthoPoint: function (point, optionalTarget) {
        var perpendicularMagnitude = this.distanceToPoint(point);
        var result = optionalTarget || new Vector3();
        return result.copy(this.normal).multiplyScalar(perpendicularMagnitude);
    },
    intersectLine: function () {
        var v1 = new Vector3();
        return function intersectLine(line, optionalTarget) {
            var result = optionalTarget || new Vector3();
            var direction = line.delta(v1);
            var denominator = this.normal.dot(direction);
            if (denominator === 0) {
                if (this.distanceToPoint(line.start) === 0) {
                    return result.copy(line.start);
                }
                return undefined;
            }
            var t = -(line.start.dot(this.normal) + this.constant) / denominator;
            if (t < 0 || t > 1) {
                return undefined;
            }
            return result.copy(direction).multiplyScalar(t).add(line.start);
        };
    }(),
    intersectsLine: function (line) {
        var startSign = this.distanceToPoint(line.start);
        var endSign = this.distanceToPoint(line.end);
        return startSign < 0 && endSign > 0 || endSign < 0 && startSign > 0;
    },
    intersectsBox: function (box) {
        return box.intersectsPlane(this);
    },
    intersectsSphere: function (sphere) {
        return sphere.intersectsPlane(this);
    },
    coplanarPoint: function (optionalTarget) {
        var result = optionalTarget || new Vector3();
        return result.copy(this.normal).multiplyScalar(-this.constant);
    },
    applyMatrix4: function () {
        var v1 = new Vector3();
        var m1 = new Matrix3();
        return function applyMatrix4(matrix, optionalNormalMatrix) {
            var referencePoint = this.coplanarPoint(v1).applyMatrix4(matrix);
            var normalMatrix = optionalNormalMatrix || m1.getNormalMatrix(matrix);
            var normal = this.normal.applyMatrix3(normalMatrix).normalize();
            this.constant = -referencePoint.dot(normal);
            return this;
        };
    }(),
    translate: function (offset) {
        this.constant = this.constant - offset.dot(this.normal);
        return this;
    },
    equals: function (plane) {
        return plane.normal.equals(this.normal) && plane.constant === this.constant;
    }
};
Frustum.prototype = {
    constructor: Frustum,
    set: function (p0, p1, p2, p3, p4, p5) {
        var planes = this.planes;
        planes[0].copy(p0);
        planes[1].copy(p1);
        planes[2].copy(p2);
        planes[3].copy(p3);
        planes[4].copy(p4);
        planes[5].copy(p5);
        return this;
    },
    clone: function () {
        return new this.constructor().copy(this);
    },
    copy: function (frustum) {
        var planes = this.planes;
        for (var i = 0; i < 6; i++) {
            planes[i].copy(frustum.planes[i]);
        }
        return this;
    },
    setFromMatrix: function (m) {
        var planes = this.planes;
        var me = m.elements;
        var me0 = me[0], me1 = me[1], me2 = me[2], me3 = me[3];
        var me4 = me[4], me5 = me[5], me6 = me[6], me7 = me[7];
        var me8 = me[8], me9 = me[9], me10 = me[10], me11 = me[11];
        var me12 = me[12], me13 = me[13], me14 = me[14], me15 = me[15];
        planes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize();
        planes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize();
        planes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize();
        planes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize();
        planes[4].setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14).normalize();
        planes[5].setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14).normalize();
        return this;
    },
    intersectsObject: function () {
        var sphere = new Sphere();
        return function intersectsObject(object) {
            var geometry = object.geometry;
            if (geometry.boundingSphere === null)
                geometry.computeBoundingSphere();
            sphere.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld);
            return this.intersectsSphere(sphere);
        };
    }(),
    intersectsSprite: function () {
        var sphere = new Sphere();
        return function intersectsSprite(sprite) {
            sphere.center.set(0, 0, 0);
            sphere.radius = 0.7071067811865476;
            sphere.applyMatrix4(sprite.matrixWorld);
            return this.intersectsSphere(sphere);
        };
    }(),
    intersectsSphere: function (sphere) {
        var planes = this.planes;
        var center = sphere.center;
        var negRadius = -sphere.radius;
        for (var i = 0; i < 6; i++) {
            var distance = planes[i].distanceToPoint(center);
            if (distance < negRadius) {
                return false;
            }
        }
        return true;
    },
    intersectsBox: function () {
        var p1 = new Vector3(), p2 = new Vector3();
        return function intersectsBox(box) {
            var planes = this.planes;
            for (var i = 0; i < 6; i++) {
                var plane = planes[i];
                p1.x = plane.normal.x > 0 ? box.min.x : box.max.x;
                p2.x = plane.normal.x > 0 ? box.max.x : box.min.x;
                p1.y = plane.normal.y > 0 ? box.min.y : box.max.y;
                p2.y = plane.normal.y > 0 ? box.max.y : box.min.y;
                p1.z = plane.normal.z > 0 ? box.min.z : box.max.z;
                p2.z = plane.normal.z > 0 ? box.max.z : box.min.z;
                var d1 = plane.distanceToPoint(p1);
                var d2 = plane.distanceToPoint(p2);
                if (d1 < 0 && d2 < 0) {
                    return false;
                }
            }
            return true;
        };
    }(),
    containsPoint: function (point) {
        var planes = this.planes;
        for (var i = 0; i < 6; i++) {
            if (planes[i].distanceToPoint(point) < 0) {
                return false;
            }
        }
        return true;
    }
};
programIdCount = 0;
BufferAttribute.prototype = {
    constructor: BufferAttribute,
    isBufferAttribute: true,
    get count() {
        return this.array.length / this.itemSize;
    },
    set needsUpdate(value) {
        if (value === true)
            this.version++;
    },
    setDynamic: function (value) {
        this.dynamic = value;
        return this;
    },
    copy: function (source) {
        this.array = new source.array.constructor(source.array);
        this.itemSize = source.itemSize;
        this.normalized = source.normalized;
        this.dynamic = source.dynamic;
        return this;
    },
    copyAt: function (index1, attribute, index2) {
        index1 *= this.itemSize;
        index2 *= attribute.itemSize;
        for (var i = 0, l = this.itemSize; i < l; i++) {
            this.array[index1 + i] = attribute.array[index2 + i];
        }
        return this;
    },
    copyArray: function (array) {
        this.array.set(array);
        return this;
    },
    copyColorsArray: function (colors) {
        var array = this.array, offset = 0;
        for (var i = 0, l = colors.length; i < l; i++) {
            var color = colors[i];
            if (color === undefined) {
                console.warn('THREE.BufferAttribute.copyColorsArray(): color is undefined', i);
                color = new Color();
            }
            array[offset++] = color.r;
            array[offset++] = color.g;
            array[offset++] = color.b;
        }
        return this;
    },
    copyIndicesArray: function (indices) {
        var array = this.array, offset = 0;
        for (var i = 0, l = indices.length; i < l; i++) {
            var index = indices[i];
            array[offset++] = index.a;
            array[offset++] = index.b;
            array[offset++] = index.c;
        }
        return this;
    },
    copyVector2sArray: function (vectors) {
        var array = this.array, offset = 0;
        for (var i = 0, l = vectors.length; i < l; i++) {
            var vector = vectors[i];
            if (vector === undefined) {
                console.warn('THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i);
                vector = new Vector2();
            }
            array[offset++] = vector.x;
            array[offset++] = vector.y;
        }
        return this;
    },
    copyVector3sArray: function (vectors) {
        var array = this.array, offset = 0;
        for (var i = 0, l = vectors.length; i < l; i++) {
            var vector = vectors[i];
            if (vector === undefined) {
                console.warn('THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i);
                vector = new Vector3();
            }
            array[offset++] = vector.x;
            array[offset++] = vector.y;
            array[offset++] = vector.z;
        }
        return this;
    },
    copyVector4sArray: function (vectors) {
        var array = this.array, offset = 0;
        for (var i = 0, l = vectors.length; i < l; i++) {
            var vector = vectors[i];
            if (vector === undefined) {
                console.warn('THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i);
                vector = new Vector4();
            }
            array[offset++] = vector.x;
            array[offset++] = vector.y;
            array[offset++] = vector.z;
            array[offset++] = vector.w;
        }
        return this;
    },
    set: function (value, offset) {
        if (offset === undefined)
            offset = 0;
        this.array.set(value, offset);
        return this;
    },
    getX: function (index) {
        return this.array[index * this.itemSize];
    },
    setX: function (index, x) {
        this.array[index * this.itemSize] = x;
        return this;
    },
    getY: function (index) {
        return this.array[index * this.itemSize + 1];
    },
    setY: function (index, y) {
        this.array[index * this.itemSize + 1] = y;
        return this;
    },
    getZ: function (index) {
        return this.array[index * this.itemSize + 2];
    },
    setZ: function (index, z) {
        this.array[index * this.itemSize + 2] = z;
        return this;
    },
    getW: function (index) {
        return this.array[index * this.itemSize + 3];
    },
    setW: function (index, w) {
        this.array[index * this.itemSize + 3] = w;
        return this;
    },
    setXY: function (index, x, y) {
        index *= this.itemSize;
        this.array[index + 0] = x;
        this.array[index + 1] = y;
        return this;
    },
    setXYZ: function (index, x, y, z) {
        index *= this.itemSize;
        this.array[index + 0] = x;
        this.array[index + 1] = y;
        this.array[index + 2] = z;
        return this;
    },
    setXYZW: function (index, x, y, z, w) {
        index *= this.itemSize;
        this.array[index + 0] = x;
        this.array[index + 1] = y;
        this.array[index + 2] = z;
        this.array[index + 3] = w;
        return this;
    },
    clone: function () {
        return new this.constructor().copy(this);
    }
};
Face3.prototype = {
    constructor: Face3,
    clone: function () {
        return new this.constructor().copy(this);
    },
    copy: function (source) {
        this.a = source.a;
        this.b = source.b;
        this.c = source.c;
        this.normal.copy(source.normal);
        this.color.copy(source.color);
        this.materialIndex = source.materialIndex;
        for (var i = 0, il = source.vertexNormals.length; i < il; i++) {
            this.vertexNormals[i] = source.vertexNormals[i].clone();
        }
        for (var i = 0, il = source.vertexColors.length; i < il; i++) {
            this.vertexColors[i] = source.vertexColors[i].clone();
        }
        return this;
    }
};
Euler.RotationOrders = [
    'XYZ',
    'YZX',
    'ZXY',
    'XZY',
    'YXZ',
    'ZYX'
];
Euler.DefaultOrder = 'XYZ';
Euler.prototype = {
    constructor: Euler,
    isEuler: true,
    get x() {
        return this._x;
    },
    set x(value) {
        this._x = value;
        this.onChangeCallback();
    },
    get y() {
        return this._y;
    },
    set y(value) {
        this._y = value;
        this.onChangeCallback();
    },
    get z() {
        return this._z;
    },
    set z(value) {
        this._z = value;
        this.onChangeCallback();
    },
    get order() {
        return this._order;
    },
    set order(value) {
        this._order = value;
        this.onChangeCallback();
    },
    set: function (x, y, z, order) {
        this._x = x;
        this._y = y;
        this._z = z;
        this._order = order || this._order;
        this.onChangeCallback();
        return this;
    },
    clone: function () {
        return new this.constructor(this._x, this._y, this._z, this._order);
    },
    copy: function (euler) {
        this._x = euler._x;
        this._y = euler._y;
        this._z = euler._z;
        this._order = euler._order;
        this.onChangeCallback();
        return this;
    },
    setFromRotationMatrix: function (m, order, update) {
        var clamp = exports.Math.clamp;
        var te = m.elements;
        var m11 = te[0], m12 = te[4], m13 = te[8];
        var m21 = te[1], m22 = te[5], m23 = te[9];
        var m31 = te[2], m32 = te[6], m33 = te[10];
        order = order || this._order;
        if (order === 'XYZ') {
            this._y = Math.asin(clamp(m13, -1, 1));
            if (Math.abs(m13) < 0.99999) {
                this._x = Math.atan2(-m23, m33);
                this._z = Math.atan2(-m12, m11);
            } else {
                this._x = Math.atan2(m32, m22);
                this._z = 0;
            }
        } else if (order === 'YXZ') {
            this._x = Math.asin(-clamp(m23, -1, 1));
            if (Math.abs(m23) < 0.99999) {
                this._y = Math.atan2(m13, m33);
                this._z = Math.atan2(m21, m22);
            } else {
                this._y = Math.atan2(-m31, m11);
                this._z = 0;
            }
        } else if (order === 'ZXY') {
            this._x = Math.asin(clamp(m32, -1, 1));
            if (Math.abs(m32) < 0.99999) {
                this._y = Math.atan2(-m31, m33);
                this._z = Math.atan2(-m12, m22);
            } else {
                this._y = 0;
                this._z = Math.atan2(m21, m11);
            }
        } else if (order === 'ZYX') {
            this._y = Math.asin(-clamp(m31, -1, 1));
            if (Math.abs(m31) < 0.99999) {
                this._x = Math.atan2(m32, m33);
                this._z = Math.atan2(m21, m11);
            } else {
                this._x = 0;
                this._z = Math.atan2(-m12, m22);
            }
        } else if (order === 'YZX') {
            this._z = Math.asin(clamp(m21, -1, 1));
            if (Math.abs(m21) < 0.99999) {
                this._x = Math.atan2(-m23, m22);
                this._y = Math.atan2(-m31, m11);
            } else {
                this._x = 0;
                this._y = Math.atan2(m13, m33);
            }
        } else if (order === 'XZY') {
            this._z = Math.asin(-clamp(m12, -1, 1));
            if (Math.abs(m12) < 0.99999) {
                this._x = Math.atan2(m32, m22);
                this._y = Math.atan2(m13, m11);
            } else {
                this._x = Math.atan2(-m23, m33);
                this._y = 0;
            }
        } else {
            console.warn('THREE.Euler: .setFromRotationMatrix() given unsupported order: ' + order);
        }
        this._order = order;
        if (update !== false)
            this.onChangeCallback();
        return this;
    },
    setFromQuaternion: function () {
        var matrix;
        return function setFromQuaternion(q, order, update) {
            if (matrix === undefined)
                matrix = new Matrix4();
            matrix.makeRotationFromQuaternion(q);
            return this.setFromRotationMatrix(matrix, order, update);
        };
    }(),
    setFromVector3: function (v, order) {
        return this.set(v.x, v.y, v.z, order || this._order);
    },
    reorder: function () {
        var q = new Quaternion();
        return function reorder(newOrder) {
            q.setFromEuler(this);
            return this.setFromQuaternion(q, newOrder);
        };
    }(),
    equals: function (euler) {
        return euler._x === this._x && euler._y === this._y && euler._z === this._z && euler._order === this._order;
    },
    fromArray: function (array) {
        this._x = array[0];
        this._y = array[1];
        this._z = array[2];
        if (array[3] !== undefined)
            this._order = array[3];
        this.onChangeCallback();
        return this;
    },
    toArray: function (array, offset) {
        if (array === undefined)
            array = [];
        if (offset === undefined)
            offset = 0;
        array[offset] = this._x;
        array[offset + 1] = this._y;
        array[offset + 2] = this._z;
        array[offset + 3] = this._order;
        return array;
    },
    toVector3: function (optionalResult) {
        if (optionalResult) {
            return optionalResult.set(this._x, this._y, this._z);
        } else {
            return new Vector3(this._x, this._y, this._z);
        }
    },
    onChange: function (callback) {
        this.onChangeCallback = callback;
        return this;
    },
    onChangeCallback: function () {
    }
};
Layers.prototype = {
    constructor: Layers,
    set: function (channel) {
        this.mask = 1 << channel;
    },
    enable: function (channel) {
        this.mask |= 1 << channel;
    },
    toggle: function (channel) {
        this.mask ^= 1 << channel;
    },
    disable: function (channel) {
        this.mask &= ~(1 << channel);
    },
    test: function (layers) {
        return (this.mask & layers.mask) !== 0;
    }
};
Object3D.DefaultUp = new Vector3(0, 1, 0);
Object3D.DefaultMatrixAutoUpdate = true;
Object.assign(Object3D.prototype, EventDispatcher.prototype, {
    isObject3D: true,
    applyMatrix: function (matrix) {
        this.matrix.multiplyMatrices(matrix, this.matrix);
        this.matrix.decompose(this.position, this.quaternion, this.scale);
    },
    setRotationFromAxisAngle: function (axis, angle) {
        this.quaternion.setFromAxisAngle(axis, angle);
    },
    setRotationFromEuler: function (euler) {
        this.quaternion.setFromEuler(euler, true);
    },
    setRotationFromMatrix: function (m) {
        this.quaternion.setFromRotationMatrix(m);
    },
    setRotationFromQuaternion: function (q) {
        this.quaternion.copy(q);
    },
    rotateOnAxis: function () {
        var q1 = new Quaternion();
        return function rotateOnAxis(axis, angle) {
            q1.setFromAxisAngle(axis, angle);
            this.quaternion.multiply(q1);
            return this;
        };
    }(),
    rotateX: function () {
        var v1 = new Vector3(1, 0, 0);
        return function rotateX(angle) {
            return this.rotateOnAxis(v1, angle);
        };
    }(),
    rotateY: function () {
        var v1 = new Vector3(0, 1, 0);
        return function rotateY(angle) {
            return this.rotateOnAxis(v1, angle);
        };
    }(),
    rotateZ: function () {
        var v1 = new Vector3(0, 0, 1);
        return function rotateZ(angle) {
            return this.rotateOnAxis(v1, angle);
        };
    }(),
    translateOnAxis: function () {
        var v1 = new Vector3();
        return function translateOnAxis(axis, distance) {
            v1.copy(axis).applyQuaternion(this.quaternion);
            this.position.add(v1.multiplyScalar(distance));
            return this;
        };
    }(),
    translateX: function () {
        var v1 = new Vector3(1, 0, 0);
        return function translateX(distance) {
            return this.translateOnAxis(v1, distance);
        };
    }(),
    translateY: function () {
        var v1 = new Vector3(0, 1, 0);
        return function translateY(distance) {
            return this.translateOnAxis(v1, distance);
        };
    }(),
    translateZ: function () {
        var v1 = new Vector3(0, 0, 1);
        return function translateZ(distance) {
            return this.translateOnAxis(v1, distance);
        };
    }(),
    localToWorld: function (vector) {
        return vector.applyMatrix4(this.matrixWorld);
    },
    worldToLocal: function () {
        var m1 = new Matrix4();
        return function worldToLocal(vector) {
            return vector.applyMatrix4(m1.getInverse(this.matrixWorld));
        };
    }(),
    lookAt: function () {
        var m1 = new Matrix4();
        return function lookAt(vector) {
            m1.lookAt(vector, this.position, this.up);
            this.quaternion.setFromRotationMatrix(m1);
        };
    }(),
    add: function (object) {
        if (arguments.length > 1) {
            for (var i = 0; i < arguments.length; i++) {
                this.add(arguments[i]);
            }
            return this;
        }
        if (object === this) {
            console.error('THREE.Object3D.add: object can\'t be added as a child of itself.', object);
            return this;
        }
        if (object && object.isObject3D) {
            if (object.parent !== null) {
                object.parent.remove(object);
            }
            object.parent = this;
            object.dispatchEvent({
                type: 'added'
            });
            this.children.push(object);
        } else {
            console.error('THREE.Object3D.add: object not an instance of THREE.Object3D.', object);
        }
        return this;
    },
    remove: function (object) {
        if (arguments.length > 1) {
            for (var i = 0; i < arguments.length; i++) {
                this.remove(arguments[i]);
            }
        }
        var index = this.children.indexOf(object);
        if (index !== -1) {
            object.parent = null;
            object.dispatchEvent({
                type: 'removed'
            });
            this.children.splice(index, 1);
        }
    },
    getObjectById: function (id) {
        return this.getObjectByProperty('id', id);
    },
    getObjectByName: function (name) {
        return this.getObjectByProperty('name', name);
    },
    getObjectByProperty: function (name, value) {
        if (this[name] === value)
            return this;
        for (var i = 0, l = this.children.length; i < l; i++) {
            var child = this.children[i];
            var object = child.getObjectByProperty(name, value);
            if (object !== undefined) {
                return object;
            }
        }
        return undefined;
    },
    getWorldPosition: function (optionalTarget) {
        var result = optionalTarget || new Vector3();
        this.updateMatrixWorld(true);
        return result.setFromMatrixPosition(this.matrixWorld);
    },
    getWorldQuaternion: function () {
        var position = new Vector3();
        var scale = new Vector3();
        return function getWorldQuaternion(optionalTarget) {
            var result = optionalTarget || new Quaternion();
            this.updateMatrixWorld(true);
            this.matrixWorld.decompose(position, result, scale);
            return result;
        };
    }(),
    getWorldRotation: function () {
        var quaternion = new Quaternion();
        return function getWorldRotation(optionalTarget) {
            var result = optionalTarget || new Euler();
            this.getWorldQuaternion(quaternion);
            return result.setFromQuaternion(quaternion, this.rotation.order, false);
        };
    }(),
    getWorldScale: function () {
        var position = new Vector3();
        var quaternion = new Quaternion();
        return function getWorldScale(optionalTarget) {
            var result = optionalTarget || new Vector3();
            this.updateMatrixWorld(true);
            this.matrixWorld.decompose(position, quaternion, result);
            return result;
        };
    }(),
    getWorldDirection: function () {
        var quaternion = new Quaternion();
        return function getWorldDirection(optionalTarget) {
            var result = optionalTarget || new Vector3();
            this.getWorldQuaternion(quaternion);
            return result.set(0, 0, 1).applyQuaternion(quaternion);
        };
    }(),
    raycast: function () {
    },
    traverse: function (callback) {
        callback(this);
        var children = this.children;
        for (var i = 0, l = children.length; i < l; i++) {
            children[i].traverse(callback);
        }
    },
    traverseVisible: function (callback) {
        if (this.visible === false)
            return;
        callback(this);
        var children = this.children;
        for (var i = 0, l = children.length; i < l; i++) {
            children[i].traverseVisible(callback);
        }
    },
    traverseAncestors: function (callback) {
        var parent = this.parent;
        if (parent !== null) {
            callback(parent);
            parent.traverseAncestors(callback);
        }
    },
    updateMatrix: function () {
        this.matrix.compose(this.position, this.quaternion, this.scale);
        this.matrixWorldNeedsUpdate = true;
    },
    updateMatrixWorld: function (force) {
        if (this.matrixAutoUpdate === true)
            this.updateMatrix();
        if (this.matrixWorldNeedsUpdate === true || force === true) {
            if (this.parent === null) {
                this.matrixWorld.copy(this.matrix);
            } else {
                this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
            }
            this.matrixWorldNeedsUpdate = false;
            force = true;
        }
        var children = this.children;
        for (var i = 0, l = children.length; i < l; i++) {
            children[i].updateMatrixWorld(force);
        }
    },
    toJSON: function (meta) {
        var isRootObject = meta === undefined || meta === '';
        var output = {};
        if (isRootObject) {
            meta = {
                geometries: {},
                materials: {},
                textures: {},
                images: {}
            };
            output.metadata = {
                version: 4.4,
                type: 'Object',
                generator: 'Object3D.toJSON'
            };
        }
        var object = {};
        object.uuid = this.uuid;
        object.type = this.type;
        if (this.name !== '')
            object.name = this.name;
        if (JSON.stringify(this.userData) !== '{}')
            object.userData = this.userData;
        if (this.castShadow === true)
            object.castShadow = true;
        if (this.receiveShadow === true)
            object.receiveShadow = true;
        if (this.visible === false)
            object.visible = false;
        object.matrix = this.matrix.toArray();
        if (this.geometry !== undefined) {
            if (meta.geometries[this.geometry.uuid] === undefined) {
                meta.geometries[this.geometry.uuid] = this.geometry.toJSON(meta);
            }
            object.geometry = this.geometry.uuid;
        }
        if (this.material !== undefined) {
            if (meta.materials[this.material.uuid] === undefined) {
                meta.materials[this.material.uuid] = this.material.toJSON(meta);
            }
            object.material = this.material.uuid;
        }
        if (this.children.length > 0) {
            object.children = [];
            for (var i = 0; i < this.children.length; i++) {
                object.children.push(this.children[i].toJSON(meta).object);
            }
        }
        if (isRootObject) {
            var geometries = extractFromCache(meta.geometries);
            var materials = extractFromCache(meta.materials);
            var textures = extractFromCache(meta.textures);
            var images = extractFromCache(meta.images);
            if (geometries.length > 0)
                output.geometries = geometries;
            if (materials.length > 0)
                output.materials = materials;
            if (textures.length > 0)
                output.textures = textures;
            if (images.length > 0)
                output.images = images;
        }
        output.object = object;
        return output;
        function extractFromCache(cache) {
            var values = [];
            for (var key in cache) {
                var data = cache[key];
                delete data.metadata;
                values.push(data);
            }
            return values;
        }
    },
    clone: function (recursive) {
        return new this.constructor().copy(this, recursive);
    },
    copy: function (source, recursive) {
        if (recursive === undefined)
            recursive = true;
        this.name = source.name;
        this.up.copy(source.up);
        this.position.copy(source.position);
        this.quaternion.copy(source.quaternion);
        this.scale.copy(source.scale);
        this.matrix.copy(source.matrix);
        this.matrixWorld.copy(source.matrixWorld);
        this.matrixAutoUpdate = source.matrixAutoUpdate;
        this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;
        this.visible = source.visible;
        this.castShadow = source.castShadow;
        this.receiveShadow = source.receiveShadow;
        this.frustumCulled = source.frustumCulled;
        this.renderOrder = source.renderOrder;
        this.userData = JSON.parse(JSON.stringify(source.userData));
        if (recursive === true) {
            for (var i = 0; i < source.children.length; i++) {
                var child = source.children[i];
                this.add(child.clone());
            }
        }
        return this;
    }
});
count$3 = 0;
;
Object.assign(Geometry.prototype, EventDispatcher.prototype, {
    isGeometry: true,
    applyMatrix: function (matrix) {
        var normalMatrix = new Matrix3().getNormalMatrix(matrix);
        for (var i = 0, il = this.vertices.length; i < il; i++) {
            var vertex = this.vertices[i];
            vertex.applyMatrix4(matrix);
        }
        for (var i = 0, il = this.faces.length; i < il; i++) {
            var face = this.faces[i];
            face.normal.applyMatrix3(normalMatrix).normalize();
            for (var j = 0, jl = face.vertexNormals.length; j < jl; j++) {
                face.vertexNormals[j].applyMatrix3(normalMatrix).normalize();
            }
        }
        if (this.boundingBox !== null) {
            this.computeBoundingBox();
        }
        if (this.boundingSphere !== null) {
            this.computeBoundingSphere();
        }
        this.verticesNeedUpdate = true;
        this.normalsNeedUpdate = true;
        return this;
    },
    rotateX: function () {
        var m1;
        return function rotateX(angle) {
            if (m1 === undefined)
                m1 = new Matrix4();
            m1.makeRotationX(angle);
            this.applyMatrix(m1);
            return this;
        };
    }(),
    rotateY: function () {
        var m1;
        return function rotateY(angle) {
            if (m1 === undefined)
                m1 = new Matrix4();
            m1.makeRotationY(angle);
            this.applyMatrix(m1);
            return this;
        };
    }(),
    rotateZ: function () {
        var m1;
        return function rotateZ(angle) {
            if (m1 === undefined)
                m1 = new Matrix4();
            m1.makeRotationZ(angle);
            this.applyMatrix(m1);
            return this;
        };
    }(),
    translate: function () {
        var m1;
        return function translate(x, y, z) {
            if (m1 === undefined)
                m1 = new Matrix4();
            m1.makeTranslation(x, y, z);
            this.applyMatrix(m1);
            return this;
        };
    }(),
    scale: function () {
        var m1;
        return function scale(x, y, z) {
            if (m1 === undefined)
                m1 = new Matrix4();
            m1.makeScale(x, y, z);
            this.applyMatrix(m1);
            return this;
        };
    }(),
    lookAt: function () {
        var obj;
        return function lookAt(vector) {
            if (obj === undefined)
                obj = new Object3D();
            obj.lookAt(vector);
            obj.updateMatrix();
            this.applyMatrix(obj.matrix);
        };
    }(),
    fromBufferGeometry: function (geometry) {
        var scope = this;
        var indices = geometry.index !== null ? geometry.index.array : undefined;
        var attributes = geometry.attributes;
        var positions = attributes.position.array;
        var normals = attributes.normal !== undefined ? attributes.normal.array : undefined;
        var colors = attributes.color !== undefined ? attributes.color.array : undefined;
        var uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;
        var uvs2 = attributes.uv2 !== undefined ? attributes.uv2.array : undefined;
        if (uvs2 !== undefined)
            this.faceVertexUvs[1] = [];
        var tempNormals = [];
        var tempUVs = [];
        var tempUVs2 = [];
        for (var i = 0, j = 0; i < positions.length; i += 3, j += 2) {
            scope.vertices.push(new Vector3(positions[i], positions[i + 1], positions[i + 2]));
            if (normals !== undefined) {
                tempNormals.push(new Vector3(normals[i], normals[i + 1], normals[i + 2]));
            }
            if (colors !== undefined) {
                scope.colors.push(new Color(colors[i], colors[i + 1], colors[i + 2]));
            }
            if (uvs !== undefined) {
                tempUVs.push(new Vector2(uvs[j], uvs[j + 1]));
            }
            if (uvs2 !== undefined) {
                tempUVs2.push(new Vector2(uvs2[j], uvs2[j + 1]));
            }
        }
        function addFace(a, b, c, materialIndex) {
            var vertexNormals = normals !== undefined ? [
                tempNormals[a].clone(),
                tempNormals[b].clone(),
                tempNormals[c].clone()
            ] : [];
            var vertexColors = colors !== undefined ? [
                scope.colors[a].clone(),
                scope.colors[b].clone(),
                scope.colors[c].clone()
            ] : [];
            var face = new Face3(a, b, c, vertexNormals, vertexColors, materialIndex);
            scope.faces.push(face);
            if (uvs !== undefined) {
                scope.faceVertexUvs[0].push([
                    tempUVs[a].clone(),
                    tempUVs[b].clone(),
                    tempUVs[c].clone()
                ]);
            }
            if (uvs2 !== undefined) {
                scope.faceVertexUvs[1].push([
                    tempUVs2[a].clone(),
                    tempUVs2[b].clone(),
                    tempUVs2[c].clone()
                ]);
            }
        }
        if (indices !== undefined) {
            var groups = geometry.groups;
            if (groups.length > 0) {
                for (var i = 0; i < groups.length; i++) {
                    var group = groups[i];
                    var start = group.start;
                    var count = group.count;
                    for (var j = start, jl = start + count; j < jl; j += 3) {
                        addFace(indices[j], indices[j + 1], indices[j + 2], group.materialIndex);
                    }
                }
            } else {
                for (var i = 0; i < indices.length; i += 3) {
                    addFace(indices[i], indices[i + 1], indices[i + 2]);
                }
            }
        } else {
            for (var i = 0; i < positions.length / 3; i += 3) {
                addFace(i, i + 1, i + 2);
            }
        }
        this.computeFaceNormals();
        if (geometry.boundingBox !== null) {
            this.boundingBox = geometry.boundingBox.clone();
        }
        if (geometry.boundingSphere !== null) {
            this.boundingSphere = geometry.boundingSphere.clone();
        }
        return this;
    },
    center: function () {
        this.computeBoundingBox();
        var offset = this.boundingBox.center().negate();
        this.translate(offset.x, offset.y, offset.z);
        return offset;
    },
    normalize: function () {
        this.computeBoundingSphere();
        var center = this.boundingSphere.center;
        var radius = this.boundingSphere.radius;
        var s = radius === 0 ? 1 : 1 / radius;
        var matrix = new Matrix4();
        matrix.set(s, 0, 0, -s * center.x, 0, s, 0, -s * center.y, 0, 0, s, -s * center.z, 0, 0, 0, 1);
        this.applyMatrix(matrix);
        return this;
    },
    computeFaceNormals: function () {
        var cb = new Vector3(), ab = new Vector3();
        for (var f = 0, fl = this.faces.length; f < fl; f++) {
            var face = this.faces[f];
            var vA = this.vertices[face.a];
            var vB = this.vertices[face.b];
            var vC = this.vertices[face.c];
            cb.subVectors(vC, vB);
            ab.subVectors(vA, vB);
            cb.cross(ab);
            cb.normalize();
            face.normal.copy(cb);
        }
    },
    computeVertexNormals: function (areaWeighted) {
        if (areaWeighted === undefined)
            areaWeighted = true;
        var v, vl, f, fl, face, vertices;
        vertices = new Array(this.vertices.length);
        for (v = 0, vl = this.vertices.length; v < vl; v++) {
            vertices[v] = new Vector3();
        }
        if (areaWeighted) {
            var vA, vB, vC;
            var cb = new Vector3(), ab = new Vector3();
            for (f = 0, fl = this.faces.length; f < fl; f++) {
                face = this.faces[f];
                vA = this.vertices[face.a];
                vB = this.vertices[face.b];
                vC = this.vertices[face.c];
                cb.subVectors(vC, vB);
                ab.subVectors(vA, vB);
                cb.cross(ab);
                vertices[face.a].add(cb);
                vertices[face.b].add(cb);
                vertices[face.c].add(cb);
            }
        } else {
            for (f = 0, fl = this.faces.length; f < fl; f++) {
                face = this.faces[f];
                vertices[face.a].add(face.normal);
                vertices[face.b].add(face.normal);
                vertices[face.c].add(face.normal);
            }
        }
        for (v = 0, vl = this.vertices.length; v < vl; v++) {
            vertices[v].normalize();
        }
        for (f = 0, fl = this.faces.length; f < fl; f++) {
            face = this.faces[f];
            var vertexNormals = face.vertexNormals;
            if (vertexNormals.length === 3) {
                vertexNormals[0].copy(vertices[face.a]);
                vertexNormals[1].copy(vertices[face.b]);
                vertexNormals[2].copy(vertices[face.c]);
            } else {
                vertexNormals[0] = vertices[face.a].clone();
                vertexNormals[1] = vertices[face.b].clone();
                vertexNormals[2] = vertices[face.c].clone();
            }
        }
        if (this.faces.length > 0) {
            this.normalsNeedUpdate = true;
        }
    },
    computeMorphNormals: function () {
        var i, il, f, fl, face;
        for (f = 0, fl = this.faces.length; f < fl; f++) {
            face = this.faces[f];
            if (!face.__originalFaceNormal) {
                face.__originalFaceNormal = face.normal.clone();
            } else {
                face.__originalFaceNormal.copy(face.normal);
            }
            if (!face.__originalVertexNormals)
                face.__originalVertexNormals = [];
            for (i = 0, il = face.vertexNormals.length; i < il; i++) {
                if (!face.__originalVertexNormals[i]) {
                    face.__originalVertexNormals[i] = face.vertexNormals[i].clone();
                } else {
                    face.__originalVertexNormals[i].copy(face.vertexNormals[i]);
                }
            }
        }
        var tmpGeo = new Geometry();
        tmpGeo.faces = this.faces;
        for (i = 0, il = this.morphTargets.length; i < il; i++) {
            if (!this.morphNormals[i]) {
                this.morphNormals[i] = {};
                this.morphNormals[i].faceNormals = [];
                this.morphNormals[i].vertexNormals = [];
                var dstNormalsFace = this.morphNormals[i].faceNormals;
                var dstNormalsVertex = this.morphNormals[i].vertexNormals;
                var faceNormal, vertexNormals;
                for (f = 0, fl = this.faces.length; f < fl; f++) {
                    faceNormal = new Vector3();
                    vertexNormals = {
                        a: new Vector3(),
                        b: new Vector3(),
                        c: new Vector3()
                    };
                    dstNormalsFace.push(faceNormal);
                    dstNormalsVertex.push(vertexNormals);
                }
            }
            var morphNormals = this.morphNormals[i];
            tmpGeo.vertices = this.morphTargets[i].vertices;
            tmpGeo.computeFaceNormals();
            tmpGeo.computeVertexNormals();
            var faceNormal, vertexNormals;
            for (f = 0, fl = this.faces.length; f < fl; f++) {
                face = this.faces[f];
                faceNormal = morphNormals.faceNormals[f];
                vertexNormals = morphNormals.vertexNormals[f];
                faceNormal.copy(face.normal);
                vertexNormals.a.copy(face.vertexNormals[0]);
                vertexNormals.b.copy(face.vertexNormals[1]);
                vertexNormals.c.copy(face.vertexNormals[2]);
            }
        }
        for (f = 0, fl = this.faces.length; f < fl; f++) {
            face = this.faces[f];
            face.normal = face.__originalFaceNormal;
            face.vertexNormals = face.__originalVertexNormals;
        }
    },
    computeTangents: function () {
        console.warn('THREE.Geometry: .computeTangents() has been removed.');
    },
    computeLineDistances: function () {
        var d = 0;
        var vertices = this.vertices;
        for (var i = 0, il = vertices.length; i < il; i++) {
            if (i > 0) {
                d += vertices[i].distanceTo(vertices[i - 1]);
            }
            this.lineDistances[i] = d;
        }
    },
    computeBoundingBox: function () {
        if (this.boundingBox === null) {
            this.boundingBox = new Box3();
        }
        this.boundingBox.setFromPoints(this.vertices);
    },
    computeBoundingSphere: function () {
        if (this.boundingSphere === null) {
            this.boundingSphere = new Sphere();
        }
        this.boundingSphere.setFromPoints(this.vertices);
    },
    merge: function (geometry, matrix, materialIndexOffset) {
        if ((geometry && geometry.isGeometry) === false) {
            console.error('THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry);
            return;
        }
        var normalMatrix, vertexOffset = this.vertices.length, vertices1 = this.vertices, vertices2 = geometry.vertices, faces1 = this.faces, faces2 = geometry.faces, uvs1 = this.faceVertexUvs[0], uvs2 = geometry.faceVertexUvs[0];
        if (materialIndexOffset === undefined)
            materialIndexOffset = 0;
        if (matrix !== undefined) {
            normalMatrix = new Matrix3().getNormalMatrix(matrix);
        }
        for (var i = 0, il = vertices2.length; i < il; i++) {
            var vertex = vertices2[i];
            var vertexCopy = vertex.clone();
            if (matrix !== undefined)
                vertexCopy.applyMatrix4(matrix);
            vertices1.push(vertexCopy);
        }
        for (i = 0, il = faces2.length; i < il; i++) {
            var face = faces2[i], faceCopy, normal, color, faceVertexNormals = face.vertexNormals, faceVertexColors = face.vertexColors;
            faceCopy = new Face3(face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset);
            faceCopy.normal.copy(face.normal);
            if (normalMatrix !== undefined) {
                faceCopy.normal.applyMatrix3(normalMatrix).normalize();
            }
            for (var j = 0, jl = faceVertexNormals.length; j < jl; j++) {
                normal = faceVertexNormals[j].clone();
                if (normalMatrix !== undefined) {
                    normal.applyMatrix3(normalMatrix).normalize();
                }
                faceCopy.vertexNormals.push(normal);
            }
            faceCopy.color.copy(face.color);
            for (var j = 0, jl = faceVertexColors.length; j < jl; j++) {
                color = faceVertexColors[j];
                faceCopy.vertexColors.push(color.clone());
            }
            faceCopy.materialIndex = face.materialIndex + materialIndexOffset;
            faces1.push(faceCopy);
        }
        for (i = 0, il = uvs2.length; i < il; i++) {
            var uv = uvs2[i], uvCopy = [];
            if (uv === undefined) {
                continue;
            }
            for (var j = 0, jl = uv.length; j < jl; j++) {
                uvCopy.push(uv[j].clone());
            }
            uvs1.push(uvCopy);
        }
    },
    mergeMesh: function (mesh) {
        if ((mesh && mesh.isMesh) === false) {
            console.error('THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh);
            return;
        }
        mesh.matrixAutoUpdate && mesh.updateMatrix();
        this.merge(mesh.geometry, mesh.matrix);
    },
    mergeVertices: function () {
        var verticesMap = {};
        var unique = [], changes = [];
        var v, key;
        var precisionPoints = 4;
        var precision = Math.pow(10, precisionPoints);
        var i, il, face;
        var indices, j, jl;
        for (i = 0, il = this.vertices.length; i < il; i++) {
            v = this.vertices[i];
            key = Math.round(v.x * precision) + '_' + Math.round(v.y * precision) + '_' + Math.round(v.z * precision);
            if (verticesMap[key] === undefined) {
                verticesMap[key] = i;
                unique.push(this.vertices[i]);
                changes[i] = unique.length - 1;
            } else {
                changes[i] = changes[verticesMap[key]];
            }
        }
        var faceIndicesToRemove = [];
        for (i = 0, il = this.faces.length; i < il; i++) {
            face = this.faces[i];
            face.a = changes[face.a];
            face.b = changes[face.b];
            face.c = changes[face.c];
            indices = [
                face.a,
                face.b,
                face.c
            ];
            var dupIndex = -1;
            for (var n = 0; n < 3; n++) {
                if (indices[n] === indices[(n + 1) % 3]) {
                    dupIndex = n;
                    faceIndicesToRemove.push(i);
                    break;
                }
            }
        }
        for (i = faceIndicesToRemove.length - 1; i >= 0; i--) {
            var idx = faceIndicesToRemove[i];
            this.faces.splice(idx, 1);
            for (j = 0, jl = this.faceVertexUvs.length; j < jl; j++) {
                this.faceVertexUvs[j].splice(idx, 1);
            }
        }
        var diff = this.vertices.length - unique.length;
        this.vertices = unique;
        return diff;
    },
    sortFacesByMaterialIndex: function () {
        var faces = this.faces;
        var length = faces.length;
        for (var i = 0; i < length; i++) {
            faces[i]._id = i;
        }
        function materialIndexSort(a, b) {
            return a.materialIndex - b.materialIndex;
        }
        faces.sort(materialIndexSort);
        var uvs1 = this.faceVertexUvs[0];
        var uvs2 = this.faceVertexUvs[1];
        var newUvs1, newUvs2;
        if (uvs1 && uvs1.length === length)
            newUvs1 = [];
        if (uvs2 && uvs2.length === length)
            newUvs2 = [];
        for (var i = 0; i < length; i++) {
            var id = faces[i]._id;
            if (newUvs1)
                newUvs1.push(uvs1[id]);
            if (newUvs2)
                newUvs2.push(uvs2[id]);
        }
        if (newUvs1)
            this.faceVertexUvs[0] = newUvs1;
        if (newUvs2)
            this.faceVertexUvs[1] = newUvs2;
    },
    toJSON: function () {
        var data = {
            metadata: {
                version: 4.4,
                type: 'Geometry',
                generator: 'Geometry.toJSON'
            }
        };
        data.uuid = this.uuid;
        data.type = this.type;
        if (this.name !== '')
            data.name = this.name;
        if (this.parameters !== undefined) {
            var parameters = this.parameters;
            for (var key in parameters) {
                if (parameters[key] !== undefined)
                    data[key] = parameters[key];
            }
            return data;
        }
        var vertices = [];
        for (var i = 0; i < this.vertices.length; i++) {
            var vertex = this.vertices[i];
            vertices.push(vertex.x, vertex.y, vertex.z);
        }
        var faces = [];
        var normals = [];
        var normalsHash = {};
        var colors = [];
        var colorsHash = {};
        var uvs = [];
        var uvsHash = {};
        for (var i = 0; i < this.faces.length; i++) {
            var face = this.faces[i];
            var hasMaterial = true;
            var hasFaceUv = false;
            var hasFaceVertexUv = this.faceVertexUvs[0][i] !== undefined;
            var hasFaceNormal = face.normal.length() > 0;
            var hasFaceVertexNormal = face.vertexNormals.length > 0;
            var hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;
            var hasFaceVertexColor = face.vertexColors.length > 0;
            var faceType = 0;
            faceType = setBit(faceType, 0, 0);
            faceType = setBit(faceType, 1, hasMaterial);
            faceType = setBit(faceType, 2, hasFaceUv);
            faceType = setBit(faceType, 3, hasFaceVertexUv);
            faceType = setBit(faceType, 4, hasFaceNormal);
            faceType = setBit(faceType, 5, hasFaceVertexNormal);
            faceType = setBit(faceType, 6, hasFaceColor);
            faceType = setBit(faceType, 7, hasFaceVertexColor);
            faces.push(faceType);
            faces.push(face.a, face.b, face.c);
            faces.push(face.materialIndex);
            if (hasFaceVertexUv) {
                var faceVertexUvs = this.faceVertexUvs[0][i];
                faces.push(getUvIndex(faceVertexUvs[0]), getUvIndex(faceVertexUvs[1]), getUvIndex(faceVertexUvs[2]));
            }
            if (hasFaceNormal) {
                faces.push(getNormalIndex(face.normal));
            }
            if (hasFaceVertexNormal) {
                var vertexNormals = face.vertexNormals;
                faces.push(getNormalIndex(vertexNormals[0]), getNormalIndex(vertexNormals[1]), getNormalIndex(vertexNormals[2]));
            }
            if (hasFaceColor) {
                faces.push(getColorIndex(face.color));
            }
            if (hasFaceVertexColor) {
                var vertexColors = face.vertexColors;
                faces.push(getColorIndex(vertexColors[0]), getColorIndex(vertexColors[1]), getColorIndex(vertexColors[2]));
            }
        }
        function setBit(value, position, enabled) {
            return enabled ? value | 1 << position : value & ~(1 << position);
        }
        function getNormalIndex(normal) {
            var hash = normal.x.toString() + normal.y.toString() + normal.z.toString();
            if (normalsHash[hash] !== undefined) {
                return normalsHash[hash];
            }
            normalsHash[hash] = normals.length / 3;
            normals.push(normal.x, normal.y, normal.z);
            return normalsHash[hash];
        }
        function getColorIndex(color) {
            var hash = color.r.toString() + color.g.toString() + color.b.toString();
            if (colorsHash[hash] !== undefined) {
                return colorsHash[hash];
            }
            colorsHash[hash] = colors.length;
            colors.push(color.getHex());
            return colorsHash[hash];
        }
        function getUvIndex(uv) {
            var hash = uv.x.toString() + uv.y.toString();
            if (uvsHash[hash] !== undefined) {
                return uvsHash[hash];
            }
            uvsHash[hash] = uvs.length / 2;
            uvs.push(uv.x, uv.y);
            return uvsHash[hash];
        }
        data.data = {};
        data.data.vertices = vertices;
        data.data.normals = normals;
        if (colors.length > 0)
            data.data.colors = colors;
        if (uvs.length > 0)
            data.data.uvs = [uvs];
        data.data.faces = faces;
        return data;
    },
    clone: function () {
        return new Geometry().copy(this);
    },
    copy: function (source) {
        this.vertices = [];
        this.faces = [];
        this.faceVertexUvs = [[]];
        var vertices = source.vertices;
        for (var i = 0, il = vertices.length; i < il; i++) {
            this.vertices.push(vertices[i].clone());
        }
        var faces = source.faces;
        for (var i = 0, il = faces.length; i < il; i++) {
            this.faces.push(faces[i].clone());
        }
        for (var i = 0, il = source.faceVertexUvs.length; i < il; i++) {
            var faceVertexUvs = source.faceVertexUvs[i];
            if (this.faceVertexUvs[i] === undefined) {
                this.faceVertexUvs[i] = [];
            }
            for (var j = 0, jl = faceVertexUvs.length; j < jl; j++) {
                var uvs = faceVertexUvs[j], uvsCopy = [];
                for (var k = 0, kl = uvs.length; k < kl; k++) {
                    var uv = uvs[k];
                    uvsCopy.push(uv.clone());
                }
                this.faceVertexUvs[i].push(uvsCopy);
            }
        }
        return this;
    },
    dispose: function () {
        this.dispatchEvent({
            type: 'dispose'
        });
    }
});
count$2 = 0;
;
Object.assign(DirectGeometry.prototype, EventDispatcher.prototype, {
    computeBoundingBox: Geometry.prototype.computeBoundingBox,
    computeBoundingSphere: Geometry.prototype.computeBoundingSphere,
    computeFaceNormals: function () {
        console.warn('THREE.DirectGeometry: computeFaceNormals() is not a method of this type of geometry.');
    },
    computeVertexNormals: function () {
        console.warn('THREE.DirectGeometry: computeVertexNormals() is not a method of this type of geometry.');
    },
    computeGroups: function (geometry) {
        var group;
        var groups = [];
        var materialIndex;
        var faces = geometry.faces;
        for (var i = 0; i < faces.length; i++) {
            var face = faces[i];
            if (face.materialIndex !== materialIndex) {
                materialIndex = face.materialIndex;
                if (group !== undefined) {
                    group.count = i * 3 - group.start;
                    groups.push(group);
                }
                group = {
                    start: i * 3,
                    materialIndex: materialIndex
                };
            }
        }
        if (group !== undefined) {
            group.count = i * 3 - group.start;
            groups.push(group);
        }
        this.groups = groups;
    },
    fromGeometry: function (geometry) {
        var faces = geometry.faces;
        var vertices = geometry.vertices;
        var faceVertexUvs = geometry.faceVertexUvs;
        var hasFaceVertexUv = faceVertexUvs[0] && faceVertexUvs[0].length > 0;
        var hasFaceVertexUv2 = faceVertexUvs[1] && faceVertexUvs[1].length > 0;
        var morphTargets = geometry.morphTargets;
        var morphTargetsLength = morphTargets.length;
        var morphTargetsPosition;
        if (morphTargetsLength > 0) {
            morphTargetsPosition = [];
            for (var i = 0; i < morphTargetsLength; i++) {
                morphTargetsPosition[i] = [];
            }
            this.morphTargets.position = morphTargetsPosition;
        }
        var morphNormals = geometry.morphNormals;
        var morphNormalsLength = morphNormals.length;
        var morphTargetsNormal;
        if (morphNormalsLength > 0) {
            morphTargetsNormal = [];
            for (var i = 0; i < morphNormalsLength; i++) {
                morphTargetsNormal[i] = [];
            }
            this.morphTargets.normal = morphTargetsNormal;
        }
        var skinIndices = geometry.skinIndices;
        var skinWeights = geometry.skinWeights;
        var hasSkinIndices = skinIndices.length === vertices.length;
        var hasSkinWeights = skinWeights.length === vertices.length;
        for (var i = 0; i < faces.length; i++) {
            var face = faces[i];
            this.vertices.push(vertices[face.a], vertices[face.b], vertices[face.c]);
            var vertexNormals = face.vertexNormals;
            if (vertexNormals.length === 3) {
                this.normals.push(vertexNormals[0], vertexNormals[1], vertexNormals[2]);
            } else {
                var normal = face.normal;
                this.normals.push(normal, normal, normal);
            }
            var vertexColors = face.vertexColors;
            if (vertexColors.length === 3) {
                this.colors.push(vertexColors[0], vertexColors[1], vertexColors[2]);
            } else {
                var color = face.color;
                this.colors.push(color, color, color);
            }
            if (hasFaceVertexUv === true) {
                var vertexUvs = faceVertexUvs[0][i];
                if (vertexUvs !== undefined) {
                    this.uvs.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);
                } else {
                    console.warn('THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i);
                    this.uvs.push(new Vector2(), new Vector2(), new Vector2());
                }
            }
            if (hasFaceVertexUv2 === true) {
                var vertexUvs = faceVertexUvs[1][i];
                if (vertexUvs !== undefined) {
                    this.uvs2.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);
                } else {
                    console.warn('THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i);
                    this.uvs2.push(new Vector2(), new Vector2(), new Vector2());
                }
            }
            for (var j = 0; j < morphTargetsLength; j++) {
                var morphTarget = morphTargets[j].vertices;
                morphTargetsPosition[j].push(morphTarget[face.a], morphTarget[face.b], morphTarget[face.c]);
            }
            for (var j = 0; j < morphNormalsLength; j++) {
                var morphNormal = morphNormals[j].vertexNormals[i];
                morphTargetsNormal[j].push(morphNormal.a, morphNormal.b, morphNormal.c);
            }
            if (hasSkinIndices) {
                this.skinIndices.push(skinIndices[face.a], skinIndices[face.b], skinIndices[face.c]);
            }
            if (hasSkinWeights) {
                this.skinWeights.push(skinWeights[face.a], skinWeights[face.b], skinWeights[face.c]);
            }
        }
        this.computeGroups(geometry);
        this.verticesNeedUpdate = geometry.verticesNeedUpdate;
        this.normalsNeedUpdate = geometry.normalsNeedUpdate;
        this.colorsNeedUpdate = geometry.colorsNeedUpdate;
        this.uvsNeedUpdate = geometry.uvsNeedUpdate;
        this.groupsNeedUpdate = geometry.groupsNeedUpdate;
        return this;
    },
    dispose: function () {
        this.dispatchEvent({
            type: 'dispose'
        });
    }
});
Object.assign(BufferGeometry.prototype, EventDispatcher.prototype, {
    isBufferGeometry: true,
    getIndex: function () {
        return this.index;
    },
    setIndex: function (index) {
        this.index = index;
    },
    addAttribute: function (name, attribute) {
        if ((attribute && attribute.isBufferAttribute) === false && (attribute && attribute.isInterleavedBufferAttribute) === false) {
            console.warn('THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).');
            this.addAttribute(name, new BufferAttribute(arguments[1], arguments[2]));
            return;
        }
        if (name === 'index') {
            console.warn('THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.');
            this.setIndex(attribute);
            return;
        }
        this.attributes[name] = attribute;
        return this;
    },
    getAttribute: function (name) {
        return this.attributes[name];
    },
    removeAttribute: function (name) {
        delete this.attributes[name];
        return this;
    },
    addGroup: function (start, count, materialIndex) {
        this.groups.push({
            start: start,
            count: count,
            materialIndex: materialIndex !== undefined ? materialIndex : 0
        });
    },
    clearGroups: function () {
        this.groups = [];
    },
    setDrawRange: function (start, count) {
        this.drawRange.start = start;
        this.drawRange.count = count;
    },
    applyMatrix: function (matrix) {
        var position = this.attributes.position;
        if (position !== undefined) {
            matrix.applyToVector3Array(position.array);
            position.needsUpdate = true;
        }
        var normal = this.attributes.normal;
        if (normal !== undefined) {
            var normalMatrix = new Matrix3().getNormalMatrix(matrix);
            normalMatrix.applyToVector3Array(normal.array);
            normal.needsUpdate = true;
        }
        if (this.boundingBox !== null) {
            this.computeBoundingBox();
        }
        if (this.boundingSphere !== null) {
            this.computeBoundingSphere();
        }
        return this;
    },
    rotateX: function () {
        var m1;
        return function rotateX(angle) {
            if (m1 === undefined)
                m1 = new Matrix4();
            m1.makeRotationX(angle);
            this.applyMatrix(m1);
            return this;
        };
    }(),
    rotateY: function () {
        var m1;
        return function rotateY(angle) {
            if (m1 === undefined)
                m1 = new Matrix4();
            m1.makeRotationY(angle);
            this.applyMatrix(m1);
            return this;
        };
    }(),
    rotateZ: function () {
        var m1;
        return function rotateZ(angle) {
            if (m1 === undefined)
                m1 = new Matrix4();
            m1.makeRotationZ(angle);
            this.applyMatrix(m1);
            return this;
        };
    }(),
    translate: function () {
        var m1;
        return function translate(x, y, z) {
            if (m1 === undefined)
                m1 = new Matrix4();
            m1.makeTranslation(x, y, z);
            this.applyMatrix(m1);
            return this;
        };
    }(),
    scale: function () {
        var m1;
        return function scale(x, y, z) {
            if (m1 === undefined)
                m1 = new Matrix4();
            m1.makeScale(x, y, z);
            this.applyMatrix(m1);
            return this;
        };
    }(),
    lookAt: function () {
        var obj;
        return function lookAt(vector) {
            if (obj === undefined)
                obj = new Object3D();
            obj.lookAt(vector);
            obj.updateMatrix();
            this.applyMatrix(obj.matrix);
        };
    }(),
    center: function () {
        this.computeBoundingBox();
        var offset = this.boundingBox.center().negate();
        this.translate(offset.x, offset.y, offset.z);
        return offset;
    },
    setFromObject: function (object) {
        var geometry = object.geometry;
        if (object && object.isPoints || object && object.isLine) {
            var positions = new Float32Attribute(geometry.vertices.length * 3, 3);
            var colors = new Float32Attribute(geometry.colors.length * 3, 3);
            this.addAttribute('position', positions.copyVector3sArray(geometry.vertices));
            this.addAttribute('color', colors.copyColorsArray(geometry.colors));
            if (geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length) {
                var lineDistances = new Float32Attribute(geometry.lineDistances.length, 1);
                this.addAttribute('lineDistance', lineDistances.copyArray(geometry.lineDistances));
            }
            if (geometry.boundingSphere !== null) {
                this.boundingSphere = geometry.boundingSphere.clone();
            }
            if (geometry.boundingBox !== null) {
                this.boundingBox = geometry.boundingBox.clone();
            }
        } else if (object && object.isMesh) {
            if (geometry && geometry.isGeometry) {
                this.fromGeometry(geometry);
            }
        }
        return this;
    },
    updateFromObject: function (object) {
        var geometry = object.geometry;
        if (object && object.isMesh) {
            var direct = geometry.__directGeometry;
            if (geometry.elementsNeedUpdate === true) {
                direct = undefined;
                geometry.elementsNeedUpdate = false;
            }
            if (direct === undefined) {
                return this.fromGeometry(geometry);
            }
            direct.verticesNeedUpdate = geometry.verticesNeedUpdate;
            direct.normalsNeedUpdate = geometry.normalsNeedUpdate;
            direct.colorsNeedUpdate = geometry.colorsNeedUpdate;
            direct.uvsNeedUpdate = geometry.uvsNeedUpdate;
            direct.groupsNeedUpdate = geometry.groupsNeedUpdate;
            geometry.verticesNeedUpdate = false;
            geometry.normalsNeedUpdate = false;
            geometry.colorsNeedUpdate = false;
            geometry.uvsNeedUpdate = false;
            geometry.groupsNeedUpdate = false;
            geometry = direct;
        }
        var attribute;
        if (geometry.verticesNeedUpdate === true) {
            attribute = this.attributes.position;
            if (attribute !== undefined) {
                attribute.copyVector3sArray(geometry.vertices);
                attribute.needsUpdate = true;
            }
            geometry.verticesNeedUpdate = false;
        }
        if (geometry.normalsNeedUpdate === true) {
            attribute = this.attributes.normal;
            if (attribute !== undefined) {
                attribute.copyVector3sArray(geometry.normals);
                attribute.needsUpdate = true;
            }
            geometry.normalsNeedUpdate = false;
        }
        if (geometry.colorsNeedUpdate === true) {
            attribute = this.attributes.color;
            if (attribute !== undefined) {
                attribute.copyColorsArray(geometry.colors);
                attribute.needsUpdate = true;
            }
            geometry.colorsNeedUpdate = false;
        }
        if (geometry.uvsNeedUpdate) {
            attribute = this.attributes.uv;
            if (attribute !== undefined) {
                attribute.copyVector2sArray(geometry.uvs);
                attribute.needsUpdate = true;
            }
            geometry.uvsNeedUpdate = false;
        }
        if (geometry.lineDistancesNeedUpdate) {
            attribute = this.attributes.lineDistance;
            if (attribute !== undefined) {
                attribute.copyArray(geometry.lineDistances);
                attribute.needsUpdate = true;
            }
            geometry.lineDistancesNeedUpdate = false;
        }
        if (geometry.groupsNeedUpdate) {
            geometry.computeGroups(object.geometry);
            this.groups = geometry.groups;
            geometry.groupsNeedUpdate = false;
        }
        return this;
    },
    fromGeometry: function (geometry) {
        geometry.__directGeometry = new DirectGeometry().fromGeometry(geometry);
        return this.fromDirectGeometry(geometry.__directGeometry);
    },
    fromDirectGeometry: function (geometry) {
        var positions = new Float32Array(geometry.vertices.length * 3);
        this.addAttribute('position', new BufferAttribute(positions, 3).copyVector3sArray(geometry.vertices));
        if (geometry.normals.length > 0) {
            var normals = new Float32Array(geometry.normals.length * 3);
            this.addAttribute('normal', new BufferAttribute(normals, 3).copyVector3sArray(geometry.normals));
        }
        if (geometry.colors.length > 0) {
            var colors = new Float32Array(geometry.colors.length * 3);
            this.addAttribute('color', new BufferAttribute(colors, 3).copyColorsArray(geometry.colors));
        }
        if (geometry.uvs.length > 0) {
            var uvs = new Float32Array(geometry.uvs.length * 2);
            this.addAttribute('uv', new BufferAttribute(uvs, 2).copyVector2sArray(geometry.uvs));
        }
        if (geometry.uvs2.length > 0) {
            var uvs2 = new Float32Array(geometry.uvs2.length * 2);
            this.addAttribute('uv2', new BufferAttribute(uvs2, 2).copyVector2sArray(geometry.uvs2));
        }
        if (geometry.indices.length > 0) {
            var TypeArray = geometry.vertices.length > 65535 ? Uint32Array : Uint16Array;
            var indices = new TypeArray(geometry.indices.length * 3);
            this.setIndex(new BufferAttribute(indices, 1).copyIndicesArray(geometry.indices));
        }
        this.groups = geometry.groups;
        for (var name in geometry.morphTargets) {
            var array = [];
            var morphTargets = geometry.morphTargets[name];
            for (var i = 0, l = morphTargets.length; i < l; i++) {
                var morphTarget = morphTargets[i];
                var attribute = new Float32Attribute(morphTarget.length * 3, 3);
                array.push(attribute.copyVector3sArray(morphTarget));
            }
            this.morphAttributes[name] = array;
        }
        if (geometry.skinIndices.length > 0) {
            var skinIndices = new Float32Attribute(geometry.skinIndices.length * 4, 4);
            this.addAttribute('skinIndex', skinIndices.copyVector4sArray(geometry.skinIndices));
        }
        if (geometry.skinWeights.length > 0) {
            var skinWeights = new Float32Attribute(geometry.skinWeights.length * 4, 4);
            this.addAttribute('skinWeight', skinWeights.copyVector4sArray(geometry.skinWeights));
        }
        if (geometry.boundingSphere !== null) {
            this.boundingSphere = geometry.boundingSphere.clone();
        }
        if (geometry.boundingBox !== null) {
            this.boundingBox = geometry.boundingBox.clone();
        }
        return this;
    },
    computeBoundingBox: function () {
        if (this.boundingBox === null) {
            this.boundingBox = new Box3();
        }
        var positions = this.attributes.position.array;
        if (positions !== undefined) {
            this.boundingBox.setFromArray(positions);
        } else {
            this.boundingBox.makeEmpty();
        }
        if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) {
            console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
        }
    },
    computeBoundingSphere: function () {
        var box = new Box3();
        var vector = new Vector3();
        return function computeBoundingSphere() {
            if (this.boundingSphere === null) {
                this.boundingSphere = new Sphere();
            }
            var positions = this.attributes.position;
            if (positions) {
                var array = positions.array;
                var center = this.boundingSphere.center;
                box.setFromArray(array);
                box.center(center);
                var maxRadiusSq = 0;
                for (var i = 0, il = array.length; i < il; i += 3) {
                    vector.fromArray(array, i);
                    maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(vector));
                }
                this.boundingSphere.radius = Math.sqrt(maxRadiusSq);
                if (isNaN(this.boundingSphere.radius)) {
                    console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
                }
            }
        };
    }(),
    computeFaceNormals: function () {
    },
    computeVertexNormals: function () {
        var index = this.index;
        var attributes = this.attributes;
        var groups = this.groups;
        if (attributes.position) {
            var positions = attributes.position.array;
            if (attributes.normal === undefined) {
                this.addAttribute('normal', new BufferAttribute(new Float32Array(positions.length), 3));
            } else {
                var array = attributes.normal.array;
                for (var i = 0, il = array.length; i < il; i++) {
                    array[i] = 0;
                }
            }
            var normals = attributes.normal.array;
            var vA, vB, vC, pA = new Vector3(), pB = new Vector3(), pC = new Vector3(), cb = new Vector3(), ab = new Vector3();
            if (index) {
                var indices = index.array;
                if (groups.length === 0) {
                    this.addGroup(0, indices.length);
                }
                for (var j = 0, jl = groups.length; j < jl; ++j) {
                    var group = groups[j];
                    var start = group.start;
                    var count = group.count;
                    for (var i = start, il = start + count; i < il; i += 3) {
                        vA = indices[i + 0] * 3;
                        vB = indices[i + 1] * 3;
                        vC = indices[i + 2] * 3;
                        pA.fromArray(positions, vA);
                        pB.fromArray(positions, vB);
                        pC.fromArray(positions, vC);
                        cb.subVectors(pC, pB);
                        ab.subVectors(pA, pB);
                        cb.cross(ab);
                        normals[vA] += cb.x;
                        normals[vA + 1] += cb.y;
                        normals[vA + 2] += cb.z;
                        normals[vB] += cb.x;
                        normals[vB + 1] += cb.y;
                        normals[vB + 2] += cb.z;
                        normals[vC] += cb.x;
                        normals[vC + 1] += cb.y;
                        normals[vC + 2] += cb.z;
                    }
                }
            } else {
                for (var i = 0, il = positions.length; i < il; i += 9) {
                    pA.fromArray(positions, i);
                    pB.fromArray(positions, i + 3);
                    pC.fromArray(positions, i + 6);
                    cb.subVectors(pC, pB);
                    ab.subVectors(pA, pB);
                    cb.cross(ab);
                    normals[i] = cb.x;
                    normals[i + 1] = cb.y;
                    normals[i + 2] = cb.z;
                    normals[i + 3] = cb.x;
                    normals[i + 4] = cb.y;
                    normals[i + 5] = cb.z;
                    normals[i + 6] = cb.x;
                    normals[i + 7] = cb.y;
                    normals[i + 8] = cb.z;
                }
            }
            this.normalizeNormals();
            attributes.normal.needsUpdate = true;
        }
    },
    merge: function (geometry, offset) {
        if ((geometry && geometry.isBufferGeometry) === false) {
            console.error('THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry);
            return;
        }
        if (offset === undefined)
            offset = 0;
        var attributes = this.attributes;
        for (var key in attributes) {
            if (geometry.attributes[key] === undefined)
                continue;
            var attribute1 = attributes[key];
            var attributeArray1 = attribute1.array;
            var attribute2 = geometry.attributes[key];
            var attributeArray2 = attribute2.array;
            var attributeSize = attribute2.itemSize;
            for (var i = 0, j = attributeSize * offset; i < attributeArray2.length; i++, j++) {
                attributeArray1[j] = attributeArray2[i];
            }
        }
        return this;
    },
    normalizeNormals: function () {
        var normals = this.attributes.normal.array;
        var x, y, z, n;
        for (var i = 0, il = normals.length; i < il; i += 3) {
            x = normals[i];
            y = normals[i + 1];
            z = normals[i + 2];
            n = 1 / Math.sqrt(x * x + y * y + z * z);
            normals[i] *= n;
            normals[i + 1] *= n;
            normals[i + 2] *= n;
        }
    },
    toNonIndexed: function () {
        if (this.index === null) {
            console.warn('THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.');
            return this;
        }
        var geometry2 = new BufferGeometry();
        var indices = this.index.array;
        var attributes = this.attributes;
        for (var name in attributes) {
            var attribute = attributes[name];
            var array = attribute.array;
            var itemSize = attribute.itemSize;
            var array2 = new array.constructor(indices.length * itemSize);
            var index = 0, index2 = 0;
            for (var i = 0, l = indices.length; i < l; i++) {
                index = indices[i] * itemSize;
                for (var j = 0; j < itemSize; j++) {
                    array2[index2++] = array[index++];
                }
            }
            geometry2.addAttribute(name, new BufferAttribute(array2, itemSize));
        }
        return geometry2;
    },
    toJSON: function () {
        var data = {
            metadata: {
                version: 4.4,
                type: 'BufferGeometry',
                generator: 'BufferGeometry.toJSON'
            }
        };
        data.uuid = this.uuid;
        data.type = this.type;
        if (this.name !== '')
            data.name = this.name;
        if (this.parameters !== undefined) {
            var parameters = this.parameters;
            for (var key in parameters) {
                if (parameters[key] !== undefined)
                    data[key] = parameters[key];
            }
            return data;
        }
        data.data = {
            attributes: {}
        };
        var index = this.index;
        if (index !== null) {
            var array = Array.prototype.slice.call(index.array);
            data.data.index = {
                type: index.array.constructor.name,
                array: array
            };
        }
        var attributes = this.attributes;
        for (var key in attributes) {
            var attribute = attributes[key];
            var array = Array.prototype.slice.call(attribute.array);
            data.data.attributes[key] = {
                itemSize: attribute.itemSize,
                type: attribute.array.constructor.name,
                array: array,
                normalized: attribute.normalized
            };
        }
        var groups = this.groups;
        if (groups.length > 0) {
            data.data.groups = JSON.parse(JSON.stringify(groups));
        }
        var boundingSphere = this.boundingSphere;
        if (boundingSphere !== null) {
            data.data.boundingSphere = {
                center: boundingSphere.center.toArray(),
                radius: boundingSphere.radius
            };
        }
        return data;
    },
    clone: function () {
        return new BufferGeometry().copy(this);
    },
    copy: function (source) {
        var index = source.index;
        if (index !== null) {
            this.setIndex(index.clone());
        }
        var attributes = source.attributes;
        for (var name in attributes) {
            var attribute = attributes[name];
            this.addAttribute(name, attribute.clone());
        }
        var groups = source.groups;
        for (var i = 0, l = groups.length; i < l; i++) {
            var group = groups[i];
            this.addGroup(group.start, group.count, group.materialIndex);
        }
        return this;
    },
    dispose: function () {
        this.dispatchEvent({
            type: 'dispose'
        });
    }
});
BufferGeometry.MaxIndex = 65535;
WebGLRenderTargetCube.prototype = Object.create(WebGLRenderTarget.prototype);
WebGLRenderTargetCube.prototype.constructor = WebGLRenderTargetCube;
WebGLRenderTargetCube.prototype.isWebGLRenderTargetCube = true;
BoxBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
BoxBufferGeometry.prototype.constructor = BoxBufferGeometry;
Ray.prototype = {
    constructor: Ray,
    set: function (origin, direction) {
        this.origin.copy(origin);
        this.direction.copy(direction);
        return this;
    },
    clone: function () {
        return new this.constructor().copy(this);
    },
    copy: function (ray) {
        this.origin.copy(ray.origin);
        this.direction.copy(ray.direction);
        return this;
    },
    at: function (t, optionalTarget) {
        var result = optionalTarget || new Vector3();
        return result.copy(this.direction).multiplyScalar(t).add(this.origin);
    },
    lookAt: function (v) {
        this.direction.copy(v).sub(this.origin).normalize();
        return this;
    },
    recast: function () {
        var v1 = new Vector3();
        return function recast(t) {
            this.origin.copy(this.at(t, v1));
            return this;
        };
    }(),
    closestPointToPoint: function (point, optionalTarget) {
        var result = optionalTarget || new Vector3();
        result.subVectors(point, this.origin);
        var directionDistance = result.dot(this.direction);
        if (directionDistance < 0) {
            return result.copy(this.origin);
        }
        return result.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
    },
    distanceToPoint: function (point) {
        return Math.sqrt(this.distanceSqToPoint(point));
    },
    distanceSqToPoint: function () {
        var v1 = new Vector3();
        return function distanceSqToPoint(point) {
            var directionDistance = v1.subVectors(point, this.origin).dot(this.direction);
            if (directionDistance < 0) {
                return this.origin.distanceToSquared(point);
            }
            v1.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
            return v1.distanceToSquared(point);
        };
    }(),
    distanceSqToSegment: function () {
        var segCenter = new Vector3();
        var segDir = new Vector3();
        var diff = new Vector3();
        return function distanceSqToSegment(v0, v1, optionalPointOnRay, optionalPointOnSegment) {
            segCenter.copy(v0).add(v1).multiplyScalar(0.5);
            segDir.copy(v1).sub(v0).normalize();
            diff.copy(this.origin).sub(segCenter);
            var segExtent = v0.distanceTo(v1) * 0.5;
            var a01 = -this.direction.dot(segDir);
            var b0 = diff.dot(this.direction);
            var b1 = -diff.dot(segDir);
            var c = diff.lengthSq();
            var det = Math.abs(1 - a01 * a01);
            var s0, s1, sqrDist, extDet;
            if (det > 0) {
                s0 = a01 * b1 - b0;
                s1 = a01 * b0 - b1;
                extDet = segExtent * det;
                if (s0 >= 0) {
                    if (s1 >= -extDet) {
                        if (s1 <= extDet) {
                            var invDet = 1 / det;
                            s0 *= invDet;
                            s1 *= invDet;
                            sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c;
                        } else {
                            s1 = segExtent;
                            s0 = Math.max(0, -(a01 * s1 + b0));
                            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
                        }
                    } else {
                        s1 = -segExtent;
                        s0 = Math.max(0, -(a01 * s1 + b0));
                        sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
                    }
                } else {
                    if (s1 <= -extDet) {
                        s0 = Math.max(0, -(-a01 * segExtent + b0));
                        s1 = s0 > 0 ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
                        sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
                    } else if (s1 <= extDet) {
                        s0 = 0;
                        s1 = Math.min(Math.max(-segExtent, -b1), segExtent);
                        sqrDist = s1 * (s1 + 2 * b1) + c;
                    } else {
                        s0 = Math.max(0, -(a01 * segExtent + b0));
                        s1 = s0 > 0 ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
                        sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
                    }
                }
            } else {
                s1 = a01 > 0 ? -segExtent : segExtent;
                s0 = Math.max(0, -(a01 * s1 + b0));
                sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
            }
            if (optionalPointOnRay) {
                optionalPointOnRay.copy(this.direction).multiplyScalar(s0).add(this.origin);
            }
            if (optionalPointOnSegment) {
                optionalPointOnSegment.copy(segDir).multiplyScalar(s1).add(segCenter);
            }
            return sqrDist;
        };
    }(),
    intersectSphere: function () {
        var v1 = new Vector3();
        return function intersectSphere(sphere, optionalTarget) {
            v1.subVectors(sphere.center, this.origin);
            var tca = v1.dot(this.direction);
            var d2 = v1.dot(v1) - tca * tca;
            var radius2 = sphere.radius * sphere.radius;
            if (d2 > radius2)
                return null;
            var thc = Math.sqrt(radius2 - d2);
            var t0 = tca - thc;
            var t1 = tca + thc;
            if (t0 < 0 && t1 < 0)
                return null;
            if (t0 < 0)
                return this.at(t1, optionalTarget);
            return this.at(t0, optionalTarget);
        };
    }(),
    intersectsSphere: function (sphere) {
        return this.distanceToPoint(sphere.center) <= sphere.radius;
    },
    distanceToPlane: function (plane) {
        var denominator = plane.normal.dot(this.direction);
        if (denominator === 0) {
            if (plane.distanceToPoint(this.origin) === 0) {
                return 0;
            }
            return null;
        }
        var t = -(this.origin.dot(plane.normal) + plane.constant) / denominator;
        return t >= 0 ? t : null;
    },
    intersectPlane: function (plane, optionalTarget) {
        var t = this.distanceToPlane(plane);
        if (t === null) {
            return null;
        }
        return this.at(t, optionalTarget);
    },
    intersectsPlane: function (plane) {
        var distToPoint = plane.distanceToPoint(this.origin);
        if (distToPoint === 0) {
            return true;
        }
        var denominator = plane.normal.dot(this.direction);
        if (denominator * distToPoint < 0) {
            return true;
        }
        return false;
    },
    intersectBox: function (box, optionalTarget) {
        var tmin, tmax, tymin, tymax, tzmin, tzmax;
        var invdirx = 1 / this.direction.x, invdiry = 1 / this.direction.y, invdirz = 1 / this.direction.z;
        var origin = this.origin;
        if (invdirx >= 0) {
            tmin = (box.min.x - origin.x) * invdirx;
            tmax = (box.max.x - origin.x) * invdirx;
        } else {
            tmin = (box.max.x - origin.x) * invdirx;
            tmax = (box.min.x - origin.x) * invdirx;
        }
        if (invdiry >= 0) {
            tymin = (box.min.y - origin.y) * invdiry;
            tymax = (box.max.y - origin.y) * invdiry;
        } else {
            tymin = (box.max.y - origin.y) * invdiry;
            tymax = (box.min.y - origin.y) * invdiry;
        }
        if (tmin > tymax || tymin > tmax)
            return null;
        if (tymin > tmin || tmin !== tmin)
            tmin = tymin;
        if (tymax < tmax || tmax !== tmax)
            tmax = tymax;
        if (invdirz >= 0) {
            tzmin = (box.min.z - origin.z) * invdirz;
            tzmax = (box.max.z - origin.z) * invdirz;
        } else {
            tzmin = (box.max.z - origin.z) * invdirz;
            tzmax = (box.min.z - origin.z) * invdirz;
        }
        if (tmin > tzmax || tzmin > tmax)
            return null;
        if (tzmin > tmin || tmin !== tmin)
            tmin = tzmin;
        if (tzmax < tmax || tmax !== tmax)
            tmax = tzmax;
        if (tmax < 0)
            return null;
        return this.at(tmin >= 0 ? tmin : tmax, optionalTarget);
    },
    intersectsBox: function () {
        var v = new Vector3();
        return function intersectsBox(box) {
            return this.intersectBox(box, v) !== null;
        };
    }(),
    intersectTriangle: function () {
        var diff = new Vector3();
        var edge1 = new Vector3();
        var edge2 = new Vector3();
        var normal = new Vector3();
        return function intersectTriangle(a, b, c, backfaceCulling, optionalTarget) {
            edge1.subVectors(b, a);
            edge2.subVectors(c, a);
            normal.crossVectors(edge1, edge2);
            var DdN = this.direction.dot(normal);
            var sign;
            if (DdN > 0) {
                if (backfaceCulling)
                    return null;
                sign = 1;
            } else if (DdN < 0) {
                sign = -1;
                DdN = -DdN;
            } else {
                return null;
            }
            diff.subVectors(this.origin, a);
            var DdQxE2 = sign * this.direction.dot(edge2.crossVectors(diff, edge2));
            if (DdQxE2 < 0) {
                return null;
            }
            var DdE1xQ = sign * this.direction.dot(edge1.cross(diff));
            if (DdE1xQ < 0) {
                return null;
            }
            if (DdQxE2 + DdE1xQ > DdN) {
                return null;
            }
            var QdN = -sign * diff.dot(normal);
            if (QdN < 0) {
                return null;
            }
            return this.at(QdN / DdN, optionalTarget);
        };
    }(),
    applyMatrix4: function (matrix4) {
        this.direction.add(this.origin).applyMatrix4(matrix4);
        this.origin.applyMatrix4(matrix4);
        this.direction.sub(this.origin);
        this.direction.normalize();
        return this;
    },
    equals: function (ray) {
        return ray.origin.equals(this.origin) && ray.direction.equals(this.direction);
    }
};
Line3.prototype = {
    constructor: Line3,
    set: function (start, end) {
        this.start.copy(start);
        this.end.copy(end);
        return this;
    },
    clone: function () {
        return new this.constructor().copy(this);
    },
    copy: function (line) {
        this.start.copy(line.start);
        this.end.copy(line.end);
        return this;
    },
    center: function (optionalTarget) {
        var result = optionalTarget || new Vector3();
        return result.addVectors(this.start, this.end).multiplyScalar(0.5);
    },
    delta: function (optionalTarget) {
        var result = optionalTarget || new Vector3();
        return result.subVectors(this.end, this.start);
    },
    distanceSq: function () {
        return this.start.distanceToSquared(this.end);
    },
    distance: function () {
        return this.start.distanceTo(this.end);
    },
    at: function (t, optionalTarget) {
        var result = optionalTarget || new Vector3();
        return this.delta(result).multiplyScalar(t).add(this.start);
    },
    closestPointToPointParameter: function () {
        var startP = new Vector3();
        var startEnd = new Vector3();
        return function closestPointToPointParameter(point, clampToLine) {
            startP.subVectors(point, this.start);
            startEnd.subVectors(this.end, this.start);
            var startEnd2 = startEnd.dot(startEnd);
            var startEnd_startP = startEnd.dot(startP);
            var t = startEnd_startP / startEnd2;
            if (clampToLine) {
                t = exports.Math.clamp(t, 0, 1);
            }
            return t;
        };
    }(),
    closestPointToPoint: function (point, clampToLine, optionalTarget) {
        var t = this.closestPointToPointParameter(point, clampToLine);
        var result = optionalTarget || new Vector3();
        return this.delta(result).multiplyScalar(t).add(this.start);
    },
    applyMatrix4: function (matrix) {
        this.start.applyMatrix4(matrix);
        this.end.applyMatrix4(matrix);
        return this;
    },
    equals: function (line) {
        return line.start.equals(this.start) && line.end.equals(this.end);
    }
};
Triangle.normal = function () {
    var v0 = new Vector3();
    return function normal(a, b, c, optionalTarget) {
        var result = optionalTarget || new Vector3();
        result.subVectors(c, b);
        v0.subVectors(a, b);
        result.cross(v0);
        var resultLengthSq = result.lengthSq();
        if (resultLengthSq > 0) {
            return result.multiplyScalar(1 / Math.sqrt(resultLengthSq));
        }
        return result.set(0, 0, 0);
    };
}();
Triangle.barycoordFromPoint = function () {
    var v0 = new Vector3();
    var v1 = new Vector3();
    var v2 = new Vector3();
    return function barycoordFromPoint(point, a, b, c, optionalTarget) {
        v0.subVectors(c, a);
        v1.subVectors(b, a);
        v2.subVectors(point, a);
        var dot00 = v0.dot(v0);
        var dot01 = v0.dot(v1);
        var dot02 = v0.dot(v2);
        var dot11 = v1.dot(v1);
        var dot12 = v1.dot(v2);
        var denom = dot00 * dot11 - dot01 * dot01;
        var result = optionalTarget || new Vector3();
        if (denom === 0) {
            return result.set(-2, -1, -1);
        }
        var invDenom = 1 / denom;
        var u = (dot11 * dot02 - dot01 * dot12) * invDenom;
        var v = (dot00 * dot12 - dot01 * dot02) * invDenom;
        return result.set(1 - u - v, v, u);
    };
}();
Triangle.containsPoint = function () {
    var v1 = new Vector3();
    return function containsPoint(point, a, b, c) {
        var result = Triangle.barycoordFromPoint(point, a, b, c, v1);
        return result.x >= 0 && result.y >= 0 && result.x + result.y <= 1;
    };
}();
Triangle.prototype = {
    constructor: Triangle,
    set: function (a, b, c) {
        this.a.copy(a);
        this.b.copy(b);
        this.c.copy(c);
        return this;
    },
    setFromPointsAndIndices: function (points, i0, i1, i2) {
        this.a.copy(points[i0]);
        this.b.copy(points[i1]);
        this.c.copy(points[i2]);
        return this;
    },
    clone: function () {
        return new this.constructor().copy(this);
    },
    copy: function (triangle) {
        this.a.copy(triangle.a);
        this.b.copy(triangle.b);
        this.c.copy(triangle.c);
        return this;
    },
    area: function () {
        var v0 = new Vector3();
        var v1 = new Vector3();
        return function area() {
            v0.subVectors(this.c, this.b);
            v1.subVectors(this.a, this.b);
            return v0.cross(v1).length() * 0.5;
        };
    }(),
    midpoint: function (optionalTarget) {
        var result = optionalTarget || new Vector3();
        return result.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
    },
    normal: function (optionalTarget) {
        return Triangle.normal(this.a, this.b, this.c, optionalTarget);
    },
    plane: function (optionalTarget) {
        var result = optionalTarget || new Plane();
        return result.setFromCoplanarPoints(this.a, this.b, this.c);
    },
    barycoordFromPoint: function (point, optionalTarget) {
        return Triangle.barycoordFromPoint(point, this.a, this.b, this.c, optionalTarget);
    },
    containsPoint: function (point) {
        return Triangle.containsPoint(point, this.a, this.b, this.c);
    },
    closestPointToPoint: function () {
        var plane, edgeList, projectedPoint, closestPoint;
        return function closestPointToPoint(point, optionalTarget) {
            if (plane === undefined) {
                plane = new Plane();
                edgeList = [
                    new Line3(),
                    new Line3(),
                    new Line3()
                ];
                projectedPoint = new Vector3();
                closestPoint = new Vector3();
            }
            var result = optionalTarget || new Vector3();
            var minDistance = Infinity;
            plane.setFromCoplanarPoints(this.a, this.b, this.c);
            plane.projectPoint(point, projectedPoint);
            if (this.containsPoint(projectedPoint) === true) {
                result.copy(projectedPoint);
            } else {
                edgeList[0].set(this.a, this.b);
                edgeList[1].set(this.b, this.c);
                edgeList[2].set(this.c, this.a);
                for (var i = 0; i < edgeList.length; i++) {
                    edgeList[i].closestPointToPoint(projectedPoint, true, closestPoint);
                    var distance = projectedPoint.distanceToSquared(closestPoint);
                    if (distance < minDistance) {
                        minDistance = distance;
                        result.copy(closestPoint);
                    }
                }
            }
            return result;
        };
    }(),
    equals: function (triangle) {
        return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c);
    }
};
MeshBasicMaterial.prototype = Object.create(Material.prototype);
MeshBasicMaterial.prototype.constructor = MeshBasicMaterial;
MeshBasicMaterial.prototype.isMeshBasicMaterial = true;
MeshBasicMaterial.prototype.copy = function (source) {
    Material.prototype.copy.call(this, source);
    this.color.copy(source.color);
    this.map = source.map;
    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;
    this.specularMap = source.specularMap;
    this.alphaMap = source.alphaMap;
    this.envMap = source.envMap;
    this.combine = source.combine;
    this.reflectivity = source.reflectivity;
    this.refractionRatio = source.refractionRatio;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    return this;
};
Mesh.prototype = Object.assign(Object.create(Object3D.prototype), {
    constructor: Mesh,
    isMesh: true,
    setDrawMode: function (value) {
        this.drawMode = value;
    },
    copy: function (source) {
        Object3D.prototype.copy.call(this, source);
        this.drawMode = source.drawMode;
        return this;
    },
    updateMorphTargets: function () {
        if (this.geometry.morphTargets !== undefined && this.geometry.morphTargets.length > 0) {
            this.morphTargetBase = -1;
            this.morphTargetInfluences = [];
            this.morphTargetDictionary = {};
            for (var m = 0, ml = this.geometry.morphTargets.length; m < ml; m++) {
                this.morphTargetInfluences.push(0);
                this.morphTargetDictionary[this.geometry.morphTargets[m].name] = m;
            }
        }
    },
    getMorphTargetIndexByName: function (name) {
        if (this.morphTargetDictionary[name] !== undefined) {
            return this.morphTargetDictionary[name];
        }
        console.warn('THREE.Mesh.getMorphTargetIndexByName: morph target ' + name + ' does not exist. Returning 0.');
        return 0;
    },
    raycast: function () {
        var inverseMatrix = new Matrix4();
        var ray = new Ray();
        var sphere = new Sphere();
        var vA = new Vector3();
        var vB = new Vector3();
        var vC = new Vector3();
        var tempA = new Vector3();
        var tempB = new Vector3();
        var tempC = new Vector3();
        var uvA = new Vector2();
        var uvB = new Vector2();
        var uvC = new Vector2();
        var barycoord = new Vector3();
        var intersectionPoint = new Vector3();
        var intersectionPointWorld = new Vector3();
        function uvIntersection(point, p1, p2, p3, uv1, uv2, uv3) {
            Triangle.barycoordFromPoint(point, p1, p2, p3, barycoord);
            uv1.multiplyScalar(barycoord.x);
            uv2.multiplyScalar(barycoord.y);
            uv3.multiplyScalar(barycoord.z);
            uv1.add(uv2).add(uv3);
            return uv1.clone();
        }
        function checkIntersection(object, raycaster, ray, pA, pB, pC, point) {
            var intersect;
            var material = object.material;
            if (material.side === BackSide) {
                intersect = ray.intersectTriangle(pC, pB, pA, true, point);
            } else {
                intersect = ray.intersectTriangle(pA, pB, pC, material.side !== DoubleSide, point);
            }
            if (intersect === null)
                return null;
            intersectionPointWorld.copy(point);
            intersectionPointWorld.applyMatrix4(object.matrixWorld);
            var distance = raycaster.ray.origin.distanceTo(intersectionPointWorld);
            if (distance < raycaster.near || distance > raycaster.far)
                return null;
            return {
                distance: distance,
                point: intersectionPointWorld.clone(),
                object: object
            };
        }
        function checkBufferGeometryIntersection(object, raycaster, ray, positions, uvs, a, b, c) {
            vA.fromArray(positions, a * 3);
            vB.fromArray(positions, b * 3);
            vC.fromArray(positions, c * 3);
            var intersection = checkIntersection(object, raycaster, ray, vA, vB, vC, intersectionPoint);
            if (intersection) {
                if (uvs) {
                    uvA.fromArray(uvs, a * 2);
                    uvB.fromArray(uvs, b * 2);
                    uvC.fromArray(uvs, c * 2);
                    intersection.uv = uvIntersection(intersectionPoint, vA, vB, vC, uvA, uvB, uvC);
                }
                intersection.face = new Face3(a, b, c, Triangle.normal(vA, vB, vC));
                intersection.faceIndex = a;
            }
            return intersection;
        }
        return function raycast(raycaster, intersects) {
            var geometry = this.geometry;
            var material = this.material;
            var matrixWorld = this.matrixWorld;
            if (material === undefined)
                return;
            if (geometry.boundingSphere === null)
                geometry.computeBoundingSphere();
            sphere.copy(geometry.boundingSphere);
            sphere.applyMatrix4(matrixWorld);
            if (raycaster.ray.intersectsSphere(sphere) === false)
                return;
            inverseMatrix.getInverse(matrixWorld);
            ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);
            if (geometry.boundingBox !== null) {
                if (ray.intersectsBox(geometry.boundingBox) === false)
                    return;
            }
            var uvs, intersection;
            if (geometry && geometry.isBufferGeometry) {
                var a, b, c;
                var index = geometry.index;
                var attributes = geometry.attributes;
                var positions = attributes.position.array;
                if (attributes.uv !== undefined) {
                    uvs = attributes.uv.array;
                }
                if (index !== null) {
                    var indices = index.array;
                    for (var i = 0, l = indices.length; i < l; i += 3) {
                        a = indices[i];
                        b = indices[i + 1];
                        c = indices[i + 2];
                        intersection = checkBufferGeometryIntersection(this, raycaster, ray, positions, uvs, a, b, c);
                        if (intersection) {
                            intersection.faceIndex = Math.floor(i / 3);
                            intersects.push(intersection);
                        }
                    }
                } else {
                    for (var i = 0, l = positions.length; i < l; i += 9) {
                        a = i / 3;
                        b = a + 1;
                        c = a + 2;
                        intersection = checkBufferGeometryIntersection(this, raycaster, ray, positions, uvs, a, b, c);
                        if (intersection) {
                            intersection.index = a;
                            intersects.push(intersection);
                        }
                    }
                }
            } else if (geometry && geometry.isGeometry) {
                var fvA, fvB, fvC;
                var isFaceMaterial = material && material.isMultiMaterial;
                var materials = isFaceMaterial === true ? material.materials : null;
                var vertices = geometry.vertices;
                var faces = geometry.faces;
                var faceVertexUvs = geometry.faceVertexUvs[0];
                if (faceVertexUvs.length > 0)
                    uvs = faceVertexUvs;
                for (var f = 0, fl = faces.length; f < fl; f++) {
                    var face = faces[f];
                    var faceMaterial = isFaceMaterial === true ? materials[face.materialIndex] : material;
                    if (faceMaterial === undefined)
                        continue;
                    fvA = vertices[face.a];
                    fvB = vertices[face.b];
                    fvC = vertices[face.c];
                    if (faceMaterial.morphTargets === true) {
                        var morphTargets = geometry.morphTargets;
                        var morphInfluences = this.morphTargetInfluences;
                        vA.set(0, 0, 0);
                        vB.set(0, 0, 0);
                        vC.set(0, 0, 0);
                        for (var t = 0, tl = morphTargets.length; t < tl; t++) {
                            var influence = morphInfluences[t];
                            if (influence === 0)
                                continue;
                            var targets = morphTargets[t].vertices;
                            vA.addScaledVector(tempA.subVectors(targets[face.a], fvA), influence);
                            vB.addScaledVector(tempB.subVectors(targets[face.b], fvB), influence);
                            vC.addScaledVector(tempC.subVectors(targets[face.c], fvC), influence);
                        }
                        vA.add(fvA);
                        vB.add(fvB);
                        vC.add(fvC);
                        fvA = vA;
                        fvB = vB;
                        fvC = vC;
                    }
                    intersection = checkIntersection(this, raycaster, ray, fvA, fvB, fvC, intersectionPoint);
                    if (intersection) {
                        if (uvs) {
                            var uvs_f = uvs[f];
                            uvA.copy(uvs_f[0]);
                            uvB.copy(uvs_f[1]);
                            uvC.copy(uvs_f[2]);
                            intersection.uv = uvIntersection(intersectionPoint, fvA, fvB, fvC, uvA, uvB, uvC);
                        }
                        intersection.face = face;
                        intersection.faceIndex = f;
                        intersects.push(intersection);
                    }
                }
            }
        };
    }(),
    clone: function () {
        return new this.constructor(this.geometry, this.material).copy(this);
    }
});
PlaneBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
PlaneBufferGeometry.prototype.constructor = PlaneBufferGeometry;
Camera.prototype = Object.create(Object3D.prototype);
Camera.prototype.constructor = Camera;
Camera.prototype.isCamera = true;
Camera.prototype.getWorldDirection = function () {
    var quaternion = new Quaternion();
    return function getWorldDirection(optionalTarget) {
        var result = optionalTarget || new Vector3();
        this.getWorldQuaternion(quaternion);
        return result.set(0, 0, -1).applyQuaternion(quaternion);
    };
}();
Camera.prototype.lookAt = function () {
    var m1 = new Matrix4();
    return function lookAt(vector) {
        m1.lookAt(this.position, vector, this.up);
        this.quaternion.setFromRotationMatrix(m1);
    };
}();
Camera.prototype.clone = function () {
    return new this.constructor().copy(this);
};
Camera.prototype.copy = function (source) {
    Object3D.prototype.copy.call(this, source);
    this.matrixWorldInverse.copy(source.matrixWorldInverse);
    this.projectionMatrix.copy(source.projectionMatrix);
    return this;
};
PerspectiveCamera.prototype = Object.assign(Object.create(Camera.prototype), {
    constructor: PerspectiveCamera,
    isPerspectiveCamera: true,
    copy: function (source) {
        Camera.prototype.copy.call(this, source);
        this.fov = source.fov;
        this.zoom = source.zoom;
        this.near = source.near;
        this.far = source.far;
        this.focus = source.focus;
        this.aspect = source.aspect;
        this.view = source.view === null ? null : Object.assign({}, source.view);
        this.filmGauge = source.filmGauge;
        this.filmOffset = source.filmOffset;
        return this;
    },
    setFocalLength: function (focalLength) {
        var vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;
        this.fov = exports.Math.RAD2DEG * 2 * Math.atan(vExtentSlope);
        this.updateProjectionMatrix();
    },
    getFocalLength: function () {
        var vExtentSlope = Math.tan(exports.Math.DEG2RAD * 0.5 * this.fov);
        return 0.5 * this.getFilmHeight() / vExtentSlope;
    },
    getEffectiveFOV: function () {
        return exports.Math.RAD2DEG * 2 * Math.atan(Math.tan(exports.Math.DEG2RAD * 0.5 * this.fov) / this.zoom);
    },
    getFilmWidth: function () {
        return this.filmGauge * Math.min(this.aspect, 1);
    },
    getFilmHeight: function () {
        return this.filmGauge / Math.max(this.aspect, 1);
    },
    setViewOffset: function (fullWidth, fullHeight, x, y, width, height) {
        this.aspect = fullWidth / fullHeight;
        this.view = {
            fullWidth: fullWidth,
            fullHeight: fullHeight,
            offsetX: x,
            offsetY: y,
            width: width,
            height: height
        };
        this.updateProjectionMatrix();
    },
    clearViewOffset: function () {
        this.view = null;
        this.updateProjectionMatrix();
    },
    updateProjectionMatrix: function () {
        var near = this.near, top = near * Math.tan(exports.Math.DEG2RAD * 0.5 * this.fov) / this.zoom, height = 2 * top, width = this.aspect * height, left = -0.5 * width, view = this.view;
        if (view !== null) {
            var fullWidth = view.fullWidth, fullHeight = view.fullHeight;
            left += view.offsetX * width / fullWidth;
            top -= view.offsetY * height / fullHeight;
            width *= view.width / fullWidth;
            height *= view.height / fullHeight;
        }
        var skew = this.filmOffset;
        if (skew !== 0)
            left += near * skew / this.getFilmWidth();
        this.projectionMatrix.makeFrustum(left, left + width, top - height, top, near, this.far);
    },
    toJSON: function (meta) {
        var data = Object3D.prototype.toJSON.call(this, meta);
        data.object.fov = this.fov;
        data.object.zoom = this.zoom;
        data.object.near = this.near;
        data.object.far = this.far;
        data.object.focus = this.focus;
        data.object.aspect = this.aspect;
        if (this.view !== null)
            data.object.view = Object.assign({}, this.view);
        data.object.filmGauge = this.filmGauge;
        data.object.filmOffset = this.filmOffset;
        return data;
    }
});
OrthographicCamera.prototype = Object.assign(Object.create(Camera.prototype), {
    constructor: OrthographicCamera,
    isOrthographicCamera: true,
    copy: function (source) {
        Camera.prototype.copy.call(this, source);
        this.left = source.left;
        this.right = source.right;
        this.top = source.top;
        this.bottom = source.bottom;
        this.near = source.near;
        this.far = source.far;
        this.zoom = source.zoom;
        this.view = source.view === null ? null : Object.assign({}, source.view);
        return this;
    },
    setViewOffset: function (fullWidth, fullHeight, x, y, width, height) {
        this.view = {
            fullWidth: fullWidth,
            fullHeight: fullHeight,
            offsetX: x,
            offsetY: y,
            width: width,
            height: height
        };
        this.updateProjectionMatrix();
    },
    clearViewOffset: function () {
        this.view = null;
        this.updateProjectionMatrix();
    },
    updateProjectionMatrix: function () {
        var dx = (this.right - this.left) / (2 * this.zoom);
        var dy = (this.top - this.bottom) / (2 * this.zoom);
        var cx = (this.right + this.left) / 2;
        var cy = (this.top + this.bottom) / 2;
        var left = cx - dx;
        var right = cx + dx;
        var top = cy + dy;
        var bottom = cy - dy;
        if (this.view !== null) {
            var zoomW = this.zoom / (this.view.width / this.view.fullWidth);
            var zoomH = this.zoom / (this.view.height / this.view.fullHeight);
            var scaleW = (this.right - this.left) / this.view.width;
            var scaleH = (this.top - this.bottom) / this.view.height;
            left += scaleW * (this.view.offsetX / zoomW);
            right = left + scaleW * (this.view.width / zoomW);
            top -= scaleH * (this.view.offsetY / zoomH);
            bottom = top - scaleH * (this.view.height / zoomH);
        }
        this.projectionMatrix.makeOrthographic(left, right, top, bottom, this.near, this.far);
    },
    toJSON: function (meta) {
        var data = Object3D.prototype.toJSON.call(this, meta);
        data.object.zoom = this.zoom;
        data.object.left = this.left;
        data.object.right = this.right;
        data.object.top = this.top;
        data.object.bottom = this.bottom;
        data.object.near = this.near;
        data.object.far = this.far;
        if (this.view !== null)
            data.object.view = Object.assign({}, this.view);
        return data;
    }
});
FogExp2.prototype.isFogExp2 = true;
FogExp2.prototype.clone = function () {
    return new FogExp2(this.color.getHex(), this.density);
};
FogExp2.prototype.toJSON = function (meta) {
    return {
        type: 'FogExp2',
        color: this.color.getHex(),
        density: this.density
    };
};
Fog.prototype.isFog = true;
Fog.prototype.clone = function () {
    return new Fog(this.color.getHex(), this.near, this.far);
};
Fog.prototype.toJSON = function (meta) {
    return {
        type: 'Fog',
        color: this.color.getHex(),
        near: this.near,
        far: this.far
    };
};
Scene.prototype = Object.create(Object3D.prototype);
Scene.prototype.constructor = Scene;
Scene.prototype.copy = function (source, recursive) {
    Object3D.prototype.copy.call(this, source, recursive);
    if (source.background !== null)
        this.background = source.background.clone();
    if (source.fog !== null)
        this.fog = source.fog.clone();
    if (source.overrideMaterial !== null)
        this.overrideMaterial = source.overrideMaterial.clone();
    this.autoUpdate = source.autoUpdate;
    this.matrixAutoUpdate = source.matrixAutoUpdate;
    return this;
};
Scene.prototype.toJSON = function (meta) {
    var data = Object3D.prototype.toJSON.call(this, meta);
    if (this.background !== null)
        data.object.background = this.background.toJSON(meta);
    if (this.fog !== null)
        data.object.fog = this.fog.toJSON();
    return data;
};
LensFlare.prototype = Object.assign(Object.create(Object3D.prototype), {
    constructor: LensFlare,
    isLensFlare: true,
    copy: function (source) {
        Object3D.prototype.copy.call(this, source);
        this.positionScreen.copy(source.positionScreen);
        this.customUpdateCallback = source.customUpdateCallback;
        for (var i = 0, l = source.lensFlares.length; i < l; i++) {
            this.lensFlares.push(source.lensFlares[i]);
        }
        return this;
    },
    add: function (texture, size, distance, blending, color, opacity) {
        if (size === undefined)
            size = -1;
        if (distance === undefined)
            distance = 0;
        if (opacity === undefined)
            opacity = 1;
        if (color === undefined)
            color = new Color(16777215);
        if (blending === undefined)
            blending = NormalBlending;
        distance = Math.min(distance, Math.max(0, distance));
        this.lensFlares.push({
            texture: texture,
            size: size,
            distance: distance,
            x: 0,
            y: 0,
            z: 0,
            scale: 1,
            rotation: 0,
            opacity: opacity,
            color: color,
            blending: blending
        });
    },
    updateLensFlares: function () {
        var f, fl = this.lensFlares.length;
        var flare;
        var vecX = -this.positionScreen.x * 2;
        var vecY = -this.positionScreen.y * 2;
        for (f = 0; f < fl; f++) {
            flare = this.lensFlares[f];
            flare.x = this.positionScreen.x + vecX * flare.distance;
            flare.y = this.positionScreen.y + vecY * flare.distance;
            flare.wantedRotation = flare.x * Math.PI * 0.25;
            flare.rotation += (flare.wantedRotation - flare.rotation) * 0.25;
        }
    }
});
SpriteMaterial.prototype = Object.create(Material.prototype);
SpriteMaterial.prototype.constructor = SpriteMaterial;
SpriteMaterial.prototype.copy = function (source) {
    Material.prototype.copy.call(this, source);
    this.color.copy(source.color);
    this.map = source.map;
    this.rotation = source.rotation;
    return this;
};
Sprite.prototype = Object.assign(Object.create(Object3D.prototype), {
    constructor: Sprite,
    isSprite: true,
    raycast: function () {
        var matrixPosition = new Vector3();
        return function raycast(raycaster, intersects) {
            matrixPosition.setFromMatrixPosition(this.matrixWorld);
            var distanceSq = raycaster.ray.distanceSqToPoint(matrixPosition);
            var guessSizeSq = this.scale.x * this.scale.y / 4;
            if (distanceSq > guessSizeSq) {
                return;
            }
            intersects.push({
                distance: Math.sqrt(distanceSq),
                point: this.position,
                face: null,
                object: this
            });
        };
    }(),
    clone: function () {
        return new this.constructor(this.material).copy(this);
    }
});
LOD.prototype = Object.assign(Object.create(Object3D.prototype), {
    constructor: LOD,
    copy: function (source) {
        Object3D.prototype.copy.call(this, source, false);
        var levels = source.levels;
        for (var i = 0, l = levels.length; i < l; i++) {
            var level = levels[i];
            this.addLevel(level.object.clone(), level.distance);
        }
        return this;
    },
    addLevel: function (object, distance) {
        if (distance === undefined)
            distance = 0;
        distance = Math.abs(distance);
        var levels = this.levels;
        for (var l = 0; l < levels.length; l++) {
            if (distance < levels[l].distance) {
                break;
            }
        }
        levels.splice(l, 0, {
            distance: distance,
            object: object
        });
        this.add(object);
    },
    getObjectForDistance: function (distance) {
        var levels = this.levels;
        for (var i = 1, l = levels.length; i < l; i++) {
            if (distance < levels[i].distance) {
                break;
            }
        }
        return levels[i - 1].object;
    },
    raycast: function () {
        var matrixPosition = new Vector3();
        return function raycast(raycaster, intersects) {
            matrixPosition.setFromMatrixPosition(this.matrixWorld);
            var distance = raycaster.ray.origin.distanceTo(matrixPosition);
            this.getObjectForDistance(distance).raycast(raycaster, intersects);
        };
    }(),
    update: function () {
        var v1 = new Vector3();
        var v2 = new Vector3();
        return function update(camera) {
            var levels = this.levels;
            if (levels.length > 1) {
                v1.setFromMatrixPosition(camera.matrixWorld);
                v2.setFromMatrixPosition(this.matrixWorld);
                var distance = v1.distanceTo(v2);
                levels[0].object.visible = true;
                for (var i = 1, l = levels.length; i < l; i++) {
                    if (distance >= levels[i].distance) {
                        levels[i - 1].object.visible = false;
                        levels[i].object.visible = true;
                    } else {
                        break;
                    }
                }
                for (; i < l; i++) {
                    levels[i].object.visible = false;
                }
            }
        };
    }(),
    toJSON: function (meta) {
        var data = Object3D.prototype.toJSON.call(this, meta);
        data.object.levels = [];
        var levels = this.levels;
        for (var i = 0, l = levels.length; i < l; i++) {
            var level = levels[i];
            data.object.levels.push({
                object: level.object.uuid,
                distance: level.distance
            });
        }
        return data;
    }
});
DataTexture.prototype = Object.create(Texture.prototype);
DataTexture.prototype.constructor = DataTexture;
DataTexture.prototype.isDataTexture = true;
Object.assign(Skeleton.prototype, {
    calculateInverses: function () {
        this.boneInverses = [];
        for (var b = 0, bl = this.bones.length; b < bl; b++) {
            var inverse = new Matrix4();
            if (this.bones[b]) {
                inverse.getInverse(this.bones[b].matrixWorld);
            }
            this.boneInverses.push(inverse);
        }
    },
    pose: function () {
        var bone;
        for (var b = 0, bl = this.bones.length; b < bl; b++) {
            bone = this.bones[b];
            if (bone) {
                bone.matrixWorld.getInverse(this.boneInverses[b]);
            }
        }
        for (var b = 0, bl = this.bones.length; b < bl; b++) {
            bone = this.bones[b];
            if (bone) {
                if (bone.parent && bone.parent.isBone) {
                    bone.matrix.getInverse(bone.parent.matrixWorld);
                    bone.matrix.multiply(bone.matrixWorld);
                } else {
                    bone.matrix.copy(bone.matrixWorld);
                }
                bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);
            }
        }
    },
    update: function () {
        var offsetMatrix = new Matrix4();
        return function update() {
            for (var b = 0, bl = this.bones.length; b < bl; b++) {
                var matrix = this.bones[b] ? this.bones[b].matrixWorld : this.identityMatrix;
                offsetMatrix.multiplyMatrices(matrix, this.boneInverses[b]);
                offsetMatrix.toArray(this.boneMatrices, b * 16);
            }
            if (this.useVertexTexture) {
                this.boneTexture.needsUpdate = true;
            }
        };
    }(),
    clone: function () {
        return new Skeleton(this.bones, this.boneInverses, this.useVertexTexture);
    }
});
Bone.prototype = Object.assign(Object.create(Object3D.prototype), {
    constructor: Bone,
    isBone: true,
    copy: function (source) {
        Object3D.prototype.copy.call(this, source);
        this.skin = source.skin;
        return this;
    }
});
SkinnedMesh.prototype = Object.assign(Object.create(Mesh.prototype), {
    constructor: SkinnedMesh,
    isSkinnedMesh: true,
    bind: function (skeleton, bindMatrix) {
        this.skeleton = skeleton;
        if (bindMatrix === undefined) {
            this.updateMatrixWorld(true);
            this.skeleton.calculateInverses();
            bindMatrix = this.matrixWorld;
        }
        this.bindMatrix.copy(bindMatrix);
        this.bindMatrixInverse.getInverse(bindMatrix);
    },
    pose: function () {
        this.skeleton.pose();
    },
    normalizeSkinWeights: function () {
        if (this.geometry && this.geometry.isGeometry) {
            for (var i = 0; i < this.geometry.skinWeights.length; i++) {
                var sw = this.geometry.skinWeights[i];
                var scale = 1 / sw.lengthManhattan();
                if (scale !== Infinity) {
                    sw.multiplyScalar(scale);
                } else {
                    sw.set(1, 0, 0, 0);
                }
            }
        } else if (this.geometry && this.geometry.isBufferGeometry) {
            var vec = new Vector4();
            var skinWeight = this.geometry.attributes.skinWeight;
            for (var i = 0; i < skinWeight.count; i++) {
                vec.x = skinWeight.getX(i);
                vec.y = skinWeight.getY(i);
                vec.z = skinWeight.getZ(i);
                vec.w = skinWeight.getW(i);
                var scale = 1 / vec.lengthManhattan();
                if (scale !== Infinity) {
                    vec.multiplyScalar(scale);
                } else {
                    vec.set(1, 0, 0, 0);
                }
                skinWeight.setXYZW(i, vec.x, vec.y, vec.z, vec.w);
            }
        }
    },
    updateMatrixWorld: function (force) {
        Mesh.prototype.updateMatrixWorld.call(this, true);
        if (this.bindMode === 'attached') {
            this.bindMatrixInverse.getInverse(this.matrixWorld);
        } else if (this.bindMode === 'detached') {
            this.bindMatrixInverse.getInverse(this.bindMatrix);
        } else {
            console.warn('THREE.SkinnedMesh unrecognized bindMode: ' + this.bindMode);
        }
    },
    clone: function () {
        return new this.constructor(this.geometry, this.material, this.skeleton.useVertexTexture).copy(this);
    }
});
LineBasicMaterial.prototype = Object.create(Material.prototype);
LineBasicMaterial.prototype.constructor = LineBasicMaterial;
LineBasicMaterial.prototype.isLineBasicMaterial = true;
LineBasicMaterial.prototype.copy = function (source) {
    Material.prototype.copy.call(this, source);
    this.color.copy(source.color);
    this.linewidth = source.linewidth;
    this.linecap = source.linecap;
    this.linejoin = source.linejoin;
    return this;
};
Line.prototype = Object.assign(Object.create(Object3D.prototype), {
    constructor: Line,
    isLine: true,
    raycast: function () {
        var inverseMatrix = new Matrix4();
        var ray = new Ray();
        var sphere = new Sphere();
        return function raycast(raycaster, intersects) {
            var precision = raycaster.linePrecision;
            var precisionSq = precision * precision;
            var geometry = this.geometry;
            var matrixWorld = this.matrixWorld;
            if (geometry.boundingSphere === null)
                geometry.computeBoundingSphere();
            sphere.copy(geometry.boundingSphere);
            sphere.applyMatrix4(matrixWorld);
            if (raycaster.ray.intersectsSphere(sphere) === false)
                return;
            inverseMatrix.getInverse(matrixWorld);
            ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);
            var vStart = new Vector3();
            var vEnd = new Vector3();
            var interSegment = new Vector3();
            var interRay = new Vector3();
            var step = this && this.isLineSegments ? 2 : 1;
            if (geometry && geometry.isBufferGeometry) {
                var index = geometry.index;
                var attributes = geometry.attributes;
                var positions = attributes.position.array;
                if (index !== null) {
                    var indices = index.array;
                    for (var i = 0, l = indices.length - 1; i < l; i += step) {
                        var a = indices[i];
                        var b = indices[i + 1];
                        vStart.fromArray(positions, a * 3);
                        vEnd.fromArray(positions, b * 3);
                        var distSq = ray.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
                        if (distSq > precisionSq)
                            continue;
                        interRay.applyMatrix4(this.matrixWorld);
                        var distance = raycaster.ray.origin.distanceTo(interRay);
                        if (distance < raycaster.near || distance > raycaster.far)
                            continue;
                        intersects.push({
                            distance: distance,
                            point: interSegment.clone().applyMatrix4(this.matrixWorld),
                            index: i,
                            face: null,
                            faceIndex: null,
                            object: this
                        });
                    }
                } else {
                    for (var i = 0, l = positions.length / 3 - 1; i < l; i += step) {
                        vStart.fromArray(positions, 3 * i);
                        vEnd.fromArray(positions, 3 * i + 3);
                        var distSq = ray.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
                        if (distSq > precisionSq)
                            continue;
                        interRay.applyMatrix4(this.matrixWorld);
                        var distance = raycaster.ray.origin.distanceTo(interRay);
                        if (distance < raycaster.near || distance > raycaster.far)
                            continue;
                        intersects.push({
                            distance: distance,
                            point: interSegment.clone().applyMatrix4(this.matrixWorld),
                            index: i,
                            face: null,
                            faceIndex: null,
                            object: this
                        });
                    }
                }
            } else if (geometry && geometry.isGeometry) {
                var vertices = geometry.vertices;
                var nbVertices = vertices.length;
                for (var i = 0; i < nbVertices - 1; i += step) {
                    var distSq = ray.distanceSqToSegment(vertices[i], vertices[i + 1], interRay, interSegment);
                    if (distSq > precisionSq)
                        continue;
                    interRay.applyMatrix4(this.matrixWorld);
                    var distance = raycaster.ray.origin.distanceTo(interRay);
                    if (distance < raycaster.near || distance > raycaster.far)
                        continue;
                    intersects.push({
                        distance: distance,
                        point: interSegment.clone().applyMatrix4(this.matrixWorld),
                        index: i,
                        face: null,
                        faceIndex: null,
                        object: this
                    });
                }
            }
        };
    }(),
    clone: function () {
        return new this.constructor(this.geometry, this.material).copy(this);
    }
});
LineSegments.prototype = Object.assign(Object.create(Line.prototype), {
    constructor: LineSegments,
    isLineSegments: true
});
PointsMaterial.prototype = Object.create(Material.prototype);
PointsMaterial.prototype.constructor = PointsMaterial;
PointsMaterial.prototype.isPointsMaterial = true;
PointsMaterial.prototype.copy = function (source) {
    Material.prototype.copy.call(this, source);
    this.color.copy(source.color);
    this.map = source.map;
    this.size = source.size;
    this.sizeAttenuation = source.sizeAttenuation;
    return this;
};
Points.prototype = Object.assign(Object.create(Object3D.prototype), {
    constructor: Points,
    isPoints: true,
    raycast: function () {
        var inverseMatrix = new Matrix4();
        var ray = new Ray();
        var sphere = new Sphere();
        return function raycast(raycaster, intersects) {
            var object = this;
            var geometry = this.geometry;
            var matrixWorld = this.matrixWorld;
            var threshold = raycaster.params.Points.threshold;
            if (geometry.boundingSphere === null)
                geometry.computeBoundingSphere();
            sphere.copy(geometry.boundingSphere);
            sphere.applyMatrix4(matrixWorld);
            if (raycaster.ray.intersectsSphere(sphere) === false)
                return;
            inverseMatrix.getInverse(matrixWorld);
            ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);
            var localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
            var localThresholdSq = localThreshold * localThreshold;
            var position = new Vector3();
            function testPoint(point, index) {
                var rayPointDistanceSq = ray.distanceSqToPoint(point);
                if (rayPointDistanceSq < localThresholdSq) {
                    var intersectPoint = ray.closestPointToPoint(point);
                    intersectPoint.applyMatrix4(matrixWorld);
                    var distance = raycaster.ray.origin.distanceTo(intersectPoint);
                    if (distance < raycaster.near || distance > raycaster.far)
                        return;
                    intersects.push({
                        distance: distance,
                        distanceToRay: Math.sqrt(rayPointDistanceSq),
                        point: intersectPoint.clone(),
                        index: index,
                        face: null,
                        object: object
                    });
                }
            }
            if (geometry && geometry.isBufferGeometry) {
                var index = geometry.index;
                var attributes = geometry.attributes;
                var positions = attributes.position.array;
                if (index !== null) {
                    var indices = index.array;
                    for (var i = 0, il = indices.length; i < il; i++) {
                        var a = indices[i];
                        position.fromArray(positions, a * 3);
                        testPoint(position, a);
                    }
                } else {
                    for (var i = 0, l = positions.length / 3; i < l; i++) {
                        position.fromArray(positions, i * 3);
                        testPoint(position, i);
                    }
                }
            } else {
                var vertices = geometry.vertices;
                for (var i = 0, l = vertices.length; i < l; i++) {
                    testPoint(vertices[i], i);
                }
            }
        };
    }(),
    clone: function () {
        return new this.constructor(this.geometry, this.material).copy(this);
    }
});
Group.prototype = Object.assign(Object.create(Object3D.prototype), {
    constructor: Group
});
VideoTexture.prototype = Object.create(Texture.prototype);
VideoTexture.prototype.constructor = VideoTexture;
CompressedTexture.prototype = Object.create(Texture.prototype);
CompressedTexture.prototype.constructor = CompressedTexture;
CompressedTexture.prototype.isCompressedTexture = true;
CanvasTexture.prototype = Object.create(Texture.prototype);
CanvasTexture.prototype.constructor = CanvasTexture;
DepthTexture.prototype = Object.create(Texture.prototype);
DepthTexture.prototype.constructor = DepthTexture;
DepthTexture.prototype.isDepthTexture = true;
ShadowMaterial.prototype = Object.create(ShaderMaterial.prototype);
ShadowMaterial.prototype.constructor = ShadowMaterial;
ShadowMaterial.prototype.isShadowMaterial = true;
RawShaderMaterial.prototype = Object.create(ShaderMaterial.prototype);
RawShaderMaterial.prototype.constructor = RawShaderMaterial;
RawShaderMaterial.prototype.isRawShaderMaterial = true;
MultiMaterial.prototype = {
    constructor: MultiMaterial,
    isMultiMaterial: true,
    toJSON: function (meta) {
        var output = {
            metadata: {
                version: 4.2,
                type: 'material',
                generator: 'MaterialExporter'
            },
            uuid: this.uuid,
            type: this.type,
            materials: []
        };
        var materials = this.materials;
        for (var i = 0, l = materials.length; i < l; i++) {
            var material = materials[i].toJSON(meta);
            delete material.metadata;
            output.materials.push(material);
        }
        output.visible = this.visible;
        return output;
    },
    clone: function () {
        var material = new this.constructor();
        for (var i = 0; i < this.materials.length; i++) {
            material.materials.push(this.materials[i].clone());
        }
        material.visible = this.visible;
        return material;
    }
};
MeshStandardMaterial.prototype = Object.create(Material.prototype);
MeshStandardMaterial.prototype.constructor = MeshStandardMaterial;
MeshStandardMaterial.prototype.isMeshStandardMaterial = true;
MeshStandardMaterial.prototype.copy = function (source) {
    Material.prototype.copy.call(this, source);
    this.defines = {
        'STANDARD': ''
    };
    this.color.copy(source.color);
    this.roughness = source.roughness;
    this.metalness = source.metalness;
    this.map = source.map;
    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;
    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;
    this.emissive.copy(source.emissive);
    this.emissiveMap = source.emissiveMap;
    this.emissiveIntensity = source.emissiveIntensity;
    this.bumpMap = source.bumpMap;
    this.bumpScale = source.bumpScale;
    this.normalMap = source.normalMap;
    this.normalScale.copy(source.normalScale);
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.roughnessMap = source.roughnessMap;
    this.metalnessMap = source.metalnessMap;
    this.alphaMap = source.alphaMap;
    this.envMap = source.envMap;
    this.envMapIntensity = source.envMapIntensity;
    this.refractionRatio = source.refractionRatio;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    this.morphNormals = source.morphNormals;
    return this;
};
MeshPhysicalMaterial.prototype = Object.create(MeshStandardMaterial.prototype);
MeshPhysicalMaterial.prototype.constructor = MeshPhysicalMaterial;
MeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = true;
MeshPhysicalMaterial.prototype.copy = function (source) {
    MeshStandardMaterial.prototype.copy.call(this, source);
    this.defines = {
        'PHYSICAL': ''
    };
    this.reflectivity = source.reflectivity;
    this.clearCoat = source.clearCoat;
    this.clearCoatRoughness = source.clearCoatRoughness;
    return this;
};
MeshPhongMaterial.prototype = Object.create(Material.prototype);
MeshPhongMaterial.prototype.constructor = MeshPhongMaterial;
MeshPhongMaterial.prototype.isMeshPhongMaterial = true;
MeshPhongMaterial.prototype.copy = function (source) {
    Material.prototype.copy.call(this, source);
    this.color.copy(source.color);
    this.specular.copy(source.specular);
    this.shininess = source.shininess;
    this.map = source.map;
    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;
    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;
    this.emissive.copy(source.emissive);
    this.emissiveMap = source.emissiveMap;
    this.emissiveIntensity = source.emissiveIntensity;
    this.bumpMap = source.bumpMap;
    this.bumpScale = source.bumpScale;
    this.normalMap = source.normalMap;
    this.normalScale.copy(source.normalScale);
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.specularMap = source.specularMap;
    this.alphaMap = source.alphaMap;
    this.envMap = source.envMap;
    this.combine = source.combine;
    this.reflectivity = source.reflectivity;
    this.refractionRatio = source.refractionRatio;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    this.morphNormals = source.morphNormals;
    return this;
};
MeshNormalMaterial.prototype = Object.create(Material.prototype);
MeshNormalMaterial.prototype.constructor = MeshNormalMaterial;
MeshNormalMaterial.prototype.isMeshNormalMaterial = true;
MeshNormalMaterial.prototype.copy = function (source) {
    Material.prototype.copy.call(this, source);
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    return this;
};
MeshLambertMaterial.prototype = Object.create(Material.prototype);
MeshLambertMaterial.prototype.constructor = MeshLambertMaterial;
MeshLambertMaterial.prototype.isMeshLambertMaterial = true;
MeshLambertMaterial.prototype.copy = function (source) {
    Material.prototype.copy.call(this, source);
    this.color.copy(source.color);
    this.map = source.map;
    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;
    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;
    this.emissive.copy(source.emissive);
    this.emissiveMap = source.emissiveMap;
    this.emissiveIntensity = source.emissiveIntensity;
    this.specularMap = source.specularMap;
    this.alphaMap = source.alphaMap;
    this.envMap = source.envMap;
    this.combine = source.combine;
    this.reflectivity = source.reflectivity;
    this.refractionRatio = source.refractionRatio;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    this.morphNormals = source.morphNormals;
    return this;
};
LineDashedMaterial.prototype = Object.create(Material.prototype);
LineDashedMaterial.prototype.constructor = LineDashedMaterial;
LineDashedMaterial.prototype.isLineDashedMaterial = true;
LineDashedMaterial.prototype.copy = function (source) {
    Material.prototype.copy.call(this, source);
    this.color.copy(source.color);
    this.linewidth = source.linewidth;
    this.scale = source.scale;
    this.dashSize = source.dashSize;
    this.gapSize = source.gapSize;
    return this;
};
exports.Cache = {
    enabled: false,
    files: {},
    add: function (key, file) {
        if (this.enabled === false)
            return;
        this.files[key] = file;
    },
    get: function (key) {
        if (this.enabled === false)
            return;
        return this.files[key];
    },
    remove: function (key) {
        delete this.files[key];
    },
    clear: function () {
        this.files = {};
    }
};
exports.DefaultLoadingManager = new LoadingManager();
Object.assign(XHRLoader.prototype, {
    load: function (url, onLoad, onProgress, onError) {
        if (this.path !== undefined)
            url = this.path + url;
        var scope = this;
        var cached = exports.Cache.get(url);
        if (cached !== undefined) {
            scope.manager.itemStart(url);
            setTimeout(function () {
                if (onLoad)
                    onLoad(cached);
                scope.manager.itemEnd(url);
            }, 0);
            return cached;
        }
        var request = new XMLHttpRequest();
        request.open('GET', url, true);
        request.addEventListener('load', function (event) {
            var response = event.target.response;
            exports.Cache.add(url, response);
            if (this.status === 200) {
                if (onLoad)
                    onLoad(response);
                scope.manager.itemEnd(url);
            } else if (this.status === 0) {
                console.warn('THREE.XHRLoader: HTTP Status 0 received.');
                if (onLoad)
                    onLoad(response);
                scope.manager.itemEnd(url);
            } else {
                if (onError)
                    onError(event);
                scope.manager.itemError(url);
            }
        }, false);
        if (onProgress !== undefined) {
            request.addEventListener('progress', function (event) {
                onProgress(event);
            }, false);
        }
        request.addEventListener('error', function (event) {
            if (onError)
                onError(event);
            scope.manager.itemError(url);
        }, false);
        if (this.responseType !== undefined)
            request.responseType = this.responseType;
        if (this.withCredentials !== undefined)
            request.withCredentials = this.withCredentials;
        if (request.overrideMimeType)
            request.overrideMimeType('text/plain');
        request.send(null);
        scope.manager.itemStart(url);
        return request;
    },
    setPath: function (value) {
        this.path = value;
        return this;
    },
    setResponseType: function (value) {
        this.responseType = value;
        return this;
    },
    setWithCredentials: function (value) {
        this.withCredentials = value;
        return this;
    }
});
Object.assign(CompressedTextureLoader.prototype, {
    load: function (url, onLoad, onProgress, onError) {
        var scope = this;
        var images = [];
        var texture = new CompressedTexture();
        texture.image = images;
        var loader = new XHRLoader(this.manager);
        loader.setPath(this.path);
        loader.setResponseType('arraybuffer');
        function loadTexture(i) {
            loader.load(url[i], function (buffer) {
                var texDatas = scope._parser(buffer, true);
                images[i] = {
                    width: texDatas.width,
                    height: texDatas.height,
                    format: texDatas.format,
                    mipmaps: texDatas.mipmaps
                };
                loaded += 1;
                if (loaded === 6) {
                    if (texDatas.mipmapCount === 1)
                        texture.minFilter = LinearFilter;
                    texture.format = texDatas.format;
                    texture.needsUpdate = true;
                    if (onLoad)
                        onLoad(texture);
                }
            }, onProgress, onError);
        }
        if (Array.isArray(url)) {
            var loaded = 0;
            for (var i = 0, il = url.length; i < il; ++i) {
                loadTexture(i);
            }
        } else {
            loader.load(url, function (buffer) {
                var texDatas = scope._parser(buffer, true);
                if (texDatas.isCubemap) {
                    var faces = texDatas.mipmaps.length / texDatas.mipmapCount;
                    for (var f = 0; f < faces; f++) {
                        images[f] = {
                            mipmaps: []
                        };
                        for (var i = 0; i < texDatas.mipmapCount; i++) {
                            images[f].mipmaps.push(texDatas.mipmaps[f * texDatas.mipmapCount + i]);
                            images[f].format = texDatas.format;
                            images[f].width = texDatas.width;
                            images[f].height = texDatas.height;
                        }
                    }
                } else {
                    texture.image.width = texDatas.width;
                    texture.image.height = texDatas.height;
                    texture.mipmaps = texDatas.mipmaps;
                }
                if (texDatas.mipmapCount === 1) {
                    texture.minFilter = LinearFilter;
                }
                texture.format = texDatas.format;
                texture.needsUpdate = true;
                if (onLoad)
                    onLoad(texture);
            }, onProgress, onError);
        }
        return texture;
    },
    setPath: function (value) {
        this.path = value;
        return this;
    }
});
DataTextureLoader = BinaryTextureLoader;
Object.assign(BinaryTextureLoader.prototype, {
    load: function (url, onLoad, onProgress, onError) {
        var scope = this;
        var texture = new DataTexture();
        var loader = new XHRLoader(this.manager);
        loader.setResponseType('arraybuffer');
        loader.load(url, function (buffer) {
            var texData = scope._parser(buffer);
            if (!texData)
                return;
            if (undefined !== texData.image) {
                texture.image = texData.image;
            } else if (undefined !== texData.data) {
                texture.image.width = texData.width;
                texture.image.height = texData.height;
                texture.image.data = texData.data;
            }
            texture.wrapS = undefined !== texData.wrapS ? texData.wrapS : ClampToEdgeWrapping;
            texture.wrapT = undefined !== texData.wrapT ? texData.wrapT : ClampToEdgeWrapping;
            texture.magFilter = undefined !== texData.magFilter ? texData.magFilter : LinearFilter;
            texture.minFilter = undefined !== texData.minFilter ? texData.minFilter : LinearMipMapLinearFilter;
            texture.anisotropy = undefined !== texData.anisotropy ? texData.anisotropy : 1;
            if (undefined !== texData.format) {
                texture.format = texData.format;
            }
            if (undefined !== texData.type) {
                texture.type = texData.type;
            }
            if (undefined !== texData.mipmaps) {
                texture.mipmaps = texData.mipmaps;
            }
            if (1 === texData.mipmapCount) {
                texture.minFilter = LinearFilter;
            }
            texture.needsUpdate = true;
            if (onLoad)
                onLoad(texture, texData);
        }, onProgress, onError);
        return texture;
    }
});
Object.assign(ImageLoader.prototype, {
    load: function (url, onLoad, onProgress, onError) {
        var scope = this;
        var image = document.createElementNS('http://www.w3.org/1999/xhtml', 'img');
        image.onload = function () {
            URL.revokeObjectURL(image.src);
            if (onLoad)
                onLoad(image);
            scope.manager.itemEnd(url);
        };
        if (url.indexOf('data:') === 0) {
            image.src = url;
        } else {
            var loader = new XHRLoader();
            loader.setPath(this.path);
            loader.setResponseType('blob');
            loader.setWithCredentials(this.withCredentials);
            loader.load(url, function (blob) {
                image.src = URL.createObjectURL(blob);
            }, onProgress, onError);
        }
        scope.manager.itemStart(url);
        return image;
    },
    setCrossOrigin: function (value) {
        this.crossOrigin = value;
        return this;
    },
    setWithCredentials: function (value) {
        this.withCredentials = value;
        return this;
    },
    setPath: function (value) {
        this.path = value;
        return this;
    }
});
Object.assign(CubeTextureLoader.prototype, {
    load: function (urls, onLoad, onProgress, onError) {
        var texture = new CubeTexture();
        var loader = new ImageLoader(this.manager);
        loader.setCrossOrigin(this.crossOrigin);
        loader.setPath(this.path);
        var loaded = 0;
        function loadTexture(i) {
            loader.load(urls[i], function (image) {
                texture.images[i] = image;
                loaded++;
                if (loaded === 6) {
                    texture.needsUpdate = true;
                    if (onLoad)
                        onLoad(texture);
                }
            }, undefined, onError);
        }
        for (var i = 0; i < urls.length; ++i) {
            loadTexture(i);
        }
        return texture;
    },
    setCrossOrigin: function (value) {
        this.crossOrigin = value;
        return this;
    },
    setPath: function (value) {
        this.path = value;
        return this;
    }
});
Object.assign(TextureLoader.prototype, {
    load: function (url, onLoad, onProgress, onError) {
        var texture = new Texture();
        var loader = new ImageLoader(this.manager);
        loader.setCrossOrigin(this.crossOrigin);
        loader.setWithCredentials(this.withCredentials);
        loader.setPath(this.path);
        loader.load(url, function (image) {
            var isJPEG = url.search(/\.(jpg|jpeg)$/) > 0 || url.search(/^data\:image\/jpeg/) === 0;
            texture.format = isJPEG ? RGBFormat : RGBAFormat;
            texture.image = image;
            texture.needsUpdate = true;
            if (onLoad !== undefined) {
                onLoad(texture);
            }
        }, onProgress, onError);
        return texture;
    },
    setCrossOrigin: function (value) {
        this.crossOrigin = value;
        return this;
    },
    setWithCredentials: function (value) {
        this.withCredentials = value;
        return this;
    },
    setPath: function (value) {
        this.path = value;
        return this;
    }
});
Light.prototype = Object.assign(Object.create(Object3D.prototype), {
    constructor: Light,
    isLight: true,
    copy: function (source) {
        Object3D.prototype.copy.call(this, source);
        this.color.copy(source.color);
        this.intensity = source.intensity;
        return this;
    },
    toJSON: function (meta) {
        var data = Object3D.prototype.toJSON.call(this, meta);
        data.object.color = this.color.getHex();
        data.object.intensity = this.intensity;
        if (this.groundColor !== undefined)
            data.object.groundColor = this.groundColor.getHex();
        if (this.distance !== undefined)
            data.object.distance = this.distance;
        if (this.angle !== undefined)
            data.object.angle = this.angle;
        if (this.decay !== undefined)
            data.object.decay = this.decay;
        if (this.penumbra !== undefined)
            data.object.penumbra = this.penumbra;
        if (this.shadow !== undefined)
            data.object.shadow = this.shadow.toJSON();
        return data;
    }
});
HemisphereLight.prototype = Object.assign(Object.create(Light.prototype), {
    constructor: HemisphereLight,
    isHemisphereLight: true,
    copy: function (source) {
        Light.prototype.copy.call(this, source);
        this.groundColor.copy(source.groundColor);
        return this;
    }
});
Object.assign(LightShadow.prototype, {
    copy: function (source) {
        this.camera = source.camera.clone();
        this.bias = source.bias;
        this.radius = source.radius;
        this.mapSize.copy(source.mapSize);
        return this;
    },
    clone: function () {
        return new this.constructor().copy(this);
    },
    toJSON: function () {
        var object = {};
        if (this.bias !== 0)
            object.bias = this.bias;
        if (this.radius !== 1)
            object.radius = this.radius;
        if (this.mapSize.x !== 512 || this.mapSize.y !== 512)
            object.mapSize = this.mapSize.toArray();
        object.camera = this.camera.toJSON(false).object;
        delete object.camera.matrix;
        return object;
    }
});
SpotLightShadow.prototype = Object.assign(Object.create(LightShadow.prototype), {
    constructor: SpotLightShadow,
    isSpotLightShadow: true,
    update: function (light) {
        var fov = exports.Math.RAD2DEG * 2 * light.angle;
        var aspect = this.mapSize.width / this.mapSize.height;
        var far = light.distance || 500;
        var camera = this.camera;
        if (fov !== camera.fov || aspect !== camera.aspect || far !== camera.far) {
            camera.fov = fov;
            camera.aspect = aspect;
            camera.far = far;
            camera.updateProjectionMatrix();
        }
    }
});
SpotLight.prototype = Object.assign(Object.create(Light.prototype), {
    constructor: SpotLight,
    isSpotLight: true,
    copy: function (source) {
        Light.prototype.copy.call(this, source);
        this.distance = source.distance;
        this.angle = source.angle;
        this.penumbra = source.penumbra;
        this.decay = source.decay;
        this.target = source.target.clone();
        this.shadow = source.shadow.clone();
        return this;
    }
});
PointLight.prototype = Object.assign(Object.create(Light.prototype), {
    constructor: PointLight,
    isPointLight: true,
    copy: function (source) {
        Light.prototype.copy.call(this, source);
        this.distance = source.distance;
        this.decay = source.decay;
        this.shadow = source.shadow.clone();
        return this;
    }
});
DirectionalLightShadow.prototype = Object.assign(Object.create(LightShadow.prototype), {
    constructor: DirectionalLightShadow
});
DirectionalLight.prototype = Object.assign(Object.create(Light.prototype), {
    constructor: DirectionalLight,
    isDirectionalLight: true,
    copy: function (source) {
        Light.prototype.copy.call(this, source);
        this.target = source.target.clone();
        this.shadow = source.shadow.clone();
        return this;
    }
});
AmbientLight.prototype = Object.assign(Object.create(Light.prototype), {
    constructor: AmbientLight,
    isAmbientLight: true
});
exports.AnimationUtils = {
    arraySlice: function (array, from, to) {
        if (exports.AnimationUtils.isTypedArray(array)) {
            return new array.constructor(array.subarray(from, to));
        }
        return array.slice(from, to);
    },
    convertArray: function (array, type, forceClone) {
        if (!array || !forceClone && array.constructor === type)
            return array;
        if (typeof type.BYTES_PER_ELEMENT === 'number') {
            return new type(array);
        }
        return Array.prototype.slice.call(array);
    },
    isTypedArray: function (object) {
        return ArrayBuffer.isView(object) && !(object instanceof DataView);
    },
    getKeyframeOrder: function (times) {
        function compareTime(i, j) {
            return times[i] - times[j];
        }
        var n = times.length;
        var result = new Array(n);
        for (var i = 0; i !== n; ++i)
            result[i] = i;
        result.sort(compareTime);
        return result;
    },
    sortedArray: function (values, stride, order) {
        var nValues = values.length;
        var result = new values.constructor(nValues);
        for (var i = 0, dstOffset = 0; dstOffset !== nValues; ++i) {
            var srcOffset = order[i] * stride;
            for (var j = 0; j !== stride; ++j) {
                result[dstOffset++] = values[srcOffset + j];
            }
        }
        return result;
    },
    flattenJSON: function (jsonKeys, times, values, valuePropertyName) {
        var i = 1, key = jsonKeys[0];
        while (key !== undefined && key[valuePropertyName] === undefined) {
            key = jsonKeys[i++];
        }
        if (key === undefined)
            return;
        var value = key[valuePropertyName];
        if (value === undefined)
            return;
        if (Array.isArray(value)) {
            do {
                value = key[valuePropertyName];
                if (value !== undefined) {
                    times.push(key.time);
                    values.push.apply(values, value);
                }
                key = jsonKeys[i++];
            } while (key !== undefined);
        } else if (value.toArray !== undefined) {
            do {
                value = key[valuePropertyName];
                if (value !== undefined) {
                    times.push(key.time);
                    value.toArray(values, values.length);
                }
                key = jsonKeys[i++];
            } while (key !== undefined);
        } else {
            do {
                value = key[valuePropertyName];
                if (value !== undefined) {
                    times.push(key.time);
                    values.push(value);
                }
                key = jsonKeys[i++];
            } while (key !== undefined);
        }
    }
};
Interpolant.prototype = {
    constructor: Interpolant,
    evaluate: function (t) {
        var pp = this.parameterPositions, i1 = this._cachedIndex, t1 = pp[i1], t0 = pp[i1 - 1];
        validate_interval: {
            seek: {
                var right;
                linear_scan: {
                    forward_scan:
                        if (!(t < t1)) {
                            for (var giveUpAt = i1 + 2;;) {
                                if (t1 === undefined) {
                                    if (t < t0)
                                        break forward_scan;
                                    i1 = pp.length;
                                    this._cachedIndex = i1;
                                    return this.afterEnd_(i1 - 1, t, t0);
                                }
                                if (i1 === giveUpAt)
                                    break;
                                t0 = t1;
                                t1 = pp[++i1];
                                if (t < t1) {
                                    break seek;
                                }
                            }
                            right = pp.length;
                            break linear_scan;
                        }
                    if (!(t >= t0)) {
                        var t1global = pp[1];
                        if (t < t1global) {
                            i1 = 2;
                            t0 = t1global;
                        }
                        for (var giveUpAt = i1 - 2;;) {
                            if (t0 === undefined) {
                                this._cachedIndex = 0;
                                return this.beforeStart_(0, t, t1);
                            }
                            if (i1 === giveUpAt)
                                break;
                            t1 = t0;
                            t0 = pp[--i1 - 1];
                            if (t >= t0) {
                                break seek;
                            }
                        }
                        right = i1;
                        i1 = 0;
                        break linear_scan;
                    }
                    break validate_interval;
                }
                while (i1 < right) {
                    var mid = i1 + right >>> 1;
                    if (t < pp[mid]) {
                        right = mid;
                    } else {
                        i1 = mid + 1;
                    }
                }
                t1 = pp[i1];
                t0 = pp[i1 - 1];
                if (t0 === undefined) {
                    this._cachedIndex = 0;
                    return this.beforeStart_(0, t, t1);
                }
                if (t1 === undefined) {
                    i1 = pp.length;
                    this._cachedIndex = i1;
                    return this.afterEnd_(i1 - 1, t0, t);
                }
            }
            this._cachedIndex = i1;
            this.intervalChanged_(i1, t0, t1);
        }
        return this.interpolate_(i1, t0, t, t1);
    },
    settings: null,
    DefaultSettings_: {},
    getSettings_: function () {
        return this.settings || this.DefaultSettings_;
    },
    copySampleValue_: function (index) {
        var result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset = index * stride;
        for (var i = 0; i !== stride; ++i) {
            result[i] = values[offset + i];
        }
        return result;
    },
    interpolate_: function (i1, t0, t, t1) {
        throw new Error('call to abstract method');
    },
    intervalChanged_: function (i1, t0, t1) {
    }
};
Object.assign(Interpolant.prototype, {
    beforeStart_: Interpolant.prototype.copySampleValue_,
    afterEnd_: Interpolant.prototype.copySampleValue_
});
CubicInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
    constructor: CubicInterpolant,
    DefaultSettings_: {
        endingStart: ZeroCurvatureEnding,
        endingEnd: ZeroCurvatureEnding
    },
    intervalChanged_: function (i1, t0, t1) {
        var pp = this.parameterPositions, iPrev = i1 - 2, iNext = i1 + 1, tPrev = pp[iPrev], tNext = pp[iNext];
        if (tPrev === undefined) {
            switch (this.getSettings_().endingStart) {
            case ZeroSlopeEnding:
                iPrev = i1;
                tPrev = 2 * t0 - t1;
                break;
            case WrapAroundEnding:
                iPrev = pp.length - 2;
                tPrev = t0 + pp[iPrev] - pp[iPrev + 1];
                break;
            default:
                iPrev = i1;
                tPrev = t1;
            }
        }
        if (tNext === undefined) {
            switch (this.getSettings_().endingEnd) {
            case ZeroSlopeEnding:
                iNext = i1;
                tNext = 2 * t1 - t0;
                break;
            case WrapAroundEnding:
                iNext = 1;
                tNext = t1 + pp[1] - pp[0];
                break;
            default:
                iNext = i1 - 1;
                tNext = t0;
            }
        }
        var halfDt = (t1 - t0) * 0.5, stride = this.valueSize;
        this._weightPrev = halfDt / (t0 - tPrev);
        this._weightNext = halfDt / (tNext - t1);
        this._offsetPrev = iPrev * stride;
        this._offsetNext = iNext * stride;
    },
    interpolate_: function (i1, t0, t, t1) {
        var result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, o1 = i1 * stride, o0 = o1 - stride, oP = this._offsetPrev, oN = this._offsetNext, wP = this._weightPrev, wN = this._weightNext, p = (t - t0) / (t1 - t0), pp = p * p, ppp = pp * p;
        var sP = -wP * ppp + 2 * wP * pp - wP * p;
        var s0 = (1 + wP) * ppp + (-1.5 - 2 * wP) * pp + (-0.5 + wP) * p + 1;
        var s1 = (-1 - wN) * ppp + (1.5 + wN) * pp + 0.5 * p;
        var sN = wN * ppp - wN * pp;
        for (var i = 0; i !== stride; ++i) {
            result[i] = sP * values[oP + i] + s0 * values[o0 + i] + s1 * values[o1 + i] + sN * values[oN + i];
        }
        return result;
    }
});
LinearInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
    constructor: LinearInterpolant,
    interpolate_: function (i1, t0, t, t1) {
        var result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset1 = i1 * stride, offset0 = offset1 - stride, weight1 = (t - t0) / (t1 - t0), weight0 = 1 - weight1;
        for (var i = 0; i !== stride; ++i) {
            result[i] = values[offset0 + i] * weight0 + values[offset1 + i] * weight1;
        }
        return result;
    }
});
DiscreteInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
    constructor: DiscreteInterpolant,
    interpolate_: function (i1, t0, t, t1) {
        return this.copySampleValue_(i1 - 1);
    }
});
KeyframeTrackPrototype = {
    TimeBufferType: Float32Array,
    ValueBufferType: Float32Array,
    DefaultInterpolation: InterpolateLinear,
    InterpolantFactoryMethodDiscrete: function (result) {
        return new DiscreteInterpolant(this.times, this.values, this.getValueSize(), result);
    },
    InterpolantFactoryMethodLinear: function (result) {
        return new LinearInterpolant(this.times, this.values, this.getValueSize(), result);
    },
    InterpolantFactoryMethodSmooth: function (result) {
        return new CubicInterpolant(this.times, this.values, this.getValueSize(), result);
    },
    setInterpolation: function (interpolation) {
        var factoryMethod;
        switch (interpolation) {
        case InterpolateDiscrete:
            factoryMethod = this.InterpolantFactoryMethodDiscrete;
            break;
        case InterpolateLinear:
            factoryMethod = this.InterpolantFactoryMethodLinear;
            break;
        case InterpolateSmooth:
            factoryMethod = this.InterpolantFactoryMethodSmooth;
            break;
        }
        if (factoryMethod === undefined) {
            var message = 'unsupported interpolation for ' + this.ValueTypeName + ' keyframe track named ' + this.name;
            if (this.createInterpolant === undefined) {
                if (interpolation !== this.DefaultInterpolation) {
                    this.setInterpolation(this.DefaultInterpolation);
                } else {
                    throw new Error(message);
                }
            }
            console.warn(message);
            return;
        }
        this.createInterpolant = factoryMethod;
    },
    getInterpolation: function () {
        switch (this.createInterpolant) {
        case this.InterpolantFactoryMethodDiscrete:
            return InterpolateDiscrete;
        case this.InterpolantFactoryMethodLinear:
            return InterpolateLinear;
        case this.InterpolantFactoryMethodSmooth:
            return InterpolateSmooth;
        }
    },
    getValueSize: function () {
        return this.values.length / this.times.length;
    },
    shift: function (timeOffset) {
        if (timeOffset !== 0) {
            var times = this.times;
            for (var i = 0, n = times.length; i !== n; ++i) {
                times[i] += timeOffset;
            }
        }
        return this;
    },
    scale: function (timeScale) {
        if (timeScale !== 1) {
            var times = this.times;
            for (var i = 0, n = times.length; i !== n; ++i) {
                times[i] *= timeScale;
            }
        }
        return this;
    },
    trim: function (startTime, endTime) {
        var times = this.times, nKeys = times.length, from = 0, to = nKeys - 1;
        while (from !== nKeys && times[from] < startTime)
            ++from;
        while (to !== -1 && times[to] > endTime)
            --to;
        ++to;
        if (from !== 0 || to !== nKeys) {
            if (from >= to)
                to = Math.max(to, 1), from = to - 1;
            var stride = this.getValueSize();
            this.times = exports.AnimationUtils.arraySlice(times, from, to);
            this.values = exports.AnimationUtils.arraySlice(this.values, from * stride, to * stride);
        }
        return this;
    },
    validate: function () {
        var valid = true;
        var valueSize = this.getValueSize();
        if (valueSize - Math.floor(valueSize) !== 0) {
            console.error('invalid value size in track', this);
            valid = false;
        }
        var times = this.times, values = this.values, nKeys = times.length;
        if (nKeys === 0) {
            console.error('track is empty', this);
            valid = false;
        }
        var prevTime = null;
        for (var i = 0; i !== nKeys; i++) {
            var currTime = times[i];
            if (typeof currTime === 'number' && isNaN(currTime)) {
                console.error('time is not a valid number', this, i, currTime);
                valid = false;
                break;
            }
            if (prevTime !== null && prevTime > currTime) {
                console.error('out of order keys', this, i, currTime, prevTime);
                valid = false;
                break;
            }
            prevTime = currTime;
        }
        if (values !== undefined) {
            if (exports.AnimationUtils.isTypedArray(values)) {
                for (var i = 0, n = values.length; i !== n; ++i) {
                    var value = values[i];
                    if (isNaN(value)) {
                        console.error('value is not a valid number', this, i, value);
                        valid = false;
                        break;
                    }
                }
            }
        }
        return valid;
    },
    optimize: function () {
        var times = this.times, values = this.values, stride = this.getValueSize(), writeIndex = 1;
        for (var i = 1, n = times.length - 1; i <= n; ++i) {
            var keep = false;
            var time = times[i];
            var timeNext = times[i + 1];
            if (time !== timeNext && (i !== 1 || time !== time[0])) {
                var offset = i * stride, offsetP = offset - stride, offsetN = offset + stride;
                for (var j = 0; j !== stride; ++j) {
                    var value = values[offset + j];
                    if (value !== values[offsetP + j] || value !== values[offsetN + j]) {
                        keep = true;
                        break;
                    }
                }
            }
            if (keep) {
                if (i !== writeIndex) {
                    times[writeIndex] = times[i];
                    var readOffset = i * stride, writeOffset = writeIndex * stride;
                    for (var j = 0; j !== stride; ++j) {
                        values[writeOffset + j] = values[readOffset + j];
                    }
                }
                ++writeIndex;
            }
        }
        if (writeIndex !== times.length) {
            this.times = exports.AnimationUtils.arraySlice(times, 0, writeIndex);
            this.values = exports.AnimationUtils.arraySlice(values, 0, writeIndex * stride);
        }
        return this;
    }
};
VectorKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrackPrototype), {
    constructor: VectorKeyframeTrack,
    ValueTypeName: 'vector'
});
QuaternionLinearInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
    constructor: QuaternionLinearInterpolant,
    interpolate_: function (i1, t0, t, t1) {
        var result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset = i1 * stride, alpha = (t - t0) / (t1 - t0);
        for (var end = offset + stride; offset !== end; offset += 4) {
            Quaternion.slerpFlat(result, 0, values, offset - stride, values, offset, alpha);
        }
        return result;
    }
});
QuaternionKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrackPrototype), {
    constructor: QuaternionKeyframeTrack,
    ValueTypeName: 'quaternion',
    DefaultInterpolation: InterpolateLinear,
    InterpolantFactoryMethodLinear: function (result) {
        return new QuaternionLinearInterpolant(this.times, this.values, this.getValueSize(), result);
    },
    InterpolantFactoryMethodSmooth: undefined
});
NumberKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrackPrototype), {
    constructor: NumberKeyframeTrack,
    ValueTypeName: 'number'
});
StringKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrackPrototype), {
    constructor: StringKeyframeTrack,
    ValueTypeName: 'string',
    ValueBufferType: Array,
    DefaultInterpolation: InterpolateDiscrete,
    InterpolantFactoryMethodLinear: undefined,
    InterpolantFactoryMethodSmooth: undefined
});
BooleanKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrackPrototype), {
    constructor: BooleanKeyframeTrack,
    ValueTypeName: 'bool',
    ValueBufferType: Array,
    DefaultInterpolation: InterpolateDiscrete,
    InterpolantFactoryMethodLinear: undefined,
    InterpolantFactoryMethodSmooth: undefined
});
ColorKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrackPrototype), {
    constructor: ColorKeyframeTrack,
    ValueTypeName: 'color'
});
KeyframeTrack.prototype = KeyframeTrackPrototype;
KeyframeTrackPrototype.constructor = KeyframeTrack;
Object.assign(KeyframeTrack, {
    parse: function (json) {
        if (json.type === undefined) {
            throw new Error('track type undefined, can not parse');
        }
        var trackType = KeyframeTrack._getTrackTypeForValueTypeName(json.type);
        if (json.times === undefined) {
            var times = [], values = [];
            exports.AnimationUtils.flattenJSON(json.keys, times, values, 'value');
            json.times = times;
            json.values = values;
        }
        if (trackType.parse !== undefined) {
            return trackType.parse(json);
        } else {
            return new trackType(json.name, json.times, json.values, json.interpolation);
        }
    },
    toJSON: function (track) {
        var trackType = track.constructor;
        var json;
        if (trackType.toJSON !== undefined) {
            json = trackType.toJSON(track);
        } else {
            json = {
                'name': track.name,
                'times': exports.AnimationUtils.convertArray(track.times, Array),
                'values': exports.AnimationUtils.convertArray(track.values, Array)
            };
            var interpolation = track.getInterpolation();
            if (interpolation !== track.DefaultInterpolation) {
                json.interpolation = interpolation;
            }
        }
        json.type = track.ValueTypeName;
        return json;
    },
    _getTrackTypeForValueTypeName: function (typeName) {
        switch (typeName.toLowerCase()) {
        case 'scalar':
        case 'double':
        case 'float':
        case 'number':
        case 'integer':
            return NumberKeyframeTrack;
        case 'vector':
        case 'vector2':
        case 'vector3':
        case 'vector4':
            return VectorKeyframeTrack;
        case 'color':
            return ColorKeyframeTrack;
        case 'quaternion':
            return QuaternionKeyframeTrack;
        case 'bool':
        case 'boolean':
            return BooleanKeyframeTrack;
        case 'string':
            return StringKeyframeTrack;
        }
        throw new Error('Unsupported typeName: ' + typeName);
    }
});
AnimationClip.prototype = {
    constructor: AnimationClip,
    resetDuration: function () {
        var tracks = this.tracks, duration = 0;
        for (var i = 0, n = tracks.length; i !== n; ++i) {
            var track = this.tracks[i];
            duration = Math.max(duration, track.times[track.times.length - 1]);
        }
        this.duration = duration;
    },
    trim: function () {
        for (var i = 0; i < this.tracks.length; i++) {
            this.tracks[i].trim(0, this.duration);
        }
        return this;
    },
    optimize: function () {
        for (var i = 0; i < this.tracks.length; i++) {
            this.tracks[i].optimize();
        }
        return this;
    }
};
Object.assign(AnimationClip, {
    parse: function (json) {
        var tracks = [], jsonTracks = json.tracks, frameTime = 1 / (json.fps || 1);
        for (var i = 0, n = jsonTracks.length; i !== n; ++i) {
            tracks.push(KeyframeTrack.parse(jsonTracks[i]).scale(frameTime));
        }
        return new AnimationClip(json.name, json.duration, tracks);
    },
    toJSON: function (clip) {
        var tracks = [], clipTracks = clip.tracks;
        var json = {
            'name': clip.name,
            'duration': clip.duration,
            'tracks': tracks
        };
        for (var i = 0, n = clipTracks.length; i !== n; ++i) {
            tracks.push(KeyframeTrack.toJSON(clipTracks[i]));
        }
        return json;
    },
    CreateFromMorphTargetSequence: function (name, morphTargetSequence, fps, noLoop) {
        var numMorphTargets = morphTargetSequence.length;
        var tracks = [];
        for (var i = 0; i < numMorphTargets; i++) {
            var times = [];
            var values = [];
            times.push((i + numMorphTargets - 1) % numMorphTargets, i, (i + 1) % numMorphTargets);
            values.push(0, 1, 0);
            var order = exports.AnimationUtils.getKeyframeOrder(times);
            times = exports.AnimationUtils.sortedArray(times, 1, order);
            values = exports.AnimationUtils.sortedArray(values, 1, order);
            if (!noLoop && times[0] === 0) {
                times.push(numMorphTargets);
                values.push(values[0]);
            }
            tracks.push(new NumberKeyframeTrack('.morphTargetInfluences[' + morphTargetSequence[i].name + ']', times, values).scale(1 / fps));
        }
        return new AnimationClip(name, -1, tracks);
    },
    findByName: function (objectOrClipArray, name) {
        var clipArray = objectOrClipArray;
        if (!Array.isArray(objectOrClipArray)) {
            var o = objectOrClipArray;
            clipArray = o.geometry && o.geometry.animations || o.animations;
        }
        for (var i = 0; i < clipArray.length; i++) {
            if (clipArray[i].name === name) {
                return clipArray[i];
            }
        }
        return null;
    },
    CreateClipsFromMorphTargetSequences: function (morphTargets, fps, noLoop) {
        var animationToMorphTargets = {};
        var pattern = /^([\w-]*?)([\d]+)$/;
        for (var i = 0, il = morphTargets.length; i < il; i++) {
            var morphTarget = morphTargets[i];
            var parts = morphTarget.name.match(pattern);
            if (parts && parts.length > 1) {
                var name = parts[1];
                var animationMorphTargets = animationToMorphTargets[name];
                if (!animationMorphTargets) {
                    animationToMorphTargets[name] = animationMorphTargets = [];
                }
                animationMorphTargets.push(morphTarget);
            }
        }
        var clips = [];
        for (var name in animationToMorphTargets) {
            clips.push(AnimationClip.CreateFromMorphTargetSequence(name, animationToMorphTargets[name], fps, noLoop));
        }
        return clips;
    },
    parseAnimation: function (animation, bones, nodeName) {
        if (!animation) {
            console.error('  no animation in JSONLoader data');
            return null;
        }
        var addNonemptyTrack = function (trackType, trackName, animationKeys, propertyName, destTracks) {
            if (animationKeys.length !== 0) {
                var times = [];
                var values = [];
                exports.AnimationUtils.flattenJSON(animationKeys, times, values, propertyName);
                if (times.length !== 0) {
                    destTracks.push(new trackType(trackName, times, values));
                }
            }
        };
        var tracks = [];
        var clipName = animation.name || 'default';
        var duration = animation.length || -1;
        var fps = animation.fps || 30;
        var hierarchyTracks = animation.hierarchy || [];
        for (var h = 0; h < hierarchyTracks.length; h++) {
            var animationKeys = hierarchyTracks[h].keys;
            if (!animationKeys || animationKeys.length === 0)
                continue;
            if (animationKeys[0].morphTargets) {
                var morphTargetNames = {};
                for (var k = 0; k < animationKeys.length; k++) {
                    if (animationKeys[k].morphTargets) {
                        for (var m = 0; m < animationKeys[k].morphTargets.length; m++) {
                            morphTargetNames[animationKeys[k].morphTargets[m]] = -1;
                        }
                    }
                }
                for (var morphTargetName in morphTargetNames) {
                    var times = [];
                    var values = [];
                    for (var m = 0; m !== animationKeys[k].morphTargets.length; ++m) {
                        var animationKey = animationKeys[k];
                        times.push(animationKey.time);
                        values.push(animationKey.morphTarget === morphTargetName ? 1 : 0);
                    }
                    tracks.push(new NumberKeyframeTrack('.morphTargetInfluence[' + morphTargetName + ']', times, values));
                }
                duration = morphTargetNames.length * (fps || 1);
            } else {
                var boneName = '.bones[' + bones[h].name + ']';
                addNonemptyTrack(VectorKeyframeTrack, boneName + '.position', animationKeys, 'pos', tracks);
                addNonemptyTrack(QuaternionKeyframeTrack, boneName + '.quaternion', animationKeys, 'rot', tracks);
                addNonemptyTrack(VectorKeyframeTrack, boneName + '.scale', animationKeys, 'scl', tracks);
            }
        }
        if (tracks.length === 0) {
            return null;
        }
        var clip = new AnimationClip(clipName, duration, tracks);
        return clip;
    }
});
Object.assign(MaterialLoader.prototype, {
    load: function (url, onLoad, onProgress, onError) {
        var scope = this;
        var loader = new XHRLoader(scope.manager);
        loader.load(url, function (text) {
            onLoad(scope.parse(JSON.parse(text)));
        }, onProgress, onError);
    },
    setTextures: function (value) {
        this.textures = value;
    },
    parse: function (json) {
        var textures = this.textures;
        function getTexture(name) {
            if (textures[name] === undefined) {
                console.warn('THREE.MaterialLoader: Undefined texture', name);
            }
            return textures[name];
        }
        var material = new THREE[json.type]();
        if (json.uuid !== undefined)
            material.uuid = json.uuid;
        if (json.name !== undefined)
            material.name = json.name;
        if (json.color !== undefined)
            material.color.setHex(json.color);
        if (json.roughness !== undefined)
            material.roughness = json.roughness;
        if (json.metalness !== undefined)
            material.metalness = json.metalness;
        if (json.emissive !== undefined)
            material.emissive.setHex(json.emissive);
        if (json.specular !== undefined)
            material.specular.setHex(json.specular);
        if (json.shininess !== undefined)
            material.shininess = json.shininess;
        if (json.uniforms !== undefined)
            material.uniforms = json.uniforms;
        if (json.vertexShader !== undefined)
            material.vertexShader = json.vertexShader;
        if (json.fragmentShader !== undefined)
            material.fragmentShader = json.fragmentShader;
        if (json.vertexColors !== undefined)
            material.vertexColors = json.vertexColors;
        if (json.fog !== undefined)
            material.fog = json.fog;
        if (json.shading !== undefined)
            material.shading = json.shading;
        if (json.blending !== undefined)
            material.blending = json.blending;
        if (json.side !== undefined)
            material.side = json.side;
        if (json.opacity !== undefined)
            material.opacity = json.opacity;
        if (json.transparent !== undefined)
            material.transparent = json.transparent;
        if (json.alphaTest !== undefined)
            material.alphaTest = json.alphaTest;
        if (json.depthTest !== undefined)
            material.depthTest = json.depthTest;
        if (json.depthWrite !== undefined)
            material.depthWrite = json.depthWrite;
        if (json.colorWrite !== undefined)
            material.colorWrite = json.colorWrite;
        if (json.wireframe !== undefined)
            material.wireframe = json.wireframe;
        if (json.wireframeLinewidth !== undefined)
            material.wireframeLinewidth = json.wireframeLinewidth;
        if (json.wireframeLinecap !== undefined)
            material.wireframeLinecap = json.wireframeLinecap;
        if (json.wireframeLinejoin !== undefined)
            material.wireframeLinejoin = json.wireframeLinejoin;
        if (json.skinning !== undefined)
            material.skinning = json.skinning;
        if (json.morphTargets !== undefined)
            material.morphTargets = json.morphTargets;
        if (json.size !== undefined)
            material.size = json.size;
        if (json.sizeAttenuation !== undefined)
            material.sizeAttenuation = json.sizeAttenuation;
        if (json.map !== undefined)
            material.map = getTexture(json.map);
        if (json.alphaMap !== undefined) {
            material.alphaMap = getTexture(json.alphaMap);
            material.transparent = true;
        }
        if (json.bumpMap !== undefined)
            material.bumpMap = getTexture(json.bumpMap);
        if (json.bumpScale !== undefined)
            material.bumpScale = json.bumpScale;
        if (json.normalMap !== undefined)
            material.normalMap = getTexture(json.normalMap);
        if (json.normalScale !== undefined) {
            var normalScale = json.normalScale;
            if (Array.isArray(normalScale) === false) {
                normalScale = [
                    normalScale,
                    normalScale
                ];
            }
            material.normalScale = new Vector2().fromArray(normalScale);
        }
        if (json.displacementMap !== undefined)
            material.displacementMap = getTexture(json.displacementMap);
        if (json.displacementScale !== undefined)
            material.displacementScale = json.displacementScale;
        if (json.displacementBias !== undefined)
            material.displacementBias = json.displacementBias;
        if (json.roughnessMap !== undefined)
            material.roughnessMap = getTexture(json.roughnessMap);
        if (json.metalnessMap !== undefined)
            material.metalnessMap = getTexture(json.metalnessMap);
        if (json.emissiveMap !== undefined)
            material.emissiveMap = getTexture(json.emissiveMap);
        if (json.emissiveIntensity !== undefined)
            material.emissiveIntensity = json.emissiveIntensity;
        if (json.specularMap !== undefined)
            material.specularMap = getTexture(json.specularMap);
        if (json.envMap !== undefined)
            material.envMap = getTexture(json.envMap);
        if (json.reflectivity !== undefined)
            material.reflectivity = json.reflectivity;
        if (json.lightMap !== undefined)
            material.lightMap = getTexture(json.lightMap);
        if (json.lightMapIntensity !== undefined)
            material.lightMapIntensity = json.lightMapIntensity;
        if (json.aoMap !== undefined)
            material.aoMap = getTexture(json.aoMap);
        if (json.aoMapIntensity !== undefined)
            material.aoMapIntensity = json.aoMapIntensity;
        if (json.materials !== undefined) {
            for (var i = 0, l = json.materials.length; i < l; i++) {
                material.materials.push(this.parse(json.materials[i]));
            }
        }
        return material;
    }
});
Object.assign(BufferGeometryLoader.prototype, {
    load: function (url, onLoad, onProgress, onError) {
        var scope = this;
        var loader = new XHRLoader(scope.manager);
        loader.load(url, function (text) {
            onLoad(scope.parse(JSON.parse(text)));
        }, onProgress, onError);
    },
    parse: function (json) {
        var geometry = new BufferGeometry();
        var index = json.data.index;
        var TYPED_ARRAYS = {
            'Int8Array': Int8Array,
            'Uint8Array': Uint8Array,
            'Uint8ClampedArray': Uint8ClampedArray,
            'Int16Array': Int16Array,
            'Uint16Array': Uint16Array,
            'Int32Array': Int32Array,
            'Uint32Array': Uint32Array,
            'Float32Array': Float32Array,
            'Float64Array': Float64Array
        };
        if (index !== undefined) {
            var typedArray = new TYPED_ARRAYS[index.type](index.array);
            geometry.setIndex(new BufferAttribute(typedArray, 1));
        }
        var attributes = json.data.attributes;
        for (var key in attributes) {
            var attribute = attributes[key];
            var typedArray = new TYPED_ARRAYS[attribute.type](attribute.array);
            geometry.addAttribute(key, new BufferAttribute(typedArray, attribute.itemSize, attribute.normalized));
        }
        var groups = json.data.groups || json.data.drawcalls || json.data.offsets;
        if (groups !== undefined) {
            for (var i = 0, n = groups.length; i !== n; ++i) {
                var group = groups[i];
                geometry.addGroup(group.start, group.count, group.materialIndex);
            }
        }
        var boundingSphere = json.data.boundingSphere;
        if (boundingSphere !== undefined) {
            var center = new Vector3();
            if (boundingSphere.center !== undefined) {
                center.fromArray(boundingSphere.center);
            }
            geometry.boundingSphere = new Sphere(center, boundingSphere.radius);
        }
        return geometry;
    }
});
Loader.prototype = {
    constructor: Loader,
    crossOrigin: undefined,
    extractUrlBase: function (url) {
        var parts = url.split('/');
        if (parts.length === 1)
            return './';
        parts.pop();
        return parts.join('/') + '/';
    },
    initMaterials: function (materials, texturePath, crossOrigin) {
        var array = [];
        for (var i = 0; i < materials.length; ++i) {
            array[i] = this.createMaterial(materials[i], texturePath, crossOrigin);
        }
        return array;
    },
    createMaterial: function () {
        var color, textureLoader, materialLoader;
        return function createMaterial(m, texturePath, crossOrigin) {
            if (color === undefined)
                color = new Color();
            if (textureLoader === undefined)
                textureLoader = new TextureLoader();
            if (materialLoader === undefined)
                materialLoader = new MaterialLoader();
            var textures = {};
            function loadTexture(path, repeat, offset, wrap, anisotropy) {
                var fullPath = texturePath + path;
                var loader = Loader.Handlers.get(fullPath);
                var texture;
                if (loader !== null) {
                    texture = loader.load(fullPath);
                } else {
                    textureLoader.setCrossOrigin(crossOrigin);
                    texture = textureLoader.load(fullPath);
                }
                if (repeat !== undefined) {
                    texture.repeat.fromArray(repeat);
                    if (repeat[0] !== 1)
                        texture.wrapS = RepeatWrapping;
                    if (repeat[1] !== 1)
                        texture.wrapT = RepeatWrapping;
                }
                if (offset !== undefined) {
                    texture.offset.fromArray(offset);
                }
                if (wrap !== undefined) {
                    if (wrap[0] === 'repeat')
                        texture.wrapS = RepeatWrapping;
                    if (wrap[0] === 'mirror')
                        texture.wrapS = MirroredRepeatWrapping;
                    if (wrap[1] === 'repeat')
                        texture.wrapT = RepeatWrapping;
                    if (wrap[1] === 'mirror')
                        texture.wrapT = MirroredRepeatWrapping;
                }
                if (anisotropy !== undefined) {
                    texture.anisotropy = anisotropy;
                }
                var uuid = exports.Math.generateUUID();
                textures[uuid] = texture;
                return uuid;
            }
            var json = {
                uuid: exports.Math.generateUUID(),
                type: 'MeshLambertMaterial'
            };
            for (var name in m) {
                var value = m[name];
                switch (name) {
                case 'DbgColor':
                case 'DbgIndex':
                case 'opticalDensity':
                case 'illumination':
                    break;
                case 'DbgName':
                    json.name = value;
                    break;
                case 'blending':
                    json.blending = THREE[value];
                    break;
                case 'colorAmbient':
                case 'mapAmbient':
                    console.warn('THREE.Loader.createMaterial:', name, 'is no longer supported.');
                    break;
                case 'colorDiffuse':
                    json.color = color.fromArray(value).getHex();
                    break;
                case 'colorSpecular':
                    json.specular = color.fromArray(value).getHex();
                    break;
                case 'colorEmissive':
                    json.emissive = color.fromArray(value).getHex();
                    break;
                case 'specularCoef':
                    json.shininess = value;
                    break;
                case 'shading':
                    if (value.toLowerCase() === 'basic')
                        json.type = 'MeshBasicMaterial';
                    if (value.toLowerCase() === 'phong')
                        json.type = 'MeshPhongMaterial';
                    if (value.toLowerCase() === 'standard')
                        json.type = 'MeshStandardMaterial';
                    break;
                case 'mapDiffuse':
                    json.map = loadTexture(value, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy);
                    break;
                case 'mapDiffuseRepeat':
                case 'mapDiffuseOffset':
                case 'mapDiffuseWrap':
                case 'mapDiffuseAnisotropy':
                    break;
                case 'mapEmissive':
                    json.emissiveMap = loadTexture(value, m.mapEmissiveRepeat, m.mapEmissiveOffset, m.mapEmissiveWrap, m.mapEmissiveAnisotropy);
                    break;
                case 'mapEmissiveRepeat':
                case 'mapEmissiveOffset':
                case 'mapEmissiveWrap':
                case 'mapEmissiveAnisotropy':
                    break;
                case 'mapLight':
                    json.lightMap = loadTexture(value, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy);
                    break;
                case 'mapLightRepeat':
                case 'mapLightOffset':
                case 'mapLightWrap':
                case 'mapLightAnisotropy':
                    break;
                case 'mapAO':
                    json.aoMap = loadTexture(value, m.mapAORepeat, m.mapAOOffset, m.mapAOWrap, m.mapAOAnisotropy);
                    break;
                case 'mapAORepeat':
                case 'mapAOOffset':
                case 'mapAOWrap':
                case 'mapAOAnisotropy':
                    break;
                case 'mapBump':
                    json.bumpMap = loadTexture(value, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy);
                    break;
                case 'mapBumpScale':
                    json.bumpScale = value;
                    break;
                case 'mapBumpRepeat':
                case 'mapBumpOffset':
                case 'mapBumpWrap':
                case 'mapBumpAnisotropy':
                    break;
                case 'mapNormal':
                    json.normalMap = loadTexture(value, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy);
                    break;
                case 'mapNormalFactor':
                    json.normalScale = [
                        value,
                        value
                    ];
                    break;
                case 'mapNormalRepeat':
                case 'mapNormalOffset':
                case 'mapNormalWrap':
                case 'mapNormalAnisotropy':
                    break;
                case 'mapSpecular':
                    json.specularMap = loadTexture(value, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy);
                    break;
                case 'mapSpecularRepeat':
                case 'mapSpecularOffset':
                case 'mapSpecularWrap':
                case 'mapSpecularAnisotropy':
                    break;
                case 'mapMetalness':
                    json.metalnessMap = loadTexture(value, m.mapMetalnessRepeat, m.mapMetalnessOffset, m.mapMetalnessWrap, m.mapMetalnessAnisotropy);
                    break;
                case 'mapMetalnessRepeat':
                case 'mapMetalnessOffset':
                case 'mapMetalnessWrap':
                case 'mapMetalnessAnisotropy':
                    break;
                case 'mapRoughness':
                    json.roughnessMap = loadTexture(value, m.mapRoughnessRepeat, m.mapRoughnessOffset, m.mapRoughnessWrap, m.mapRoughnessAnisotropy);
                    break;
                case 'mapRoughnessRepeat':
                case 'mapRoughnessOffset':
                case 'mapRoughnessWrap':
                case 'mapRoughnessAnisotropy':
                    break;
                case 'mapAlpha':
                    json.alphaMap = loadTexture(value, m.mapAlphaRepeat, m.mapAlphaOffset, m.mapAlphaWrap, m.mapAlphaAnisotropy);
                    break;
                case 'mapAlphaRepeat':
                case 'mapAlphaOffset':
                case 'mapAlphaWrap':
                case 'mapAlphaAnisotropy':
                    break;
                case 'flipSided':
                    json.side = BackSide;
                    break;
                case 'doubleSided':
                    json.side = DoubleSide;
                    break;
                case 'transparency':
                    console.warn('THREE.Loader.createMaterial: transparency has been renamed to opacity');
                    json.opacity = value;
                    break;
                case 'depthTest':
                case 'depthWrite':
                case 'colorWrite':
                case 'opacity':
                case 'reflectivity':
                case 'transparent':
                case 'visible':
                case 'wireframe':
                    json[name] = value;
                    break;
                case 'vertexColors':
                    if (value === true)
                        json.vertexColors = VertexColors;
                    if (value === 'face')
                        json.vertexColors = FaceColors;
                    break;
                default:
                    console.error('THREE.Loader.createMaterial: Unsupported', name, value);
                    break;
                }
            }
            if (json.type === 'MeshBasicMaterial')
                delete json.emissive;
            if (json.type !== 'MeshPhongMaterial')
                delete json.specular;
            if (json.opacity < 1)
                json.transparent = true;
            materialLoader.setTextures(textures);
            return materialLoader.parse(json);
        };
    }()
};
Loader.Handlers = {
    handlers: [],
    add: function (regex, loader) {
        this.handlers.push(regex, loader);
    },
    get: function (file) {
        var handlers = this.handlers;
        for (var i = 0, l = handlers.length; i < l; i += 2) {
            var regex = handlers[i];
            var loader = handlers[i + 1];
            if (regex.test(file)) {
                return loader;
            }
        }
        return null;
    }
};
Object.assign(JSONLoader.prototype, {
    load: function (url, onLoad, onProgress, onError) {
        var scope = this;
        var texturePath = this.texturePath && typeof this.texturePath === 'string' ? this.texturePath : Loader.prototype.extractUrlBase(url);
        var loader = new XHRLoader(this.manager);
        loader.setWithCredentials(this.withCredentials);
        loader.load(url, function (text) {
            var json = JSON.parse(text);
            var metadata = json.metadata;
            if (metadata !== undefined) {
                var type = metadata.type;
                if (type !== undefined) {
                    if (type.toLowerCase() === 'object') {
                        console.error('THREE.JSONLoader: ' + url + ' should be loaded with THREE.ObjectLoader instead.');
                        return;
                    }
                    if (type.toLowerCase() === 'scene') {
                        console.error('THREE.JSONLoader: ' + url + ' should be loaded with THREE.SceneLoader instead.');
                        return;
                    }
                }
            }
            var object = scope.parse(json, texturePath);
            onLoad(object.geometry, object.materials);
        }, onProgress, onError);
    },
    setTexturePath: function (value) {
        this.texturePath = value;
    },
    parse: function (json, texturePath) {
        var geometry = new Geometry(), scale = json.scale !== undefined ? 1 / json.scale : 1;
        parseModel(scale);
        parseSkin();
        parseMorphing(scale);
        parseAnimations();
        geometry.computeFaceNormals();
        geometry.computeBoundingSphere();
        function parseModel(scale) {
            function isBitSet(value, position) {
                return value & 1 << position;
            }
            var i, j, fi, offset, zLength, colorIndex, normalIndex, uvIndex, materialIndex, type, isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor, vertex, face, faceA, faceB, hex, normal, uvLayer, uv, u, v, faces = json.faces, vertices = json.vertices, normals = json.normals, colors = json.colors, nUvLayers = 0;
            if (json.uvs !== undefined) {
                for (i = 0; i < json.uvs.length; i++) {
                    if (json.uvs[i].length)
                        nUvLayers++;
                }
                for (i = 0; i < nUvLayers; i++) {
                    geometry.faceVertexUvs[i] = [];
                }
            }
            offset = 0;
            zLength = vertices.length;
            while (offset < zLength) {
                vertex = new Vector3();
                vertex.x = vertices[offset++] * scale;
                vertex.y = vertices[offset++] * scale;
                vertex.z = vertices[offset++] * scale;
                geometry.vertices.push(vertex);
            }
            offset = 0;
            zLength = faces.length;
            while (offset < zLength) {
                type = faces[offset++];
                isQuad = isBitSet(type, 0);
                hasMaterial = isBitSet(type, 1);
                hasFaceVertexUv = isBitSet(type, 3);
                hasFaceNormal = isBitSet(type, 4);
                hasFaceVertexNormal = isBitSet(type, 5);
                hasFaceColor = isBitSet(type, 6);
                hasFaceVertexColor = isBitSet(type, 7);
                if (isQuad) {
                    faceA = new Face3();
                    faceA.a = faces[offset];
                    faceA.b = faces[offset + 1];
                    faceA.c = faces[offset + 3];
                    faceB = new Face3();
                    faceB.a = faces[offset + 1];
                    faceB.b = faces[offset + 2];
                    faceB.c = faces[offset + 3];
                    offset += 4;
                    if (hasMaterial) {
                        materialIndex = faces[offset++];
                        faceA.materialIndex = materialIndex;
                        faceB.materialIndex = materialIndex;
                    }
                    fi = geometry.faces.length;
                    if (hasFaceVertexUv) {
                        for (i = 0; i < nUvLayers; i++) {
                            uvLayer = json.uvs[i];
                            geometry.faceVertexUvs[i][fi] = [];
                            geometry.faceVertexUvs[i][fi + 1] = [];
                            for (j = 0; j < 4; j++) {
                                uvIndex = faces[offset++];
                                u = uvLayer[uvIndex * 2];
                                v = uvLayer[uvIndex * 2 + 1];
                                uv = new Vector2(u, v);
                                if (j !== 2)
                                    geometry.faceVertexUvs[i][fi].push(uv);
                                if (j !== 0)
                                    geometry.faceVertexUvs[i][fi + 1].push(uv);
                            }
                        }
                    }
                    if (hasFaceNormal) {
                        normalIndex = faces[offset++] * 3;
                        faceA.normal.set(normals[normalIndex++], normals[normalIndex++], normals[normalIndex]);
                        faceB.normal.copy(faceA.normal);
                    }
                    if (hasFaceVertexNormal) {
                        for (i = 0; i < 4; i++) {
                            normalIndex = faces[offset++] * 3;
                            normal = new Vector3(normals[normalIndex++], normals[normalIndex++], normals[normalIndex]);
                            if (i !== 2)
                                faceA.vertexNormals.push(normal);
                            if (i !== 0)
                                faceB.vertexNormals.push(normal);
                        }
                    }
                    if (hasFaceColor) {
                        colorIndex = faces[offset++];
                        hex = colors[colorIndex];
                        faceA.color.setHex(hex);
                        faceB.color.setHex(hex);
                    }
                    if (hasFaceVertexColor) {
                        for (i = 0; i < 4; i++) {
                            colorIndex = faces[offset++];
                            hex = colors[colorIndex];
                            if (i !== 2)
                                faceA.vertexColors.push(new Color(hex));
                            if (i !== 0)
                                faceB.vertexColors.push(new Color(hex));
                        }
                    }
                    geometry.faces.push(faceA);
                    geometry.faces.push(faceB);
                } else {
                    face = new Face3();
                    face.a = faces[offset++];
                    face.b = faces[offset++];
                    face.c = faces[offset++];
                    if (hasMaterial) {
                        materialIndex = faces[offset++];
                        face.materialIndex = materialIndex;
                    }
                    fi = geometry.faces.length;
                    if (hasFaceVertexUv) {
                        for (i = 0; i < nUvLayers; i++) {
                            uvLayer = json.uvs[i];
                            geometry.faceVertexUvs[i][fi] = [];
                            for (j = 0; j < 3; j++) {
                                uvIndex = faces[offset++];
                                u = uvLayer[uvIndex * 2];
                                v = uvLayer[uvIndex * 2 + 1];
                                uv = new Vector2(u, v);
                                geometry.faceVertexUvs[i][fi].push(uv);
                            }
                        }
                    }
                    if (hasFaceNormal) {
                        normalIndex = faces[offset++] * 3;
                        face.normal.set(normals[normalIndex++], normals[normalIndex++], normals[normalIndex]);
                    }
                    if (hasFaceVertexNormal) {
                        for (i = 0; i < 3; i++) {
                            normalIndex = faces[offset++] * 3;
                            normal = new Vector3(normals[normalIndex++], normals[normalIndex++], normals[normalIndex]);
                            face.vertexNormals.push(normal);
                        }
                    }
                    if (hasFaceColor) {
                        colorIndex = faces[offset++];
                        face.color.setHex(colors[colorIndex]);
                    }
                    if (hasFaceVertexColor) {
                        for (i = 0; i < 3; i++) {
                            colorIndex = faces[offset++];
                            face.vertexColors.push(new Color(colors[colorIndex]));
                        }
                    }
                    geometry.faces.push(face);
                }
            }
        }
        function parseSkin() {
            var influencesPerVertex = json.influencesPerVertex !== undefined ? json.influencesPerVertex : 2;
            if (json.skinWeights) {
                for (var i = 0, l = json.skinWeights.length; i < l; i += influencesPerVertex) {
                    var x = json.skinWeights[i];
                    var y = influencesPerVertex > 1 ? json.skinWeights[i + 1] : 0;
                    var z = influencesPerVertex > 2 ? json.skinWeights[i + 2] : 0;
                    var w = influencesPerVertex > 3 ? json.skinWeights[i + 3] : 0;
                    geometry.skinWeights.push(new Vector4(x, y, z, w));
                }
            }
            if (json.skinIndices) {
                for (var i = 0, l = json.skinIndices.length; i < l; i += influencesPerVertex) {
                    var a = json.skinIndices[i];
                    var b = influencesPerVertex > 1 ? json.skinIndices[i + 1] : 0;
                    var c = influencesPerVertex > 2 ? json.skinIndices[i + 2] : 0;
                    var d = influencesPerVertex > 3 ? json.skinIndices[i + 3] : 0;
                    geometry.skinIndices.push(new Vector4(a, b, c, d));
                }
            }
            geometry.bones = json.bones;
            if (geometry.bones && geometry.bones.length > 0 && (geometry.skinWeights.length !== geometry.skinIndices.length || geometry.skinIndices.length !== geometry.vertices.length)) {
                console.warn('When skinning, number of vertices (' + geometry.vertices.length + '), skinIndices (' + geometry.skinIndices.length + '), and skinWeights (' + geometry.skinWeights.length + ') should match.');
            }
        }
        function parseMorphing(scale) {
            if (json.morphTargets !== undefined) {
                for (var i = 0, l = json.morphTargets.length; i < l; i++) {
                    geometry.morphTargets[i] = {};
                    geometry.morphTargets[i].name = json.morphTargets[i].name;
                    geometry.morphTargets[i].vertices = [];
                    var dstVertices = geometry.morphTargets[i].vertices;
                    var srcVertices = json.morphTargets[i].vertices;
                    for (var v = 0, vl = srcVertices.length; v < vl; v += 3) {
                        var vertex = new Vector3();
                        vertex.x = srcVertices[v] * scale;
                        vertex.y = srcVertices[v + 1] * scale;
                        vertex.z = srcVertices[v + 2] * scale;
                        dstVertices.push(vertex);
                    }
                }
            }
            if (json.morphColors !== undefined && json.morphColors.length > 0) {
                console.warn('THREE.JSONLoader: "morphColors" no longer supported. Using them as face colors.');
                var faces = geometry.faces;
                var morphColors = json.morphColors[0].colors;
                for (var i = 0, l = faces.length; i < l; i++) {
                    faces[i].color.fromArray(morphColors, i * 3);
                }
            }
        }
        function parseAnimations() {
            var outputAnimations = [];
            var animations = [];
            if (json.animation !== undefined) {
                animations.push(json.animation);
            }
            if (json.animations !== undefined) {
                if (json.animations.length) {
                    animations = animations.concat(json.animations);
                } else {
                    animations.push(json.animations);
                }
            }
            for (var i = 0; i < animations.length; i++) {
                var clip = AnimationClip.parseAnimation(animations[i], geometry.bones);
                if (clip)
                    outputAnimations.push(clip);
            }
            if (geometry.morphTargets) {
                var morphAnimationClips = AnimationClip.CreateClipsFromMorphTargetSequences(geometry.morphTargets, 10);
                outputAnimations = outputAnimations.concat(morphAnimationClips);
            }
            if (outputAnimations.length > 0)
                geometry.animations = outputAnimations;
        }
        if (json.materials === undefined || json.materials.length === 0) {
            return {
                geometry: geometry
            };
        } else {
            var materials = Loader.prototype.initMaterials(json.materials, texturePath, this.crossOrigin);
            return {
                geometry: geometry,
                materials: materials
            };
        }
    }
});
Object.assign(ObjectLoader.prototype, {
    load: function (url, onLoad, onProgress, onError) {
        if (this.texturePath === '') {
            this.texturePath = url.substring(0, url.lastIndexOf('/') + 1);
        }
        var scope = this;
        var loader = new XHRLoader(scope.manager);
        loader.load(url, function (text) {
            scope.parse(JSON.parse(text), onLoad);
        }, onProgress, onError);
    },
    setTexturePath: function (value) {
        this.texturePath = value;
    },
    setCrossOrigin: function (value) {
        this.crossOrigin = value;
    },
    parse: function (json, onLoad) {
        var geometries = this.parseGeometries(json.geometries);
        var images = this.parseImages(json.images, function () {
            if (onLoad !== undefined)
                onLoad(object);
        });
        var textures = this.parseTextures(json.textures, images);
        var materials = this.parseMaterials(json.materials, textures);
        var object = this.parseObject(json.object, geometries, materials);
        if (json.animations) {
            object.animations = this.parseAnimations(json.animations);
        }
        if (json.images === undefined || json.images.length === 0) {
            if (onLoad !== undefined)
                onLoad(object);
        }
        return object;
    },
    parseGeometries: function (json) {
        var geometries = {};
        if (json !== undefined) {
            var geometryLoader = new JSONLoader();
            var bufferGeometryLoader = new BufferGeometryLoader();
            for (var i = 0, l = json.length; i < l; i++) {
                var geometry;
                var data = json[i];
                switch (data.type) {
                case 'PlaneGeometry':
                case 'PlaneBufferGeometry':
                    geometry = new THREE[data.type](data.width, data.height, data.widthSegments, data.heightSegments);
                    break;
                case 'BoxGeometry':
                case 'BoxBufferGeometry':
                case 'CubeGeometry':
                    geometry = new THREE[data.type](data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments);
                    break;
                case 'CircleGeometry':
                case 'CircleBufferGeometry':
                    geometry = new THREE[data.type](data.radius, data.segments, data.thetaStart, data.thetaLength);
                    break;
                case 'CylinderGeometry':
                case 'CylinderBufferGeometry':
                    geometry = new THREE[data.type](data.radiusTop, data.radiusBottom, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
                    break;
                case 'ConeGeometry':
                case 'ConeBufferGeometry':
                    geometry = new THREE[data.type](data.radius, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
                    break;
                case 'SphereGeometry':
                case 'SphereBufferGeometry':
                    geometry = new THREE[data.type](data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength);
                    break;
                case 'DodecahedronGeometry':
                case 'IcosahedronGeometry':
                case 'OctahedronGeometry':
                case 'TetrahedronGeometry':
                    geometry = new THREE[data.type](data.radius, data.detail);
                    break;
                case 'RingGeometry':
                case 'RingBufferGeometry':
                    geometry = new THREE[data.type](data.innerRadius, data.outerRadius, data.thetaSegments, data.phiSegments, data.thetaStart, data.thetaLength);
                    break;
                case 'TorusGeometry':
                case 'TorusBufferGeometry':
                    geometry = new THREE[data.type](data.radius, data.tube, data.radialSegments, data.tubularSegments, data.arc);
                    break;
                case 'TorusKnotGeometry':
                case 'TorusKnotBufferGeometry':
                    geometry = new THREE[data.type](data.radius, data.tube, data.tubularSegments, data.radialSegments, data.p, data.q);
                    break;
                case 'LatheGeometry':
                case 'LatheBufferGeometry':
                    geometry = new THREE[data.type](data.points, data.segments, data.phiStart, data.phiLength);
                    break;
                case 'BufferGeometry':
                    geometry = bufferGeometryLoader.parse(data);
                    break;
                case 'Geometry':
                    geometry = geometryLoader.parse(data.data, this.texturePath).geometry;
                    break;
                default:
                    console.warn('THREE.ObjectLoader: Unsupported geometry type "' + data.type + '"');
                    continue;
                }
                geometry.uuid = data.uuid;
                if (data.name !== undefined)
                    geometry.name = data.name;
                geometries[data.uuid] = geometry;
            }
        }
        return geometries;
    },
    parseMaterials: function (json, textures) {
        var materials = {};
        if (json !== undefined) {
            var loader = new MaterialLoader();
            loader.setTextures(textures);
            for (var i = 0, l = json.length; i < l; i++) {
                var material = loader.parse(json[i]);
                materials[material.uuid] = material;
            }
        }
        return materials;
    },
    parseAnimations: function (json) {
        var animations = [];
        for (var i = 0; i < json.length; i++) {
            var clip = AnimationClip.parse(json[i]);
            animations.push(clip);
        }
        return animations;
    },
    parseImages: function (json, onLoad) {
        var scope = this;
        var images = {};
        function loadImage(url) {
            scope.manager.itemStart(url);
            return loader.load(url, function () {
                scope.manager.itemEnd(url);
            }, undefined, function () {
                scope.manager.itemError(url);
            });
        }
        if (json !== undefined && json.length > 0) {
            var manager = new LoadingManager(onLoad);
            var loader = new ImageLoader(manager);
            loader.setCrossOrigin(this.crossOrigin);
            for (var i = 0, l = json.length; i < l; i++) {
                var image = json[i];
                var path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(image.url) ? image.url : scope.texturePath + image.url;
                images[image.uuid] = loadImage(path);
            }
        }
        return images;
    },
    parseTextures: function (json, images) {
        function parseConstant(value) {
            if (typeof value === 'number')
                return value;
            console.warn('THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value);
            return THREE[value];
        }
        var textures = {};
        if (json !== undefined) {
            for (var i = 0, l = json.length; i < l; i++) {
                var data = json[i];
                if (data.image === undefined) {
                    console.warn('THREE.ObjectLoader: No "image" specified for', data.uuid);
                }
                if (images[data.image] === undefined) {
                    console.warn('THREE.ObjectLoader: Undefined image', data.image);
                }
                var texture = new Texture(images[data.image]);
                texture.needsUpdate = true;
                texture.uuid = data.uuid;
                if (data.name !== undefined)
                    texture.name = data.name;
                if (data.mapping !== undefined)
                    texture.mapping = parseConstant(data.mapping);
                if (data.offset !== undefined)
                    texture.offset.fromArray(data.offset);
                if (data.repeat !== undefined)
                    texture.repeat.fromArray(data.repeat);
                if (data.wrap !== undefined) {
                    texture.wrapS = parseConstant(data.wrap[0]);
                    texture.wrapT = parseConstant(data.wrap[1]);
                }
                if (data.minFilter !== undefined)
                    texture.minFilter = parseConstant(data.minFilter);
                if (data.magFilter !== undefined)
                    texture.magFilter = parseConstant(data.magFilter);
                if (data.anisotropy !== undefined)
                    texture.anisotropy = data.anisotropy;
                if (data.flipY !== undefined)
                    texture.flipY = data.flipY;
                textures[data.uuid] = texture;
            }
        }
        return textures;
    },
    parseObject: function () {
        var matrix = new Matrix4();
        return function parseObject(data, geometries, materials) {
            var object;
            function getGeometry(name) {
                if (geometries[name] === undefined) {
                    console.warn('THREE.ObjectLoader: Undefined geometry', name);
                }
                return geometries[name];
            }
            function getMaterial(name) {
                if (name === undefined)
                    return undefined;
                if (materials[name] === undefined) {
                    console.warn('THREE.ObjectLoader: Undefined material', name);
                }
                return materials[name];
            }
            switch (data.type) {
            case 'Scene':
                object = new Scene();
                if (data.background !== undefined) {
                    if (Number.isInteger(data.background)) {
                        object.background = new THREE.Color(data.background);
                    }
                }
                if (data.fog !== undefined) {
                    if (data.fog.type === 'Fog') {
                        object.fog = new Fog(data.fog.color, data.fog.near, data.fog.far);
                    } else if (data.fog.type === 'FogExp2') {
                        object.fog = new FogExp2(data.fog.color, data.fog.density);
                    }
                }
                break;
            case 'PerspectiveCamera':
                object = new PerspectiveCamera(data.fov, data.aspect, data.near, data.far);
                if (data.focus !== undefined)
                    object.focus = data.focus;
                if (data.zoom !== undefined)
                    object.zoom = data.zoom;
                if (data.filmGauge !== undefined)
                    object.filmGauge = data.filmGauge;
                if (data.filmOffset !== undefined)
                    object.filmOffset = data.filmOffset;
                if (data.view !== undefined)
                    object.view = Object.assign({}, data.view);
                break;
            case 'OrthographicCamera':
                object = new OrthographicCamera(data.left, data.right, data.top, data.bottom, data.near, data.far);
                break;
            case 'AmbientLight':
                object = new AmbientLight(data.color, data.intensity);
                break;
            case 'DirectionalLight':
                object = new DirectionalLight(data.color, data.intensity);
                break;
            case 'PointLight':
                object = new PointLight(data.color, data.intensity, data.distance, data.decay);
                break;
            case 'SpotLight':
                object = new SpotLight(data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay);
                break;
            case 'HemisphereLight':
                object = new HemisphereLight(data.color, data.groundColor, data.intensity);
                break;
            case 'Mesh':
                var geometry = getGeometry(data.geometry);
                var material = getMaterial(data.material);
                if (geometry.bones && geometry.bones.length > 0) {
                    object = new SkinnedMesh(geometry, material);
                } else {
                    object = new Mesh(geometry, material);
                }
                break;
            case 'LOD':
                object = new LOD();
                break;
            case 'Line':
                object = new Line(getGeometry(data.geometry), getMaterial(data.material), data.mode);
                break;
            case 'LineSegments':
                object = new LineSegments(getGeometry(data.geometry), getMaterial(data.material));
                break;
            case 'PointCloud':
            case 'Points':
                object = new Points(getGeometry(data.geometry), getMaterial(data.material));
                break;
            case 'Sprite':
                object = new Sprite(getMaterial(data.material));
                break;
            case 'Group':
                object = new Group();
                break;
            default:
                object = new Object3D();
            }
            object.uuid = data.uuid;
            if (data.name !== undefined)
                object.name = data.name;
            if (data.matrix !== undefined) {
                matrix.fromArray(data.matrix);
                matrix.decompose(object.position, object.quaternion, object.scale);
            } else {
                if (data.position !== undefined)
                    object.position.fromArray(data.position);
                if (data.rotation !== undefined)
                    object.rotation.fromArray(data.rotation);
                if (data.quaternion !== undefined)
                    object.quaternion.fromArray(data.quaternion);
                if (data.scale !== undefined)
                    object.scale.fromArray(data.scale);
            }
            if (data.castShadow !== undefined)
                object.castShadow = data.castShadow;
            if (data.receiveShadow !== undefined)
                object.receiveShadow = data.receiveShadow;
            if (data.shadow) {
                if (data.shadow.bias !== undefined)
                    object.shadow.bias = data.shadow.bias;
                if (data.shadow.radius !== undefined)
                    object.shadow.radius = data.shadow.radius;
                if (data.shadow.mapSize !== undefined)
                    object.shadow.mapSize.fromArray(data.shadow.mapSize);
                if (data.shadow.camera !== undefined)
                    object.shadow.camera = this.parseObject(data.shadow.camera);
            }
            if (data.visible !== undefined)
                object.visible = data.visible;
            if (data.userData !== undefined)
                object.userData = data.userData;
            if (data.children !== undefined) {
                for (var child in data.children) {
                    object.add(this.parseObject(data.children[child], geometries, materials));
                }
            }
            if (data.type === 'LOD') {
                var levels = data.levels;
                for (var l = 0; l < levels.length; l++) {
                    var level = levels[l];
                    var child = object.getObjectByProperty('uuid', level.object);
                    if (child !== undefined) {
                        object.addLevel(child, level.distance);
                    }
                }
            }
            return object;
        };
    }()
});
exports.ShapeUtils = {
    area: function (contour) {
        var n = contour.length;
        var a = 0;
        for (var p = n - 1, q = 0; q < n; p = q++) {
            a += contour[p].x * contour[q].y - contour[q].x * contour[p].y;
        }
        return a * 0.5;
    },
    triangulate: function () {
        function snip(contour, u, v, w, n, verts) {
            var p;
            var ax, ay, bx, by;
            var cx, cy, px, py;
            ax = contour[verts[u]].x;
            ay = contour[verts[u]].y;
            bx = contour[verts[v]].x;
            by = contour[verts[v]].y;
            cx = contour[verts[w]].x;
            cy = contour[verts[w]].y;
            if (Number.EPSILON > (bx - ax) * (cy - ay) - (by - ay) * (cx - ax))
                return false;
            var aX, aY, bX, bY, cX, cY;
            var apx, apy, bpx, bpy, cpx, cpy;
            var cCROSSap, bCROSScp, aCROSSbp;
            aX = cx - bx;
            aY = cy - by;
            bX = ax - cx;
            bY = ay - cy;
            cX = bx - ax;
            cY = by - ay;
            for (p = 0; p < n; p++) {
                px = contour[verts[p]].x;
                py = contour[verts[p]].y;
                if (px === ax && py === ay || px === bx && py === by || px === cx && py === cy)
                    continue;
                apx = px - ax;
                apy = py - ay;
                bpx = px - bx;
                bpy = py - by;
                cpx = px - cx;
                cpy = py - cy;
                aCROSSbp = aX * bpy - aY * bpx;
                cCROSSap = cX * apy - cY * apx;
                bCROSScp = bX * cpy - bY * cpx;
                if (aCROSSbp >= -Number.EPSILON && bCROSScp >= -Number.EPSILON && cCROSSap >= -Number.EPSILON)
                    return false;
            }
            return true;
        }
        return function triangulate(contour, indices) {
            var n = contour.length;
            if (n < 3)
                return null;
            var result = [], verts = [], vertIndices = [];
            var u, v, w;
            if (exports.ShapeUtils.area(contour) > 0) {
                for (v = 0; v < n; v++)
                    verts[v] = v;
            } else {
                for (v = 0; v < n; v++)
                    verts[v] = n - 1 - v;
            }
            var nv = n;
            var count = 2 * nv;
            for (v = nv - 1; nv > 2;) {
                if (count-- <= 0) {
                    console.warn('THREE.ShapeUtils: Unable to triangulate polygon! in triangulate()');
                    if (indices)
                        return vertIndices;
                    return result;
                }
                u = v;
                if (nv <= u)
                    u = 0;
                v = u + 1;
                if (nv <= v)
                    v = 0;
                w = v + 1;
                if (nv <= w)
                    w = 0;
                if (snip(contour, u, v, w, nv, verts)) {
                    var a, b, c, s, t;
                    a = verts[u];
                    b = verts[v];
                    c = verts[w];
                    result.push([
                        contour[a],
                        contour[b],
                        contour[c]
                    ]);
                    vertIndices.push([
                        verts[u],
                        verts[v],
                        verts[w]
                    ]);
                    for (s = v, t = v + 1; t < nv; s++, t++) {
                        verts[s] = verts[t];
                    }
                    nv--;
                    count = 2 * nv;
                }
            }
            if (indices)
                return vertIndices;
            return result;
        };
    }(),
    triangulateShape: function (contour, holes) {
        function removeDupEndPts(points) {
            var l = points.length;
            if (l > 2 && points[l - 1].equals(points[0])) {
                points.pop();
            }
        }
        removeDupEndPts(contour);
        holes.forEach(removeDupEndPts);
        function point_in_segment_2D_colin(inSegPt1, inSegPt2, inOtherPt) {
            if (inSegPt1.x !== inSegPt2.x) {
                if (inSegPt1.x < inSegPt2.x) {
                    return inSegPt1.x <= inOtherPt.x && inOtherPt.x <= inSegPt2.x;
                } else {
                    return inSegPt2.x <= inOtherPt.x && inOtherPt.x <= inSegPt1.x;
                }
            } else {
                if (inSegPt1.y < inSegPt2.y) {
                    return inSegPt1.y <= inOtherPt.y && inOtherPt.y <= inSegPt2.y;
                } else {
                    return inSegPt2.y <= inOtherPt.y && inOtherPt.y <= inSegPt1.y;
                }
            }
        }
        function intersect_segments_2D(inSeg1Pt1, inSeg1Pt2, inSeg2Pt1, inSeg2Pt2, inExcludeAdjacentSegs) {
            var seg1dx = inSeg1Pt2.x - inSeg1Pt1.x, seg1dy = inSeg1Pt2.y - inSeg1Pt1.y;
            var seg2dx = inSeg2Pt2.x - inSeg2Pt1.x, seg2dy = inSeg2Pt2.y - inSeg2Pt1.y;
            var seg1seg2dx = inSeg1Pt1.x - inSeg2Pt1.x;
            var seg1seg2dy = inSeg1Pt1.y - inSeg2Pt1.y;
            var limit = seg1dy * seg2dx - seg1dx * seg2dy;
            var perpSeg1 = seg1dy * seg1seg2dx - seg1dx * seg1seg2dy;
            if (Math.abs(limit) > Number.EPSILON) {
                var perpSeg2;
                if (limit > 0) {
                    if (perpSeg1 < 0 || perpSeg1 > limit)
                        return [];
                    perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;
                    if (perpSeg2 < 0 || perpSeg2 > limit)
                        return [];
                } else {
                    if (perpSeg1 > 0 || perpSeg1 < limit)
                        return [];
                    perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;
                    if (perpSeg2 > 0 || perpSeg2 < limit)
                        return [];
                }
                if (perpSeg2 === 0) {
                    if (inExcludeAdjacentSegs && (perpSeg1 === 0 || perpSeg1 === limit))
                        return [];
                    return [inSeg1Pt1];
                }
                if (perpSeg2 === limit) {
                    if (inExcludeAdjacentSegs && (perpSeg1 === 0 || perpSeg1 === limit))
                        return [];
                    return [inSeg1Pt2];
                }
                if (perpSeg1 === 0)
                    return [inSeg2Pt1];
                if (perpSeg1 === limit)
                    return [inSeg2Pt2];
                var factorSeg1 = perpSeg2 / limit;
                return [{
                        x: inSeg1Pt1.x + factorSeg1 * seg1dx,
                        y: inSeg1Pt1.y + factorSeg1 * seg1dy
                    }];
            } else {
                if (perpSeg1 !== 0 || seg2dy * seg1seg2dx !== seg2dx * seg1seg2dy)
                    return [];
                var seg1Pt = seg1dx === 0 && seg1dy === 0;
                var seg2Pt = seg2dx === 0 && seg2dy === 0;
                if (seg1Pt && seg2Pt) {
                    if (inSeg1Pt1.x !== inSeg2Pt1.x || inSeg1Pt1.y !== inSeg2Pt1.y)
                        return [];
                    return [inSeg1Pt1];
                }
                if (seg1Pt) {
                    if (!point_in_segment_2D_colin(inSeg2Pt1, inSeg2Pt2, inSeg1Pt1))
                        return [];
                    return [inSeg1Pt1];
                }
                if (seg2Pt) {
                    if (!point_in_segment_2D_colin(inSeg1Pt1, inSeg1Pt2, inSeg2Pt1))
                        return [];
                    return [inSeg2Pt1];
                }
                var seg1min, seg1max, seg1minVal, seg1maxVal;
                var seg2min, seg2max, seg2minVal, seg2maxVal;
                if (seg1dx !== 0) {
                    if (inSeg1Pt1.x < inSeg1Pt2.x) {
                        seg1min = inSeg1Pt1;
                        seg1minVal = inSeg1Pt1.x;
                        seg1max = inSeg1Pt2;
                        seg1maxVal = inSeg1Pt2.x;
                    } else {
                        seg1min = inSeg1Pt2;
                        seg1minVal = inSeg1Pt2.x;
                        seg1max = inSeg1Pt1;
                        seg1maxVal = inSeg1Pt1.x;
                    }
                    if (inSeg2Pt1.x < inSeg2Pt2.x) {
                        seg2min = inSeg2Pt1;
                        seg2minVal = inSeg2Pt1.x;
                        seg2max = inSeg2Pt2;
                        seg2maxVal = inSeg2Pt2.x;
                    } else {
                        seg2min = inSeg2Pt2;
                        seg2minVal = inSeg2Pt2.x;
                        seg2max = inSeg2Pt1;
                        seg2maxVal = inSeg2Pt1.x;
                    }
                } else {
                    if (inSeg1Pt1.y < inSeg1Pt2.y) {
                        seg1min = inSeg1Pt1;
                        seg1minVal = inSeg1Pt1.y;
                        seg1max = inSeg1Pt2;
                        seg1maxVal = inSeg1Pt2.y;
                    } else {
                        seg1min = inSeg1Pt2;
                        seg1minVal = inSeg1Pt2.y;
                        seg1max = inSeg1Pt1;
                        seg1maxVal = inSeg1Pt1.y;
                    }
                    if (inSeg2Pt1.y < inSeg2Pt2.y) {
                        seg2min = inSeg2Pt1;
                        seg2minVal = inSeg2Pt1.y;
                        seg2max = inSeg2Pt2;
                        seg2maxVal = inSeg2Pt2.y;
                    } else {
                        seg2min = inSeg2Pt2;
                        seg2minVal = inSeg2Pt2.y;
                        seg2max = inSeg2Pt1;
                        seg2maxVal = inSeg2Pt1.y;
                    }
                }
                if (seg1minVal <= seg2minVal) {
                    if (seg1maxVal < seg2minVal)
                        return [];
                    if (seg1maxVal === seg2minVal) {
                        if (inExcludeAdjacentSegs)
                            return [];
                        return [seg2min];
                    }
                    if (seg1maxVal <= seg2maxVal)
                        return [
                        seg2min,
                        seg1max
                    ];
                    return [
                        seg2min,
                        seg2max
                    ];
                } else {
                    if (seg1minVal > seg2maxVal)
                        return [];
                    if (seg1minVal === seg2maxVal) {
                        if (inExcludeAdjacentSegs)
                            return [];
                        return [seg1min];
                    }
                    if (seg1maxVal <= seg2maxVal)
                        return [
                        seg1min,
                        seg1max
                    ];
                    return [
                        seg1min,
                        seg2max
                    ];
                }
            }
        }
        function isPointInsideAngle(inVertex, inLegFromPt, inLegToPt, inOtherPt) {
            var legFromPtX = inLegFromPt.x - inVertex.x, legFromPtY = inLegFromPt.y - inVertex.y;
            var legToPtX = inLegToPt.x - inVertex.x, legToPtY = inLegToPt.y - inVertex.y;
            var otherPtX = inOtherPt.x - inVertex.x, otherPtY = inOtherPt.y - inVertex.y;
            var from2toAngle = legFromPtX * legToPtY - legFromPtY * legToPtX;
            var from2otherAngle = legFromPtX * otherPtY - legFromPtY * otherPtX;
            if (Math.abs(from2toAngle) > Number.EPSILON) {
                var other2toAngle = otherPtX * legToPtY - otherPtY * legToPtX;
                if (from2toAngle > 0) {
                    return from2otherAngle >= 0 && other2toAngle >= 0;
                } else {
                    return from2otherAngle >= 0 || other2toAngle >= 0;
                }
            } else {
                return from2otherAngle > 0;
            }
        }
        function removeHoles(contour, holes) {
            var shape = contour.concat();
            var hole;
            function isCutLineInsideAngles(inShapeIdx, inHoleIdx) {
                var lastShapeIdx = shape.length - 1;
                var prevShapeIdx = inShapeIdx - 1;
                if (prevShapeIdx < 0)
                    prevShapeIdx = lastShapeIdx;
                var nextShapeIdx = inShapeIdx + 1;
                if (nextShapeIdx > lastShapeIdx)
                    nextShapeIdx = 0;
                var insideAngle = isPointInsideAngle(shape[inShapeIdx], shape[prevShapeIdx], shape[nextShapeIdx], hole[inHoleIdx]);
                if (!insideAngle) {
                    return false;
                }
                var lastHoleIdx = hole.length - 1;
                var prevHoleIdx = inHoleIdx - 1;
                if (prevHoleIdx < 0)
                    prevHoleIdx = lastHoleIdx;
                var nextHoleIdx = inHoleIdx + 1;
                if (nextHoleIdx > lastHoleIdx)
                    nextHoleIdx = 0;
                insideAngle = isPointInsideAngle(hole[inHoleIdx], hole[prevHoleIdx], hole[nextHoleIdx], shape[inShapeIdx]);
                if (!insideAngle) {
                    return false;
                }
                return true;
            }
            function intersectsShapeEdge(inShapePt, inHolePt) {
                var sIdx, nextIdx, intersection;
                for (sIdx = 0; sIdx < shape.length; sIdx++) {
                    nextIdx = sIdx + 1;
                    nextIdx %= shape.length;
                    intersection = intersect_segments_2D(inShapePt, inHolePt, shape[sIdx], shape[nextIdx], true);
                    if (intersection.length > 0)
                        return true;
                }
                return false;
            }
            var indepHoles = [];
            function intersectsHoleEdge(inShapePt, inHolePt) {
                var ihIdx, chkHole, hIdx, nextIdx, intersection;
                for (ihIdx = 0; ihIdx < indepHoles.length; ihIdx++) {
                    chkHole = holes[indepHoles[ihIdx]];
                    for (hIdx = 0; hIdx < chkHole.length; hIdx++) {
                        nextIdx = hIdx + 1;
                        nextIdx %= chkHole.length;
                        intersection = intersect_segments_2D(inShapePt, inHolePt, chkHole[hIdx], chkHole[nextIdx], true);
                        if (intersection.length > 0)
                            return true;
                    }
                }
                return false;
            }
            var holeIndex, shapeIndex, shapePt, holePt, holeIdx, cutKey, failedCuts = [], tmpShape1, tmpShape2, tmpHole1, tmpHole2;
            for (var h = 0, hl = holes.length; h < hl; h++) {
                indepHoles.push(h);
            }
            var minShapeIndex = 0;
            var counter = indepHoles.length * 2;
            while (indepHoles.length > 0) {
                counter--;
                if (counter < 0) {
                    console.log('Infinite Loop! Holes left:' + indepHoles.length + ', Probably Hole outside Shape!');
                    break;
                }
                for (shapeIndex = minShapeIndex; shapeIndex < shape.length; shapeIndex++) {
                    shapePt = shape[shapeIndex];
                    holeIndex = -1;
                    for (var h = 0; h < indepHoles.length; h++) {
                        holeIdx = indepHoles[h];
                        cutKey = shapePt.x + ':' + shapePt.y + ':' + holeIdx;
                        if (failedCuts[cutKey] !== undefined)
                            continue;
                        hole = holes[holeIdx];
                        for (var h2 = 0; h2 < hole.length; h2++) {
                            holePt = hole[h2];
                            if (!isCutLineInsideAngles(shapeIndex, h2))
                                continue;
                            if (intersectsShapeEdge(shapePt, holePt))
                                continue;
                            if (intersectsHoleEdge(shapePt, holePt))
                                continue;
                            holeIndex = h2;
                            indepHoles.splice(h, 1);
                            tmpShape1 = shape.slice(0, shapeIndex + 1);
                            tmpShape2 = shape.slice(shapeIndex);
                            tmpHole1 = hole.slice(holeIndex);
                            tmpHole2 = hole.slice(0, holeIndex + 1);
                            shape = tmpShape1.concat(tmpHole1).concat(tmpHole2).concat(tmpShape2);
                            minShapeIndex = shapeIndex;
                            break;
                        }
                        if (holeIndex >= 0)
                            break;
                        failedCuts[cutKey] = true;
                    }
                    if (holeIndex >= 0)
                        break;
                }
            }
            return shape;
        }
        var i, il, f, face, key, index, allPointsMap = {};
        var allpoints = contour.concat();
        for (var h = 0, hl = holes.length; h < hl; h++) {
            Array.prototype.push.apply(allpoints, holes[h]);
        }
        for (i = 0, il = allpoints.length; i < il; i++) {
            key = allpoints[i].x + ':' + allpoints[i].y;
            if (allPointsMap[key] !== undefined) {
                console.warn('THREE.ShapeUtils: Duplicate point', key, i);
            }
            allPointsMap[key] = i;
        }
        var shapeWithoutHoles = removeHoles(contour, holes);
        var triangles = exports.ShapeUtils.triangulate(shapeWithoutHoles, false);
        for (i = 0, il = triangles.length; i < il; i++) {
            face = triangles[i];
            for (f = 0; f < 3; f++) {
                key = face[f].x + ':' + face[f].y;
                index = allPointsMap[key];
                if (index !== undefined) {
                    face[f] = index;
                }
            }
        }
        return triangles.concat();
    },
    isClockWise: function (pts) {
        return exports.ShapeUtils.area(pts) < 0;
    },
    b2: function () {
        function b2p0(t, p) {
            var k = 1 - t;
            return k * k * p;
        }
        function b2p1(t, p) {
            return 2 * (1 - t) * t * p;
        }
        function b2p2(t, p) {
            return t * t * p;
        }
        return function b2(t, p0, p1, p2) {
            return b2p0(t, p0) + b2p1(t, p1) + b2p2(t, p2);
        };
    }(),
    b3: function () {
        function b3p0(t, p) {
            var k = 1 - t;
            return k * k * k * p;
        }
        function b3p1(t, p) {
            var k = 1 - t;
            return 3 * k * k * t * p;
        }
        function b3p2(t, p) {
            var k = 1 - t;
            return 3 * k * t * t * p;
        }
        function b3p3(t, p) {
            return t * t * t * p;
        }
        return function b3(t, p0, p1, p2, p3) {
            return b3p0(t, p0) + b3p1(t, p1) + b3p2(t, p2) + b3p3(t, p3);
        };
    }()
};
Curve.prototype = {
    constructor: Curve,
    getPoint: function (t) {
        console.warn('THREE.Curve: Warning, getPoint() not implemented!');
        return null;
    },
    getPointAt: function (u) {
        var t = this.getUtoTmapping(u);
        return this.getPoint(t);
    },
    getPoints: function (divisions) {
        if (!divisions)
            divisions = 5;
        var points = [];
        for (var d = 0; d <= divisions; d++) {
            points.push(this.getPoint(d / divisions));
        }
        return points;
    },
    getSpacedPoints: function (divisions) {
        if (!divisions)
            divisions = 5;
        var points = [];
        for (var d = 0; d <= divisions; d++) {
            points.push(this.getPointAt(d / divisions));
        }
        return points;
    },
    getLength: function () {
        var lengths = this.getLengths();
        return lengths[lengths.length - 1];
    },
    getLengths: function (divisions) {
        if (!divisions)
            divisions = this.__arcLengthDivisions ? this.__arcLengthDivisions : 200;
        if (this.cacheArcLengths && this.cacheArcLengths.length === divisions + 1 && !this.needsUpdate) {
            return this.cacheArcLengths;
        }
        this.needsUpdate = false;
        var cache = [];
        var current, last = this.getPoint(0);
        var p, sum = 0;
        cache.push(0);
        for (p = 1; p <= divisions; p++) {
            current = this.getPoint(p / divisions);
            sum += current.distanceTo(last);
            cache.push(sum);
            last = current;
        }
        this.cacheArcLengths = cache;
        return cache;
    },
    updateArcLengths: function () {
        this.needsUpdate = true;
        this.getLengths();
    },
    getUtoTmapping: function (u, distance) {
        var arcLengths = this.getLengths();
        var i = 0, il = arcLengths.length;
        var targetArcLength;
        if (distance) {
            targetArcLength = distance;
        } else {
            targetArcLength = u * arcLengths[il - 1];
        }
        var low = 0, high = il - 1, comparison;
        while (low <= high) {
            i = Math.floor(low + (high - low) / 2);
            comparison = arcLengths[i] - targetArcLength;
            if (comparison < 0) {
                low = i + 1;
            } else if (comparison > 0) {
                high = i - 1;
            } else {
                high = i;
                break;
            }
        }
        i = high;
        if (arcLengths[i] === targetArcLength) {
            var t = i / (il - 1);
            return t;
        }
        var lengthBefore = arcLengths[i];
        var lengthAfter = arcLengths[i + 1];
        var segmentLength = lengthAfter - lengthBefore;
        var segmentFraction = (targetArcLength - lengthBefore) / segmentLength;
        var t = (i + segmentFraction) / (il - 1);
        return t;
    },
    getTangent: function (t) {
        var delta = 0.0001;
        var t1 = t - delta;
        var t2 = t + delta;
        if (t1 < 0)
            t1 = 0;
        if (t2 > 1)
            t2 = 1;
        var pt1 = this.getPoint(t1);
        var pt2 = this.getPoint(t2);
        var vec = pt2.clone().sub(pt1);
        return vec.normalize();
    },
    getTangentAt: function (u) {
        var t = this.getUtoTmapping(u);
        return this.getTangent(t);
    }
};
Curve.create = function (constructor, getPointFunc) {
    constructor.prototype = Object.create(Curve.prototype);
    constructor.prototype.constructor = constructor;
    constructor.prototype.getPoint = getPointFunc;
    return constructor;
};
LineCurve.prototype = Object.create(Curve.prototype);
LineCurve.prototype.constructor = LineCurve;
LineCurve.prototype.isLineCurve = true;
LineCurve.prototype.getPoint = function (t) {
    if (t === 1) {
        return this.v2.clone();
    }
    var point = this.v2.clone().sub(this.v1);
    point.multiplyScalar(t).add(this.v1);
    return point;
};
LineCurve.prototype.getPointAt = function (u) {
    return this.getPoint(u);
};
LineCurve.prototype.getTangent = function (t) {
    var tangent = this.v2.clone().sub(this.v1);
    return tangent.normalize();
};
CurvePath.prototype = Object.assign(Object.create(Curve.prototype), {
    constructor: CurvePath,
    add: function (curve) {
        this.curves.push(curve);
    },
    closePath: function () {
        var startPoint = this.curves[0].getPoint(0);
        var endPoint = this.curves[this.curves.length - 1].getPoint(1);
        if (!startPoint.equals(endPoint)) {
            this.curves.push(new LineCurve(endPoint, startPoint));
        }
    },
    getPoint: function (t) {
        var d = t * this.getLength();
        var curveLengths = this.getCurveLengths();
        var i = 0;
        while (i < curveLengths.length) {
            if (curveLengths[i] >= d) {
                var diff = curveLengths[i] - d;
                var curve = this.curves[i];
                var segmentLength = curve.getLength();
                var u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;
                return curve.getPointAt(u);
            }
            i++;
        }
        return null;
    },
    getLength: function () {
        var lens = this.getCurveLengths();
        return lens[lens.length - 1];
    },
    updateArcLengths: function () {
        this.needsUpdate = true;
        this.cacheLengths = null;
        this.getLengths();
    },
    getCurveLengths: function () {
        if (this.cacheLengths && this.cacheLengths.length === this.curves.length) {
            return this.cacheLengths;
        }
        var lengths = [], sums = 0;
        for (var i = 0, l = this.curves.length; i < l; i++) {
            sums += this.curves[i].getLength();
            lengths.push(sums);
        }
        this.cacheLengths = lengths;
        return lengths;
    },
    getSpacedPoints: function (divisions) {
        if (!divisions)
            divisions = 40;
        var points = [];
        for (var i = 0; i <= divisions; i++) {
            points.push(this.getPoint(i / divisions));
        }
        if (this.autoClose) {
            points.push(points[0]);
        }
        return points;
    },
    getPoints: function (divisions) {
        divisions = divisions || 12;
        var points = [], last;
        for (var i = 0, curves = this.curves; i < curves.length; i++) {
            var curve = curves[i];
            var resolution = curve && curve.isEllipseCurve ? divisions * 2 : curve && curve.isLineCurve ? 1 : curve && curve.isSplineCurve ? divisions * curve.points.length : divisions;
            var pts = curve.getPoints(resolution);
            for (var j = 0; j < pts.length; j++) {
                var point = pts[j];
                if (last && last.equals(point))
                    continue;
                points.push(point);
                last = point;
            }
        }
        if (this.autoClose && points.length > 1 && !points[points.length - 1].equals(points[0])) {
            points.push(points[0]);
        }
        return points;
    },
    createPointsGeometry: function (divisions) {
        var pts = this.getPoints(divisions);
        return this.createGeometry(pts);
    },
    createSpacedPointsGeometry: function (divisions) {
        var pts = this.getSpacedPoints(divisions);
        return this.createGeometry(pts);
    },
    createGeometry: function (points) {
        var geometry = new Geometry();
        for (var i = 0, l = points.length; i < l; i++) {
            var point = points[i];
            geometry.vertices.push(new Vector3(point.x, point.y, point.z || 0));
        }
        return geometry;
    }
});
EllipseCurve.prototype = Object.create(Curve.prototype);
EllipseCurve.prototype.constructor = EllipseCurve;
EllipseCurve.prototype.isEllipseCurve = true;
EllipseCurve.prototype.getPoint = function (t) {
    var twoPi = Math.PI * 2;
    var deltaAngle = this.aEndAngle - this.aStartAngle;
    var samePoints = Math.abs(deltaAngle) < Number.EPSILON;
    while (deltaAngle < 0)
        deltaAngle += twoPi;
    while (deltaAngle > twoPi)
        deltaAngle -= twoPi;
    if (deltaAngle < Number.EPSILON) {
        if (samePoints) {
            deltaAngle = 0;
        } else {
            deltaAngle = twoPi;
        }
    }
    if (this.aClockwise === true && !samePoints) {
        if (deltaAngle === twoPi) {
            deltaAngle = -twoPi;
        } else {
            deltaAngle = deltaAngle - twoPi;
        }
    }
    var angle = this.aStartAngle + t * deltaAngle;
    var x = this.aX + this.xRadius * Math.cos(angle);
    var y = this.aY + this.yRadius * Math.sin(angle);
    if (this.aRotation !== 0) {
        var cos = Math.cos(this.aRotation);
        var sin = Math.sin(this.aRotation);
        var tx = x - this.aX;
        var ty = y - this.aY;
        x = tx * cos - ty * sin + this.aX;
        y = tx * sin + ty * cos + this.aY;
    }
    return new Vector2(x, y);
};
exports.CurveUtils = {
    tangentQuadraticBezier: function (t, p0, p1, p2) {
        return 2 * (1 - t) * (p1 - p0) + 2 * t * (p2 - p1);
    },
    tangentCubicBezier: function (t, p0, p1, p2, p3) {
        return -3 * p0 * (1 - t) * (1 - t) + 3 * p1 * (1 - t) * (1 - t) - 6 * t * p1 * (1 - t) + 6 * t * p2 * (1 - t) - 3 * t * t * p2 + 3 * t * t * p3;
    },
    tangentSpline: function (t, p0, p1, p2, p3) {
        var h00 = 6 * t * t - 6 * t;
        var h10 = 3 * t * t - 4 * t + 1;
        var h01 = -6 * t * t + 6 * t;
        var h11 = 3 * t * t - 2 * t;
        return h00 + h10 + h01 + h11;
    },
    interpolate: function (p0, p1, p2, p3, t) {
        var v0 = (p2 - p0) * 0.5;
        var v1 = (p3 - p1) * 0.5;
        var t2 = t * t;
        var t3 = t * t2;
        return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;
    }
};
SplineCurve.prototype = Object.create(Curve.prototype);
SplineCurve.prototype.constructor = SplineCurve;
SplineCurve.prototype.isSplineCurve = true;
SplineCurve.prototype.getPoint = function (t) {
    var points = this.points;
    var point = (points.length - 1) * t;
    var intPoint = Math.floor(point);
    var weight = point - intPoint;
    var point0 = points[intPoint === 0 ? intPoint : intPoint - 1];
    var point1 = points[intPoint];
    var point2 = points[intPoint > points.length - 2 ? points.length - 1 : intPoint + 1];
    var point3 = points[intPoint > points.length - 3 ? points.length - 1 : intPoint + 2];
    var interpolate = exports.CurveUtils.interpolate;
    return new Vector2(interpolate(point0.x, point1.x, point2.x, point3.x, weight), interpolate(point0.y, point1.y, point2.y, point3.y, weight));
};
CubicBezierCurve.prototype = Object.create(Curve.prototype);
CubicBezierCurve.prototype.constructor = CubicBezierCurve;
CubicBezierCurve.prototype.getPoint = function (t) {
    var b3 = exports.ShapeUtils.b3;
    return new Vector2(b3(t, this.v0.x, this.v1.x, this.v2.x, this.v3.x), b3(t, this.v0.y, this.v1.y, this.v2.y, this.v3.y));
};
CubicBezierCurve.prototype.getTangent = function (t) {
    var tangentCubicBezier = exports.CurveUtils.tangentCubicBezier;
    return new Vector2(tangentCubicBezier(t, this.v0.x, this.v1.x, this.v2.x, this.v3.x), tangentCubicBezier(t, this.v0.y, this.v1.y, this.v2.y, this.v3.y)).normalize();
};
QuadraticBezierCurve.prototype = Object.create(Curve.prototype);
QuadraticBezierCurve.prototype.constructor = QuadraticBezierCurve;
QuadraticBezierCurve.prototype.getPoint = function (t) {
    var b2 = exports.ShapeUtils.b2;
    return new Vector2(b2(t, this.v0.x, this.v1.x, this.v2.x), b2(t, this.v0.y, this.v1.y, this.v2.y));
};
QuadraticBezierCurve.prototype.getTangent = function (t) {
    var tangentQuadraticBezier = exports.CurveUtils.tangentQuadraticBezier;
    return new Vector2(tangentQuadraticBezier(t, this.v0.x, this.v1.x, this.v2.x), tangentQuadraticBezier(t, this.v0.y, this.v1.y, this.v2.y)).normalize();
};
PathPrototype = Object.assign(Object.create(CurvePath.prototype), {
    fromPoints: function (vectors) {
        this.moveTo(vectors[0].x, vectors[0].y);
        for (var i = 1, l = vectors.length; i < l; i++) {
            this.lineTo(vectors[i].x, vectors[i].y);
        }
    },
    moveTo: function (x, y) {
        this.currentPoint.set(x, y);
    },
    lineTo: function (x, y) {
        var curve = new LineCurve(this.currentPoint.clone(), new Vector2(x, y));
        this.curves.push(curve);
        this.currentPoint.set(x, y);
    },
    quadraticCurveTo: function (aCPx, aCPy, aX, aY) {
        var curve = new QuadraticBezierCurve(this.currentPoint.clone(), new Vector2(aCPx, aCPy), new Vector2(aX, aY));
        this.curves.push(curve);
        this.currentPoint.set(aX, aY);
    },
    bezierCurveTo: function (aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
        var curve = new CubicBezierCurve(this.currentPoint.clone(), new Vector2(aCP1x, aCP1y), new Vector2(aCP2x, aCP2y), new Vector2(aX, aY));
        this.curves.push(curve);
        this.currentPoint.set(aX, aY);
    },
    splineThru: function (pts) {
        var npts = [this.currentPoint.clone()].concat(pts);
        var curve = new SplineCurve(npts);
        this.curves.push(curve);
        this.currentPoint.copy(pts[pts.length - 1]);
    },
    arc: function (aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
        var x0 = this.currentPoint.x;
        var y0 = this.currentPoint.y;
        this.absarc(aX + x0, aY + y0, aRadius, aStartAngle, aEndAngle, aClockwise);
    },
    absarc: function (aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
        this.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
    },
    ellipse: function (aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
        var x0 = this.currentPoint.x;
        var y0 = this.currentPoint.y;
        this.absellipse(aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
    },
    absellipse: function (aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
        var curve = new EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
        if (this.curves.length > 0) {
            var firstPoint = curve.getPoint(0);
            if (!firstPoint.equals(this.currentPoint)) {
                this.lineTo(firstPoint.x, firstPoint.y);
            }
        }
        this.curves.push(curve);
        var lastPoint = curve.getPoint(1);
        this.currentPoint.copy(lastPoint);
    }
});
TubeGeometry.prototype = Object.create(Geometry.prototype);
TubeGeometry.prototype.constructor = TubeGeometry;
TubeGeometry.NoTaper = function (u) {
    return 1;
};
TubeGeometry.SinusoidalTaper = function (u) {
    return Math.sin(Math.PI * u);
};
TubeGeometry.FrenetFrames = function (path, segments, closed) {
    var normal = new Vector3(), tangents = [], normals = [], binormals = [], vec = new Vector3(), mat = new Matrix4(), numpoints = segments + 1, theta, smallest, tx, ty, tz, i, u;
    this.tangents = tangents;
    this.normals = normals;
    this.binormals = binormals;
    for (i = 0; i < numpoints; i++) {
        u = i / (numpoints - 1);
        tangents[i] = path.getTangentAt(u);
        tangents[i].normalize();
    }
    initialNormal3();
    function initialNormal3() {
        normals[0] = new Vector3();
        binormals[0] = new Vector3();
        smallest = Number.MAX_VALUE;
        tx = Math.abs(tangents[0].x);
        ty = Math.abs(tangents[0].y);
        tz = Math.abs(tangents[0].z);
        if (tx <= smallest) {
            smallest = tx;
            normal.set(1, 0, 0);
        }
        if (ty <= smallest) {
            smallest = ty;
            normal.set(0, 1, 0);
        }
        if (tz <= smallest) {
            normal.set(0, 0, 1);
        }
        vec.crossVectors(tangents[0], normal).normalize();
        normals[0].crossVectors(tangents[0], vec);
        binormals[0].crossVectors(tangents[0], normals[0]);
    }
    for (i = 1; i < numpoints; i++) {
        normals[i] = normals[i - 1].clone();
        binormals[i] = binormals[i - 1].clone();
        vec.crossVectors(tangents[i - 1], tangents[i]);
        if (vec.length() > Number.EPSILON) {
            vec.normalize();
            theta = Math.acos(exports.Math.clamp(tangents[i - 1].dot(tangents[i]), -1, 1));
            normals[i].applyMatrix4(mat.makeRotationAxis(vec, theta));
        }
        binormals[i].crossVectors(tangents[i], normals[i]);
    }
    if (closed) {
        theta = Math.acos(exports.Math.clamp(normals[0].dot(normals[numpoints - 1]), -1, 1));
        theta /= numpoints - 1;
        if (tangents[0].dot(vec.crossVectors(normals[0], normals[numpoints - 1])) > 0) {
            theta = -theta;
        }
        for (i = 1; i < numpoints; i++) {
            normals[i].applyMatrix4(mat.makeRotationAxis(tangents[i], theta * i));
            binormals[i].crossVectors(tangents[i], normals[i]);
        }
    }
};
ExtrudeGeometry.prototype = Object.create(Geometry.prototype);
ExtrudeGeometry.prototype.constructor = ExtrudeGeometry;
ExtrudeGeometry.prototype.addShapeList = function (shapes, options) {
    var sl = shapes.length;
    for (var s = 0; s < sl; s++) {
        var shape = shapes[s];
        this.addShape(shape, options);
    }
};
ExtrudeGeometry.prototype.addShape = function (shape, options) {
    var amount = options.amount !== undefined ? options.amount : 100;
    var bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6;
    var bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2;
    var bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;
    var bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true;
    var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;
    var steps = options.steps !== undefined ? options.steps : 1;
    var extrudePath = options.extrudePath;
    var extrudePts, extrudeByPath = false;
    var uvgen = options.UVGenerator !== undefined ? options.UVGenerator : ExtrudeGeometry.WorldUVGenerator;
    var splineTube, binormal, normal, position2;
    if (extrudePath) {
        extrudePts = extrudePath.getSpacedPoints(steps);
        extrudeByPath = true;
        bevelEnabled = false;
        splineTube = options.frames !== undefined ? options.frames : new TubeGeometry.FrenetFrames(extrudePath, steps, false);
        binormal = new Vector3();
        normal = new Vector3();
        position2 = new Vector3();
    }
    if (!bevelEnabled) {
        bevelSegments = 0;
        bevelThickness = 0;
        bevelSize = 0;
    }
    var ahole, h, hl;
    var scope = this;
    var shapesOffset = this.vertices.length;
    var shapePoints = shape.extractPoints(curveSegments);
    var vertices = shapePoints.shape;
    var holes = shapePoints.holes;
    var reverse = !exports.ShapeUtils.isClockWise(vertices);
    if (reverse) {
        vertices = vertices.reverse();
        for (h = 0, hl = holes.length; h < hl; h++) {
            ahole = holes[h];
            if (exports.ShapeUtils.isClockWise(ahole)) {
                holes[h] = ahole.reverse();
            }
        }
        reverse = false;
    }
    var faces = exports.ShapeUtils.triangulateShape(vertices, holes);
    var contour = vertices;
    for (h = 0, hl = holes.length; h < hl; h++) {
        ahole = holes[h];
        vertices = vertices.concat(ahole);
    }
    function scalePt2(pt, vec, size) {
        if (!vec)
            console.error('THREE.ExtrudeGeometry: vec does not exist');
        return vec.clone().multiplyScalar(size).add(pt);
    }
    var b, bs, t, z, vert, vlen = vertices.length, face, flen = faces.length;
    function getBevelVec(inPt, inPrev, inNext) {
        var v_trans_x, v_trans_y, shrink_by = 1;
        var v_prev_x = inPt.x - inPrev.x, v_prev_y = inPt.y - inPrev.y;
        var v_next_x = inNext.x - inPt.x, v_next_y = inNext.y - inPt.y;
        var v_prev_lensq = v_prev_x * v_prev_x + v_prev_y * v_prev_y;
        var collinear0 = v_prev_x * v_next_y - v_prev_y * v_next_x;
        if (Math.abs(collinear0) > Number.EPSILON) {
            var v_prev_len = Math.sqrt(v_prev_lensq);
            var v_next_len = Math.sqrt(v_next_x * v_next_x + v_next_y * v_next_y);
            var ptPrevShift_x = inPrev.x - v_prev_y / v_prev_len;
            var ptPrevShift_y = inPrev.y + v_prev_x / v_prev_len;
            var ptNextShift_x = inNext.x - v_next_y / v_next_len;
            var ptNextShift_y = inNext.y + v_next_x / v_next_len;
            var sf = ((ptNextShift_x - ptPrevShift_x) * v_next_y - (ptNextShift_y - ptPrevShift_y) * v_next_x) / (v_prev_x * v_next_y - v_prev_y * v_next_x);
            v_trans_x = ptPrevShift_x + v_prev_x * sf - inPt.x;
            v_trans_y = ptPrevShift_y + v_prev_y * sf - inPt.y;
            var v_trans_lensq = v_trans_x * v_trans_x + v_trans_y * v_trans_y;
            if (v_trans_lensq <= 2) {
                return new Vector2(v_trans_x, v_trans_y);
            } else {
                shrink_by = Math.sqrt(v_trans_lensq / 2);
            }
        } else {
            var direction_eq = false;
            if (v_prev_x > Number.EPSILON) {
                if (v_next_x > Number.EPSILON) {
                    direction_eq = true;
                }
            } else {
                if (v_prev_x < -Number.EPSILON) {
                    if (v_next_x < -Number.EPSILON) {
                        direction_eq = true;
                    }
                } else {
                    if (Math.sign(v_prev_y) === Math.sign(v_next_y)) {
                        direction_eq = true;
                    }
                }
            }
            if (direction_eq) {
                v_trans_x = -v_prev_y;
                v_trans_y = v_prev_x;
                shrink_by = Math.sqrt(v_prev_lensq);
            } else {
                v_trans_x = v_prev_x;
                v_trans_y = v_prev_y;
                shrink_by = Math.sqrt(v_prev_lensq / 2);
            }
        }
        return new Vector2(v_trans_x / shrink_by, v_trans_y / shrink_by);
    }
    var contourMovements = [];
    for (var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {
        if (j === il)
            j = 0;
        if (k === il)
            k = 0;
        contourMovements[i] = getBevelVec(contour[i], contour[j], contour[k]);
    }
    var holesMovements = [], oneHoleMovements, verticesMovements = contourMovements.concat();
    for (h = 0, hl = holes.length; h < hl; h++) {
        ahole = holes[h];
        oneHoleMovements = [];
        for (i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {
            if (j === il)
                j = 0;
            if (k === il)
                k = 0;
            oneHoleMovements[i] = getBevelVec(ahole[i], ahole[j], ahole[k]);
        }
        holesMovements.push(oneHoleMovements);
        verticesMovements = verticesMovements.concat(oneHoleMovements);
    }
    for (b = 0; b < bevelSegments; b++) {
        t = b / bevelSegments;
        z = bevelThickness * Math.cos(t * Math.PI / 2);
        bs = bevelSize * Math.sin(t * Math.PI / 2);
        for (i = 0, il = contour.length; i < il; i++) {
            vert = scalePt2(contour[i], contourMovements[i], bs);
            v(vert.x, vert.y, -z);
        }
        for (h = 0, hl = holes.length; h < hl; h++) {
            ahole = holes[h];
            oneHoleMovements = holesMovements[h];
            for (i = 0, il = ahole.length; i < il; i++) {
                vert = scalePt2(ahole[i], oneHoleMovements[i], bs);
                v(vert.x, vert.y, -z);
            }
        }
    }
    bs = bevelSize;
    for (i = 0; i < vlen; i++) {
        vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];
        if (!extrudeByPath) {
            v(vert.x, vert.y, 0);
        } else {
            normal.copy(splineTube.normals[0]).multiplyScalar(vert.x);
            binormal.copy(splineTube.binormals[0]).multiplyScalar(vert.y);
            position2.copy(extrudePts[0]).add(normal).add(binormal);
            v(position2.x, position2.y, position2.z);
        }
    }
    var s;
    for (s = 1; s <= steps; s++) {
        for (i = 0; i < vlen; i++) {
            vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];
            if (!extrudeByPath) {
                v(vert.x, vert.y, amount / steps * s);
            } else {
                normal.copy(splineTube.normals[s]).multiplyScalar(vert.x);
                binormal.copy(splineTube.binormals[s]).multiplyScalar(vert.y);
                position2.copy(extrudePts[s]).add(normal).add(binormal);
                v(position2.x, position2.y, position2.z);
            }
        }
    }
    for (b = bevelSegments - 1; b >= 0; b--) {
        t = b / bevelSegments;
        z = bevelThickness * Math.cos(t * Math.PI / 2);
        bs = bevelSize * Math.sin(t * Math.PI / 2);
        for (i = 0, il = contour.length; i < il; i++) {
            vert = scalePt2(contour[i], contourMovements[i], bs);
            v(vert.x, vert.y, amount + z);
        }
        for (h = 0, hl = holes.length; h < hl; h++) {
            ahole = holes[h];
            oneHoleMovements = holesMovements[h];
            for (i = 0, il = ahole.length; i < il; i++) {
                vert = scalePt2(ahole[i], oneHoleMovements[i], bs);
                if (!extrudeByPath) {
                    v(vert.x, vert.y, amount + z);
                } else {
                    v(vert.x, vert.y + extrudePts[steps - 1].y, extrudePts[steps - 1].x + z);
                }
            }
        }
    }
    buildLidFaces();
    buildSideFaces();
    function buildLidFaces() {
        if (bevelEnabled) {
            var layer = 0;
            var offset = vlen * layer;
            for (i = 0; i < flen; i++) {
                face = faces[i];
                f3(face[2] + offset, face[1] + offset, face[0] + offset);
            }
            layer = steps + bevelSegments * 2;
            offset = vlen * layer;
            for (i = 0; i < flen; i++) {
                face = faces[i];
                f3(face[0] + offset, face[1] + offset, face[2] + offset);
            }
        } else {
            for (i = 0; i < flen; i++) {
                face = faces[i];
                f3(face[2], face[1], face[0]);
            }
            for (i = 0; i < flen; i++) {
                face = faces[i];
                f3(face[0] + vlen * steps, face[1] + vlen * steps, face[2] + vlen * steps);
            }
        }
    }
    function buildSideFaces() {
        var layeroffset = 0;
        sidewalls(contour, layeroffset);
        layeroffset += contour.length;
        for (h = 0, hl = holes.length; h < hl; h++) {
            ahole = holes[h];
            sidewalls(ahole, layeroffset);
            layeroffset += ahole.length;
        }
    }
    function sidewalls(contour, layeroffset) {
        var j, k;
        i = contour.length;
        while (--i >= 0) {
            j = i;
            k = i - 1;
            if (k < 0)
                k = contour.length - 1;
            var s = 0, sl = steps + bevelSegments * 2;
            for (s = 0; s < sl; s++) {
                var slen1 = vlen * s;
                var slen2 = vlen * (s + 1);
                var a = layeroffset + j + slen1, b = layeroffset + k + slen1, c = layeroffset + k + slen2, d = layeroffset + j + slen2;
                f4(a, b, c, d, contour, s, sl, j, k);
            }
        }
    }
    function v(x, y, z) {
        scope.vertices.push(new Vector3(x, y, z));
    }
    function f3(a, b, c) {
        a += shapesOffset;
        b += shapesOffset;
        c += shapesOffset;
        scope.faces.push(new Face3(a, b, c, null, null, 0));
        var uvs = uvgen.generateTopUV(scope, a, b, c);
        scope.faceVertexUvs[0].push(uvs);
    }
    function f4(a, b, c, d, wallContour, stepIndex, stepsLength, contourIndex1, contourIndex2) {
        a += shapesOffset;
        b += shapesOffset;
        c += shapesOffset;
        d += shapesOffset;
        scope.faces.push(new Face3(a, b, d, null, null, 1));
        scope.faces.push(new Face3(b, c, d, null, null, 1));
        var uvs = uvgen.generateSideWallUV(scope, a, b, c, d);
        scope.faceVertexUvs[0].push([
            uvs[0],
            uvs[1],
            uvs[3]
        ]);
        scope.faceVertexUvs[0].push([
            uvs[1],
            uvs[2],
            uvs[3]
        ]);
    }
};
ExtrudeGeometry.WorldUVGenerator = {
    generateTopUV: function (geometry, indexA, indexB, indexC) {
        var vertices = geometry.vertices;
        var a = vertices[indexA];
        var b = vertices[indexB];
        var c = vertices[indexC];
        return [
            new Vector2(a.x, a.y),
            new Vector2(b.x, b.y),
            new Vector2(c.x, c.y)
        ];
    },
    generateSideWallUV: function (geometry, indexA, indexB, indexC, indexD) {
        var vertices = geometry.vertices;
        var a = vertices[indexA];
        var b = vertices[indexB];
        var c = vertices[indexC];
        var d = vertices[indexD];
        if (Math.abs(a.y - b.y) < 0.01) {
            return [
                new Vector2(a.x, 1 - a.z),
                new Vector2(b.x, 1 - b.z),
                new Vector2(c.x, 1 - c.z),
                new Vector2(d.x, 1 - d.z)
            ];
        } else {
            return [
                new Vector2(a.y, 1 - a.z),
                new Vector2(b.y, 1 - b.z),
                new Vector2(c.y, 1 - c.z),
                new Vector2(d.y, 1 - d.z)
            ];
        }
    }
};
ShapeGeometry.prototype = Object.create(Geometry.prototype);
ShapeGeometry.prototype.constructor = ShapeGeometry;
ShapeGeometry.prototype.addShapeList = function (shapes, options) {
    for (var i = 0, l = shapes.length; i < l; i++) {
        this.addShape(shapes[i], options);
    }
    return this;
};
ShapeGeometry.prototype.addShape = function (shape, options) {
    if (options === undefined)
        options = {};
    var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;
    var material = options.material;
    var uvgen = options.UVGenerator === undefined ? ExtrudeGeometry.WorldUVGenerator : options.UVGenerator;
    var i, l, hole;
    var shapesOffset = this.vertices.length;
    var shapePoints = shape.extractPoints(curveSegments);
    var vertices = shapePoints.shape;
    var holes = shapePoints.holes;
    var reverse = !exports.ShapeUtils.isClockWise(vertices);
    if (reverse) {
        vertices = vertices.reverse();
        for (i = 0, l = holes.length; i < l; i++) {
            hole = holes[i];
            if (exports.ShapeUtils.isClockWise(hole)) {
                holes[i] = hole.reverse();
            }
        }
        reverse = false;
    }
    var faces = exports.ShapeUtils.triangulateShape(vertices, holes);
    for (i = 0, l = holes.length; i < l; i++) {
        hole = holes[i];
        vertices = vertices.concat(hole);
    }
    var vert, vlen = vertices.length;
    var face, flen = faces.length;
    for (i = 0; i < vlen; i++) {
        vert = vertices[i];
        this.vertices.push(new Vector3(vert.x, vert.y, 0));
    }
    for (i = 0; i < flen; i++) {
        face = faces[i];
        var a = face[0] + shapesOffset;
        var b = face[1] + shapesOffset;
        var c = face[2] + shapesOffset;
        this.faces.push(new Face3(a, b, c, null, null, material));
        this.faceVertexUvs[0].push(uvgen.generateTopUV(this, a, b, c));
    }
};
Shape.prototype = Object.assign(Object.create(PathPrototype), {
    constructor: Shape,
    extrude: function (options) {
        return new ExtrudeGeometry(this, options);
    },
    makeGeometry: function (options) {
        return new ShapeGeometry(this, options);
    },
    getPointsHoles: function (divisions) {
        var holesPts = [];
        for (var i = 0, l = this.holes.length; i < l; i++) {
            holesPts[i] = this.holes[i].getPoints(divisions);
        }
        return holesPts;
    },
    extractAllPoints: function (divisions) {
        return {
            shape: this.getPoints(divisions),
            holes: this.getPointsHoles(divisions)
        };
    },
    extractPoints: function (divisions) {
        return this.extractAllPoints(divisions);
    }
});
Path.prototype = PathPrototype;
PathPrototype.constructor = Path;
ShapePath.prototype = {
    moveTo: function (x, y) {
        this.currentPath = new Path();
        this.subPaths.push(this.currentPath);
        this.currentPath.moveTo(x, y);
    },
    lineTo: function (x, y) {
        this.currentPath.lineTo(x, y);
    },
    quadraticCurveTo: function (aCPx, aCPy, aX, aY) {
        this.currentPath.quadraticCurveTo(aCPx, aCPy, aX, aY);
    },
    bezierCurveTo: function (aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
        this.currentPath.bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY);
    },
    splineThru: function (pts) {
        this.currentPath.splineThru(pts);
    },
    toShapes: function (isCCW, noHoles) {
        function toShapesNoHoles(inSubpaths) {
            var shapes = [];
            for (var i = 0, l = inSubpaths.length; i < l; i++) {
                var tmpPath = inSubpaths[i];
                var tmpShape = new Shape();
                tmpShape.curves = tmpPath.curves;
                shapes.push(tmpShape);
            }
            return shapes;
        }
        function isPointInsidePolygon(inPt, inPolygon) {
            var polyLen = inPolygon.length;
            var inside = false;
            for (var p = polyLen - 1, q = 0; q < polyLen; p = q++) {
                var edgeLowPt = inPolygon[p];
                var edgeHighPt = inPolygon[q];
                var edgeDx = edgeHighPt.x - edgeLowPt.x;
                var edgeDy = edgeHighPt.y - edgeLowPt.y;
                if (Math.abs(edgeDy) > Number.EPSILON) {
                    if (edgeDy < 0) {
                        edgeLowPt = inPolygon[q];
                        edgeDx = -edgeDx;
                        edgeHighPt = inPolygon[p];
                        edgeDy = -edgeDy;
                    }
                    if (inPt.y < edgeLowPt.y || inPt.y > edgeHighPt.y)
                        continue;
                    if (inPt.y === edgeLowPt.y) {
                        if (inPt.x === edgeLowPt.x)
                            return true;
                    } else {
                        var perpEdge = edgeDy * (inPt.x - edgeLowPt.x) - edgeDx * (inPt.y - edgeLowPt.y);
                        if (perpEdge === 0)
                            return true;
                        if (perpEdge < 0)
                            continue;
                        inside = !inside;
                    }
                } else {
                    if (inPt.y !== edgeLowPt.y)
                        continue;
                    if (edgeHighPt.x <= inPt.x && inPt.x <= edgeLowPt.x || edgeLowPt.x <= inPt.x && inPt.x <= edgeHighPt.x)
                        return true;
                }
            }
            return inside;
        }
        var isClockWise = exports.ShapeUtils.isClockWise;
        var subPaths = this.subPaths;
        if (subPaths.length === 0)
            return [];
        if (noHoles === true)
            return toShapesNoHoles(subPaths);
        var solid, tmpPath, tmpShape, shapes = [];
        if (subPaths.length === 1) {
            tmpPath = subPaths[0];
            tmpShape = new Shape();
            tmpShape.curves = tmpPath.curves;
            shapes.push(tmpShape);
            return shapes;
        }
        var holesFirst = !isClockWise(subPaths[0].getPoints());
        holesFirst = isCCW ? !holesFirst : holesFirst;
        var betterShapeHoles = [];
        var newShapes = [];
        var newShapeHoles = [];
        var mainIdx = 0;
        var tmpPoints;
        newShapes[mainIdx] = undefined;
        newShapeHoles[mainIdx] = [];
        for (var i = 0, l = subPaths.length; i < l; i++) {
            tmpPath = subPaths[i];
            tmpPoints = tmpPath.getPoints();
            solid = isClockWise(tmpPoints);
            solid = isCCW ? !solid : solid;
            if (solid) {
                if (!holesFirst && newShapes[mainIdx])
                    mainIdx++;
                newShapes[mainIdx] = {
                    s: new Shape(),
                    p: tmpPoints
                };
                newShapes[mainIdx].s.curves = tmpPath.curves;
                if (holesFirst)
                    mainIdx++;
                newShapeHoles[mainIdx] = [];
            } else {
                newShapeHoles[mainIdx].push({
                    h: tmpPath,
                    p: tmpPoints[0]
                });
            }
        }
        if (!newShapes[0])
            return toShapesNoHoles(subPaths);
        if (newShapes.length > 1) {
            var ambiguous = false;
            var toChange = [];
            for (var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {
                betterShapeHoles[sIdx] = [];
            }
            for (var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {
                var sho = newShapeHoles[sIdx];
                for (var hIdx = 0; hIdx < sho.length; hIdx++) {
                    var ho = sho[hIdx];
                    var hole_unassigned = true;
                    for (var s2Idx = 0; s2Idx < newShapes.length; s2Idx++) {
                        if (isPointInsidePolygon(ho.p, newShapes[s2Idx].p)) {
                            if (sIdx !== s2Idx)
                                toChange.push({
                                froms: sIdx,
                                tos: s2Idx,
                                hole: hIdx
                            });
                            if (hole_unassigned) {
                                hole_unassigned = false;
                                betterShapeHoles[s2Idx].push(ho);
                            } else {
                                ambiguous = true;
                            }
                        }
                    }
                    if (hole_unassigned) {
                        betterShapeHoles[sIdx].push(ho);
                    }
                }
            }
            if (toChange.length > 0) {
                if (!ambiguous)
                    newShapeHoles = betterShapeHoles;
            }
        }
        var tmpHoles;
        for (var i = 0, il = newShapes.length; i < il; i++) {
            tmpShape = newShapes[i].s;
            shapes.push(tmpShape);
            tmpHoles = newShapeHoles[i];
            for (var j = 0, jl = tmpHoles.length; j < jl; j++) {
                tmpShape.holes.push(tmpHoles[j].h);
            }
        }
        return shapes;
    }
};
Object.assign(Font.prototype, {
    isFont: true,
    generateShapes: function (text, size, divisions) {
        function createPaths(text) {
            var chars = String(text).split('');
            var scale = size / data.resolution;
            var offset = 0;
            var paths = [];
            for (var i = 0; i < chars.length; i++) {
                var ret = createPath(chars[i], scale, offset);
                offset += ret.offset;
                paths.push(ret.path);
            }
            return paths;
        }
        function createPath(c, scale, offset) {
            var glyph = data.glyphs[c] || data.glyphs['?'];
            if (!glyph)
                return;
            var path = new ShapePath();
            var pts = [], b2 = exports.ShapeUtils.b2, b3 = exports.ShapeUtils.b3;
            var x, y, cpx, cpy, cpx0, cpy0, cpx1, cpy1, cpx2, cpy2, laste;
            if (glyph.o) {
                var outline = glyph._cachedOutline || (glyph._cachedOutline = glyph.o.split(' '));
                for (var i = 0, l = outline.length; i < l;) {
                    var action = outline[i++];
                    switch (action) {
                    case 'm':
                        x = outline[i++] * scale + offset;
                        y = outline[i++] * scale;
                        path.moveTo(x, y);
                        break;
                    case 'l':
                        x = outline[i++] * scale + offset;
                        y = outline[i++] * scale;
                        path.lineTo(x, y);
                        break;
                    case 'q':
                        cpx = outline[i++] * scale + offset;
                        cpy = outline[i++] * scale;
                        cpx1 = outline[i++] * scale + offset;
                        cpy1 = outline[i++] * scale;
                        path.quadraticCurveTo(cpx1, cpy1, cpx, cpy);
                        laste = pts[pts.length - 1];
                        if (laste) {
                            cpx0 = laste.x;
                            cpy0 = laste.y;
                            for (var i2 = 1; i2 <= divisions; i2++) {
                                var t = i2 / divisions;
                                b2(t, cpx0, cpx1, cpx);
                                b2(t, cpy0, cpy1, cpy);
                            }
                        }
                        break;
                    case 'b':
                        cpx = outline[i++] * scale + offset;
                        cpy = outline[i++] * scale;
                        cpx1 = outline[i++] * scale + offset;
                        cpy1 = outline[i++] * scale;
                        cpx2 = outline[i++] * scale + offset;
                        cpy2 = outline[i++] * scale;
                        path.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, cpx, cpy);
                        laste = pts[pts.length - 1];
                        if (laste) {
                            cpx0 = laste.x;
                            cpy0 = laste.y;
                            for (var i2 = 1; i2 <= divisions; i2++) {
                                var t = i2 / divisions;
                                b3(t, cpx0, cpx1, cpx2, cpx);
                                b3(t, cpy0, cpy1, cpy2, cpy);
                            }
                        }
                        break;
                    }
                }
            }
            return {
                offset: glyph.ha * scale,
                path: path
            };
        }
        if (size === undefined)
            size = 100;
        if (divisions === undefined)
            divisions = 4;
        var data = this.data;
        var paths = createPaths(text);
        var shapes = [];
        for (var p = 0, pl = paths.length; p < pl; p++) {
            Array.prototype.push.apply(shapes, paths[p].toShapes());
        }
        return shapes;
    }
});
Object.assign(FontLoader.prototype, {
    load: function (url, onLoad, onProgress, onError) {
        var scope = this;
        var loader = new XHRLoader(this.manager);
        loader.load(url, function (text) {
            var json;
            try {
                json = JSON.parse(text);
            } catch (e) {
                console.warn('THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.');
                json = JSON.parse(text.substring(65, text.length - 2));
            }
            var font = scope.parse(json);
            if (onLoad)
                onLoad(font);
        }, onProgress, onError);
    },
    parse: function (json) {
        return new Font(json);
    }
});
Object.assign(AudioLoader.prototype, {
    load: function (url, onLoad, onProgress, onError) {
        var loader = new XHRLoader(this.manager);
        loader.setResponseType('arraybuffer');
        loader.load(url, function (buffer) {
            var context = getAudioContext();
            context.decodeAudioData(buffer, function (audioBuffer) {
                onLoad(audioBuffer);
            });
        }, onProgress, onError);
    }
});
Object.assign(StereoCamera.prototype, {
    update: function () {
        var focus, fov, aspect, near, far;
        var eyeRight = new Matrix4();
        var eyeLeft = new Matrix4();
        return function update(camera) {
            var needsUpdate = focus !== camera.focus || fov !== camera.fov || aspect !== camera.aspect * this.aspect || near !== camera.near || far !== camera.far;
            if (needsUpdate) {
                focus = camera.focus;
                fov = camera.fov;
                aspect = camera.aspect * this.aspect;
                near = camera.near;
                far = camera.far;
                var projectionMatrix = camera.projectionMatrix.clone();
                var eyeSep = this.eyeSep / 2;
                var eyeSepOnProjection = eyeSep * near / focus;
                var ymax = near * Math.tan(exports.Math.DEG2RAD * fov * 0.5);
                var xmin, xmax;
                eyeLeft.elements[12] = -eyeSep;
                eyeRight.elements[12] = eyeSep;
                xmin = -ymax * aspect + eyeSepOnProjection;
                xmax = ymax * aspect + eyeSepOnProjection;
                projectionMatrix.elements[0] = 2 * near / (xmax - xmin);
                projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);
                this.cameraL.projectionMatrix.copy(projectionMatrix);
                xmin = -ymax * aspect - eyeSepOnProjection;
                xmax = ymax * aspect - eyeSepOnProjection;
                projectionMatrix.elements[0] = 2 * near / (xmax - xmin);
                projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);
                this.cameraR.projectionMatrix.copy(projectionMatrix);
            }
            this.cameraL.matrixWorld.copy(camera.matrixWorld).multiply(eyeLeft);
            this.cameraR.matrixWorld.copy(camera.matrixWorld).multiply(eyeRight);
        };
    }()
});
CubeCamera.prototype = Object.create(Object3D.prototype);
CubeCamera.prototype.constructor = CubeCamera;
AudioListener.prototype = Object.assign(Object.create(Object3D.prototype), {
    constructor: AudioListener,
    getInput: function () {
        return this.gain;
    },
    removeFilter: function () {
        if (this.filter !== null) {
            this.gain.disconnect(this.filter);
            this.filter.disconnect(this.context.destination);
            this.gain.connect(this.context.destination);
            this.filter = null;
        }
    },
    getFilter: function () {
        return this.filter;
    },
    setFilter: function (value) {
        if (this.filter !== null) {
            this.gain.disconnect(this.filter);
            this.filter.disconnect(this.context.destination);
        } else {
            this.gain.disconnect(this.context.destination);
        }
        this.filter = value;
        this.gain.connect(this.filter);
        this.filter.connect(this.context.destination);
    },
    getMasterVolume: function () {
        return this.gain.gain.value;
    },
    setMasterVolume: function (value) {
        this.gain.gain.value = value;
    },
    updateMatrixWorld: function () {
        var position = new Vector3();
        var quaternion = new Quaternion();
        var scale = new Vector3();
        var orientation = new Vector3();
        return function updateMatrixWorld(force) {
            Object3D.prototype.updateMatrixWorld.call(this, force);
            var listener = this.context.listener;
            var up = this.up;
            this.matrixWorld.decompose(position, quaternion, scale);
            orientation.set(0, 0, -1).applyQuaternion(quaternion);
            listener.setPosition(position.x, position.y, position.z);
            listener.setOrientation(orientation.x, orientation.y, orientation.z, up.x, up.y, up.z);
        };
    }()
});
Audio.prototype = Object.assign(Object.create(Object3D.prototype), {
    constructor: Audio,
    getOutput: function () {
        return this.gain;
    },
    setNodeSource: function (audioNode) {
        this.hasPlaybackControl = false;
        this.sourceType = 'audioNode';
        this.source = audioNode;
        this.connect();
        return this;
    },
    setBuffer: function (audioBuffer) {
        this.source.buffer = audioBuffer;
        this.sourceType = 'buffer';
        if (this.autoplay)
            this.play();
        return this;
    },
    play: function () {
        if (this.isPlaying === true) {
            console.warn('THREE.Audio: Audio is already playing.');
            return;
        }
        if (this.hasPlaybackControl === false) {
            console.warn('THREE.Audio: this Audio has no playback control.');
            return;
        }
        var source = this.context.createBufferSource();
        source.buffer = this.source.buffer;
        source.loop = this.source.loop;
        source.onended = this.source.onended;
        source.start(0, this.startTime);
        source.playbackRate.value = this.playbackRate;
        this.isPlaying = true;
        this.source = source;
        return this.connect();
    },
    pause: function () {
        if (this.hasPlaybackControl === false) {
            console.warn('THREE.Audio: this Audio has no playback control.');
            return;
        }
        this.source.stop();
        this.startTime = this.context.currentTime;
        this.isPlaying = false;
        return this;
    },
    stop: function () {
        if (this.hasPlaybackControl === false) {
            console.warn('THREE.Audio: this Audio has no playback control.');
            return;
        }
        this.source.stop();
        this.startTime = 0;
        this.isPlaying = false;
        return this;
    },
    connect: function () {
        if (this.filters.length > 0) {
            this.source.connect(this.filters[0]);
            for (var i = 1, l = this.filters.length; i < l; i++) {
                this.filters[i - 1].connect(this.filters[i]);
            }
            this.filters[this.filters.length - 1].connect(this.getOutput());
        } else {
            this.source.connect(this.getOutput());
        }
        return this;
    },
    disconnect: function () {
        if (this.filters.length > 0) {
            this.source.disconnect(this.filters[0]);
            for (var i = 1, l = this.filters.length; i < l; i++) {
                this.filters[i - 1].disconnect(this.filters[i]);
            }
            this.filters[this.filters.length - 1].disconnect(this.getOutput());
        } else {
            this.source.disconnect(this.getOutput());
        }
        return this;
    },
    getFilters: function () {
        return this.filters;
    },
    setFilters: function (value) {
        if (!value)
            value = [];
        if (this.isPlaying === true) {
            this.disconnect();
            this.filters = value;
            this.connect();
        } else {
            this.filters = value;
        }
        return this;
    },
    getFilter: function () {
        return this.getFilters()[0];
    },
    setFilter: function (filter) {
        return this.setFilters(filter ? [filter] : []);
    },
    setPlaybackRate: function (value) {
        if (this.hasPlaybackControl === false) {
            console.warn('THREE.Audio: this Audio has no playback control.');
            return;
        }
        this.playbackRate = value;
        if (this.isPlaying === true) {
            this.source.playbackRate.value = this.playbackRate;
        }
        return this;
    },
    getPlaybackRate: function () {
        return this.playbackRate;
    },
    onEnded: function () {
        this.isPlaying = false;
    },
    getLoop: function () {
        if (this.hasPlaybackControl === false) {
            console.warn('THREE.Audio: this Audio has no playback control.');
            return false;
        }
        return this.source.loop;
    },
    setLoop: function (value) {
        if (this.hasPlaybackControl === false) {
            console.warn('THREE.Audio: this Audio has no playback control.');
            return;
        }
        this.source.loop = value;
    },
    getVolume: function () {
        return this.gain.gain.value;
    },
    setVolume: function (value) {
        this.gain.gain.value = value;
        return this;
    }
});
PositionalAudio.prototype = Object.assign(Object.create(Audio.prototype), {
    constructor: PositionalAudio,
    getOutput: function () {
        return this.panner;
    },
    getRefDistance: function () {
        return this.panner.refDistance;
    },
    setRefDistance: function (value) {
        this.panner.refDistance = value;
    },
    getRolloffFactor: function () {
        return this.panner.rolloffFactor;
    },
    setRolloffFactor: function (value) {
        this.panner.rolloffFactor = value;
    },
    getDistanceModel: function () {
        return this.panner.distanceModel;
    },
    setDistanceModel: function (value) {
        this.panner.distanceModel = value;
    },
    getMaxDistance: function () {
        return this.panner.maxDistance;
    },
    setMaxDistance: function (value) {
        this.panner.maxDistance = value;
    },
    updateMatrixWorld: function () {
        var position = new Vector3();
        return function updateMatrixWorld(force) {
            Object3D.prototype.updateMatrixWorld.call(this, force);
            position.setFromMatrixPosition(this.matrixWorld);
            this.panner.setPosition(position.x, position.y, position.z);
        };
    }()
});
Object.assign(AudioAnalyser.prototype, {
    getFrequencyData: function () {
        this.analyser.getByteFrequencyData(this.data);
        return this.data;
    },
    getAverageFrequency: function () {
        var value = 0, data = this.getFrequencyData();
        for (var i = 0; i < data.length; i++) {
            value += data[i];
        }
        return value / data.length;
    }
});
PropertyMixer.prototype = {
    constructor: PropertyMixer,
    accumulate: function (accuIndex, weight) {
        var buffer = this.buffer, stride = this.valueSize, offset = accuIndex * stride + stride, currentWeight = this.cumulativeWeight;
        if (currentWeight === 0) {
            for (var i = 0; i !== stride; ++i) {
                buffer[offset + i] = buffer[i];
            }
            currentWeight = weight;
        } else {
            currentWeight += weight;
            var mix = weight / currentWeight;
            this._mixBufferRegion(buffer, offset, 0, mix, stride);
        }
        this.cumulativeWeight = currentWeight;
    },
    apply: function (accuIndex) {
        var stride = this.valueSize, buffer = this.buffer, offset = accuIndex * stride + stride, weight = this.cumulativeWeight, binding = this.binding;
        this.cumulativeWeight = 0;
        if (weight < 1) {
            var originalValueOffset = stride * 3;
            this._mixBufferRegion(buffer, offset, originalValueOffset, 1 - weight, stride);
        }
        for (var i = stride, e = stride + stride; i !== e; ++i) {
            if (buffer[i] !== buffer[i + stride]) {
                binding.setValue(buffer, offset);
                break;
            }
        }
    },
    saveOriginalState: function () {
        var binding = this.binding;
        var buffer = this.buffer, stride = this.valueSize, originalValueOffset = stride * 3;
        binding.getValue(buffer, originalValueOffset);
        for (var i = stride, e = originalValueOffset; i !== e; ++i) {
            buffer[i] = buffer[originalValueOffset + i % stride];
        }
        this.cumulativeWeight = 0;
    },
    restoreOriginalState: function () {
        var originalValueOffset = this.valueSize * 3;
        this.binding.setValue(this.buffer, originalValueOffset);
    },
    _select: function (buffer, dstOffset, srcOffset, t, stride) {
        if (t >= 0.5) {
            for (var i = 0; i !== stride; ++i) {
                buffer[dstOffset + i] = buffer[srcOffset + i];
            }
        }
    },
    _slerp: function (buffer, dstOffset, srcOffset, t, stride) {
        Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t);
    },
    _lerp: function (buffer, dstOffset, srcOffset, t, stride) {
        var s = 1 - t;
        for (var i = 0; i !== stride; ++i) {
            var j = dstOffset + i;
            buffer[j] = buffer[j] * s + buffer[srcOffset + i] * t;
        }
    }
};
PropertyBinding.prototype = {
    constructor: PropertyBinding,
    getValue: function getValue_unbound(targetArray, offset) {
        this.bind();
        this.getValue(targetArray, offset);
    },
    setValue: function getValue_unbound(sourceArray, offset) {
        this.bind();
        this.setValue(sourceArray, offset);
    },
    bind: function () {
        var targetObject = this.node, parsedPath = this.parsedPath, objectName = parsedPath.objectName, propertyName = parsedPath.propertyName, propertyIndex = parsedPath.propertyIndex;
        if (!targetObject) {
            targetObject = PropertyBinding.findNode(this.rootNode, parsedPath.nodeName) || this.rootNode;
            this.node = targetObject;
        }
        this.getValue = this._getValue_unavailable;
        this.setValue = this._setValue_unavailable;
        if (!targetObject) {
            console.error('  trying to update node for track: ' + this.path + ' but it wasn\'t found.');
            return;
        }
        if (objectName) {
            var objectIndex = parsedPath.objectIndex;
            switch (objectName) {
            case 'materials':
                if (!targetObject.material) {
                    console.error('  can not bind to material as node does not have a material', this);
                    return;
                }
                if (!targetObject.material.materials) {
                    console.error('  can not bind to material.materials as node.material does not have a materials array', this);
                    return;
                }
                targetObject = targetObject.material.materials;
                break;
            case 'bones':
                if (!targetObject.skeleton) {
                    console.error('  can not bind to bones as node does not have a skeleton', this);
                    return;
                }
                targetObject = targetObject.skeleton.bones;
                for (var i = 0; i < targetObject.length; i++) {
                    if (targetObject[i].name === objectIndex) {
                        objectIndex = i;
                        break;
                    }
                }
                break;
            default:
                if (targetObject[objectName] === undefined) {
                    console.error('  can not bind to objectName of node, undefined', this);
                    return;
                }
                targetObject = targetObject[objectName];
            }
            if (objectIndex !== undefined) {
                if (targetObject[objectIndex] === undefined) {
                    console.error('  trying to bind to objectIndex of objectName, but is undefined:', this, targetObject);
                    return;
                }
                targetObject = targetObject[objectIndex];
            }
        }
        var nodeProperty = targetObject[propertyName];
        if (nodeProperty === undefined) {
            var nodeName = parsedPath.nodeName;
            console.error('  trying to update property for track: ' + nodeName + '.' + propertyName + ' but it wasn\'t found.', targetObject);
            return;
        }
        var versioning = this.Versioning.None;
        if (targetObject.needsUpdate !== undefined) {
            versioning = this.Versioning.NeedsUpdate;
            this.targetObject = targetObject;
        } else if (targetObject.matrixWorldNeedsUpdate !== undefined) {
            versioning = this.Versioning.MatrixWorldNeedsUpdate;
            this.targetObject = targetObject;
        }
        var bindingType = this.BindingType.Direct;
        if (propertyIndex !== undefined) {
            if (propertyName === 'morphTargetInfluences') {
                if (!targetObject.geometry) {
                    console.error('  can not bind to morphTargetInfluences becasuse node does not have a geometry', this);
                    return;
                }
                if (!targetObject.geometry.morphTargets) {
                    console.error('  can not bind to morphTargetInfluences becasuse node does not have a geometry.morphTargets', this);
                    return;
                }
                for (var i = 0; i < this.node.geometry.morphTargets.length; i++) {
                    if (targetObject.geometry.morphTargets[i].name === propertyIndex) {
                        propertyIndex = i;
                        break;
                    }
                }
            }
            bindingType = this.BindingType.ArrayElement;
            this.resolvedProperty = nodeProperty;
            this.propertyIndex = propertyIndex;
        } else if (nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined) {
            bindingType = this.BindingType.HasFromToArray;
            this.resolvedProperty = nodeProperty;
        } else if (nodeProperty.length !== undefined) {
            bindingType = this.BindingType.EntireArray;
            this.resolvedProperty = nodeProperty;
        } else {
            this.propertyName = propertyName;
        }
        this.getValue = this.GetterByBindingType[bindingType];
        this.setValue = this.SetterByBindingTypeAndVersioning[bindingType][versioning];
    },
    unbind: function () {
        this.node = null;
        this.getValue = this._getValue_unbound;
        this.setValue = this._setValue_unbound;
    }
};
Object.assign(PropertyBinding.prototype, {
    _getValue_unavailable: function () {
    },
    _setValue_unavailable: function () {
    },
    _getValue_unbound: PropertyBinding.prototype.getValue,
    _setValue_unbound: PropertyBinding.prototype.setValue,
    BindingType: {
        Direct: 0,
        EntireArray: 1,
        ArrayElement: 2,
        HasFromToArray: 3
    },
    Versioning: {
        None: 0,
        NeedsUpdate: 1,
        MatrixWorldNeedsUpdate: 2
    },
    GetterByBindingType: [
        function getValue_direct(buffer, offset) {
            buffer[offset] = this.node[this.propertyName];
        },
        function getValue_array(buffer, offset) {
            var source = this.resolvedProperty;
            for (var i = 0, n = source.length; i !== n; ++i) {
                buffer[offset++] = source[i];
            }
        },
        function getValue_arrayElement(buffer, offset) {
            buffer[offset] = this.resolvedProperty[this.propertyIndex];
        },
        function getValue_toArray(buffer, offset) {
            this.resolvedProperty.toArray(buffer, offset);
        }
    ],
    SetterByBindingTypeAndVersioning: [
        [
            function setValue_direct(buffer, offset) {
                this.node[this.propertyName] = buffer[offset];
            },
            function setValue_direct_setNeedsUpdate(buffer, offset) {
                this.node[this.propertyName] = buffer[offset];
                this.targetObject.needsUpdate = true;
            },
            function setValue_direct_setMatrixWorldNeedsUpdate(buffer, offset) {
                this.node[this.propertyName] = buffer[offset];
                this.targetObject.matrixWorldNeedsUpdate = true;
            }
        ],
        [
            function setValue_array(buffer, offset) {
                var dest = this.resolvedProperty;
                for (var i = 0, n = dest.length; i !== n; ++i) {
                    dest[i] = buffer[offset++];
                }
            },
            function setValue_array_setNeedsUpdate(buffer, offset) {
                var dest = this.resolvedProperty;
                for (var i = 0, n = dest.length; i !== n; ++i) {
                    dest[i] = buffer[offset++];
                }
                this.targetObject.needsUpdate = true;
            },
            function setValue_array_setMatrixWorldNeedsUpdate(buffer, offset) {
                var dest = this.resolvedProperty;
                for (var i = 0, n = dest.length; i !== n; ++i) {
                    dest[i] = buffer[offset++];
                }
                this.targetObject.matrixWorldNeedsUpdate = true;
            }
        ],
        [
            function setValue_arrayElement(buffer, offset) {
                this.resolvedProperty[this.propertyIndex] = buffer[offset];
            },
            function setValue_arrayElement_setNeedsUpdate(buffer, offset) {
                this.resolvedProperty[this.propertyIndex] = buffer[offset];
                this.targetObject.needsUpdate = true;
            },
            function setValue_arrayElement_setMatrixWorldNeedsUpdate(buffer, offset) {
                this.resolvedProperty[this.propertyIndex] = buffer[offset];
                this.targetObject.matrixWorldNeedsUpdate = true;
            }
        ],
        [
            function setValue_fromArray(buffer, offset) {
                this.resolvedProperty.fromArray(buffer, offset);
            },
            function setValue_fromArray_setNeedsUpdate(buffer, offset) {
                this.resolvedProperty.fromArray(buffer, offset);
                this.targetObject.needsUpdate = true;
            },
            function setValue_fromArray_setMatrixWorldNeedsUpdate(buffer, offset) {
                this.resolvedProperty.fromArray(buffer, offset);
                this.targetObject.matrixWorldNeedsUpdate = true;
            }
        ]
    ]
});
PropertyBinding.Composite = function (targetGroup, path, optionalParsedPath) {
    var parsedPath = optionalParsedPath || PropertyBinding.parseTrackName(path);
    this._targetGroup = targetGroup;
    this._bindings = targetGroup.subscribe_(path, parsedPath);
};
PropertyBinding.Composite.prototype = {
    constructor: PropertyBinding.Composite,
    getValue: function (array, offset) {
        this.bind();
        var firstValidIndex = this._targetGroup.nCachedObjects_, binding = this._bindings[firstValidIndex];
        if (binding !== undefined)
            binding.getValue(array, offset);
    },
    setValue: function (array, offset) {
        var bindings = this._bindings;
        for (var i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
            bindings[i].setValue(array, offset);
        }
    },
    bind: function () {
        var bindings = this._bindings;
        for (var i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
            bindings[i].bind();
        }
    },
    unbind: function () {
        var bindings = this._bindings;
        for (var i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
            bindings[i].unbind();
        }
    }
};
PropertyBinding.create = function (root, path, parsedPath) {
    if (!(root && root.isAnimationObjectGroup)) {
        return new PropertyBinding(root, path, parsedPath);
    } else {
        return new PropertyBinding.Composite(root, path, parsedPath);
    }
};
PropertyBinding.parseTrackName = function (trackName) {
    var re = /^((?:\w+\/)*)(\w+)?(?:\.(\w+)(?:\[(.+)\])?)?\.(\w+)(?:\[(.+)\])?$/;
    var matches = re.exec(trackName);
    if (!matches) {
        throw new Error('cannot parse trackName at all: ' + trackName);
    }
    var results = {
        nodeName: matches[2],
        objectName: matches[3],
        objectIndex: matches[4],
        propertyName: matches[5],
        propertyIndex: matches[6]
    };
    if (results.propertyName === null || results.propertyName.length === 0) {
        throw new Error('can not parse propertyName from trackName: ' + trackName);
    }
    return results;
};
PropertyBinding.findNode = function (root, nodeName) {
    if (!nodeName || nodeName === '' || nodeName === 'root' || nodeName === '.' || nodeName === -1 || nodeName === root.name || nodeName === root.uuid) {
        return root;
    }
    if (root.skeleton) {
        var searchSkeleton = function (skeleton) {
            for (var i = 0; i < skeleton.bones.length; i++) {
                var bone = skeleton.bones[i];
                if (bone.name === nodeName) {
                    return bone;
                }
            }
            return null;
        };
        var bone = searchSkeleton(root.skeleton);
        if (bone) {
            return bone;
        }
    }
    if (root.children) {
        var searchNodeSubtree = function (children) {
            for (var i = 0; i < children.length; i++) {
                var childNode = children[i];
                if (childNode.name === nodeName || childNode.uuid === nodeName) {
                    return childNode;
                }
                var result = searchNodeSubtree(childNode.children);
                if (result)
                    return result;
            }
            return null;
        };
        var subTreeNode = searchNodeSubtree(root.children);
        if (subTreeNode) {
            return subTreeNode;
        }
    }
    return null;
};
AnimationObjectGroup.prototype = {
    constructor: AnimationObjectGroup,
    isAnimationObjectGroup: true,
    add: function (var_args) {
        var objects = this._objects, nObjects = objects.length, nCachedObjects = this.nCachedObjects_, indicesByUUID = this._indicesByUUID, paths = this._paths, parsedPaths = this._parsedPaths, bindings = this._bindings, nBindings = bindings.length;
        for (var i = 0, n = arguments.length; i !== n; ++i) {
            var object = arguments[i], uuid = object.uuid, index = indicesByUUID[uuid];
            if (index === undefined) {
                index = nObjects++;
                indicesByUUID[uuid] = index;
                objects.push(object);
                for (var j = 0, m = nBindings; j !== m; ++j) {
                    bindings[j].push(new PropertyBinding(object, paths[j], parsedPaths[j]));
                }
            } else if (index < nCachedObjects) {
                var knownObject = objects[index];
                var firstActiveIndex = --nCachedObjects, lastCachedObject = objects[firstActiveIndex];
                indicesByUUID[lastCachedObject.uuid] = index;
                objects[index] = lastCachedObject;
                indicesByUUID[uuid] = firstActiveIndex;
                objects[firstActiveIndex] = object;
                for (var j = 0, m = nBindings; j !== m; ++j) {
                    var bindingsForPath = bindings[j], lastCached = bindingsForPath[firstActiveIndex], binding = bindingsForPath[index];
                    bindingsForPath[index] = lastCached;
                    if (binding === undefined) {
                        binding = new PropertyBinding(object, paths[j], parsedPaths[j]);
                    }
                    bindingsForPath[firstActiveIndex] = binding;
                }
            } else if (objects[index] !== knownObject) {
                console.error('Different objects with the same UUID ' + 'detected. Clean the caches or recreate your ' + 'infrastructure when reloading scenes...');
            }
        }
        this.nCachedObjects_ = nCachedObjects;
    },
    remove: function (var_args) {
        var objects = this._objects, nCachedObjects = this.nCachedObjects_, indicesByUUID = this._indicesByUUID, bindings = this._bindings, nBindings = bindings.length;
        for (var i = 0, n = arguments.length; i !== n; ++i) {
            var object = arguments[i], uuid = object.uuid, index = indicesByUUID[uuid];
            if (index !== undefined && index >= nCachedObjects) {
                var lastCachedIndex = nCachedObjects++, firstActiveObject = objects[lastCachedIndex];
                indicesByUUID[firstActiveObject.uuid] = index;
                objects[index] = firstActiveObject;
                indicesByUUID[uuid] = lastCachedIndex;
                objects[lastCachedIndex] = object;
                for (var j = 0, m = nBindings; j !== m; ++j) {
                    var bindingsForPath = bindings[j], firstActive = bindingsForPath[lastCachedIndex], binding = bindingsForPath[index];
                    bindingsForPath[index] = firstActive;
                    bindingsForPath[lastCachedIndex] = binding;
                }
            }
        }
        this.nCachedObjects_ = nCachedObjects;
    },
    uncache: function (var_args) {
        var objects = this._objects, nObjects = objects.length, nCachedObjects = this.nCachedObjects_, indicesByUUID = this._indicesByUUID, bindings = this._bindings, nBindings = bindings.length;
        for (var i = 0, n = arguments.length; i !== n; ++i) {
            var object = arguments[i], uuid = object.uuid, index = indicesByUUID[uuid];
            if (index !== undefined) {
                delete indicesByUUID[uuid];
                if (index < nCachedObjects) {
                    var firstActiveIndex = --nCachedObjects, lastCachedObject = objects[firstActiveIndex], lastIndex = --nObjects, lastObject = objects[lastIndex];
                    indicesByUUID[lastCachedObject.uuid] = index;
                    objects[index] = lastCachedObject;
                    indicesByUUID[lastObject.uuid] = firstActiveIndex;
                    objects[firstActiveIndex] = lastObject;
                    objects.pop();
                    for (var j = 0, m = nBindings; j !== m; ++j) {
                        var bindingsForPath = bindings[j], lastCached = bindingsForPath[firstActiveIndex], last = bindingsForPath[lastIndex];
                        bindingsForPath[index] = lastCached;
                        bindingsForPath[firstActiveIndex] = last;
                        bindingsForPath.pop();
                    }
                } else {
                    var lastIndex = --nObjects, lastObject = objects[lastIndex];
                    indicesByUUID[lastObject.uuid] = index;
                    objects[index] = lastObject;
                    objects.pop();
                    for (var j = 0, m = nBindings; j !== m; ++j) {
                        var bindingsForPath = bindings[j];
                        bindingsForPath[index] = bindingsForPath[lastIndex];
                        bindingsForPath.pop();
                    }
                }
            }
        }
        this.nCachedObjects_ = nCachedObjects;
    },
    subscribe_: function (path, parsedPath) {
        var indicesByPath = this._bindingsIndicesByPath, index = indicesByPath[path], bindings = this._bindings;
        if (index !== undefined)
            return bindings[index];
        var paths = this._paths, parsedPaths = this._parsedPaths, objects = this._objects, nObjects = objects.length, nCachedObjects = this.nCachedObjects_, bindingsForPath = new Array(nObjects);
        index = bindings.length;
        indicesByPath[path] = index;
        paths.push(path);
        parsedPaths.push(parsedPath);
        bindings.push(bindingsForPath);
        for (var i = nCachedObjects, n = objects.length; i !== n; ++i) {
            var object = objects[i];
            bindingsForPath[i] = new PropertyBinding(object, path, parsedPath);
        }
        return bindingsForPath;
    },
    unsubscribe_: function (path) {
        var indicesByPath = this._bindingsIndicesByPath, index = indicesByPath[path];
        if (index !== undefined) {
            var paths = this._paths, parsedPaths = this._parsedPaths, bindings = this._bindings, lastBindingsIndex = bindings.length - 1, lastBindings = bindings[lastBindingsIndex], lastBindingsPath = path[lastBindingsIndex];
            indicesByPath[lastBindingsPath] = index;
            bindings[index] = lastBindings;
            bindings.pop();
            parsedPaths[index] = parsedPaths[lastBindingsIndex];
            parsedPaths.pop();
            paths[index] = paths[lastBindingsIndex];
            paths.pop();
        }
    }
};
;
AnimationAction.prototype = {
    constructor: AnimationAction,
    play: function () {
        this._mixer._activateAction(this);
        return this;
    },
    stop: function () {
        this._mixer._deactivateAction(this);
        return this.reset();
    },
    reset: function () {
        this.paused = false;
        this.enabled = true;
        this.time = 0;
        this._loopCount = -1;
        this._startTime = null;
        return this.stopFading().stopWarping();
    },
    isRunning: function () {
        return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);
    },
    isScheduled: function () {
        return this._mixer._isActiveAction(this);
    },
    startAt: function (time) {
        this._startTime = time;
        return this;
    },
    setLoop: function (mode, repetitions) {
        this.loop = mode;
        this.repetitions = repetitions;
        return this;
    },
    setEffectiveWeight: function (weight) {
        this.weight = weight;
        this._effectiveWeight = this.enabled ? weight : 0;
        return this.stopFading();
    },
    getEffectiveWeight: function () {
        return this._effectiveWeight;
    },
    fadeIn: function (duration) {
        return this._scheduleFading(duration, 0, 1);
    },
    fadeOut: function (duration) {
        return this._scheduleFading(duration, 1, 0);
    },
    crossFadeFrom: function (fadeOutAction, duration, warp) {
        fadeOutAction.fadeOut(duration);
        this.fadeIn(duration);
        if (warp) {
            var fadeInDuration = this._clip.duration, fadeOutDuration = fadeOutAction._clip.duration, startEndRatio = fadeOutDuration / fadeInDuration, endStartRatio = fadeInDuration / fadeOutDuration;
            fadeOutAction.warp(1, startEndRatio, duration);
            this.warp(endStartRatio, 1, duration);
        }
        return this;
    },
    crossFadeTo: function (fadeInAction, duration, warp) {
        return fadeInAction.crossFadeFrom(this, duration, warp);
    },
    stopFading: function () {
        var weightInterpolant = this._weightInterpolant;
        if (weightInterpolant !== null) {
            this._weightInterpolant = null;
            this._mixer._takeBackControlInterpolant(weightInterpolant);
        }
        return this;
    },
    setEffectiveTimeScale: function (timeScale) {
        this.timeScale = timeScale;
        this._effectiveTimeScale = this.paused ? 0 : timeScale;
        return this.stopWarping();
    },
    getEffectiveTimeScale: function () {
        return this._effectiveTimeScale;
    },
    setDuration: function (duration) {
        this.timeScale = this._clip.duration / duration;
        return this.stopWarping();
    },
    syncWith: function (action) {
        this.time = action.time;
        this.timeScale = action.timeScale;
        return this.stopWarping();
    },
    halt: function (duration) {
        return this.warp(this._effectiveTimeScale, 0, duration);
    },
    warp: function (startTimeScale, endTimeScale, duration) {
        var mixer = this._mixer, now = mixer.time, interpolant = this._timeScaleInterpolant, timeScale = this.timeScale;
        if (interpolant === null) {
            interpolant = mixer._lendControlInterpolant(), this._timeScaleInterpolant = interpolant;
        }
        var times = interpolant.parameterPositions, values = interpolant.sampleValues;
        times[0] = now;
        times[1] = now + duration;
        values[0] = startTimeScale / timeScale;
        values[1] = endTimeScale / timeScale;
        return this;
    },
    stopWarping: function () {
        var timeScaleInterpolant = this._timeScaleInterpolant;
        if (timeScaleInterpolant !== null) {
            this._timeScaleInterpolant = null;
            this._mixer._takeBackControlInterpolant(timeScaleInterpolant);
        }
        return this;
    },
    getMixer: function () {
        return this._mixer;
    },
    getClip: function () {
        return this._clip;
    },
    getRoot: function () {
        return this._localRoot || this._mixer._root;
    },
    _update: function (time, deltaTime, timeDirection, accuIndex) {
        var startTime = this._startTime;
        if (startTime !== null) {
            var timeRunning = (time - startTime) * timeDirection;
            if (timeRunning < 0 || timeDirection === 0) {
                return;
            }
            this._startTime = null;
            deltaTime = timeDirection * timeRunning;
        }
        deltaTime *= this._updateTimeScale(time);
        var clipTime = this._updateTime(deltaTime);
        var weight = this._updateWeight(time);
        if (weight > 0) {
            var interpolants = this._interpolants;
            var propertyMixers = this._propertyBindings;
            for (var j = 0, m = interpolants.length; j !== m; ++j) {
                interpolants[j].evaluate(clipTime);
                propertyMixers[j].accumulate(accuIndex, weight);
            }
        }
    },
    _updateWeight: function (time) {
        var weight = 0;
        if (this.enabled) {
            weight = this.weight;
            var interpolant = this._weightInterpolant;
            if (interpolant !== null) {
                var interpolantValue = interpolant.evaluate(time)[0];
                weight *= interpolantValue;
                if (time > interpolant.parameterPositions[1]) {
                    this.stopFading();
                    if (interpolantValue === 0) {
                        this.enabled = false;
                    }
                }
            }
        }
        this._effectiveWeight = weight;
        return weight;
    },
    _updateTimeScale: function (time) {
        var timeScale = 0;
        if (!this.paused) {
            timeScale = this.timeScale;
            var interpolant = this._timeScaleInterpolant;
            if (interpolant !== null) {
                var interpolantValue = interpolant.evaluate(time)[0];
                timeScale *= interpolantValue;
                if (time > interpolant.parameterPositions[1]) {
                    this.stopWarping();
                    if (timeScale === 0) {
                        this.paused = true;
                    } else {
                        this.timeScale = timeScale;
                    }
                }
            }
        }
        this._effectiveTimeScale = timeScale;
        return timeScale;
    },
    _updateTime: function (deltaTime) {
        var time = this.time + deltaTime;
        if (deltaTime === 0)
            return time;
        var duration = this._clip.duration, loop = this.loop, loopCount = this._loopCount;
        if (loop === LoopOnce) {
            if (loopCount === -1) {
                this.loopCount = 0;
                this._setEndings(true, true, false);
            }
            handle_stop: {
                if (time >= duration) {
                    time = duration;
                } else if (time < 0) {
                    time = 0;
                } else
                    break handle_stop;
                if (this.clampWhenFinished)
                    this.paused = true;
                else
                    this.enabled = false;
                this._mixer.dispatchEvent({
                    type: 'finished',
                    action: this,
                    direction: deltaTime < 0 ? -1 : 1
                });
            }
        } else {
            var pingPong = loop === LoopPingPong;
            if (loopCount === -1) {
                if (deltaTime >= 0) {
                    loopCount = 0;
                    this._setEndings(true, this.repetitions === 0, pingPong);
                } else {
                    this._setEndings(this.repetitions === 0, true, pingPong);
                }
            }
            if (time >= duration || time < 0) {
                var loopDelta = Math.floor(time / duration);
                time -= duration * loopDelta;
                loopCount += Math.abs(loopDelta);
                var pending = this.repetitions - loopCount;
                if (pending < 0) {
                    if (this.clampWhenFinished)
                        this.paused = true;
                    else
                        this.enabled = false;
                    time = deltaTime > 0 ? duration : 0;
                    this._mixer.dispatchEvent({
                        type: 'finished',
                        action: this,
                        direction: deltaTime > 0 ? 1 : -1
                    });
                } else {
                    if (pending === 0) {
                        var atStart = deltaTime < 0;
                        this._setEndings(atStart, !atStart, pingPong);
                    } else {
                        this._setEndings(false, false, pingPong);
                    }
                    this._loopCount = loopCount;
                    this._mixer.dispatchEvent({
                        type: 'loop',
                        action: this,
                        loopDelta: loopDelta
                    });
                }
            }
            if (pingPong && (loopCount & 1) === 1) {
                this.time = time;
                return duration - time;
            }
        }
        this.time = time;
        return time;
    },
    _setEndings: function (atStart, atEnd, pingPong) {
        var settings = this._interpolantSettings;
        if (pingPong) {
            settings.endingStart = ZeroSlopeEnding;
            settings.endingEnd = ZeroSlopeEnding;
        } else {
            if (atStart) {
                settings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;
            } else {
                settings.endingStart = WrapAroundEnding;
            }
            if (atEnd) {
                settings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;
            } else {
                settings.endingEnd = WrapAroundEnding;
            }
        }
    },
    _scheduleFading: function (duration, weightNow, weightThen) {
        var mixer = this._mixer, now = mixer.time, interpolant = this._weightInterpolant;
        if (interpolant === null) {
            interpolant = mixer._lendControlInterpolant(), this._weightInterpolant = interpolant;
        }
        var times = interpolant.parameterPositions, values = interpolant.sampleValues;
        times[0] = now;
        values[0] = weightNow;
        times[1] = now + duration;
        values[1] = weightThen;
        return this;
    }
};
Object.assign(AnimationMixer.prototype, EventDispatcher.prototype, {
    clipAction: function (clip, optionalRoot) {
        var root = optionalRoot || this._root, rootUuid = root.uuid, clipObject = typeof clip === 'string' ? AnimationClip.findByName(root, clip) : clip, clipUuid = clipObject !== null ? clipObject.uuid : clip, actionsForClip = this._actionsByClip[clipUuid], prototypeAction = null;
        if (actionsForClip !== undefined) {
            var existingAction = actionsForClip.actionByRoot[rootUuid];
            if (existingAction !== undefined) {
                return existingAction;
            }
            prototypeAction = actionsForClip.knownActions[0];
            if (clipObject === null)
                clipObject = prototypeAction._clip;
        }
        if (clipObject === null)
            return null;
        var newAction = new AnimationAction(this, clipObject, optionalRoot);
        this._bindAction(newAction, prototypeAction);
        this._addInactiveAction(newAction, clipUuid, rootUuid);
        return newAction;
    },
    existingAction: function (clip, optionalRoot) {
        var root = optionalRoot || this._root, rootUuid = root.uuid, clipObject = typeof clip === 'string' ? AnimationClip.findByName(root, clip) : clip, clipUuid = clipObject ? clipObject.uuid : clip, actionsForClip = this._actionsByClip[clipUuid];
        if (actionsForClip !== undefined) {
            return actionsForClip.actionByRoot[rootUuid] || null;
        }
        return null;
    },
    stopAllAction: function () {
        var actions = this._actions, nActions = this._nActiveActions, bindings = this._bindings, nBindings = this._nActiveBindings;
        this._nActiveActions = 0;
        this._nActiveBindings = 0;
        for (var i = 0; i !== nActions; ++i) {
            actions[i].reset();
        }
        for (var i = 0; i !== nBindings; ++i) {
            bindings[i].useCount = 0;
        }
        return this;
    },
    update: function (deltaTime) {
        deltaTime *= this.timeScale;
        var actions = this._actions, nActions = this._nActiveActions, time = this.time += deltaTime, timeDirection = Math.sign(deltaTime), accuIndex = this._accuIndex ^= 1;
        for (var i = 0; i !== nActions; ++i) {
            var action = actions[i];
            if (action.enabled) {
                action._update(time, deltaTime, timeDirection, accuIndex);
            }
        }
        var bindings = this._bindings, nBindings = this._nActiveBindings;
        for (var i = 0; i !== nBindings; ++i) {
            bindings[i].apply(accuIndex);
        }
        return this;
    },
    getRoot: function () {
        return this._root;
    },
    uncacheClip: function (clip) {
        var actions = this._actions, clipUuid = clip.uuid, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid];
        if (actionsForClip !== undefined) {
            var actionsToRemove = actionsForClip.knownActions;
            for (var i = 0, n = actionsToRemove.length; i !== n; ++i) {
                var action = actionsToRemove[i];
                this._deactivateAction(action);
                var cacheIndex = action._cacheIndex, lastInactiveAction = actions[actions.length - 1];
                action._cacheIndex = null;
                action._byClipCacheIndex = null;
                lastInactiveAction._cacheIndex = cacheIndex;
                actions[cacheIndex] = lastInactiveAction;
                actions.pop();
                this._removeInactiveBindingsForAction(action);
            }
            delete actionsByClip[clipUuid];
        }
    },
    uncacheRoot: function (root) {
        var rootUuid = root.uuid, actionsByClip = this._actionsByClip;
        for (var clipUuid in actionsByClip) {
            var actionByRoot = actionsByClip[clipUuid].actionByRoot, action = actionByRoot[rootUuid];
            if (action !== undefined) {
                this._deactivateAction(action);
                this._removeInactiveAction(action);
            }
        }
        var bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid];
        if (bindingByName !== undefined) {
            for (var trackName in bindingByName) {
                var binding = bindingByName[trackName];
                binding.restoreOriginalState();
                this._removeInactiveBinding(binding);
            }
        }
    },
    uncacheAction: function (clip, optionalRoot) {
        var action = this.existingAction(clip, optionalRoot);
        if (action !== null) {
            this._deactivateAction(action);
            this._removeInactiveAction(action);
        }
    }
});
Object.assign(AnimationMixer.prototype, {
    _bindAction: function (action, prototypeAction) {
        var root = action._localRoot || this._root, tracks = action._clip.tracks, nTracks = tracks.length, bindings = action._propertyBindings, interpolants = action._interpolants, rootUuid = root.uuid, bindingsByRoot = this._bindingsByRootAndName, bindingsByName = bindingsByRoot[rootUuid];
        if (bindingsByName === undefined) {
            bindingsByName = {};
            bindingsByRoot[rootUuid] = bindingsByName;
        }
        for (var i = 0; i !== nTracks; ++i) {
            var track = tracks[i], trackName = track.name, binding = bindingsByName[trackName];
            if (binding !== undefined) {
                bindings[i] = binding;
            } else {
                binding = bindings[i];
                if (binding !== undefined) {
                    if (binding._cacheIndex === null) {
                        ++binding.referenceCount;
                        this._addInactiveBinding(binding, rootUuid, trackName);
                    }
                    continue;
                }
                var path = prototypeAction && prototypeAction._propertyBindings[i].binding.parsedPath;
                binding = new PropertyMixer(PropertyBinding.create(root, trackName, path), track.ValueTypeName, track.getValueSize());
                ++binding.referenceCount;
                this._addInactiveBinding(binding, rootUuid, trackName);
                bindings[i] = binding;
            }
            interpolants[i].resultBuffer = binding.buffer;
        }
    },
    _activateAction: function (action) {
        if (!this._isActiveAction(action)) {
            if (action._cacheIndex === null) {
                var rootUuid = (action._localRoot || this._root).uuid, clipUuid = action._clip.uuid, actionsForClip = this._actionsByClip[clipUuid];
                this._bindAction(action, actionsForClip && actionsForClip.knownActions[0]);
                this._addInactiveAction(action, clipUuid, rootUuid);
            }
            var bindings = action._propertyBindings;
            for (var i = 0, n = bindings.length; i !== n; ++i) {
                var binding = bindings[i];
                if (binding.useCount++ === 0) {
                    this._lendBinding(binding);
                    binding.saveOriginalState();
                }
            }
            this._lendAction(action);
        }
    },
    _deactivateAction: function (action) {
        if (this._isActiveAction(action)) {
            var bindings = action._propertyBindings;
            for (var i = 0, n = bindings.length; i !== n; ++i) {
                var binding = bindings[i];
                if (--binding.useCount === 0) {
                    binding.restoreOriginalState();
                    this._takeBackBinding(binding);
                }
            }
            this._takeBackAction(action);
        }
    },
    _initMemoryManager: function () {
        this._actions = [];
        this._nActiveActions = 0;
        this._actionsByClip = {};
        this._bindings = [];
        this._nActiveBindings = 0;
        this._bindingsByRootAndName = {};
        this._controlInterpolants = [];
        this._nActiveControlInterpolants = 0;
        var scope = this;
        this.stats = {
            actions: {
                get total() {
                    return scope._actions.length;
                },
                get inUse() {
                    return scope._nActiveActions;
                }
            },
            bindings: {
                get total() {
                    return scope._bindings.length;
                },
                get inUse() {
                    return scope._nActiveBindings;
                }
            },
            controlInterpolants: {
                get total() {
                    return scope._controlInterpolants.length;
                },
                get inUse() {
                    return scope._nActiveControlInterpolants;
                }
            }
        };
    },
    _isActiveAction: function (action) {
        var index = action._cacheIndex;
        return index !== null && index < this._nActiveActions;
    },
    _addInactiveAction: function (action, clipUuid, rootUuid) {
        var actions = this._actions, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid];
        if (actionsForClip === undefined) {
            actionsForClip = {
                knownActions: [action],
                actionByRoot: {}
            };
            action._byClipCacheIndex = 0;
            actionsByClip[clipUuid] = actionsForClip;
        } else {
            var knownActions = actionsForClip.knownActions;
            action._byClipCacheIndex = knownActions.length;
            knownActions.push(action);
        }
        action._cacheIndex = actions.length;
        actions.push(action);
        actionsForClip.actionByRoot[rootUuid] = action;
    },
    _removeInactiveAction: function (action) {
        var actions = this._actions, lastInactiveAction = actions[actions.length - 1], cacheIndex = action._cacheIndex;
        lastInactiveAction._cacheIndex = cacheIndex;
        actions[cacheIndex] = lastInactiveAction;
        actions.pop();
        action._cacheIndex = null;
        var clipUuid = action._clip.uuid, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid], knownActionsForClip = actionsForClip.knownActions, lastKnownAction = knownActionsForClip[knownActionsForClip.length - 1], byClipCacheIndex = action._byClipCacheIndex;
        lastKnownAction._byClipCacheIndex = byClipCacheIndex;
        knownActionsForClip[byClipCacheIndex] = lastKnownAction;
        knownActionsForClip.pop();
        action._byClipCacheIndex = null;
        var actionByRoot = actionsForClip.actionByRoot, rootUuid = (actions._localRoot || this._root).uuid;
        delete actionByRoot[rootUuid];
        if (knownActionsForClip.length === 0) {
            delete actionsByClip[clipUuid];
        }
        this._removeInactiveBindingsForAction(action);
    },
    _removeInactiveBindingsForAction: function (action) {
        var bindings = action._propertyBindings;
        for (var i = 0, n = bindings.length; i !== n; ++i) {
            var binding = bindings[i];
            if (--binding.referenceCount === 0) {
                this._removeInactiveBinding(binding);
            }
        }
    },
    _lendAction: function (action) {
        var actions = this._actions, prevIndex = action._cacheIndex, lastActiveIndex = this._nActiveActions++, firstInactiveAction = actions[lastActiveIndex];
        action._cacheIndex = lastActiveIndex;
        actions[lastActiveIndex] = action;
        firstInactiveAction._cacheIndex = prevIndex;
        actions[prevIndex] = firstInactiveAction;
    },
    _takeBackAction: function (action) {
        var actions = this._actions, prevIndex = action._cacheIndex, firstInactiveIndex = --this._nActiveActions, lastActiveAction = actions[firstInactiveIndex];
        action._cacheIndex = firstInactiveIndex;
        actions[firstInactiveIndex] = action;
        lastActiveAction._cacheIndex = prevIndex;
        actions[prevIndex] = lastActiveAction;
    },
    _addInactiveBinding: function (binding, rootUuid, trackName) {
        var bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid], bindings = this._bindings;
        if (bindingByName === undefined) {
            bindingByName = {};
            bindingsByRoot[rootUuid] = bindingByName;
        }
        bindingByName[trackName] = binding;
        binding._cacheIndex = bindings.length;
        bindings.push(binding);
    },
    _removeInactiveBinding: function (binding) {
        var bindings = this._bindings, propBinding = binding.binding, rootUuid = propBinding.rootNode.uuid, trackName = propBinding.path, bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid], lastInactiveBinding = bindings[bindings.length - 1], cacheIndex = binding._cacheIndex;
        lastInactiveBinding._cacheIndex = cacheIndex;
        bindings[cacheIndex] = lastInactiveBinding;
        bindings.pop();
        delete bindingByName[trackName];
        remove_empty_map: {
            for (var _ in bindingByName)
                break remove_empty_map;
            delete bindingsByRoot[rootUuid];
        }
    },
    _lendBinding: function (binding) {
        var bindings = this._bindings, prevIndex = binding._cacheIndex, lastActiveIndex = this._nActiveBindings++, firstInactiveBinding = bindings[lastActiveIndex];
        binding._cacheIndex = lastActiveIndex;
        bindings[lastActiveIndex] = binding;
        firstInactiveBinding._cacheIndex = prevIndex;
        bindings[prevIndex] = firstInactiveBinding;
    },
    _takeBackBinding: function (binding) {
        var bindings = this._bindings, prevIndex = binding._cacheIndex, firstInactiveIndex = --this._nActiveBindings, lastActiveBinding = bindings[firstInactiveIndex];
        binding._cacheIndex = firstInactiveIndex;
        bindings[firstInactiveIndex] = binding;
        lastActiveBinding._cacheIndex = prevIndex;
        bindings[prevIndex] = lastActiveBinding;
    },
    _lendControlInterpolant: function () {
        var interpolants = this._controlInterpolants, lastActiveIndex = this._nActiveControlInterpolants++, interpolant = interpolants[lastActiveIndex];
        if (interpolant === undefined) {
            interpolant = new LinearInterpolant(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer);
            interpolant.__cacheIndex = lastActiveIndex;
            interpolants[lastActiveIndex] = interpolant;
        }
        return interpolant;
    },
    _takeBackControlInterpolant: function (interpolant) {
        var interpolants = this._controlInterpolants, prevIndex = interpolant.__cacheIndex, firstInactiveIndex = --this._nActiveControlInterpolants, lastActiveInterpolant = interpolants[firstInactiveIndex];
        interpolant.__cacheIndex = firstInactiveIndex;
        interpolants[firstInactiveIndex] = interpolant;
        lastActiveInterpolant.__cacheIndex = prevIndex;
        interpolants[prevIndex] = lastActiveInterpolant;
    },
    _controlInterpolantsResultBuffer: new Float32Array(1)
});
Uniform.prototype = {
    constructor: Uniform,
    onUpdate: function (callback) {
        this.dynamic = true;
        this.onUpdateCallback = callback;
        return this;
    }
};
InstancedBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
InstancedBufferGeometry.prototype.constructor = InstancedBufferGeometry;
InstancedBufferGeometry.prototype.isInstancedBufferGeometry = true;
InstancedBufferGeometry.prototype.addGroup = function (start, count, instances) {
    this.groups.push({
        start: start,
        count: count,
        instances: instances
    });
};
InstancedBufferGeometry.prototype.copy = function (source) {
    var index = source.index;
    if (index !== null) {
        this.setIndex(index.clone());
    }
    var attributes = source.attributes;
    for (var name in attributes) {
        var attribute = attributes[name];
        this.addAttribute(name, attribute.clone());
    }
    var groups = source.groups;
    for (var i = 0, l = groups.length; i < l; i++) {
        var group = groups[i];
        this.addGroup(group.start, group.count, group.instances);
    }
    return this;
};
InterleavedBufferAttribute.prototype = {
    constructor: InterleavedBufferAttribute,
    isInterleavedBufferAttribute: true,
    get length() {
        console.warn('THREE.BufferAttribute: .length has been deprecated. Please use .count.');
        return this.array.length;
    },
    get count() {
        return this.data.count;
    },
    get array() {
        return this.data.array;
    },
    setX: function (index, x) {
        this.data.array[index * this.data.stride + this.offset] = x;
        return this;
    },
    setY: function (index, y) {
        this.data.array[index * this.data.stride + this.offset + 1] = y;
        return this;
    },
    setZ: function (index, z) {
        this.data.array[index * this.data.stride + this.offset + 2] = z;
        return this;
    },
    setW: function (index, w) {
        this.data.array[index * this.data.stride + this.offset + 3] = w;
        return this;
    },
    getX: function (index) {
        return this.data.array[index * this.data.stride + this.offset];
    },
    getY: function (index) {
        return this.data.array[index * this.data.stride + this.offset + 1];
    },
    getZ: function (index) {
        return this.data.array[index * this.data.stride + this.offset + 2];
    },
    getW: function (index) {
        return this.data.array[index * this.data.stride + this.offset + 3];
    },
    setXY: function (index, x, y) {
        index = index * this.data.stride + this.offset;
        this.data.array[index + 0] = x;
        this.data.array[index + 1] = y;
        return this;
    },
    setXYZ: function (index, x, y, z) {
        index = index * this.data.stride + this.offset;
        this.data.array[index + 0] = x;
        this.data.array[index + 1] = y;
        this.data.array[index + 2] = z;
        return this;
    },
    setXYZW: function (index, x, y, z, w) {
        index = index * this.data.stride + this.offset;
        this.data.array[index + 0] = x;
        this.data.array[index + 1] = y;
        this.data.array[index + 2] = z;
        this.data.array[index + 3] = w;
        return this;
    }
};
InterleavedBuffer.prototype = {
    constructor: InterleavedBuffer,
    isInterleavedBuffer: true,
    get length() {
        return this.array.length;
    },
    get count() {
        return this.array.length / this.stride;
    },
    set needsUpdate(value) {
        if (value === true)
            this.version++;
    },
    setDynamic: function (value) {
        this.dynamic = value;
        return this;
    },
    copy: function (source) {
        this.array = new source.array.constructor(source.array);
        this.stride = source.stride;
        this.dynamic = source.dynamic;
        return this;
    },
    copyAt: function (index1, attribute, index2) {
        index1 *= this.stride;
        index2 *= attribute.stride;
        for (var i = 0, l = this.stride; i < l; i++) {
            this.array[index1 + i] = attribute.array[index2 + i];
        }
        return this;
    },
    set: function (value, offset) {
        if (offset === undefined)
            offset = 0;
        this.array.set(value, offset);
        return this;
    },
    clone: function () {
        return new this.constructor().copy(this);
    }
};
InstancedInterleavedBuffer.prototype = Object.create(InterleavedBuffer.prototype);
InstancedInterleavedBuffer.prototype.constructor = InstancedInterleavedBuffer;
InstancedInterleavedBuffer.prototype.isInstancedInterleavedBuffer = true;
InstancedInterleavedBuffer.prototype.copy = function (source) {
    InterleavedBuffer.prototype.copy.call(this, source);
    this.meshPerAttribute = source.meshPerAttribute;
    return this;
};
InstancedBufferAttribute.prototype = Object.create(BufferAttribute.prototype);
InstancedBufferAttribute.prototype.constructor = InstancedBufferAttribute;
InstancedBufferAttribute.prototype.isInstancedBufferAttribute = true;
InstancedBufferAttribute.prototype.copy = function (source) {
    BufferAttribute.prototype.copy.call(this, source);
    this.meshPerAttribute = source.meshPerAttribute;
    return this;
};
Raycaster.prototype = {
    constructor: Raycaster,
    linePrecision: 1,
    set: function (origin, direction) {
        this.ray.set(origin, direction);
    },
    setFromCamera: function (coords, camera) {
        if (camera && camera.isPerspectiveCamera) {
            this.ray.origin.setFromMatrixPosition(camera.matrixWorld);
            this.ray.direction.set(coords.x, coords.y, 0.5).unproject(camera).sub(this.ray.origin).normalize();
        } else if (camera && camera.isOrthographicCamera) {
            this.ray.origin.set(coords.x, coords.y, (camera.near + camera.far) / (camera.near - camera.far)).unproject(camera);
            this.ray.direction.set(0, 0, -1).transformDirection(camera.matrixWorld);
        } else {
            console.error('THREE.Raycaster: Unsupported camera type.');
        }
    },
    intersectObject: function (object, recursive) {
        var intersects = [];
        intersectObject(object, this, intersects, recursive);
        intersects.sort(ascSort);
        return intersects;
    },
    intersectObjects: function (objects, recursive) {
        var intersects = [];
        if (Array.isArray(objects) === false) {
            console.warn('THREE.Raycaster.intersectObjects: objects is not an Array.');
            return intersects;
        }
        for (var i = 0, l = objects.length; i < l; i++) {
            intersectObject(objects[i], this, intersects, recursive);
        }
        intersects.sort(ascSort);
        return intersects;
    }
};
Clock.prototype = {
    constructor: Clock,
    start: function () {
        this.startTime = (performance || Date).now();
        this.oldTime = this.startTime;
        this.running = true;
    },
    stop: function () {
        this.getElapsedTime();
        this.running = false;
    },
    getElapsedTime: function () {
        this.getDelta();
        return this.elapsedTime;
    },
    getDelta: function () {
        var diff = 0;
        if (this.autoStart && !this.running) {
            this.start();
        }
        if (this.running) {
            var newTime = (performance || Date).now();
            diff = (newTime - this.oldTime) / 1000;
            this.oldTime = newTime;
            this.elapsedTime += diff;
        }
        return diff;
    }
};
Spherical.prototype = {
    constructor: Spherical,
    set: function (radius, phi, theta) {
        this.radius = radius;
        this.phi = phi;
        this.theta = theta;
        return this;
    },
    clone: function () {
        return new this.constructor().copy(this);
    },
    copy: function (other) {
        this.radius.copy(other.radius);
        this.phi.copy(other.phi);
        this.theta.copy(other.theta);
        return this;
    },
    makeSafe: function () {
        var EPS = 0.000001;
        this.phi = Math.max(EPS, Math.min(Math.PI - EPS, this.phi));
        return this;
    },
    setFromVector3: function (vec3) {
        this.radius = vec3.length();
        if (this.radius === 0) {
            this.theta = 0;
            this.phi = 0;
        } else {
            this.theta = Math.atan2(vec3.x, vec3.z);
            this.phi = Math.acos(exports.Math.clamp(vec3.y / this.radius, -1, 1));
        }
        return this;
    }
};
MorphBlendMesh.prototype = Object.create(Mesh.prototype);
MorphBlendMesh.prototype.constructor = MorphBlendMesh;
MorphBlendMesh.prototype.createAnimation = function (name, start, end, fps) {
    var animation = {
        start: start,
        end: end,
        length: end - start + 1,
        fps: fps,
        duration: (end - start) / fps,
        lastFrame: 0,
        currentFrame: 0,
        active: false,
        time: 0,
        direction: 1,
        weight: 1,
        directionBackwards: false,
        mirroredLoop: false
    };
    this.animationsMap[name] = animation;
    this.animationsList.push(animation);
};
MorphBlendMesh.prototype.autoCreateAnimations = function (fps) {
    var pattern = /([a-z]+)_?(\d+)/i;
    var firstAnimation, frameRanges = {};
    var geometry = this.geometry;
    for (var i = 0, il = geometry.morphTargets.length; i < il; i++) {
        var morph = geometry.morphTargets[i];
        var chunks = morph.name.match(pattern);
        if (chunks && chunks.length > 1) {
            var name = chunks[1];
            if (!frameRanges[name])
                frameRanges[name] = {
                start: Infinity,
                end: -Infinity
            };
            var range = frameRanges[name];
            if (i < range.start)
                range.start = i;
            if (i > range.end)
                range.end = i;
            if (!firstAnimation)
                firstAnimation = name;
        }
    }
    for (var name in frameRanges) {
        var range = frameRanges[name];
        this.createAnimation(name, range.start, range.end, fps);
    }
    this.firstAnimation = firstAnimation;
};
MorphBlendMesh.prototype.setAnimationDirectionForward = function (name) {
    var animation = this.animationsMap[name];
    if (animation) {
        animation.direction = 1;
        animation.directionBackwards = false;
    }
};
MorphBlendMesh.prototype.setAnimationDirectionBackward = function (name) {
    var animation = this.animationsMap[name];
    if (animation) {
        animation.direction = -1;
        animation.directionBackwards = true;
    }
};
MorphBlendMesh.prototype.setAnimationFPS = function (name, fps) {
    var animation = this.animationsMap[name];
    if (animation) {
        animation.fps = fps;
        animation.duration = (animation.end - animation.start) / animation.fps;
    }
};
MorphBlendMesh.prototype.setAnimationDuration = function (name, duration) {
    var animation = this.animationsMap[name];
    if (animation) {
        animation.duration = duration;
        animation.fps = (animation.end - animation.start) / animation.duration;
    }
};
MorphBlendMesh.prototype.setAnimationWeight = function (name, weight) {
    var animation = this.animationsMap[name];
    if (animation) {
        animation.weight = weight;
    }
};
MorphBlendMesh.prototype.setAnimationTime = function (name, time) {
    var animation = this.animationsMap[name];
    if (animation) {
        animation.time = time;
    }
};
MorphBlendMesh.prototype.getAnimationTime = function (name) {
    var time = 0;
    var animation = this.animationsMap[name];
    if (animation) {
        time = animation.time;
    }
    return time;
};
MorphBlendMesh.prototype.getAnimationDuration = function (name) {
    var duration = -1;
    var animation = this.animationsMap[name];
    if (animation) {
        duration = animation.duration;
    }
    return duration;
};
MorphBlendMesh.prototype.playAnimation = function (name) {
    var animation = this.animationsMap[name];
    if (animation) {
        animation.time = 0;
        animation.active = true;
    } else {
        console.warn('THREE.MorphBlendMesh: animation[' + name + '] undefined in .playAnimation()');
    }
};
MorphBlendMesh.prototype.stopAnimation = function (name) {
    var animation = this.animationsMap[name];
    if (animation) {
        animation.active = false;
    }
};
MorphBlendMesh.prototype.update = function (delta) {
    for (var i = 0, il = this.animationsList.length; i < il; i++) {
        var animation = this.animationsList[i];
        if (!animation.active)
            continue;
        var frameTime = animation.duration / animation.length;
        animation.time += animation.direction * delta;
        if (animation.mirroredLoop) {
            if (animation.time > animation.duration || animation.time < 0) {
                animation.direction *= -1;
                if (animation.time > animation.duration) {
                    animation.time = animation.duration;
                    animation.directionBackwards = true;
                }
                if (animation.time < 0) {
                    animation.time = 0;
                    animation.directionBackwards = false;
                }
            }
        } else {
            animation.time = animation.time % animation.duration;
            if (animation.time < 0)
                animation.time += animation.duration;
        }
        var keyframe = animation.start + exports.Math.clamp(Math.floor(animation.time / frameTime), 0, animation.length - 1);
        var weight = animation.weight;
        if (keyframe !== animation.currentFrame) {
            this.morphTargetInfluences[animation.lastFrame] = 0;
            this.morphTargetInfluences[animation.currentFrame] = 1 * weight;
            this.morphTargetInfluences[keyframe] = 0;
            animation.lastFrame = animation.currentFrame;
            animation.currentFrame = keyframe;
        }
        var mix = animation.time % frameTime / frameTime;
        if (animation.directionBackwards)
            mix = 1 - mix;
        if (animation.currentFrame !== animation.lastFrame) {
            this.morphTargetInfluences[animation.currentFrame] = mix * weight;
            this.morphTargetInfluences[animation.lastFrame] = (1 - mix) * weight;
        } else {
            this.morphTargetInfluences[animation.currentFrame] = weight;
        }
    }
};
ImmediateRenderObject.prototype = Object.create(Object3D.prototype);
ImmediateRenderObject.prototype.constructor = ImmediateRenderObject;
ImmediateRenderObject.prototype.isImmediateRenderObject = true;
WireframeGeometry.prototype = Object.create(BufferGeometry.prototype);
WireframeGeometry.prototype.constructor = WireframeGeometry;
WireframeHelper.prototype = Object.create(LineSegments.prototype);
WireframeHelper.prototype.constructor = WireframeHelper;
VertexNormalsHelper.prototype = Object.create(LineSegments.prototype);
VertexNormalsHelper.prototype.constructor = VertexNormalsHelper;
VertexNormalsHelper.prototype.update = function () {
    var v1 = new Vector3();
    var v2 = new Vector3();
    var normalMatrix = new Matrix3();
    return function update() {
        var keys = [
            'a',
            'b',
            'c'
        ];
        this.object.updateMatrixWorld(true);
        normalMatrix.getNormalMatrix(this.object.matrixWorld);
        var matrixWorld = this.object.matrixWorld;
        var position = this.geometry.attributes.position;
        var objGeometry = this.object.geometry;
        if (objGeometry && objGeometry.isGeometry) {
            var vertices = objGeometry.vertices;
            var faces = objGeometry.faces;
            var idx = 0;
            for (var i = 0, l = faces.length; i < l; i++) {
                var face = faces[i];
                for (var j = 0, jl = face.vertexNormals.length; j < jl; j++) {
                    var vertex = vertices[face[keys[j]]];
                    var normal = face.vertexNormals[j];
                    v1.copy(vertex).applyMatrix4(matrixWorld);
                    v2.copy(normal).applyMatrix3(normalMatrix).normalize().multiplyScalar(this.size).add(v1);
                    position.setXYZ(idx, v1.x, v1.y, v1.z);
                    idx = idx + 1;
                    position.setXYZ(idx, v2.x, v2.y, v2.z);
                    idx = idx + 1;
                }
            }
        } else if (objGeometry && objGeometry.isBufferGeometry) {
            var objPos = objGeometry.attributes.position;
            var objNorm = objGeometry.attributes.normal;
            var idx = 0;
            for (var j = 0, jl = objPos.count; j < jl; j++) {
                v1.set(objPos.getX(j), objPos.getY(j), objPos.getZ(j)).applyMatrix4(matrixWorld);
                v2.set(objNorm.getX(j), objNorm.getY(j), objNorm.getZ(j));
                v2.applyMatrix3(normalMatrix).normalize().multiplyScalar(this.size).add(v1);
                position.setXYZ(idx, v1.x, v1.y, v1.z);
                idx = idx + 1;
                position.setXYZ(idx, v2.x, v2.y, v2.z);
                idx = idx + 1;
            }
        }
        position.needsUpdate = true;
        return this;
    };
}();
SpotLightHelper.prototype = Object.create(Object3D.prototype);
SpotLightHelper.prototype.constructor = SpotLightHelper;
SpotLightHelper.prototype.dispose = function () {
    this.cone.geometry.dispose();
    this.cone.material.dispose();
};
SpotLightHelper.prototype.update = function () {
    var vector = new Vector3();
    var vector2 = new Vector3();
    return function update() {
        var coneLength = this.light.distance ? this.light.distance : 1000;
        var coneWidth = coneLength * Math.tan(this.light.angle);
        this.cone.scale.set(coneWidth, coneWidth, coneLength);
        vector.setFromMatrixPosition(this.light.matrixWorld);
        vector2.setFromMatrixPosition(this.light.target.matrixWorld);
        this.cone.lookAt(vector2.sub(vector));
        this.cone.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
    };
}();
SkeletonHelper.prototype = Object.create(LineSegments.prototype);
SkeletonHelper.prototype.constructor = SkeletonHelper;
SkeletonHelper.prototype.getBoneList = function (object) {
    var boneList = [];
    if (object && object.isBone) {
        boneList.push(object);
    }
    for (var i = 0; i < object.children.length; i++) {
        boneList.push.apply(boneList, this.getBoneList(object.children[i]));
    }
    return boneList;
};
SkeletonHelper.prototype.update = function () {
    var geometry = this.geometry;
    var matrixWorldInv = new Matrix4().getInverse(this.root.matrixWorld);
    var boneMatrix = new Matrix4();
    var j = 0;
    for (var i = 0; i < this.bones.length; i++) {
        var bone = this.bones[i];
        if (bone.parent && bone.parent.isBone) {
            boneMatrix.multiplyMatrices(matrixWorldInv, bone.matrixWorld);
            geometry.vertices[j].setFromMatrixPosition(boneMatrix);
            boneMatrix.multiplyMatrices(matrixWorldInv, bone.parent.matrixWorld);
            geometry.vertices[j + 1].setFromMatrixPosition(boneMatrix);
            j += 2;
        }
    }
    geometry.verticesNeedUpdate = true;
    geometry.computeBoundingSphere();
};
SphereBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
SphereBufferGeometry.prototype.constructor = SphereBufferGeometry;
PointLightHelper.prototype = Object.create(Mesh.prototype);
PointLightHelper.prototype.constructor = PointLightHelper;
PointLightHelper.prototype.dispose = function () {
    this.geometry.dispose();
    this.material.dispose();
};
PointLightHelper.prototype.update = function () {
    this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
};
SphereGeometry.prototype = Object.create(Geometry.prototype);
SphereGeometry.prototype.constructor = SphereGeometry;
HemisphereLightHelper.prototype = Object.create(Object3D.prototype);
HemisphereLightHelper.prototype.constructor = HemisphereLightHelper;
HemisphereLightHelper.prototype.dispose = function () {
    this.lightSphere.geometry.dispose();
    this.lightSphere.material.dispose();
};
HemisphereLightHelper.prototype.update = function () {
    var vector = new Vector3();
    return function update() {
        this.colors[0].copy(this.light.color).multiplyScalar(this.light.intensity);
        this.colors[1].copy(this.light.groundColor).multiplyScalar(this.light.intensity);
        this.lightSphere.lookAt(vector.setFromMatrixPosition(this.light.matrixWorld).negate());
        this.lightSphere.geometry.colorsNeedUpdate = true;
    };
}();
GridHelper.prototype = Object.create(LineSegments.prototype);
GridHelper.prototype.constructor = GridHelper;
GridHelper.prototype.setColors = function () {
    console.error('THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.');
};
FaceNormalsHelper.prototype = Object.create(LineSegments.prototype);
FaceNormalsHelper.prototype.constructor = FaceNormalsHelper;
FaceNormalsHelper.prototype.update = function () {
    var v1 = new Vector3();
    var v2 = new Vector3();
    var normalMatrix = new Matrix3();
    return function update() {
        this.object.updateMatrixWorld(true);
        normalMatrix.getNormalMatrix(this.object.matrixWorld);
        var matrixWorld = this.object.matrixWorld;
        var position = this.geometry.attributes.position;
        var objGeometry = this.object.geometry;
        var vertices = objGeometry.vertices;
        var faces = objGeometry.faces;
        var idx = 0;
        for (var i = 0, l = faces.length; i < l; i++) {
            var face = faces[i];
            var normal = face.normal;
            v1.copy(vertices[face.a]).add(vertices[face.b]).add(vertices[face.c]).divideScalar(3).applyMatrix4(matrixWorld);
            v2.copy(normal).applyMatrix3(normalMatrix).normalize().multiplyScalar(this.size).add(v1);
            position.setXYZ(idx, v1.x, v1.y, v1.z);
            idx = idx + 1;
            position.setXYZ(idx, v2.x, v2.y, v2.z);
            idx = idx + 1;
        }
        position.needsUpdate = true;
        return this;
    };
}();
EdgesGeometry.prototype = Object.create(BufferGeometry.prototype);
EdgesGeometry.prototype.constructor = EdgesGeometry;
EdgesHelper.prototype = Object.create(LineSegments.prototype);
EdgesHelper.prototype.constructor = EdgesHelper;
DirectionalLightHelper.prototype = Object.create(Object3D.prototype);
DirectionalLightHelper.prototype.constructor = DirectionalLightHelper;
DirectionalLightHelper.prototype.dispose = function () {
    var lightPlane = this.children[0];
    var targetLine = this.children[1];
    lightPlane.geometry.dispose();
    lightPlane.material.dispose();
    targetLine.geometry.dispose();
    targetLine.material.dispose();
};
DirectionalLightHelper.prototype.update = function () {
    var v1 = new Vector3();
    var v2 = new Vector3();
    var v3 = new Vector3();
    return function update() {
        v1.setFromMatrixPosition(this.light.matrixWorld);
        v2.setFromMatrixPosition(this.light.target.matrixWorld);
        v3.subVectors(v2, v1);
        var lightPlane = this.children[0];
        var targetLine = this.children[1];
        lightPlane.lookAt(v3);
        lightPlane.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
        targetLine.lookAt(v3);
        targetLine.scale.z = v3.length();
    };
}();
CameraHelper.prototype = Object.create(LineSegments.prototype);
CameraHelper.prototype.constructor = CameraHelper;
CameraHelper.prototype.update = function () {
    var geometry, pointMap;
    var vector = new Vector3();
    var camera = new Camera();
    function setPoint(point, x, y, z) {
        vector.set(x, y, z).unproject(camera);
        var points = pointMap[point];
        if (points !== undefined) {
            for (var i = 0, il = points.length; i < il; i++) {
                geometry.vertices[points[i]].copy(vector);
            }
        }
    }
    return function update() {
        geometry = this.geometry;
        pointMap = this.pointMap;
        var w = 1, h = 1;
        camera.projectionMatrix.copy(this.camera.projectionMatrix);
        setPoint('c', 0, 0, -1);
        setPoint('t', 0, 0, 1);
        setPoint('n1', -w, -h, -1);
        setPoint('n2', w, -h, -1);
        setPoint('n3', -w, h, -1);
        setPoint('n4', w, h, -1);
        setPoint('f1', -w, -h, 1);
        setPoint('f2', w, -h, 1);
        setPoint('f3', -w, h, 1);
        setPoint('f4', w, h, 1);
        setPoint('u1', w * 0.7, h * 1.1, -1);
        setPoint('u2', -w * 0.7, h * 1.1, -1);
        setPoint('u3', 0, h * 2, -1);
        setPoint('cf1', -w, 0, 1);
        setPoint('cf2', w, 0, 1);
        setPoint('cf3', 0, -h, 1);
        setPoint('cf4', 0, h, 1);
        setPoint('cn1', -w, 0, -1);
        setPoint('cn2', w, 0, -1);
        setPoint('cn3', 0, -h, -1);
        setPoint('cn4', 0, h, -1);
        geometry.verticesNeedUpdate = true;
    };
}();
BoxGeometry.prototype = Object.create(Geometry.prototype);
BoxGeometry.prototype.constructor = BoxGeometry;
BoundingBoxHelper.prototype = Object.create(Mesh.prototype);
BoundingBoxHelper.prototype.constructor = BoundingBoxHelper;
BoundingBoxHelper.prototype.update = function () {
    this.box.setFromObject(this.object);
    this.box.size(this.scale);
    this.box.center(this.position);
};
BoxHelper.prototype = Object.create(LineSegments.prototype);
BoxHelper.prototype.constructor = BoxHelper;
BoxHelper.prototype.update = function () {
    var box = new Box3();
    return function update(object) {
        if (object && object.isBox3) {
            box.copy(object);
        } else {
            box.setFromObject(object);
        }
        if (box.isEmpty())
            return;
        var min = box.min;
        var max = box.max;
        var position = this.geometry.attributes.position;
        var array = position.array;
        array[0] = max.x;
        array[1] = max.y;
        array[2] = max.z;
        array[3] = min.x;
        array[4] = max.y;
        array[5] = max.z;
        array[6] = min.x;
        array[7] = min.y;
        array[8] = max.z;
        array[9] = max.x;
        array[10] = min.y;
        array[11] = max.z;
        array[12] = max.x;
        array[13] = max.y;
        array[14] = min.z;
        array[15] = min.x;
        array[16] = max.y;
        array[17] = min.z;
        array[18] = min.x;
        array[19] = min.y;
        array[20] = min.z;
        array[21] = max.x;
        array[22] = min.y;
        array[23] = min.z;
        position.needsUpdate = true;
        this.geometry.computeBoundingSphere();
    };
}();
CylinderBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
CylinderBufferGeometry.prototype.constructor = CylinderBufferGeometry;
lineGeometry = new BufferGeometry();
lineGeometry.addAttribute('position', new Float32Attribute([
    0,
    0,
    0,
    0,
    1,
    0
], 3));
coneGeometry = new CylinderBufferGeometry(0, 0.5, 1, 5, 1);
coneGeometry.translate(0, -0.5, 0);
ArrowHelper.prototype = Object.create(Object3D.prototype);
ArrowHelper.prototype.constructor = ArrowHelper;
ArrowHelper.prototype.setDirection = function () {
    var axis = new Vector3();
    var radians;
    return function setDirection(dir) {
        if (dir.y > 0.99999) {
            this.quaternion.set(0, 0, 0, 1);
        } else if (dir.y < -0.99999) {
            this.quaternion.set(1, 0, 0, 0);
        } else {
            axis.set(dir.z, 0, -dir.x).normalize();
            radians = Math.acos(dir.y);
            this.quaternion.setFromAxisAngle(axis, radians);
        }
    };
}();
ArrowHelper.prototype.setLength = function (length, headLength, headWidth) {
    if (headLength === undefined)
        headLength = 0.2 * length;
    if (headWidth === undefined)
        headWidth = 0.2 * headLength;
    this.line.scale.set(1, Math.max(0, length - headLength), 1);
    this.line.updateMatrix();
    this.cone.scale.set(headWidth, headLength, headWidth);
    this.cone.position.y = length;
    this.cone.updateMatrix();
};
ArrowHelper.prototype.setColor = function (color) {
    this.line.material.color.copy(color);
    this.cone.material.color.copy(color);
};
AxisHelper.prototype = Object.create(LineSegments.prototype);
AxisHelper.prototype.constructor = AxisHelper;
ParametricGeometry.prototype = Object.create(Geometry.prototype);
ParametricGeometry.prototype.constructor = ParametricGeometry;
PolyhedronGeometry.prototype = Object.create(Geometry.prototype);
PolyhedronGeometry.prototype.constructor = PolyhedronGeometry;
TetrahedronGeometry.prototype = Object.create(PolyhedronGeometry.prototype);
TetrahedronGeometry.prototype.constructor = TetrahedronGeometry;
OctahedronGeometry.prototype = Object.create(PolyhedronGeometry.prototype);
OctahedronGeometry.prototype.constructor = OctahedronGeometry;
IcosahedronGeometry.prototype = Object.create(PolyhedronGeometry.prototype);
IcosahedronGeometry.prototype.constructor = IcosahedronGeometry;
DodecahedronGeometry.prototype = Object.create(PolyhedronGeometry.prototype);
DodecahedronGeometry.prototype.constructor = DodecahedronGeometry;
TorusKnotBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
TorusKnotBufferGeometry.prototype.constructor = TorusKnotBufferGeometry;
TorusKnotGeometry.prototype = Object.create(Geometry.prototype);
TorusKnotGeometry.prototype.constructor = TorusKnotGeometry;
TorusBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
TorusBufferGeometry.prototype.constructor = TorusBufferGeometry;
TorusGeometry.prototype = Object.create(Geometry.prototype);
TorusGeometry.prototype.constructor = TorusGeometry;
TextGeometry.prototype = Object.create(ExtrudeGeometry.prototype);
TextGeometry.prototype.constructor = TextGeometry;
RingBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
RingBufferGeometry.prototype.constructor = RingBufferGeometry;
RingGeometry.prototype = Object.create(Geometry.prototype);
RingGeometry.prototype.constructor = RingGeometry;
PlaneGeometry.prototype = Object.create(Geometry.prototype);
PlaneGeometry.prototype.constructor = PlaneGeometry;
LatheBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
LatheBufferGeometry.prototype.constructor = LatheBufferGeometry;
LatheGeometry.prototype = Object.create(Geometry.prototype);
LatheGeometry.prototype.constructor = LatheGeometry;
CylinderGeometry.prototype = Object.create(Geometry.prototype);
CylinderGeometry.prototype.constructor = CylinderGeometry;
ConeGeometry.prototype = Object.create(CylinderGeometry.prototype);
ConeGeometry.prototype.constructor = ConeGeometry;
ConeBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
ConeBufferGeometry.prototype.constructor = ConeBufferGeometry;
CircleBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
CircleBufferGeometry.prototype.constructor = CircleBufferGeometry;
CircleGeometry.prototype = Object.create(Geometry.prototype);
CircleGeometry.prototype.constructor = CircleGeometry;
exports.CatmullRomCurve3 = function () {
    var tmp = new Vector3(), px = new CubicPoly(), py = new CubicPoly(), pz = new CubicPoly();
    function CubicPoly() {
    }
    CubicPoly.prototype.init = function (x0, x1, t0, t1) {
        this.c0 = x0;
        this.c1 = t0;
        this.c2 = -3 * x0 + 3 * x1 - 2 * t0 - t1;
        this.c3 = 2 * x0 - 2 * x1 + t0 + t1;
    };
    CubicPoly.prototype.initNonuniformCatmullRom = function (x0, x1, x2, x3, dt0, dt1, dt2) {
        var t1 = (x1 - x0) / dt0 - (x2 - x0) / (dt0 + dt1) + (x2 - x1) / dt1;
        var t2 = (x2 - x1) / dt1 - (x3 - x1) / (dt1 + dt2) + (x3 - x2) / dt2;
        t1 *= dt1;
        t2 *= dt1;
        this.init(x1, x2, t1, t2);
    };
    CubicPoly.prototype.initCatmullRom = function (x0, x1, x2, x3, tension) {
        this.init(x1, x2, tension * (x2 - x0), tension * (x3 - x1));
    };
    CubicPoly.prototype.calc = function (t) {
        var t2 = t * t;
        var t3 = t2 * t;
        return this.c0 + this.c1 * t + this.c2 * t2 + this.c3 * t3;
    };
    return Curve.create(function (p) {
        this.points = p || [];
        this.closed = false;
    }, function (t) {
        var points = this.points, point, intPoint, weight, l;
        l = points.length;
        if (l < 2)
            console.log('duh, you need at least 2 points');
        point = (l - (this.closed ? 0 : 1)) * t;
        intPoint = Math.floor(point);
        weight = point - intPoint;
        if (this.closed) {
            intPoint += intPoint > 0 ? 0 : (Math.floor(Math.abs(intPoint) / points.length) + 1) * points.length;
        } else if (weight === 0 && intPoint === l - 1) {
            intPoint = l - 2;
            weight = 1;
        }
        var p0, p1, p2, p3;
        if (this.closed || intPoint > 0) {
            p0 = points[(intPoint - 1) % l];
        } else {
            tmp.subVectors(points[0], points[1]).add(points[0]);
            p0 = tmp;
        }
        p1 = points[intPoint % l];
        p2 = points[(intPoint + 1) % l];
        if (this.closed || intPoint + 2 < l) {
            p3 = points[(intPoint + 2) % l];
        } else {
            tmp.subVectors(points[l - 1], points[l - 2]).add(points[l - 1]);
            p3 = tmp;
        }
        if (this.type === undefined || this.type === 'centripetal' || this.type === 'chordal') {
            var pow = this.type === 'chordal' ? 0.5 : 0.25;
            var dt0 = Math.pow(p0.distanceToSquared(p1), pow);
            var dt1 = Math.pow(p1.distanceToSquared(p2), pow);
            var dt2 = Math.pow(p2.distanceToSquared(p3), pow);
            if (dt1 < 0.0001)
                dt1 = 1;
            if (dt0 < 0.0001)
                dt0 = dt1;
            if (dt2 < 0.0001)
                dt2 = dt1;
            px.initNonuniformCatmullRom(p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2);
            py.initNonuniformCatmullRom(p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2);
            pz.initNonuniformCatmullRom(p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2);
        } else if (this.type === 'catmullrom') {
            var tension = this.tension !== undefined ? this.tension : 0.5;
            px.initCatmullRom(p0.x, p1.x, p2.x, p3.x, tension);
            py.initCatmullRom(p0.y, p1.y, p2.y, p3.y, tension);
            pz.initCatmullRom(p0.z, p1.z, p2.z, p3.z, tension);
        }
        var v = new Vector3(px.calc(weight), py.calc(weight), pz.calc(weight));
        return v;
    });
}();
ClosedSplineCurve3.prototype = Object.create(exports.CatmullRomCurve3.prototype);
SplineCurve3 = Curve.create(function (points) {
    console.warn('THREE.SplineCurve3 will be deprecated. Please use THREE.CatmullRomCurve3');
    this.points = points === undefined ? [] : points;
}, function (t) {
    var points = this.points;
    var point = (points.length - 1) * t;
    var intPoint = Math.floor(point);
    var weight = point - intPoint;
    var point0 = points[intPoint == 0 ? intPoint : intPoint - 1];
    var point1 = points[intPoint];
    var point2 = points[intPoint > points.length - 2 ? points.length - 1 : intPoint + 1];
    var point3 = points[intPoint > points.length - 3 ? points.length - 1 : intPoint + 2];
    var interpolate = exports.CurveUtils.interpolate;
    return new Vector3(interpolate(point0.x, point1.x, point2.x, point3.x, weight), interpolate(point0.y, point1.y, point2.y, point3.y, weight), interpolate(point0.z, point1.z, point2.z, point3.z, weight));
});
exports.CubicBezierCurve3 = Curve.create(function (v0, v1, v2, v3) {
    this.v0 = v0;
    this.v1 = v1;
    this.v2 = v2;
    this.v3 = v3;
}, function (t) {
    var b3 = exports.ShapeUtils.b3;
    return new Vector3(b3(t, this.v0.x, this.v1.x, this.v2.x, this.v3.x), b3(t, this.v0.y, this.v1.y, this.v2.y, this.v3.y), b3(t, this.v0.z, this.v1.z, this.v2.z, this.v3.z));
});
exports.QuadraticBezierCurve3 = Curve.create(function (v0, v1, v2) {
    this.v0 = v0;
    this.v1 = v1;
    this.v2 = v2;
}, function (t) {
    var b2 = exports.ShapeUtils.b2;
    return new Vector3(b2(t, this.v0.x, this.v1.x, this.v2.x), b2(t, this.v0.y, this.v1.y, this.v2.y), b2(t, this.v0.z, this.v1.z, this.v2.z));
});
exports.LineCurve3 = Curve.create(function (v1, v2) {
    this.v1 = v1;
    this.v2 = v2;
}, function (t) {
    if (t === 1) {
        return this.v2.clone();
    }
    var vector = new Vector3();
    vector.subVectors(this.v2, this.v1);
    vector.multiplyScalar(t);
    vector.add(this.v1);
    return vector;
});
ArcCurve.prototype = Object.create(EllipseCurve.prototype);
ArcCurve.prototype.constructor = ArcCurve;
exports.SceneUtils = {
    createMultiMaterialObject: function (geometry, materials) {
        var group = new Group();
        for (var i = 0, l = materials.length; i < l; i++) {
            group.add(new Mesh(geometry, materials[i]));
        }
        return group;
    },
    detach: function (child, parent, scene) {
        child.applyMatrix(parent.matrixWorld);
        parent.remove(child);
        scene.add(child);
    },
    attach: function (child, scene, parent) {
        var matrixWorldInverse = new Matrix4();
        matrixWorldInverse.getInverse(parent.matrixWorld);
        child.applyMatrix(matrixWorldInverse);
        scene.remove(child);
        parent.add(child);
    }
};
LineStrip = 0;
LinePieces = 1;
Object.assign(Box2.prototype, {
    empty: function () {
        console.warn('THREE.Box2: .empty() has been renamed to .isEmpty().');
        return this.isEmpty();
    },
    isIntersectionBox: function (box) {
        console.warn('THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().');
        return this.intersectsBox(box);
    }
});
Object.assign(Box3.prototype, {
    empty: function () {
        console.warn('THREE.Box3: .empty() has been renamed to .isEmpty().');
        return this.isEmpty();
    },
    isIntersectionBox: function (box) {
        console.warn('THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().');
        return this.intersectsBox(box);
    },
    isIntersectionSphere: function (sphere) {
        console.warn('THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().');
        return this.intersectsSphere(sphere);
    }
});
Object.assign(Matrix3.prototype, {
    multiplyVector3: function (vector) {
        console.warn('THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.');
        return vector.applyMatrix3(this);
    },
    multiplyVector3Array: function (a) {
        console.warn('THREE.Matrix3: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.');
        return this.applyToVector3Array(a);
    }
});
Object.assign(Matrix4.prototype, {
    extractPosition: function (m) {
        console.warn('THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().');
        return this.copyPosition(m);
    },
    setRotationFromQuaternion: function (q) {
        console.warn('THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().');
        return this.makeRotationFromQuaternion(q);
    },
    multiplyVector3: function (vector) {
        console.warn('THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead.');
        return vector.applyProjection(this);
    },
    multiplyVector4: function (vector) {
        console.warn('THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.');
        return vector.applyMatrix4(this);
    },
    multiplyVector3Array: function (a) {
        console.warn('THREE.Matrix4: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.');
        return this.applyToVector3Array(a);
    },
    rotateAxis: function (v) {
        console.warn('THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.');
        v.transformDirection(this);
    },
    crossVector: function (vector) {
        console.warn('THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.');
        return vector.applyMatrix4(this);
    },
    translate: function (v) {
        console.error('THREE.Matrix4: .translate() has been removed.');
    },
    rotateX: function (angle) {
        console.error('THREE.Matrix4: .rotateX() has been removed.');
    },
    rotateY: function (angle) {
        console.error('THREE.Matrix4: .rotateY() has been removed.');
    },
    rotateZ: function (angle) {
        console.error('THREE.Matrix4: .rotateZ() has been removed.');
    },
    rotateByAxis: function (axis, angle) {
        console.error('THREE.Matrix4: .rotateByAxis() has been removed.');
    }
});
Object.assign(Plane.prototype, {
    isIntersectionLine: function (line) {
        console.warn('THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().');
        return this.intersectsLine(line);
    }
});
Object.assign(Quaternion.prototype, {
    multiplyVector3: function (vector) {
        console.warn('THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.');
        return vector.applyQuaternion(this);
    }
});
Object.assign(Ray.prototype, {
    isIntersectionBox: function (box) {
        console.warn('THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().');
        return this.intersectsBox(box);
    },
    isIntersectionPlane: function (plane) {
        console.warn('THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().');
        return this.intersectsPlane(plane);
    },
    isIntersectionSphere: function (sphere) {
        console.warn('THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().');
        return this.intersectsSphere(sphere);
    }
});
Object.assign(Vector3.prototype, {
    setEulerFromRotationMatrix: function () {
        console.error('THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.');
    },
    setEulerFromQuaternion: function () {
        console.error('THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.');
    },
    getPositionFromMatrix: function (m) {
        console.warn('THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().');
        return this.setFromMatrixPosition(m);
    },
    getScaleFromMatrix: function (m) {
        console.warn('THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().');
        return this.setFromMatrixScale(m);
    },
    getColumnFromMatrix: function (index, matrix) {
        console.warn('THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().');
        return this.setFromMatrixColumn(matrix, index);
    }
});
Object.assign(Object3D.prototype, {
    getChildByName: function (name) {
        console.warn('THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().');
        return this.getObjectByName(name);
    },
    renderDepth: function (value) {
        console.warn('THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.');
    },
    translate: function (distance, axis) {
        console.warn('THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.');
        return this.translateOnAxis(axis, distance);
    }
});
Object.defineProperties(Object3D.prototype, {
    eulerOrder: {
        get: function () {
            console.warn('THREE.Object3D: .eulerOrder is now .rotation.order.');
            return this.rotation.order;
        },
        set: function (value) {
            console.warn('THREE.Object3D: .eulerOrder is now .rotation.order.');
            this.rotation.order = value;
        }
    },
    useQuaternion: {
        get: function () {
            console.warn('THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.');
        },
        set: function (value) {
            console.warn('THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.');
        }
    }
});
Object.defineProperties(LOD.prototype, {
    objects: {
        get: function () {
            console.warn('THREE.LOD: .objects has been renamed to .levels.');
            return this.levels;
        }
    }
});
PerspectiveCamera.prototype.setLens = function (focalLength, filmGauge) {
    console.warn('THREE.PerspectiveCamera.setLens is deprecated. ' + 'Use .setFocalLength and .filmGauge for a photographic setup.');
    if (filmGauge !== undefined)
        this.filmGauge = filmGauge;
    this.setFocalLength(focalLength);
};
Object.defineProperties(Light.prototype, {
    onlyShadow: {
        set: function (value) {
            console.warn('THREE.Light: .onlyShadow has been removed.');
        }
    },
    shadowCameraFov: {
        set: function (value) {
            console.warn('THREE.Light: .shadowCameraFov is now .shadow.camera.fov.');
            this.shadow.camera.fov = value;
        }
    },
    shadowCameraLeft: {
        set: function (value) {
            console.warn('THREE.Light: .shadowCameraLeft is now .shadow.camera.left.');
            this.shadow.camera.left = value;
        }
    },
    shadowCameraRight: {
        set: function (value) {
            console.warn('THREE.Light: .shadowCameraRight is now .shadow.camera.right.');
            this.shadow.camera.right = value;
        }
    },
    shadowCameraTop: {
        set: function (value) {
            console.warn('THREE.Light: .shadowCameraTop is now .shadow.camera.top.');
            this.shadow.camera.top = value;
        }
    },
    shadowCameraBottom: {
        set: function (value) {
            console.warn('THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.');
            this.shadow.camera.bottom = value;
        }
    },
    shadowCameraNear: {
        set: function (value) {
            console.warn('THREE.Light: .shadowCameraNear is now .shadow.camera.near.');
            this.shadow.camera.near = value;
        }
    },
    shadowCameraFar: {
        set: function (value) {
            console.warn('THREE.Light: .shadowCameraFar is now .shadow.camera.far.');
            this.shadow.camera.far = value;
        }
    },
    shadowCameraVisible: {
        set: function (value) {
            console.warn('THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.');
        }
    },
    shadowBias: {
        set: function (value) {
            console.warn('THREE.Light: .shadowBias is now .shadow.bias.');
            this.shadow.bias = value;
        }
    },
    shadowDarkness: {
        set: function (value) {
            console.warn('THREE.Light: .shadowDarkness has been removed.');
        }
    },
    shadowMapWidth: {
        set: function (value) {
            console.warn('THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.');
            this.shadow.mapSize.width = value;
        }
    },
    shadowMapHeight: {
        set: function (value) {
            console.warn('THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.');
            this.shadow.mapSize.height = value;
        }
    }
});
Object.defineProperties(BufferAttribute.prototype, {
    length: {
        get: function () {
            console.warn('THREE.BufferAttribute: .length has been deprecated. Please use .count.');
            return this.array.length;
        }
    }
});
Object.assign(BufferGeometry.prototype, {
    addIndex: function (index) {
        console.warn('THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().');
        this.setIndex(index);
    },
    addDrawCall: function (start, count, indexOffset) {
        if (indexOffset !== undefined) {
            console.warn('THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.');
        }
        console.warn('THREE.BufferGeometry: .addDrawCall() is now .addGroup().');
        this.addGroup(start, count);
    },
    clearDrawCalls: function () {
        console.warn('THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().');
        this.clearGroups();
    },
    computeTangents: function () {
        console.warn('THREE.BufferGeometry: .computeTangents() has been removed.');
    },
    computeOffsets: function () {
        console.warn('THREE.BufferGeometry: .computeOffsets() has been removed.');
    }
});
Object.defineProperties(BufferGeometry.prototype, {
    drawcalls: {
        get: function () {
            console.error('THREE.BufferGeometry: .drawcalls has been renamed to .groups.');
            return this.groups;
        }
    },
    offsets: {
        get: function () {
            console.warn('THREE.BufferGeometry: .offsets has been renamed to .groups.');
            return this.groups;
        }
    }
});
Object.defineProperties(Material.prototype, {
    wrapAround: {
        get: function () {
            console.warn('THREE.' + this.type + ': .wrapAround has been removed.');
        },
        set: function (value) {
            console.warn('THREE.' + this.type + ': .wrapAround has been removed.');
        }
    },
    wrapRGB: {
        get: function () {
            console.warn('THREE.' + this.type + ': .wrapRGB has been removed.');
            return new Color();
        }
    }
});
Object.defineProperties(MeshPhongMaterial.prototype, {
    metal: {
        get: function () {
            console.warn('THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.');
            return false;
        },
        set: function (value) {
            console.warn('THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead');
        }
    }
});
Object.defineProperties(ShaderMaterial.prototype, {
    derivatives: {
        get: function () {
            console.warn('THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.');
            return this.extensions.derivatives;
        },
        set: function (value) {
            console.warn('THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.');
            this.extensions.derivatives = value;
        }
    }
});
EventDispatcher.prototype = Object.assign(Object.create({
    constructor: EventDispatcher,
    apply: function (target) {
        console.warn('THREE.EventDispatcher: .apply is deprecated, ' + 'just inherit or Object.assign the prototype to mix-in.');
        Object.assign(target, this);
    }
}), EventDispatcher.prototype);
Object.assign(WebGLRenderer.prototype, {
    supportsFloatTextures: function () {
        console.warn('THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \'OES_texture_float\' ).');
        return this.extensions.get('OES_texture_float');
    },
    supportsHalfFloatTextures: function () {
        console.warn('THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \'OES_texture_half_float\' ).');
        return this.extensions.get('OES_texture_half_float');
    },
    supportsStandardDerivatives: function () {
        console.warn('THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \'OES_standard_derivatives\' ).');
        return this.extensions.get('OES_standard_derivatives');
    },
    supportsCompressedTextureS3TC: function () {
        console.warn('THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \'WEBGL_compressed_texture_s3tc\' ).');
        return this.extensions.get('WEBGL_compressed_texture_s3tc');
    },
    supportsCompressedTexturePVRTC: function () {
        console.warn('THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \'WEBGL_compressed_texture_pvrtc\' ).');
        return this.extensions.get('WEBGL_compressed_texture_pvrtc');
    },
    supportsBlendMinMax: function () {
        console.warn('THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \'EXT_blend_minmax\' ).');
        return this.extensions.get('EXT_blend_minmax');
    },
    supportsVertexTextures: function () {
        return this.capabilities.vertexTextures;
    },
    supportsInstancedArrays: function () {
        console.warn('THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \'ANGLE_instanced_arrays\' ).');
        return this.extensions.get('ANGLE_instanced_arrays');
    },
    enableScissorTest: function (boolean) {
        console.warn('THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().');
        this.setScissorTest(boolean);
    },
    initMaterial: function () {
        console.warn('THREE.WebGLRenderer: .initMaterial() has been removed.');
    },
    addPrePlugin: function () {
        console.warn('THREE.WebGLRenderer: .addPrePlugin() has been removed.');
    },
    addPostPlugin: function () {
        console.warn('THREE.WebGLRenderer: .addPostPlugin() has been removed.');
    },
    updateShadowMap: function () {
        console.warn('THREE.WebGLRenderer: .updateShadowMap() has been removed.');
    }
});
Object.defineProperties(WebGLRenderer.prototype, {
    shadowMapEnabled: {
        get: function () {
            return this.shadowMap.enabled;
        },
        set: function (value) {
            console.warn('THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.');
            this.shadowMap.enabled = value;
        }
    },
    shadowMapType: {
        get: function () {
            return this.shadowMap.type;
        },
        set: function (value) {
            console.warn('THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.');
            this.shadowMap.type = value;
        }
    },
    shadowMapCullFace: {
        get: function () {
            return this.shadowMap.cullFace;
        },
        set: function (value) {
            console.warn('THREE.WebGLRenderer: .shadowMapCullFace is now .shadowMap.cullFace.');
            this.shadowMap.cullFace = value;
        }
    }
});
Object.defineProperties(WebGLShadowMap.prototype, {
    cullFace: {
        get: function () {
            return this.renderReverseSided ? CullFaceFront : CullFaceBack;
        },
        set: function (cullFace) {
            var value = cullFace !== CullFaceBack;
            console.warn('WebGLRenderer: .shadowMap.cullFace is deprecated. Set .shadowMap.renderReverseSided to ' + value + '.');
            this.renderReverseSided = value;
        }
    }
});
Object.defineProperties(WebGLRenderTarget.prototype, {
    wrapS: {
        get: function () {
            console.warn('THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.');
            return this.texture.wrapS;
        },
        set: function (value) {
            console.warn('THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.');
            this.texture.wrapS = value;
        }
    },
    wrapT: {
        get: function () {
            console.warn('THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.');
            return this.texture.wrapT;
        },
        set: function (value) {
            console.warn('THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.');
            this.texture.wrapT = value;
        }
    },
    magFilter: {
        get: function () {
            console.warn('THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.');
            return this.texture.magFilter;
        },
        set: function (value) {
            console.warn('THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.');
            this.texture.magFilter = value;
        }
    },
    minFilter: {
        get: function () {
            console.warn('THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.');
            return this.texture.minFilter;
        },
        set: function (value) {
            console.warn('THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.');
            this.texture.minFilter = value;
        }
    },
    anisotropy: {
        get: function () {
            console.warn('THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.');
            return this.texture.anisotropy;
        },
        set: function (value) {
            console.warn('THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.');
            this.texture.anisotropy = value;
        }
    },
    offset: {
        get: function () {
            console.warn('THREE.WebGLRenderTarget: .offset is now .texture.offset.');
            return this.texture.offset;
        },
        set: function (value) {
            console.warn('THREE.WebGLRenderTarget: .offset is now .texture.offset.');
            this.texture.offset = value;
        }
    },
    repeat: {
        get: function () {
            console.warn('THREE.WebGLRenderTarget: .repeat is now .texture.repeat.');
            return this.texture.repeat;
        },
        set: function (value) {
            console.warn('THREE.WebGLRenderTarget: .repeat is now .texture.repeat.');
            this.texture.repeat = value;
        }
    },
    format: {
        get: function () {
            console.warn('THREE.WebGLRenderTarget: .format is now .texture.format.');
            return this.texture.format;
        },
        set: function (value) {
            console.warn('THREE.WebGLRenderTarget: .format is now .texture.format.');
            this.texture.format = value;
        }
    },
    type: {
        get: function () {
            console.warn('THREE.WebGLRenderTarget: .type is now .texture.type.');
            return this.texture.type;
        },
        set: function (value) {
            console.warn('THREE.WebGLRenderTarget: .type is now .texture.type.');
            this.texture.type = value;
        }
    },
    generateMipmaps: {
        get: function () {
            console.warn('THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.');
            return this.texture.generateMipmaps;
        },
        set: function (value) {
            console.warn('THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.');
            this.texture.generateMipmaps = value;
        }
    }
});
Object.assign(Audio.prototype, {
    load: function (file) {
        console.warn('THREE.Audio: .load has been deprecated. Please use THREE.AudioLoader.');
        var scope = this;
        var audioLoader = new AudioLoader();
        audioLoader.load(file, function (buffer) {
            scope.setBuffer(buffer);
        });
        return this;
    }
});
Object.assign(AudioAnalyser.prototype, {
    getData: function (file) {
        console.warn('THREE.AudioAnalyser: .getData() is now .getFrequencyData().');
        return this.getFrequencyData();
    }
});
GeometryUtils = {
    merge: function (geometry1, geometry2, materialIndexOffset) {
        console.warn('THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.');
        var matrix;
        if (geometry2.isMesh) {
            geometry2.matrixAutoUpdate && geometry2.updateMatrix();
            matrix = geometry2.matrix;
            geometry2 = geometry2.geometry;
        }
        geometry1.merge(geometry2, matrix, materialIndexOffset);
    },
    center: function (geometry) {
        console.warn('THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.');
        return geometry.center();
    }
};
ImageUtils = {
    crossOrigin: undefined,
    loadTexture: function (url, mapping, onLoad, onError) {
        console.warn('THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.');
        var loader = new TextureLoader();
        loader.setCrossOrigin(this.crossOrigin);
        var texture = loader.load(url, onLoad, undefined, onError);
        if (mapping)
            texture.mapping = mapping;
        return texture;
    },
    loadTextureCube: function (urls, mapping, onLoad, onError) {
        console.warn('THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.');
        var loader = new CubeTextureLoader();
        loader.setCrossOrigin(this.crossOrigin);
        var texture = loader.load(urls, onLoad, undefined, onError);
        if (mapping)
            texture.mapping = mapping;
        return texture;
    },
    loadCompressedTexture: function () {
        console.error('THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.');
    },
    loadCompressedTextureCube: function () {
        console.error('THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.');
    }
};
Object.defineProperty(exports, 'AudioContext', {
    get: function () {
        return exports.getAudioContext();
    }
});
exports.SpritePlugin = SpritePlugin;
exports.LensFlarePlugin = LensFlarePlugin;
exports.WebGLUniforms = WebGLUniforms;
exports.WebGLTextures = WebGLTextures;
exports.WebGLState = WebGLState;
exports.WebGLShadowMap = WebGLShadowMap;
exports.WebGLShader = WebGLShader;
exports.WebGLProperties = WebGLProperties;
exports.WebGLPrograms = WebGLPrograms;
exports.WebGLProgram = WebGLProgram;
exports.WebGLObjects = WebGLObjects;
exports.WebGLLights = WebGLLights;
exports.WebGLGeometries = WebGLGeometries;
exports.WebGLCapabilities = WebGLCapabilities;
exports.WebGLExtensions = WebGLExtensions;
exports.WebGLIndexedBufferRenderer = WebGLIndexedBufferRenderer;
exports.WebGLClipping = WebGLClipping;
exports.WebGLBufferRenderer = WebGLBufferRenderer;
exports.WebGLRenderTargetCube = WebGLRenderTargetCube;
exports.WebGLRenderTarget = WebGLRenderTarget;
exports.WebGLRenderer = WebGLRenderer;
exports.ShaderLib = ShaderLib;
exports.UniformsLib = UniformsLib;
exports.ShaderChunk = ShaderChunk;
exports.FogExp2 = FogExp2;
exports.Fog = Fog;
exports.Scene = Scene;
exports.LensFlare = LensFlare;
exports.Sprite = Sprite;
exports.LOD = LOD;
exports.SkinnedMesh = SkinnedMesh;
exports.Skeleton = Skeleton;
exports.Bone = Bone;
exports.Mesh = Mesh;
exports.LineSegments = LineSegments;
exports.Line = Line;
exports.Points = Points;
exports.Group = Group;
exports.VideoTexture = VideoTexture;
exports.DataTexture = DataTexture;
exports.CompressedTexture = CompressedTexture;
exports.CubeTexture = CubeTexture;
exports.CanvasTexture = CanvasTexture;
exports.DepthTexture = DepthTexture;
exports.TextureIdCount = TextureIdCount;
exports.Texture = Texture;
exports.ShadowMaterial = ShadowMaterial;
exports.SpriteMaterial = SpriteMaterial;
exports.RawShaderMaterial = RawShaderMaterial;
exports.ShaderMaterial = ShaderMaterial;
exports.PointsMaterial = PointsMaterial;
exports.MultiMaterial = MultiMaterial;
exports.MeshPhysicalMaterial = MeshPhysicalMaterial;
exports.MeshStandardMaterial = MeshStandardMaterial;
exports.MeshPhongMaterial = MeshPhongMaterial;
exports.MeshNormalMaterial = MeshNormalMaterial;
exports.MeshLambertMaterial = MeshLambertMaterial;
exports.MeshDepthMaterial = MeshDepthMaterial;
exports.MeshBasicMaterial = MeshBasicMaterial;
exports.LineDashedMaterial = LineDashedMaterial;
exports.LineBasicMaterial = LineBasicMaterial;
exports.MaterialIdCount = MaterialIdCount;
exports.Material = Material;
exports.CompressedTextureLoader = CompressedTextureLoader;
exports.BinaryTextureLoader = BinaryTextureLoader;
exports.DataTextureLoader = DataTextureLoader;
exports.CubeTextureLoader = CubeTextureLoader;
exports.TextureLoader = TextureLoader;
exports.ObjectLoader = ObjectLoader;
exports.MaterialLoader = MaterialLoader;
exports.BufferGeometryLoader = BufferGeometryLoader;
exports.LoadingManager = LoadingManager;
exports.JSONLoader = JSONLoader;
exports.ImageLoader = ImageLoader;
exports.FontLoader = FontLoader;
exports.XHRLoader = XHRLoader;
exports.Loader = Loader;
exports.AudioLoader = AudioLoader;
exports.SpotLightShadow = SpotLightShadow;
exports.SpotLight = SpotLight;
exports.PointLight = PointLight;
exports.HemisphereLight = HemisphereLight;
exports.DirectionalLightShadow = DirectionalLightShadow;
exports.DirectionalLight = DirectionalLight;
exports.AmbientLight = AmbientLight;
exports.LightShadow = LightShadow;
exports.Light = Light;
exports.StereoCamera = StereoCamera;
exports.PerspectiveCamera = PerspectiveCamera;
exports.OrthographicCamera = OrthographicCamera;
exports.CubeCamera = CubeCamera;
exports.Camera = Camera;
exports.AudioListener = AudioListener;
exports.PositionalAudio = PositionalAudio;
exports.getAudioContext = getAudioContext;
exports.AudioAnalyser = AudioAnalyser;
exports.Audio = Audio;
exports.VectorKeyframeTrack = VectorKeyframeTrack;
exports.StringKeyframeTrack = StringKeyframeTrack;
exports.QuaternionKeyframeTrack = QuaternionKeyframeTrack;
exports.NumberKeyframeTrack = NumberKeyframeTrack;
exports.ColorKeyframeTrack = ColorKeyframeTrack;
exports.BooleanKeyframeTrack = BooleanKeyframeTrack;
exports.PropertyMixer = PropertyMixer;
exports.PropertyBinding = PropertyBinding;
exports.KeyframeTrack = KeyframeTrack;
exports.AnimationObjectGroup = AnimationObjectGroup;
exports.AnimationMixer = AnimationMixer;
exports.AnimationClip = AnimationClip;
exports.Uniform = Uniform;
exports.InstancedBufferGeometry = InstancedBufferGeometry;
exports.BufferGeometry = BufferGeometry;
exports.DirectGeometry = DirectGeometry;
exports.GeometryIdCount = GeometryIdCount;
exports.Geometry = Geometry;
exports.InterleavedBufferAttribute = InterleavedBufferAttribute;
exports.InstancedInterleavedBuffer = InstancedInterleavedBuffer;
exports.InterleavedBuffer = InterleavedBuffer;
exports.InstancedBufferAttribute = InstancedBufferAttribute;
exports.DynamicBufferAttribute = DynamicBufferAttribute;
exports.Float64Attribute = Float64Attribute;
exports.Float32Attribute = Float32Attribute;
exports.Uint32Attribute = Uint32Attribute;
exports.Int32Attribute = Int32Attribute;
exports.Uint16Attribute = Uint16Attribute;
exports.Int16Attribute = Int16Attribute;
exports.Uint8ClampedAttribute = Uint8ClampedAttribute;
exports.Uint8Attribute = Uint8Attribute;
exports.Int8Attribute = Int8Attribute;
exports.BufferAttribute = BufferAttribute;
exports.Face3 = Face3;
exports.Object3DIdCount = Object3DIdCount;
exports.Object3D = Object3D;
exports.Raycaster = Raycaster;
exports.Layers = Layers;
exports.EventDispatcher = EventDispatcher;
exports.Clock = Clock;
exports.QuaternionLinearInterpolant = QuaternionLinearInterpolant;
exports.LinearInterpolant = LinearInterpolant;
exports.DiscreteInterpolant = DiscreteInterpolant;
exports.CubicInterpolant = CubicInterpolant;
exports.Interpolant = Interpolant;
exports.Triangle = Triangle;
exports.Spline = Spline;
exports.Spherical = Spherical;
exports.Plane = Plane;
exports.Frustum = Frustum;
exports.Sphere = Sphere;
exports.Ray = Ray;
exports.Matrix4 = Matrix4;
exports.Matrix3 = Matrix3;
exports.Box3 = Box3;
exports.Box2 = Box2;
exports.Line3 = Line3;
exports.Euler = Euler;
exports.Vector4 = Vector4;
exports.Vector3 = Vector3;
exports.Vector2 = Vector2;
exports.Quaternion = Quaternion;
exports.Color = Color;
exports.MorphBlendMesh = MorphBlendMesh;
exports.ImmediateRenderObject = ImmediateRenderObject;
exports.WireframeHelper = WireframeHelper;
exports.VertexNormalsHelper = VertexNormalsHelper;
exports.SpotLightHelper = SpotLightHelper;
exports.SkeletonHelper = SkeletonHelper;
exports.PointLightHelper = PointLightHelper;
exports.HemisphereLightHelper = HemisphereLightHelper;
exports.GridHelper = GridHelper;
exports.FaceNormalsHelper = FaceNormalsHelper;
exports.EdgesHelper = EdgesHelper;
exports.DirectionalLightHelper = DirectionalLightHelper;
exports.CameraHelper = CameraHelper;
exports.BoundingBoxHelper = BoundingBoxHelper;
exports.BoxHelper = BoxHelper;
exports.ArrowHelper = ArrowHelper;
exports.AxisHelper = AxisHelper;
exports.WireframeGeometry = WireframeGeometry;
exports.ParametricGeometry = ParametricGeometry;
exports.TetrahedronGeometry = TetrahedronGeometry;
exports.OctahedronGeometry = OctahedronGeometry;
exports.IcosahedronGeometry = IcosahedronGeometry;
exports.DodecahedronGeometry = DodecahedronGeometry;
exports.PolyhedronGeometry = PolyhedronGeometry;
exports.TubeGeometry = TubeGeometry;
exports.TorusKnotGeometry = TorusKnotGeometry;
exports.TorusKnotBufferGeometry = TorusKnotBufferGeometry;
exports.TorusGeometry = TorusGeometry;
exports.TorusBufferGeometry = TorusBufferGeometry;
exports.TextGeometry = TextGeometry;
exports.SphereBufferGeometry = SphereBufferGeometry;
exports.SphereGeometry = SphereGeometry;
exports.RingGeometry = RingGeometry;
exports.RingBufferGeometry = RingBufferGeometry;
exports.PlaneBufferGeometry = PlaneBufferGeometry;
exports.PlaneGeometry = PlaneGeometry;
exports.LatheGeometry = LatheGeometry;
exports.LatheBufferGeometry = LatheBufferGeometry;
exports.ShapeGeometry = ShapeGeometry;
exports.ExtrudeGeometry = ExtrudeGeometry;
exports.EdgesGeometry = EdgesGeometry;
exports.ConeGeometry = ConeGeometry;
exports.ConeBufferGeometry = ConeBufferGeometry;
exports.CylinderGeometry = CylinderGeometry;
exports.CylinderBufferGeometry = CylinderBufferGeometry;
exports.CircleBufferGeometry = CircleBufferGeometry;
exports.CircleGeometry = CircleGeometry;
exports.BoxBufferGeometry = BoxBufferGeometry;
exports.BoxGeometry = BoxGeometry;
exports.ClosedSplineCurve3 = ClosedSplineCurve3;
exports.SplineCurve3 = SplineCurve3;
exports.ArcCurve = ArcCurve;
exports.EllipseCurve = EllipseCurve;
exports.SplineCurve = SplineCurve;
exports.CubicBezierCurve = CubicBezierCurve;
exports.QuadraticBezierCurve = QuadraticBezierCurve;
exports.LineCurve = LineCurve;
exports.Shape = Shape;
exports.ShapePath = ShapePath;
exports.Path = Path;
exports.Font = Font;
exports.CurvePath = CurvePath;
exports.Curve = Curve;
exports.REVISION = REVISION;
exports.MOUSE = MOUSE;
exports.CullFaceNone = CullFaceNone;
exports.CullFaceBack = CullFaceBack;
exports.CullFaceFront = CullFaceFront;
exports.CullFaceFrontBack = CullFaceFrontBack;
exports.FrontFaceDirectionCW = FrontFaceDirectionCW;
exports.FrontFaceDirectionCCW = FrontFaceDirectionCCW;
exports.BasicShadowMap = BasicShadowMap;
exports.PCFShadowMap = PCFShadowMap;
exports.PCFSoftShadowMap = PCFSoftShadowMap;
exports.FrontSide = FrontSide;
exports.BackSide = BackSide;
exports.DoubleSide = DoubleSide;
exports.FlatShading = FlatShading;
exports.SmoothShading = SmoothShading;
exports.NoColors = NoColors;
exports.FaceColors = FaceColors;
exports.VertexColors = VertexColors;
exports.NoBlending = NoBlending;
exports.NormalBlending = NormalBlending;
exports.AdditiveBlending = AdditiveBlending;
exports.SubtractiveBlending = SubtractiveBlending;
exports.MultiplyBlending = MultiplyBlending;
exports.CustomBlending = CustomBlending;
exports.AddEquation = AddEquation;
exports.SubtractEquation = SubtractEquation;
exports.ReverseSubtractEquation = ReverseSubtractEquation;
exports.MinEquation = MinEquation;
exports.MaxEquation = MaxEquation;
exports.ZeroFactor = ZeroFactor;
exports.OneFactor = OneFactor;
exports.SrcColorFactor = SrcColorFactor;
exports.OneMinusSrcColorFactor = OneMinusSrcColorFactor;
exports.SrcAlphaFactor = SrcAlphaFactor;
exports.OneMinusSrcAlphaFactor = OneMinusSrcAlphaFactor;
exports.DstAlphaFactor = DstAlphaFactor;
exports.OneMinusDstAlphaFactor = OneMinusDstAlphaFactor;
exports.DstColorFactor = DstColorFactor;
exports.OneMinusDstColorFactor = OneMinusDstColorFactor;
exports.SrcAlphaSaturateFactor = SrcAlphaSaturateFactor;
exports.NeverDepth = NeverDepth;
exports.AlwaysDepth = AlwaysDepth;
exports.LessDepth = LessDepth;
exports.LessEqualDepth = LessEqualDepth;
exports.EqualDepth = EqualDepth;
exports.GreaterEqualDepth = GreaterEqualDepth;
exports.GreaterDepth = GreaterDepth;
exports.NotEqualDepth = NotEqualDepth;
exports.MultiplyOperation = MultiplyOperation;
exports.MixOperation = MixOperation;
exports.AddOperation = AddOperation;
exports.NoToneMapping = NoToneMapping;
exports.LinearToneMapping = LinearToneMapping;
exports.ReinhardToneMapping = ReinhardToneMapping;
exports.Uncharted2ToneMapping = Uncharted2ToneMapping;
exports.CineonToneMapping = CineonToneMapping;
exports.UVMapping = UVMapping;
exports.CubeReflectionMapping = CubeReflectionMapping;
exports.CubeRefractionMapping = CubeRefractionMapping;
exports.EquirectangularReflectionMapping = EquirectangularReflectionMapping;
exports.EquirectangularRefractionMapping = EquirectangularRefractionMapping;
exports.SphericalReflectionMapping = SphericalReflectionMapping;
exports.CubeUVReflectionMapping = CubeUVReflectionMapping;
exports.CubeUVRefractionMapping = CubeUVRefractionMapping;
exports.RepeatWrapping = RepeatWrapping;
exports.ClampToEdgeWrapping = ClampToEdgeWrapping;
exports.MirroredRepeatWrapping = MirroredRepeatWrapping;
exports.NearestFilter = NearestFilter;
exports.NearestMipMapNearestFilter = NearestMipMapNearestFilter;
exports.NearestMipMapLinearFilter = NearestMipMapLinearFilter;
exports.LinearFilter = LinearFilter;
exports.LinearMipMapNearestFilter = LinearMipMapNearestFilter;
exports.LinearMipMapLinearFilter = LinearMipMapLinearFilter;
exports.UnsignedByteType = UnsignedByteType;
exports.ByteType = ByteType;
exports.ShortType = ShortType;
exports.UnsignedShortType = UnsignedShortType;
exports.IntType = IntType;
exports.UnsignedIntType = UnsignedIntType;
exports.FloatType = FloatType;
exports.HalfFloatType = HalfFloatType;
exports.UnsignedShort4444Type = UnsignedShort4444Type;
exports.UnsignedShort5551Type = UnsignedShort5551Type;
exports.UnsignedShort565Type = UnsignedShort565Type;
exports.UnsignedInt248Type = UnsignedInt248Type;
exports.AlphaFormat = AlphaFormat;
exports.RGBFormat = RGBFormat;
exports.RGBAFormat = RGBAFormat;
exports.LuminanceFormat = LuminanceFormat;
exports.LuminanceAlphaFormat = LuminanceAlphaFormat;
exports.RGBEFormat = RGBEFormat;
exports.DepthFormat = DepthFormat;
exports.DepthStencilFormat = DepthStencilFormat;
exports.RGB_S3TC_DXT1_Format = RGB_S3TC_DXT1_Format;
exports.RGBA_S3TC_DXT1_Format = RGBA_S3TC_DXT1_Format;
exports.RGBA_S3TC_DXT3_Format = RGBA_S3TC_DXT3_Format;
exports.RGBA_S3TC_DXT5_Format = RGBA_S3TC_DXT5_Format;
exports.RGB_PVRTC_4BPPV1_Format = RGB_PVRTC_4BPPV1_Format;
exports.RGB_PVRTC_2BPPV1_Format = RGB_PVRTC_2BPPV1_Format;
exports.RGBA_PVRTC_4BPPV1_Format = RGBA_PVRTC_4BPPV1_Format;
exports.RGBA_PVRTC_2BPPV1_Format = RGBA_PVRTC_2BPPV1_Format;
exports.RGB_ETC1_Format = RGB_ETC1_Format;
exports.LoopOnce = LoopOnce;
exports.LoopRepeat = LoopRepeat;
exports.LoopPingPong = LoopPingPong;
exports.InterpolateDiscrete = InterpolateDiscrete;
exports.InterpolateLinear = InterpolateLinear;
exports.InterpolateSmooth = InterpolateSmooth;
exports.ZeroCurvatureEnding = ZeroCurvatureEnding;
exports.ZeroSlopeEnding = ZeroSlopeEnding;
exports.WrapAroundEnding = WrapAroundEnding;
exports.TrianglesDrawMode = TrianglesDrawMode;
exports.TriangleStripDrawMode = TriangleStripDrawMode;
exports.TriangleFanDrawMode = TriangleFanDrawMode;
exports.LinearEncoding = LinearEncoding;
exports.sRGBEncoding = sRGBEncoding;
exports.GammaEncoding = GammaEncoding;
exports.RGBEEncoding = RGBEEncoding;
exports.LogLuvEncoding = LogLuvEncoding;
exports.RGBM7Encoding = RGBM7Encoding;
exports.RGBM16Encoding = RGBM16Encoding;
exports.RGBDEncoding = RGBDEncoding;
exports.BasicDepthPacking = BasicDepthPacking;
exports.RGBADepthPacking = RGBADepthPacking;
exports.CubeGeometry = BoxGeometry;
exports.Face4 = Face4;
exports.LineStrip = LineStrip;
exports.LinePieces = LinePieces;
exports.MeshFaceMaterial = MultiMaterial;
exports.PointCloud = PointCloud;
exports.Particle = Sprite;
exports.ParticleSystem = ParticleSystem;
exports.PointCloudMaterial = PointCloudMaterial;
exports.ParticleBasicMaterial = ParticleBasicMaterial;
exports.ParticleSystemMaterial = ParticleSystemMaterial;
exports.Vertex = Vertex;
exports.GeometryUtils = GeometryUtils;
exports.ImageUtils = ImageUtils;
exports.Projector = Projector;
exports.CanvasRenderer = CanvasRenderer;
Object.defineProperty(exports, '__esModule', {
    value: true
});})), 0, true, $__.uid);